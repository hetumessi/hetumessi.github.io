<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>置顶当然给小🍆啦</title>
    <url>/posts/e24107c6e6ec</url>
    <content><![CDATA[<center> <font face="STCAIYUN" color="8f0080" size="6">我并不想要永恒…… 因为我所看到的世界——现在就存在于此</font></center>
<hr>
<center> <img src="https://s2.loli.net/2022/05/12/lBqrdGROuhsLeix.png"> </center>
<center>
Mash Kyrielight   マシュ・キリエライト</center>
<center> 属性：秩序·善　　</center>
<center> 性别：女性   </center>
<center> 身長／体重：158cm・46kg </center>
<center> 假想宝具 拟似展开/人理之础 </center>
<center> 阶级：D　种类：对人宝具 </center>
<center> <font face="STCAIYUN" color="3f0080" size="4"> Lord Chaldeas   </font></center>

<center> <div class="hide-block"><button type="button" class="hide-button" style="background-color: [#ffffff];color: [#8B4513]">温柔可爱的小天使难道会有人不喜欢吗?
    </button><div class="hide-content"><p><s>而且能够满足胸腰腿腋臀等等各派性癖</s></p>
</div></div> </center>
有着从常服中完全看不出来的好身材，穿衣显瘦+眼镜+闷骚的人设可能是从沙条绫香身上继承来的，但比绫香要阳光了很多。
<p>人生经验虽然只有与世隔绝的不到十八个年头，知识量却非常异常丰富，远超不少屏幕前的咕哒。不太说多余的话，但吐槽总能吐到点子上。有着小鸟一样的精神构造，天真且不会怀疑别人，为了自己的信念而坚决行动，不会因为和他人的生命比较下来自己的生命如此短暂而悲伤，因此也就不会有像盖提亚一样对于生命终会终结一事有着悲叹。</p>
<p>虽然剧情里没有明说，但实际上是食物爱好者，和季节有关的语音里很多都和食物相关。不擅长饮酒，容易喝醉，曾借着酒意积极地抱住咕哒，不过实际上从玛修能够抗毒这一层面来考虑的话，可能不是生理上喝醉了，而是喝了酒之后就给自己下了足以忽悠住自己的心理暗示。<s>不愧是你瑟批茄子。</s></p>
<p>即使是试管婴儿，即使曾被作为各种非人道实验的对象，即使她从未在自己的世界中走出过南极大陆，即使她是真正意义上的命薄如纸，然而最终她却成了星球文明延续的火种，灵长类生灵生存意义的卫道者。<br>
面对自诩为神的高等生物，信念亦不曾动摇，只身以神代唯心之盾扛下几千年世代积蓄下的因果。<br>
对迦里的伙伴轻柔体贴，对外则永远刚强，坚守在队列的最前端。<strong>身若玄铁，心却不似琉璃</strong>。</p>
<p><a href="https://www.bilibili.com/read/cv2524431/">百张玛修·基列莱特的精美壁纸</a><br>
<a href="https://www.bilibili.com/read/cv2511399/">FGO高清美图（玛修篇）</a></p>
<hr>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=464686610&bvid=BV1ZL41177kT&cid=455921407&page=1&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
<div align="center" class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=13717513&bvid=BV1vx411b7uj&cid=22492124&page=1&&high_quality=1" scrolling="no" border="0" frameborder="no" framespacing="0" high_quality="1" danmaku="1" allowfullscreen="true"> 
    </iframe>
</div>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】X86 CPU发展历史</title>
    <url>/posts/2ea785cf45aa</url>
    <content><![CDATA[<p>转自<a href="https://blog.csdn.net/Hide_in_Code/article/details/113799454">csdn</a></p>
<p>近日由于需要，我对x86的CPU架构发展历史进行了调研与学习。目前主流的x86架构，其先进的技术代表厂家就是Intel与AMD，它们相爱相杀的故事广流于家家户户。但是我整理Intel的相关CPU发展就花了2、3个星期（期间还有别的事情），写了我1W5的字，累屎我了，而AMD的相关产品还没来得及整理与写入。关于Intel的芯片发展过程，相关的整理网站其实还不少，但大多数都停在2011年（因为也是那个时候写的），也就是截止到Intel Core架构之前，而后续的介绍文章都很稀碎。我借鉴了很多很多诸如这样的文章与维基百科，主要参考网站都放在了文章末尾，但是没来得及看是否有相关的文献内容，再删减去Intel、AMD、IBM等公司的发展决策与心里路程，仅仅是单单将处理器部分的内容整理出来，形成这篇文章，希望能对自己，以及其他想对ntel x86处理器这么多年来大致的发展过程有些学习的CPU芯片小白们有些许的帮助！<br>
在内容叙述架构上，由于我去年学习了计算机结构体系内容，因此本文主要按照时间顺序，对Intl发布的主要的几个芯片与新架构进行节选与简单的介绍，前期主要记录何时芯片/架构新加入的技术（如超标量与超线程SMT等）以及架构图，也可以从晶体管和主频的快速增长来感受一下摩尔定律；后期比如Core架构，架构图什么的都找不到了，而引入的一些新的技术与指令集我也不熟悉了，整理的内容可能没有写到重点或关键特色，我更关注在多代产品之间相互的关系（因为网上写的我都乱了，比如：Core品牌、Core架构、Core i系列处理器），只能权当给大家参考——尤其是Intel Core挤牙膏系列，写的我很懵逼，有一种“两代产品差别不大”的感觉…<br>
期间我搜寻资料学习时，还发现一位CSDN博主，他的博客内容主要是对具体的架构进行更细节的分析，让我如获至宝。若大家看了各个芯片的架构图，还想对每一款的架构进行深入的学习，也可以去看看他的文章：</p>
<p><a href="https://stkeke.blog.csdn.net/">一凡stkeke_CSDN</a></p>
<p><a href="https://stkeke.blog.csdn.net/article/details/85230687">8086架构/流水线及其优化</a></p>
<p>后续呢，我再抽时间把AMD部分补上~别忘了点赞哦亲~(￣▽￣)&quot;</p>
<hr>
<h1 id="x86-cpu-发展历史与分析"><a class="markdownIt-Anchor" href="#x86-cpu-发展历史与分析"></a> X86 CPU 发展历史与分析</h1>
<p>本文作者：SIST——Yippee</p>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>PC界有几大优秀的架构代代相传并迭代至今，分别是IBM的Power架构，Intel与AMD相爱相杀的X86架构，移动端独占鳌头的ARM架构，面向高性能科学计算的MIPS架构等。要实现国产的拥有独立知识产权的芯片架构技术，有必要博采众长，学习他人架构之特色而打通各路经脉。</p>
<p>在一学期的学习之后，对计算机体系结构的基础知识也算是有所了解。通过对网上的资料与博文的学习，我按照个人粗浅的理解以及体系结构的各章节要点，对Intel的X86重要的CPU版本进行学习，对其发展过程与演变之路进行一个总结记录。由于时间与篇幅关系，AMD推出的各型号微处理器未记录于其中。此外，同一款微处理器有不同主频的版本，本文只取其最低主频作为参考。</p>
<h2 id="intel-x86-cpu的历史发展"><a class="markdownIt-Anchor" href="#intel-x86-cpu的历史发展"></a> Intel X86 CPU的历史发展</h2>
<h3 id="x86架构前的铺垫"><a class="markdownIt-Anchor" href="#x86架构前的铺垫"></a> X86架构前的铺垫</h3>
<h4 id="4004首个4位处理器"><a class="markdownIt-Anchor" href="#4004首个4位处理器"></a> 4004——首个4位处理器</h4>
<img src="https://s2.loli.net/2022/05/20/BUFZgVYKjnJ2arO.png">
<center>图1 Intel首个4位微处理器4004</center>
<p>在1971年，年纪轻轻的Intel接到日本Busicom公司的订单，生产出世界首块4位CPU，代号4004。作为Intel的第一代微处理器，基于P沟道MOS硅栅技术，采取10μm工艺，拥有2250个晶体管，主频740KHz，处理速度达到0.06MIPS，前端总线为0.74MHz(4位)，socket为DIP16。</p>
<img src="https://s2.loli.net/2022/05/20/7nsN1lPFQodK43c.png">
<center>图2 4004的微体系架构图</center>
<p>4004处理器可以执行4位运算，支持8位指令集和12位寻址，指令集为<strong>4位BCD编码</strong>。<br>
4004其性能与首台电子计算机ENIAC相似，但体积较ENIAC需占用一个房间而小了很多。当时年仅3岁的Intel的主营业务是DRAM，缺少CPU方面的技术底蕴，但4004代表着Intel处理器序章的开始。</p>
<h4 id="8008首个8位处理器"><a class="markdownIt-Anchor" href="#8008首个8位处理器"></a> 8008——首个8位处理器</h4>
<img src="https://s2.loli.net/2022/05/20/m8zMVCtSLTiHh7q.png">
<center>图3 Intel首个8位微处理器8008</center>
<p>1972年，Intel发布世界首块8位CPU 8008，也是首款在PC上使用的处理器，能够执行8位运算，依然基于<strong>P沟道MOS</strong>硅栅技术与10μm工艺，拥有3500个晶体管，主频0.5MHz，处理速度达到0.05MIPS(略慢于4004)，socket位DIP18。</p>
<img src="https://s2.loli.net/2022/05/20/BUFZgVYKjnJ2arO.png">
<center>图4 8008的微体系架构图</center>
<p>8008处理器可以执行8位运算，支持14位寻址，可以访问到16KB的内存。虽然其单位时间执行指令数稍慢于4004，但由于其8位运算的优势使其在大多数应用中拥有更好的性能表现。</p>
<h4 id="8080新工艺"><a class="markdownIt-Anchor" href="#8080新工艺"></a> 8080——新工艺</h4>
<img src="https://s2.loli.net/2022/05/20/oMHeuV1zXZavTOI.png">
<center>图5 Intel微处理器8080</center>
<p>1972年，Intel发布8080芯片，依然为8位处理器，以<strong>N沟道MOS</strong>取代了P沟道MOS，使用6μm工艺，拥有6000个晶体管，主频2MHz，处理速度达到0.64MIPS，<strong>运算速度比8008提升了10倍</strong>，socket为DIP40。</p>
<img src="https://s2.loli.net/2022/05/20/Omid1Ab3qcpBuzE.png">
<center>图6 8080的微体系架构图</center>
<p>8080是早期8008处理器的增强和拓展：其地址总线为16位，可以访问64KB的内存，是8008的四倍；NMOS取代PMOS的升级；其指令集比8008指令集进一步增强等。8080的成功使其直接影响了后续的x86架构处理器。</p>
<h3 id="x86架构的开始"><a class="markdownIt-Anchor" href="#x86架构的开始"></a> x86架构的开始</h3>
<h4 id="8086"><a class="markdownIt-Anchor" href="#8086"></a> 8086</h4>
<img src="https://s2.loli.net/2022/05/20/1yTuAtoEV84NGMg.png">
<center>图7 Intel首个16位x86架构微处理器8086</center>
<p>1978年，Intel推出微处理器8086，也是第一款<strong>16位</strong>处理器，采用3μm工艺与特色的<strong>x86-16指令集</strong>，拥有2.9W个晶体管，主频4.77MHz，处理速度达到0.33MIPS，socket还是DIP40不变。在8086中，对<strong>单一指令仅仅采用2级步骤完成</strong>（取指，执行）同时CPU内只能执行一条指令，非流水线操作。8086所有的内部寄存器、内外数据总线都是16位，因此是完全的16位微处理器。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>在8086中含有<strong>2个单元部件</strong>：总线BU负责指令的读取与数据传输，执行EU负责执行指令。</li>
<li>地址分段的内存访问模型。其外部地址总线为20位，可以寻址1MB内存；但是内部地址总线为16位，可以寻址64KB空间。因此内部设立了段寄存器，系统基于“段内偏移”的概念进行内存寻址：由16位段寄存器左移4位作为段基址，加上16位段偏移地址形成20位的物理地址，从而达到最大寻址空间1MB，最大分段64KB。这个模式在后续的80286与80386中被称为“<strong>实模式</strong>”。</li>
</ul>
<img src="https://s2.loli.net/2022/05/20/aXLcZUdWMpD3NTe.png">
<center>图8 实模式下的内存访问模型</center>
<p>但它也有明显的<strong>安全与功能缺陷</strong>：在实模式下用户程序和操作系统拥有同等权利，对访问的地址即为物理地址，而同时程序可以随意修改自己的段基址，因此可以随意修改任意物理地址甚至操作系统的内容；同时，因为各程序使用的逻辑地址即物理地址——“所见即所得”——故微处理器无法支持”多任务“功能。</p>
<img src="https://s2.loli.net/2022/05/20/K2mVI95WRUHFYGa.png">
<center>图9 8086的微体系架构图</center>
<p>之后，Intel公司发布了8088处理器，采用x86指令集，实际上是外部数据总线削减为8位的8086；以及同样采用x86指令集，为辅助8086起到数学算术运算的协处理器8087，它能完成专门用于对数、指数和三角函数等的数学计算指令，提升科学运算的效率。8086是最成功的X86架构的鼻祖，其使用的X86指令集不断被使用、拓展至今。一年后，IBM公司于其PC中采用8088芯片，在当时RISC为主流的时代环境中，Intel得以初现锋芒。</p>
<h4 id="80286"><a class="markdownIt-Anchor" href="#80286"></a> 80286</h4>
<img src="https://s2.loli.net/2022/05/20/ITEnMoU9RfbFZLG.png">
<center>图10 Intel微处理器80286</center>
<p>1982年，Intel发布了16位处理器80286。其兼容8086的所有功能，采用1.5μm工艺与相同的<strong>x86-16指令集</strong>，拥有13.4W个晶体管，主频6MHz与外频相同，处理速度达到0.9MIPS，socket为正方形包装的PGA68。在80286中，对单一指令采用<strong>3级步骤</strong>完成(取指，译码，执行)但是CPU内只能执行一条指令，非流水线操作。其内、外部数据总线皆为16位，地址总线24位，可寻址16MB内存。</p>
<img src="https://s2.loli.net/2022/05/20/hlcCakvTPotgFyA.png">
<center>图11 80286的微体系架构图</center>
<p>其带来的主要新特色有：</p>
<ul>
<li>在80286中含有<strong>4个功能部件</strong>：指令IU负责指令译码，地址AU负责逻辑地址与物理地址的转换，执行EU，以及总线BU，四个部件并行工作提高处理速度与支持新增加的保护模式的运行。</li>
<li>从80286开始，CPU的工作方式也演变成两种：<strong>实模式和保护模式</strong>。</li>
</ul>
<p><strong>实模式</strong>：即原8086微处理器的内存访问方式。因CPU内寄存器数据为16位，只能寻址1MB的内存空间，因此在实模式下CPU基于段内偏移的物理地址形式进行内存寻址，这会带来系统的不安全性与功能限制。</p>
<img src="https://s2.loli.net/2022/05/20/E2aovNkU3d4MnfB.png">
<center>图12 80286保护模式下的内存寻址关系</center>
<p><strong>保护模式</strong>：80286中新增的保护模式。是为了改进实模式下内存访问的不安全性，它将内存的管理模式分为纯段模式或段页式，给内存段添加了段属性(如段基址、段界限、类型、DPL等)来限制用户程序对内存的操作权限，让用户程序对内存的访问不再“为所欲为”，从而更好的保护系统。在保护模式下，系统即可使用<strong>虚存、页面调度、多任务处理</strong>(此时还需要相关部件配合)等功能。</p>
<h4 id="80386"><a class="markdownIt-Anchor" href="#80386"></a> 80386</h4>
<img src="https://s2.loli.net/2022/05/20/iuzoVkwHv2BrCEJ.png">
<center>图13 Intel首个32位微处理器80386</center>
<p>1985年，Intel发布了第一款<strong>32位处理器</strong>80386，采用相同的1.5μm工艺与扩充后的<strong>x86-32指令集</strong>，拥有27.5W个晶体管，主频12.5MHz与外频相同，处理速度达到6MIPS，<strong>性能比80286提升约10倍</strong>，socket为PGA132。在80386中，对单一指令依然采用3级步骤完成(取指，译码，执行)，非流水线操作。其数据总线以及地址总线皆为32位，因此能够寻址4GB的内存空间，因此为保护模式的优化创立条件——虚拟8086模式。</p>
<img src="https://s2.loli.net/2022/05/20/aOilESkbCt3QBej.png">
<center>图14 80386的微体系架构图</center>
<p>其带来的主要新特色有：</p>
<ul>
<li>在80386中，引入了新的处理器工作模式——<strong>虚拟8086模式</strong>：当处理器进入保护模式后，基于实模式的应用就不能直接运行了，而PC在刚刚启动进入DOS时是实模式，当操作系统(主流OS如Linux、Windows)运行后就工作在保护模式，而保护模式不能切换回实模式。虚拟8086模式实际上就是运行在保护模式中的实模式，其指利用硬件级虚拟化技术，模拟出多个8086芯片，达到实模式的应用(8086程序)能以任务的形式工作在基于保护模式的操作系统上，真正实现各色程序的多任务处理功能。于是80386共具有三种工作模式：实模式，保护模式和虚拟模式，同时能兼容之前的老机型程序。</li>
<li>首次引入了<strong>L1 Cache(片外)</strong>，极大的提高了CPU访问内存的效率。从此，cache在CPU中的地位便不可或缺。</li>
<li>添加了内存管理单元(MMU)，从而使得处理器能够有<strong>内存保护，存储器分页管理机制</strong>等功能。</li>
<li>指令集扩充增加了一些内容等。</li>
</ul>
<p>80386位处理器，配合80387协处理器在当时已经可以完成AutoCAD的FLOPS计算。而80386作为首款32位微处理器以及其新增加的各色功能，不仅使Intel成为PC界的领头羊，更是具有划时代的重要意义。</p>
<h4 id="80486"><a class="markdownIt-Anchor" href="#80486"></a> 80486</h4>
<img src="https://s2.loli.net/2022/05/20/wD2yQzkGMT9Vhn6.png">
<center>图15 Intel微处理器80486</center>
<p>1989年，Intel发布了32位处理器80486，采用1μm工艺，指令集为<strong>x86与x87的集合</strong>(增加了浮点运算部件)，拥有120W个晶体管(<strong>突破百万晶体管的界限</strong>)，主频25MHz，处理速度达到20MIPS，socket为PGA。</p>
<img src="https://s2.loli.net/2022/05/20/GU3f2IRypv58EkD.png">
<center>图16 80486的微体系架构图</center>
<p>其带来的主要新特色有：</p>
<ul>
<li>在整数处理单元中首次引入了<strong>流水线(pipeline)<strong>的概念，采用了RISC的技术，建立了</strong>五级流水线</strong>(取指，译码，转址，执行，写回)，使得每一级流水线在同一时刻都运行着不同的指令而不是同一时刻仅有一条指令于CPU中，实现<strong>一个时钟周期内完成一条指令</strong>。虽然当时80486依然是采取顺序执行，但此设计依然使80486的提升为同频率的80386处理器的2倍性能。同时，引入<strong>Forwarding</strong>技术解决data hazard问题；并通过“<strong>Pre-fetch</strong>”的方式<strong>加快指令分支操作</strong>。</li>
<li><strong>片内集成了指令数据统一的8KB L1 Cache</strong>，同时支持外部L2 Cache。</li>
<li><strong>片内集成了增强型FPU单元</strong>，其浮点性能甚至明显快于80387。</li>
<li>提出了<strong>时钟倍频技术</strong>：由于CPU主频的快速提升，而总线外频速度没有跟上，因此Intel在80486中应用了倍频技术，使得CPU的主频通过倍频器等于外频乘上一个倍数(2倍或3倍)，进而保持增长。<br>
改进了MMU的性能，同时对指令集进行了一定扩充，如XADD，BSWAP，CMPXCHG，INVD，WBINVD，INVLPG。<br>
采用的新的内部总线传送技术上：<strong>突发传送方式</strong>，大大提高了与内存的数据交换速度。</li>
</ul>
<h2 id="p5架构pentium与pentium-mmx"><a class="markdownIt-Anchor" href="#p5架构pentium与pentium-mmx"></a> P5架构——Pentium与Pentium MMX</h2>
<h4 id="pentium"><a class="markdownIt-Anchor" href="#pentium"></a> Pentium</h4>
<img src="https://s2.loli.net/2022/05/20/4e1zgRFZuExsXOU.png">
<center>图17 Intel微处理器Pentium</center>
<p>1993年，Intel发布了32位处理器Pentium，又被号为80586，使用的<strong>超标量x86微体系架构(称为P5架构)</strong>，是8086兼容处理器系列中的第五代主要产品，<strong>指令集非常接近80486与80386</strong>，仅仅做了简单的指令内容增加。其采用0.8μm工艺，拥有310W个晶体管，主频60MHz，处理速度达到100MIPS(<strong>80486的四倍性能</strong>)，插槽采用Socket4/5/6.</p>
<img src="https://s2.loli.net/2022/05/20/BYyc5OtoJfIn8ah.png">
<center>图18 Pentium(80586)的微体系架构图</center>
<p>其带来的主要新特色有：</p>
<ul>
<li>是第一个采用<strong>超标量技术</strong>Intel微处理器，拥有<strong>2条并行</strong>的整型pipeline：pipeline U<strong>处理任意指令</strong>，pipeline V吸收了RISC的特色而负责<strong>处理简单通用指令</strong>，从而提升系统的运行效率。</li>
<li>由于超标量结构需对数据和指令进行同时读写，因此引入<strong>对L1 Cache进行数据指令分离</strong>：各单独的8K数据L1 Cache和8K指令L1 Cache，减少了指令、数据以及读/写hazard。<strong>但L2 Cache依然是片外的</strong>。拥有<strong>单个更快的浮点数单元</strong>，整个系列的CPU浮点性能都很不错。最显著的是FMUL功能，吞吐量比80486 FPU高出15倍。但可惜此浮点单元爆出存在Bug，使得极少数情况下导致除法运算的精度降低，饱受批评。</li>
<li>引入了<strong>MESI的Cache coherence协议</strong>，实现更高效的cache写回。</li>
<li>实施了<strong>分支预测算法(Branch Prediction)<strong>来提前预取指令，避免不必要的闲置等待，引入了</strong>Branch Target Buffer(BTB)结构以及Instruction Prefetch Buffer</strong>.</li>
<li>Pentium的制造工艺优良，<strong>可超频性能很好</strong>，使得“超频”概念在市场中流行起来。</li>
<li>从Pentium开始，CPU封装出现<strong>扇热盖</strong>的设计，已解决突显的CPU的发热问题。</li>
</ul>
<p>虽然Intel在Pentium实现了超标量、cache分离、分支预测等新技术，但要注意的是，此时Pentium依然采取in-order执行（指令）；同时CPU面对data hazard时pipeline中依然会出现stall。</p>
<h4 id="pentium-mmx"><a class="markdownIt-Anchor" href="#pentium-mmx"></a> Pentium MMX</h4>
<p>1996年，Intel推出了基于P5架构的微处理器Pentium MMX，添加了<strong>MMX指令集</strong>，是对P5架构的一次关键升级。采用0.35μm工艺，拥有450W个晶体管，主频166MHz，插槽采用Socket7.</p>
<img src="https://s2.loli.net/2022/05/20/eQv6hZuGDMJdjyL.png">
<center>图19 Pentium MMX的微架构图</center>
<p>其带来的主要新特色有：</p>
<ul>
<li>添加了Intel的<strong>MMX(Multi-Media Extension)指令集</strong>，目的是增强提升CPU在2D音像、图形和通信等多媒体应用对诸如编码与解码等工作的效率(只局限于整数的运算)。在架构中，Intel定义了八个64位SIMD寄存器与负责相关快速执行的硬件，由这些硬件需要而对指令集进行相应补充拓展。为CPU增加了57条MMX指令，</li>
<li><strong>L1 Cache</strong>升级为双倍大小：将CPU芯片内的L1 Cache由8KB指令+8KB数据增加为16KB指令+16KB数据Cache，在Pentium MMX中<strong>没有集成当时卖力不讨好的L2 Cache</strong>，而是独辟蹊径采用MMX技术去增强性能(如上所述)。</li>
</ul>
<p>而有了上述两种改进方式，MMX CPU比普通CPU在运行含有MMX指令的程序时，处理多媒体的能力上提高了约60％。由于应用程序都支持MMX指令，这一步操作也增强了英特尔在该领域的垄断地位。MMX技术不但是一个创新，而且还开创了CPU开发的新纪元，后来的SSE，3D NOW！等指令集也是从MMX发展演变过来的，而这种附加指令集机制也成为后来所有x86处理器的基准。</p>
<h2 id="p6架构pentium-proiiiii"><a class="markdownIt-Anchor" href="#p6架构pentium-proiiiii"></a> P6架构——Pentium Pro/Ⅱ/Ⅲ</h2>
<h3 id="pentium-pro"><a class="markdownIt-Anchor" href="#pentium-pro"></a> Pentium Pro</h3>
<img src="https://s2.loli.net/2022/05/20/IHODdwoBXnL4zlP.png">
<center>图20 Intel微处理器Pentium Pro</center>
<p>1996年，Intel发布了32位处理器Pentium Pro，此为新的<strong>P6架构</strong>。其采用相同的0.35μm工艺与<strong>x86指令集(没有支持MMX指令集)</strong>，拥有550W个晶体管，主频150MHz，处理速度达到440MIPS(是Pentium的2~3倍性能)，插槽采用Socket8.</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>首次实现CPU的<strong>L2 Cache的片内集成</strong>，采用了<strong>16KB片内L1 Cache(合计)与256KB L2 Cache</strong>。Intel将CPU与L2 Cache两个芯片之间用高频宽的内部通讯总线互连，使得<strong>L2 Cache与CPU同速</strong>，运行在更高的频率上。</li>
<li>实现了<strong>3路超标量</strong>(之前是Pentium中引入的2路超标量)。</li>
<li>实现了指令流水线的乱序执行(<strong>OoO-E</strong>)，这是在Pentium超标量结构后的又一次飞跃。Pentium Pro采取的是<strong>Tomasulo动态执行算法</strong>，其策略是<strong>顺序发射，乱序执行，按需提交</strong>，使用了<strong>Reorder buffer与Register renaming</strong>，以及<strong>12级pipeline(也有文献说11级或14级)</strong>。</li>
</ul>
<img src="https://s2.loli.net/2022/05/20/TYzyBxSMEqCgme6.png">
<center>图21 Pentium Pro的微架构图</center>
<p>Pentium Pro的P6架构标志着Intel x86处理器的架构已经基本成型，之后的Pentium Ⅱ直到Pentium 4，都没有脱离这个体系，学好Pentium Pro的微架构更是后续学习Core架构的重要基础！</p>
<p>不过当时Cache技术还没有完全成熟，且Cache非常昂贵，因此尽管Pentium Pro性能不错，却远没有达到甩开对手的程度。而其高昂的价格，使得Pentium Pro成为Intel第一个失败的产品，成为了典型的“叫好不叫座”的产品。但Pentium Pro的设计思想和总体架构却对Intel此后的处理器设计造成了深远的影响，其中L2内嵌的模式一直沿用至今。</p>
<h4 id="pentium-ii"><a class="markdownIt-Anchor" href="#pentium-ii"></a> Pentium Ⅱ</h4>
<img src="https://s2.loli.net/2022/05/20/FnJ4rjuOV26IbsH.png">
<center>图22 Intel微处理器Pentium Ⅱ</center>
<p>1997年，Intel发布了基于Pentium Pro的<strong>P6架构</strong>(此乃Pentum Pro的优点)的32位处理器Pentium Ⅱ，是<strong>对Pentium(P5)与Pentium Pro(P6)的改进版</strong>，其内核代号Klamath，采用0.35μm工艺并支持<strong>x86指令集、MMX指令集</strong>(此乃集合Pentium的优点，Pro中没有支持MMX)，拥有750W个晶体管，主频233MHz，集成了<strong>32KB片内L1 Cache(合计)与512KB 片外L2 Cache(合计)</strong>，socket为Slot1。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li><strong>L2缓存不再与CPU核心保持同速</strong>，考虑到Pentium Pro的失败，以此降低成本。</li>
<li>采用了<strong>双重独立总线结构</strong>，一条总线连通L2 Cache，另一条负责DRAM。</li>
<li>首次采用了最新的solt1接口标准，不再用陶瓷封装，而采用了一块带金属外壳的印刷电路板。</li>
</ul>
<img src="https://s2.loli.net/2022/05/20/wNE6ajbB4VeCUfp.png">
<center>图23 Pentium Ⅱ的微架构图</center>
<p>Pentium Ⅱ基本上是面向消费者的奔腾Pro，整体上与Pentium Pro很相似，只是缓存方面有些不同，而之后随着Pentium Ⅲ的发布被快速取代。但Pentium Ⅱ时期，Intel发布了在PC的商业领域做了很多改进，例如用SDRAM内存取代了老式的EDO DRAM；PC开始引入AGP显卡；发布了面向入门级市场的Celeron(赛扬)系列(即削减了L2 Cache的Pentium Ⅱ，以超频与低价为特点)，以及面向服务器市场的高端处理器Xeon系列(即增强了Cache的版本，以高频与大cache为特点)；开始发布移动版本(面向低能耗)的Pentium Ⅱ等等。</p>
<h4 id="pentium-iii"><a class="markdownIt-Anchor" href="#pentium-iii"></a> Pentium Ⅲ</h4>
<img src="https://s2.loli.net/2022/05/20/qLoTbYgWMFD5KGt.png">
<center>图24 Pentium Ⅲ的微架构图</center>
<h5 id="第一代pentium-iii内核katmai"><a class="markdownIt-Anchor" href="#第一代pentium-iii内核katmai"></a> 第一代Pentium Ⅲ内核——Katmai.</h5>
<p>1999年，Intel发布了32位处理器Pentium Ⅲ，<strong>第一代内核代号Katmai</strong>，其实就是<strong>PentiumⅡ的简单改进版</strong>。采用0.25μm工艺，<strong>指令集为IA-32(即x86)、MMX、SSE</strong>，拥有950W个晶体管，主频500MHz，处理速度达到，socket与Pentium Ⅱ相同为Slot 1。</p>
<p>Katmai除了支持<strong>SSE指令</strong>外其他方面与Pentium II是几乎一样的：</p>
<p><strong>SSE(Streaming SIMD Extensions)指令集</strong>，共包含70条指令，其中50条<strong>SIMD浮点指令</strong>，12条全新MMX指令和8条系统内存数据流传送优化指令，目的是对<strong>3D游戏性能的显著提升</strong>(MMX指令集的不足)，兼容MMX指令集。由于MMX指令集会借用原浮点寄存器而影响浮点运算的性能，于是Intel为SSE指令集新增了8个全新独立的的128位单精度寄存器，能同时处理4个单精度浮点变量，使得SSE指令集能与其他浮点运算并行。</p>
<h5 id="第二代pentium-iii内核coppermine"><a class="markdownIt-Anchor" href="#第二代pentium-iii内核coppermine"></a> 第二代Pentium Ⅲ内核——Coppermine.</h5>
<p>八个月后，Intel发布了<strong>第二代的Pentium Ⅲ</strong>，其<strong>内核版本为Coppermine</strong>， 采用新的0.18μm工艺，主频733MHz，是<strong>Intel历史上首款达到1Ghz的X86处理器</strong>。</p>
<p>其主要特点有（并非新元素）：</p>
<ul>
<li>集成了<strong>32KB片内L1 Cache以及256KB片内L2 Cache(两个都是片内)</strong>(之前Pentium Pro中首次实现，这里L1变大了);</li>
<li><strong>12级流水线设计</strong>，与后面推出的Pentium Ⅳ架构比短小精悍了，且耗电量低;</li>
<li><strong>3 路超标量架构</strong>(之前Pentium Pro中首次实现)；</li>
<li>插槽也更改为Socket 370。</li>
</ul>
<p>一般认为，Coppermine才是真正意义上的Pentium，其拥有新架构、新制造工艺、新接口对性能的提升相当巨大，对日后Intel的架构影响深远，后来Intel的Pentium-M以及今天的Core微架构都是脱胎于Coppermine。题外话，在PentiumⅢ的移动版(即Pentium-M架构)中Intel还第一次引入了SpeedStep技能技术，是Intel全新的节约能源技术。</p>
<h2 id="netburst架构pentium-iv"><a class="markdownIt-Anchor" href="#netburst架构pentium-iv"></a> NetBurst架构——Pentium Ⅳ</h2>
<img src="https://s2.loli.net/2022/05/20/DIsPiuvSTz6FqAt.png">
<center>图25 Pentium Ⅳ的微架构图</center>
<h3 id="第一代pentium-iv内核willametle"><a class="markdownIt-Anchor" href="#第一代pentium-iv内核willametle"></a> 第一代Pentium Ⅳ内核——Willametle</h3>
<p>2000年，Intel发布了第一款32位Pentium Ⅳ处理器，并没有沿用Pentium Ⅲ的P6架构，而是重新设计了<strong>新微架构NetBurst</strong>。第一款Pentium Ⅳ的<strong>内核为Willametle</strong>。采用0.18μm工艺，拥有4200W个晶体管，主频1.4GHz(轻松过GHz)，采用QPB型FSB，外频达到了400MHz，接口方式为Socket423。</p>
<p>其主要特点有：</p>
<ul>
<li><strong>20级超标量pipeline</strong>，并用各种技术来代偿pipeline停顿产生的性能损失，诸如并行执行，缓冲技术，和投机执行技术。</li>
<li>采用了<strong>奇贵的RDRAM</strong>来满足Pentium 4的带宽需求。</li>
<li>在<strong>前端总线引入QDR技术</strong>：在总线的通信信令角度，于DDR的基础上，增加为独立的写接口和读接口，以此达到4倍速率。</li>
<li>第一次引入<strong>SSE2指令集</strong>。SSE2指令一共144条(SSE包括70条指令)，引入新的数据格式，如：128位SIMD整数运算和64位双精度浮点运算等。</li>
</ul>
<p>尽管有着更高的时钟频率，但Willametle同频率的性能表现比AMD的Athlon差了不少，甚至是自家的Pentium Ⅲ在相同的频率下都运行的比它快。同时Willametle不仅发热量大，又采用了价格昂贵的RDRAM，最终成为公认的失败之作，甚至成为高噪音低性能的代名词。</p>
<h3 id="第二代pentium-iv内核northwood"><a class="markdownIt-Anchor" href="#第二代pentium-iv内核northwood"></a> 第二代Pentium Ⅳ内核——Northwood</h3>
<p>一年后，Intel发布了第二款Pentium Ⅳ，<strong>内核代号Northwood</strong>。采用精进的0.13μm工艺，拥有5500W个晶体管，主频2GHz，集成了<strong>片内512KB L2 Cache</strong>，socket为Socket478，</p>
<p>其主要特点有：</p>
<ul>
<li>内存改用便宜的<strong>DDR SDRAM</strong>。</li>
<li>第一次引入<strong>超线程技术(Hyper-Threading)</strong>，也即是课程中学的Simultaneous Multithreading(SMT)(学术叫法)，其实就是以CPU/pipeline的利用率为最大优先，按照“优先将不同线程之间没有hazard的指令装入超标量pipeline”的动态执行的思想来实现系统更高的综合吞吐量。</li>
</ul>
<h3 id="第三代pentium-iv内核prescott"><a class="markdownIt-Anchor" href="#第三代pentium-iv内核prescott"></a> 第三代Pentium Ⅳ内核——Prescott</h3>
<p>2004年，Intel发布了32位处理器，<strong>内核代号为Prescott</strong>的Pentium Ⅳ的重要修订版。采用90nm工艺，拥有1.25亿个晶体管，最高的版本主频达到了3.8GHz，<strong>socket为LGA775</strong>。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>超深流水线：<strong>31级pipeline</strong>.</li>
<li>第一次引入<strong>SSE3指令集</strong>。于SSE2的基础上又新增加了13条新指令，一条用于视频解码，两条用于线程同步，其余用于复杂的数学运算、浮点到整数转换和SIMD浮点运算。</li>
<li><strong>硬件防病毒技术EDB</strong>，与OS相配合后可以防范大部分缓冲区溢出攻击。</li>
<li>加入了<strong>节能省电技术EIST</strong>，即Pentium-M架构中的SpeedStep技术的改良版，最早在Pentium-M架构中使用。其作用是由OS控制，在CPU使用率低时动态降低CPU的倍率与工作频率，从而实现能耗的降低。</li>
<li><strong>虚拟化技术Intel VT</strong>，作用是让一个CPU工作起来像多个CPU在并行运行，使一部电脑内同时运行多个OS成为可能。</li>
</ul>
<p>Intel将Prescott接口类型的从Socket 478到LGA775，原本是希望能将发热降低，却实际上产生了反作用——功率消耗增加了大约10%，再加之90nm的工艺在当时还不够完满，最终Prescott每个时钟周期<strong>比Northwood多产生大约60%的热量</strong>。Prescott的整体功耗轻松超过百瓦大关，基本上属于火炉级别。</p>
<h3 id="第一款双核微处理器pentium-d"><a class="markdownIt-Anchor" href="#第一款双核微处理器pentium-d"></a> 第一款双核微处理器Pentium D</h3>
<p>2005年，Intel发布了“双核”微处理器，Pentium D ，采用与Prescott相同的90nm工艺与socket接口，实际上就是把俩Prescott集成到一个芯片上：<strong>一共有两个die，一个die一个core，而两个core之间的通信不能走内部总线而是走北桥</strong>，被AMD嘲讽为“伪双核”。而其巨大的功耗150w，更不是开玩笑的。</p>
<p>总结一下<strong>Pentium Ⅳ或NetBurst微架构的核心理念</strong>，四个字概括：<strong>频率至上</strong>。Intel为了与AMD的产品有所区别，而决策开发更高的时钟频率，是经典的<strong>市场驱动技术案例</strong>。为了实现更高的频率，把流水线的级数越拉越大，但pipeline的各级效率也因此降低！而<strong>更高的频率，带来的日益严重的高耗能、高发热以及平庸的性能</strong>，使得Pentium Ⅳ被最终放弃并转入Pentium-M架构，而Intel宣传的Pentium Ⅳ能达到10GHz的目标也因为散热问题化为泡影。这告诉我们，处理器的设计过于被市场需求而不是被架构本身所控制，势必或导致产品本身慢慢地走向歧途。</p>
<h2 id="移动端架构pentium-m"><a class="markdownIt-Anchor" href="#移动端架构pentium-m"></a> 移动端架构Pentium-M</h2>
<p>2000年后，便携式PC的需求开始爆发增长，而Intel的相关产品仅有P3与P4架构系列。而P4架构的高能耗高热量难以承载此应用场景——Pentium 4-M功耗35w太高，这使得Intel急需专门研发新的架构来满足移动便携市场的低功耗需求(在此前用Pentium 3-M凑活用)。于是，Intel在基于P6架构(Pentium Pro/Ⅱ/Ⅲ)上研发出了Pentium-M架构，此架构的处理器拥有超越P4的高性能，而且功耗超低，在移动平台留下了深深的烙印。</p>
<h3 id="第一代pentium-m内核banias"><a class="markdownIt-Anchor" href="#第一代pentium-m内核banias"></a> 第一代Pentium-M内核——Banias</h3>
<p>2003年，Intel发布了第一代Pentium-M架构，<strong>内核代号为Banias</strong>，是对Pentium Ⅲ(即P6架构)的重大修改（Pentium Ⅲ又是在Pentium Pro基础上改的），采用130nm工艺，拥有7700W个晶体管，主频为1.3GHz~1.6GHz(<strong>性能堪比Pentium Ⅳ的2.8GHz</strong>)，插槽使用了Socket 479(实际上仅478个针脚，且各针脚的定义与桌面款的Socket 478不一样)。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>Banias的<strong>TDP(最大散热功耗)只有24.5w</strong>，再配合其他节能措施，能够使得笔记本电脑的电池时间提升到3小时以上(比以往架构多了1小时的续航能力)。</li>
<li><strong>12级流水线</strong>。远远小于NetBurst的流水线长度，既保证了性能也不至于功耗的过高。</li>
<li><strong>64KB的片上L1 Cache</strong>；4部分<strong>合计总大小为1MB的片上L2 Cache</strong>，可支持单独访问，实现省电降功耗低的目的。</li>
<li><strong>改进的分支预测和预取机制，预测比Pentium Ⅲ高20%</strong>(presccot的核心成果)；</li>
<li>第一款x86<strong>支持Micro-ops Fusion(微操作融合)</strong>：在指令解码后的多个微操作作为一个bundle，待它们所需的处理单元都在pipeline中空闲时共同输入pipeline中，以提升pipeline的吞吐量。</li>
</ul>
<p>同时，Intel<strong>推出了Centrino(迅驰)平台</strong>——将Pentium-M CPU、i855系列芯片组和802.11b无线网卡捆绑销售——大获成功，也推动了802.11b无线网络的普及。</p>
<h3 id="第二代pentium-m内核dothan"><a class="markdownIt-Anchor" href="#第二代pentium-m内核dothan"></a> 第二代Pentium-M内核——Dothan</h3>
<p>2004年，Intel推出了二代Pentium-M架构，<strong>内核代号为Dothan</strong>，采用更精进的90nm工艺，拥有1.4亿个晶体管，主频为1.7GHz~2.0GHz。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li><strong>TDP功耗降低到21瓦</strong>(<strong>比Banias低3.5w</strong>)</li>
<li><strong>64KB的片上L1 Cache；2MB的片上L2 Cache</strong>(<strong>两倍于Banias，与Banias同技术</strong>)</li>
<li>基于Dothan的二代迅驰平台推出了<strong>54Mb/s的802.11g无线网络</strong>，带动了整个无线设备市场的更新换代。</li>
</ul>
<p>最终可以得到，Dothan的综合性能大多数情况比Banias高出10-20％。</p>
<h3 id="第三代pentium-m内核yonah"><a class="markdownIt-Anchor" href="#第三代pentium-m内核yonah"></a> 第三代Pentium-M内核——Yonah</h3>
<img src="https://s2.loli.net/2022/05/20/bgyVsZ49HKeTtEU.png">
<center>图26 Yonah微架构图</center>
<p>2006年，Intel发布了第三代Pentium-M架构，<strong>内核代号为Yonah</strong>，<strong>以Core(酷睿)品牌发行</strong>，是<strong>英特尔史上第一种原生双核心x86处理器</strong>，其<strong>本质是两个Dothan的整合</strong>，具体的处理器产品系列号为Core Duo。Yonah采用65nm工艺，主频自1.06GHz到2.33GHz，采用12级流水线(<strong>3.8GHz的Pentium 4完全没法和Yonah相比</strong>)，接口为Socket M。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>新加入<strong>共享缓存设计</strong>：<strong>两个Core可以共享2MB二级缓存</strong>，而不是独享，显著提升了双核处理器的任务配合能力。</li>
<li>加入了<strong>SSE3指令集、英特尔虚拟化技术(Intel VT)与英特尔病毒防护技术(Intel EDB)，加入了之前在Pentium Ⅳ首次实施的技术</strong>。</li>
</ul>
<p>Yonah是第一款<strong>面向便携式电脑设计的真双核X86处理器</strong>，拥有极佳的性能(比Pentium 4快多了)，保有<strong>24瓦的超低功耗水平，TDP功耗提升到31瓦</strong>，在市场上取得了巨大的成功；其唯一的缺点就是依然是32位处理器。之前的Pentium D双核是一个外壳内封装两个处理器，两个die两个core；而Yonah是一个die两个core。<strong>作为Core品牌的第一款处理器，Yonah实际上却没有使用Core 2的架构，而是Pentium-M架构</strong>。</p>
<p>在此阶段，P5与P6架构的荣光也就此落幕，而Pentium 4系列更是无地自容，使Pentium 4开发团队引咎辞职。</p>
<h2 id="core-2系列core架构"><a class="markdownIt-Anchor" href="#core-2系列core架构"></a> Core 2系列(Core架构)</h2>
<img src="https://s2.loli.net/2022/05/20/aFgCwmGdJrHc5qB.png">
<center>图27 Core微架构图</center>
<p>Intel发布了基于Core品牌的内核Yonah，但Yonah的架构是采用Pentium-M，而<strong>真正意义上的Core架构却是从Merom内核开始</strong>(同时Intel称之为Core 2系列)，其具体的产品系列代号为Core 2 Duo。</p>
<p>2006年7月，Intel发布了<strong>第一款Core架构的内核Merom(移动端)</strong>，是建立在Pentium-M架构(Yonah)基础上，融合了Pentium Ⅳ的经验与教训的产物。采用65nm工艺，使用<strong>x86_64指令集</strong>，接口采用Socket M。</p>
<p>其带来的主要新特色有：</p>
<ul>
<li>Merom实现了<strong>指令四发射</strong>：Merom将<strong>指令分为20%热指令与80%冷指令，可同时解码四道指令</strong>。相比RISC增加并行指令发射数目简单，CISC乱增加发射数目会导致频率上不去，因此之前的x86处理器只能做到三发射(此时的AMD K8架构也只能实现三发射)，这说明在<strong>Merom中实现了指令解码效率提升了33%</strong>。这项成就是Core微架构的最大变化之一，一直是<strong>当时英特尔的技术壁垒</strong>；其竞争度对手AMD的K10架构、新一代(当时)“推土机”架构统统都没有实现四发射，直到Zen架构中才实现这项技术。</li>
<li><strong>Macro-Ops Fusion(宏操作融合)</strong>——如CMP指令和JMP指令融合，可实现在指令解码阶段，<strong>对多条常用指令组合进行宏代替</strong>，实现解码效率提升与加速并降低功耗，此技术比Micro Fusion(微操作融合)用的更广泛。</li>
<li><strong>第一个采用Intel-64(EM64T)架构的Intel移动处理器</strong>。说起64位指令集，同样的64位拓展指令集却有好几个名字，千奇百怪容易乱，我细细整理后是这样的过程：<br>
以前Intel的<strong>32位x86指令集被称为IA-32</strong>；后来Intel开发出<strong>独立的64位、与x86架构完全不同又不兼容的IA-64架构</strong>；IA-64不兼容IA-32使得<strong>AMD开发出的64位指令集AMD-64(兼容IA-32)<strong>在市场上认可度很高，<strong>Intel也有模有样的开发出自己版本的“AMD-64”，命名为Intel-64，又称IA-32e或EM64T</strong>。而市场上</strong>统称IA-64与AMD-64为x86-64指令集</strong>。</li>
</ul>
<p>因为Core微架构是Intel在Yonah微架构基础上改进而来，其<strong>架构与Yonah架构的内部结构是几乎相同的</strong>。 它们具有相同的解码流程、乱序执行流程、简单解码单元与复杂解码单元相配合的设计、共享式二级缓存的设计，只是在<strong>解码单元与执行单元的数量</strong>、<strong>内部总线的宽度</strong>以及各个<strong>缓冲区的容量</strong>上的差异。</p>
<p>后来Intel在台式机市场也推出Core 2系列，<strong>内核为Conroe(扣肉)<strong>的双核处理器，在</strong>内部架构上同Merom没有任何区别</strong>，功能上也完全一致，只是作为台式机可以具有更高的频率(虽然不如Pentium Ⅳ高，但性能是能虐虐它的)。上述这些技术使Core架构极大幅度提高了性能也显著降低了功耗(移动端Merom提升幅度没桌面端大，因为Yonah本身性能很不错)——<strong>与Pentium D相比，Conroe的性能提高了40％，功耗却降低了40％</strong>。最终摧枯拉朽地击败了当时的AMD的Athlon X2系列，其只能依靠性价比优势进行突击。</p>
<p>在<strong>服务器市场，Intel推出了内核Penryn</strong>，即采用45nm工艺的Merom，四核处理器，新增了一些功能：①加入了<strong>SSE4指令集</strong>——又增加了50条新的增加性能的指令，这些指令有助于编译、媒体、字符/文本处理和程序指向的加速；②<strong>增强型动态加速技术</strong>(Enhanced Dynamic Acceleration Technology)——可以让<strong>一个内核睡眠而令一个内核加速</strong>。</p>
<h2 id="core-i系列挤牙膏到今天的intel"><a class="markdownIt-Anchor" href="#core-i系列挤牙膏到今天的intel"></a> Core i系列——挤牙膏到今天的Intel</h2>
<p>自2007年始，Intel实施了<strong>Tick-Tock的发展模式</strong>(2年周期)，从而使芯片设计制造业务更有效率：Intel将在<strong>奇数年(Tick)推出新制成工艺</strong>；<strong>偶数年(Tock)推出新架构的微处理器</strong>。而Tick-Tock战略也被很多用户戏称为**“挤牙膏策略”**——每一代处理器之间的性能差距将会很小。</p>
<img src="https://s2.loli.net/2022/05/20/D28pBlOybucIAxz.png">
<center>图28 Intel的Tick-Tock发展战略</center>
<p>而在<strong>2016年，Intel宣布Tick-Tock将放缓至三年一周期</strong>，从2年的Tick-Tock(工艺-架构)模式更改为<strong>2年周期的PAO(Process-Architecture-Optimization，工艺-架构-优化，又称Tick-Tock-Refresh)模式</strong>，原因就是制造工艺的瓶颈！</p>
<p><strong>10nm工艺被认为是硅基半导体的转折点；再往后的7nm工艺则已经进入量子学范畴</strong>，使得半导体特性都有变化了，所以研发难度更大，量产良品率也低，需要更多黑科技材料以及新一代EUV光刻设备。如果不对材料进行改进，随着晶体管越来越小、晶体管密度越来越大，随之出现的日益严重的漏电和发热问题。Intel的7nm芯片按照PAQ模式应于2020年发布，结果也延期至2022年了，真的是连“牙膏”都难挤出来了呀。而“摩尔定律将死”的呼声也开始流传开来。</p>
<p>在2015年，Intel就卡在14nm到10nm工艺之间，后来进入10nm——仅仅相当于20个硅原子宽度——制程后，其制造难度让原本的芯片研发周期更是无法适应，这使得Intel不得不延长原制成的使用周期。更何况Intel是“自产自销”模式，靠自家晶圆厂而不像AMD找台积电代工生产芯片，有报道称其10nm晶体管密度与台积电7nm晶体管密度相当，从而7nm制程良品率限制更多。</p>
<h3 id="nehalem架构"><a class="markdownIt-Anchor" href="#nehalem架构"></a> Nehalem架构</h3>
<h4 id="tocknehalem"><a class="markdownIt-Anchor" href="#tocknehalem"></a> Tock——Nehalem</h4>
<p>2008年11月，Intel推出了升级架构Nehalem，<strong>内核代号也是Nehalem</strong>，采用45nm工艺不变，是<strong>第一代Core i系列处理器</strong>。Nehalem是在Core架构上进行改进的，主频为1.06GHz~3.33GHz，核心支持2-8核，接口采用LGA1366。Intel<strong>按照i7、i5、i3的顺序发布i系列处理器，来分别对应高级、中级与入门级市场，采用相同的内核架构</strong>。</p>
<img src="https://s2.loli.net/2022/05/20/fMq5rGWIelZSBQA.png">
<center>图29 Nehalem架构图</center>
<p>其带来的主要特色有：</p>
<ul>
<li>首次引入了<strong>睿频加速技术(Intel Turbo Boost 1.0)</strong>，即使得CPU会根据当前的任务量自动调整主频甚至自动超频，实现性能与省电策略的最大化。</li>
<li><strong>重新引入了超线程技术</strong>(在Pentium Ⅳ中首次引入)。</li>
<li><strong>三级Cache</strong>：<strong>其单核L1 Cache为64KB，单核L2 Cache 256KB，共享L3 Cache 4MB~24MB；减少了L2/L3 Cache Line大小(自Netburst的128KB改为64KB，与Pentium-M架构相同)，扩大了共享的L3 Cache大小</strong>。</li>
<li>将<strong>内存控制器集成于片内(Integrated Memory Controller，IMC)，直接取消了北桥芯片组</strong>。内存控制器决定了计算机系统的内存参数与性能，CPU与内存的通信原本要经过北桥，其带宽受到前端总线FSB的限制难以提升。Intel在Nehalem采用了新的直连架构，使CPU到内存的路径更短，同时采用<strong>片内全新的QPI(Quick Path Interconnect)总线技术(支持多处理器以及允许core间内部互通)</strong>，来大幅度提高CPU与内存的I/O性能，并支持三通道DDR3。</li>
<li>支<strong>持四种分支预测predictor：Branch Target Buffer(BTB), Loop Detector, Indirect Branch Target Array和Return Stack Buffer (RSB)</strong>。</li>
<li><strong>20-24级pipeline</strong>。</li>
<li>采用<strong>64位宏操作融合(MOF)技术</strong>。</li>
<li><strong>指令与数据共存的二级4路TLB(sTLB)</strong>。</li>
<li>增大了Core的大小，从而实现更高的性能。比Penryn(Merom内核的后续精工艺版)<strong>降低了30%的功耗，平均提高了15%-20%的单周期性能</strong>(单线程/多线程都有不错的提高)。</li>
<li><strong>降低了架构中原子操作的50%时延</strong>，例如加锁操作的Compare-and-Swap(CAS)指令。</li>
</ul>
<h4 id="tickwestmere"><a class="markdownIt-Anchor" href="#tickwestmere"></a> Tick——Westmere</h4>
<p>1年后的2010年1月，Intel推出了采用升级工艺32nm的<strong>Westmere内核</strong>，<strong>架构依然是Nehalem</strong>，接口采用LGA1156。Westmere最大的变化就是<strong>片内集成了GPU(核显)</strong>，虽然性能不行但<strong>抢占了AMD宣传好久APU核显的先机</strong>，间接影响了Navida放弃芯片组市场。</p>
<h3 id="sandy-bridge架构"><a class="markdownIt-Anchor" href="#sandy-bridge架构"></a> Sandy Bridge架构</h3>
<h4 id="tocksandy-bridge"><a class="markdownIt-Anchor" href="#tocksandy-bridge"></a> Tock——Sandy Bridge</h4>
<p>2011年1月，Intel推出了<strong>升级架构Sandy Bridge</strong>，<strong>内核代号也是Sandy Bridge</strong>，采用32nm工艺不变，是第二代Core i系列处理器，其架构是Nehalem的后继者。其主频为1.6GHz~3.6GHz，接口采用LGA1155，依然是64KB-256KB-2MB(per core L1, per core L2, shared L3)的Cache模式。</p>
<img src="https://s2.loli.net/2022/05/20/2AJjTFnbC1ZW4lS.png">
<center>图30 Sandy Bridge其内Die示意图</center>
<p>其带来的主要特色有：</p>
<ul>
<li>对集成的GPU架构进行修改，<strong>真正实现将GPU与CPU融合的核显</strong>(Integrated Graphics Processor，IGP)，使核显的性能增强，直逼低端的独显，同时核显可以访问共享的L3 Cache。</li>
<li>采用了**环形总线(Ring Bus)**来链接各个core以及其L1/L2 Cache，从而以简介、高效又灵活的方式使多核之间的通信与交互变得简单。</li>
<li>支持了<strong>AVX 256-bit指令集</strong>是Sandy Bridge最重要的改进，实现浮点性能、矩阵计算快90%。<strong>AVX指令集是X86指令集的SSE延伸架构</strong>，其全新的命令格式系统同时也为AVX指令集的大幅度后续扩充做好了准备。</li>
<li>支持<strong>Intel Quick Sync Video技术</strong>，目的是加速硬件视频解码。</li>
<li>使用了<strong>新一代智能动态加速技术(睿频2.0)</strong>(Intel Turbo Boost 2.0，上一个版本用在了Nehalem上)，增强了CPU自动提速的弹性，除CPU外还可对GFX(核显)进行加速，并随着系统负载的不同协调二者的频率升降，表现得更加智能化。</li>
<li>支持双通道DDR3-1600；</li>
<li>采用14到19级的pipeline(取决于微操作cache是否命中)。</li>
</ul>
<img src="https://s2.loli.net/2022/05/20/iCSzOcRP34mvIyu.png">
<center>图31 Sandy Bridge的Ring Bus结构</center>
<p>这一时期AMD大力鼓吹<strong>异构计算</strong>，其Fusion APU概念让Intel压力山大。</p>
<h4 id="tickivy-bridge"><a class="markdownIt-Anchor" href="#tickivy-bridge"></a> Tick——Ivy Bridge</h4>
<p>2012年4月，Intel推出了采用升级工艺22nm的<strong>Ivy Bridge内核</strong>，<strong>架构依然是Sandy Bridge</strong>，是第三代Core i系列处理器。其主频为1.4GHz~4.1GHz，接口采用LGA1155不变，依然是64KB-256KB-2MB(per core L1, per core L2, shared L3)的Cache模式。</p>
<img src="https://s2.loli.net/2022/05/20/PUS3fiwEMhjtb17.png">
<center>图32 Ivy Bridge其内Die示意图</center>
<p>Ivy Bridge是Sandy Bridge的工艺改良版，并没有对架构做出太大修改，其带来的主要特色有：</p>
<ul>
<li>首次采用了22nm 3D晶体管工艺，是今后Intel半导体工艺的重要基础；</li>
<li>CPU内部PCI-E控制器也升级到<strong>PCI-E 3.0标准</strong>，带宽提升了一倍，分配方式也更灵活；</li>
<li>集成GPU得到一定增强，其<strong>EU(类似CPU中的ALU，EU是GPU的基本运算单元)数从12个提升到16个</strong>，API支持从DX10.1升级到了DX11。</li>
</ul>
<h3 id="haswell架构"><a class="markdownIt-Anchor" href="#haswell架构"></a> Haswell架构</h3>
<h4 id="tockhaswell"><a class="markdownIt-Anchor" href="#tockhaswell"></a> Tock——Haswell</h4>
<img src="https://s2.loli.net/2022/05/20/gnyoms9wKcM1e3V.png">
<center>图33 Haswell其内Die示意图</center>
<p>2013年6月，Intel推出了升级架构Haswell，<strong>内核代号也是Haswell</strong>，采用22nm工艺不变(更成熟，大幅改善因量子穿隧效应而导致的漏电率)，是第四代Core i系列处理器。其Cache依然是64KB-256KB-2MB(per core L1, per core L2, shared L3)模式，接口采用LGA1150。</p>
<img src="https://s2.loli.net/2022/05/20/IoScuWVbvtGTmf6.png">
<center>图34 Haswell架构图</center>
<p>其带来的主要特色有：</p>
<ul>
<li>Haswell最引人注目的地方就在于<strong>各种节能设计</strong>：主板上的电压调节模块(VRM)集成到了CPU内部，称为FIVR模块(全集成式电压调节模块)，是Haswell节能设计的一个重大基础，能够实现对CPU内部电压更精准的把控与功耗管理、主板的供电效率的提升以及简化主板设计。</li>
<li>增加了两个指令集：<strong>针对多线程应用的TSX扩展指令，以及AVX指令的进阶版AVX2指令集</strong>。</li>
<li>从Haswell架构开始，<strong>核显开始模块化、可扩展的设计</strong>并使用Gen7.5架构，方便走后续暴力堆砌核显规格的道路——最高级的核显拥有40个EU，还有大容量eDRAM作为L4 Cache，可同时提升CPU与GPU性能。</li>
</ul>
<h4 id="tick-processbroadwell"><a class="markdownIt-Anchor" href="#tick-processbroadwell"></a> Tick (Process)——Broadwell</h4>
<p>2014年1月，Intel推出了采用升级工艺14nm的<strong>Broadwell内核</strong>，<strong>架构依然是Haswell，是第五代Core i系列处理器</strong>。</p>
<p>Broadwell主要用在移动与服务器平台上，且国内没有正式上市所以没啥存在感。实际上，Intel自己也在2014年承认在生产14nm工艺的Broadwell就卡了很久(良品率不够)，以至于砍掉了Broadwell的桌面版，而直接在Tock年推出了后续的Skylake新架构。</p>
<p>另一方面，Broadwell也不过是Haswell的工艺增强版：Intel表示14nm工艺的每瓦性能比是22nm工艺的2倍；在诸如sTLB的大小、某些指令的延迟、指令调度队列大小等参数上进行了优化改动；实现了IPC提升约5％；同时对核显也进行了一定的优化，使用Gen8架构；微处理器接口也采用LGA1150不变。Broadwell几乎没有对架构进行太多改动。</p>
<h3 id="skylake架构"><a class="markdownIt-Anchor" href="#skylake架构"></a> Skylake架构</h3>
<h4 id="tock-architectureskylake"><a class="markdownIt-Anchor" href="#tock-architectureskylake"></a> Tock (Architecture)——Skylake</h4>
<p>2015年8月，Intel推出了升级架构Skylake，<strong>内核代号也是Skylake</strong>，采用14nm工艺不变(但比Broadwell更成熟)，是<strong>第六代Core i系列处理器</strong>。其最高主频高达4.5 GHz，接口采用LGA1151。</p>
<p>Skylake同时升级了架构、工艺及核显等，四核称为标配，其带来的CPU主要特色与改进有：</p>
<ul>
<li>内存<strong>同时支持DDR3与DDR4</strong>，实现DDR3、DDR4 的无缝接轨。</li>
<li>更先进的14nm工艺(Broadwel太菜啥也不是)，使用了第二代FinFET晶体管技术，缩小了晶体管的体积，提升了其密度，优化了漏电问题，使Skylake在<strong>提升了频率与性能又明显降低了TDP功耗</strong>(四核处理器的TDP从Haswell)。</li>
<li><strong>取消了Haswell中引入的FIVR电压控制模块</strong>，使电压控制功能重新回归主板上。因为实现片内集成FIVR电压控制模块增加了处理器的复杂性，虽然FIVR能更易于处理器进行功耗管理，但却也会增加TDP功耗。</li>
<li>使用<strong>网状总线架构(mesh bus)代替原来的ring Bus(环形总线架构)</strong>。这是因为ring bus的特点是随着核数的增加延迟时间也会增加，当核心数较多时ring bus的是延迟就会比较明显。在Skylake架构的Intel Xeon E7 v4处理器中，内核数量已经达到24个。</li>
<li>解放了一定的外频，从而强化了可超频性，令Skylake的超频性能很好。</li>
</ul>
<p>在GPU方面，Skylake核显与Broadwell相似，但使用<strong>Gen9架构</strong>，每组Subslice(GPU中多个EU加上一些附属部件组合而成)单元依旧是24个EU，但整体规模变得更大了(<strong>暴增到72个EU</strong>)。</p>
<h4 id="optimization一堆细灰级更新"><a class="markdownIt-Anchor" href="#optimization一堆细灰级更新"></a> Optimization——一堆细灰级更新</h4>
<p>2016年8月，Intel推出了采用工艺14nm的<strong>Kaby Lake内核</strong>，<strong>架构依然是Skylake</strong>，是Skylake的第一个优化版本，主要改善能耗比，是<strong>第七代Core i系列处理器</strong>，接口也采用LGA1151不变。</p>
<p>其增加的细微优化内容例如：</p>
<ul>
<li>Intel在Kaby Lake上升级为14nm+工艺，采用了更高的鳍片与更宽的栅极间距(晶体管上的)，从而降低晶体管密度、减少漏电概率，如此一来可以实现更高的频率但功耗能没什么变化。</li>
<li>在<strong>GPU方面采用全新的图形架构——使用Gen9.5架构</strong>，增加了H.265 Main.10、VP9 8/10-bit等格式的硬件解码与编码，可大幅降低3D图形和4K视频播放时的功耗。</li>
<li><strong>支持DMI 3.0(Direct Media Interface，直接媒体接口)以及Thunderbolt 3</strong>。</li>
</ul>
<p>2017年10月，Intel推出了<strong>更精进的14nm工艺的Coffee Lake内核</strong>，<strong>架构依然是Skylake</strong>，是Skylake的第二个优化版本，也是<strong>第八代Core i系列处理器</strong>，接口采用LGA1151-2。此产品主要是为了<strong>应对AMD的初代Ryzen处理器(八核)带来的压力</strong>而也迅速推出的“多核”版本。</p>
<p>其增加的细微优化内容例如：</p>
<ul>
<li><strong>更多的core</strong>(在Kaby Lake对应的i系列产品多增加两个)，并<strong>根据core的数量增加L3 Cache的容量</strong>。</li>
<li>再次改进制程，升级为14nm++工艺，具有更高的晶体管栅极间距实现更低电流和更多晶体管，从而实现更高的功率(以芯片面积和空闲功率变大为代价)。</li>
<li><strong>不再支持DDR3内存，同时DDR4内存可支持2400MHz(i3)与2666MHz(i5和i7)</strong>。</li>
<li><strong>提高了睿频时钟频率</strong>，最高可增加200MHz。</li>
</ul>
<p>2019年8月，Intel推出了<strong>精进的14nm工艺(依然是14nm++)的Comet Lake内核</strong>，是<strong>Coffee Lake的更多核心版本(i7,i9)，架构依然是Skylake，是第十代Core i系列处理器</strong>，接口采用LGA1200，其实没有明显变化。</p>
<p>纵观Intel，在2017到2019年间共发布了5款14nm的Optimization阶段的内核…而算上下面的Process、Architecture阶段，以及上面的Tick阶段发布的第一款14nm工艺的Broadwell内核，Intel在2014年到2018年一共发布了8款14nm工艺的内核…好嘛，我完全能感受到Intel被卡在10nm工艺的痛苦，以及对战略的更改。而这些处理器大部分相邻代之间的修改与调整优势何其细碎，真就是“挤牙膏”呢，性能之间的进步都不如当初4004到8008之间的飞跃(夸张)。</p>
<h4 id="process流产的cannon-lake与coffee-laker"><a class="markdownIt-Anchor" href="#process流产的cannon-lake与coffee-laker"></a> Process——流产的Cannon Lake与Coffee Lake/R</h4>
<p>2018年5月，Intel推出了<strong>依然是14nm工艺(理论上应该是10nm)的Cannon Lake内核，架构依然是Skylake，是第九代Core i系列处理器</strong>(P.S. 第十代写在了上面，19年的Comet Lake)。</p>
<p>虽然Cannon Lake应该是Process(更新工艺)阶段，但是Intel依然卡在14nm到10nm的这道坎，以致于继续推出了14nm的Cannon Lake内核！Cannon Lake被初代10nm工艺所严重拖累，以至于该系列仅推出了一款处理器就被Intel给砍掉了，而为它配套的300系芯片组被修修改改用在了Coffee Lake身上。而由于工艺制成问题无法按期解决，最终Cannon Lake也在Intel的信誓旦旦中悄然凋零，仅有一款实体产品流入了中国市场的教育机(而且性能臭的不行)。</p>
<p>同年第四季度，Intel推出了<strong>14nm+++(14nm的天花板)工艺的Coffee Lake Refresh内核</strong>(Coffee Lake是17年发布的，上面提到)，架构依然是Skylake，作为正儿八经发售的第九代Core i系列处理器，是历史上<strong>首次支持高达128GB内存的处理器</strong>，接口采用LGA1151-2不变。</p>
<h3 id="sunny-cove架构"><a class="markdownIt-Anchor" href="#sunny-cove架构"></a> Sunny Cove架构</h3>
<h4 id="architectureice-lake"><a class="markdownIt-Anchor" href="#architectureice-lake"></a> Architecture——Ice Lake</h4>
<p>2019年8月，Intel推出了<strong>升级架构Sunny Cove，其内核代号为Ice Lake，也更新采用10nm新工艺</strong>(姗姗来迟)！Ice Lake是第二代10nm工艺处理器(第一代是流产的Cannon Lake)，也是<strong>第十代Core i系列处理器</strong>(另一个是同期发布的Skylake架构的Comet Lake)，接口采用BGA1526。</p>
<p>其主要特点有：</p>
<ul>
<li>更深的缓冲区与更大的缓存结构：<strong>对L2 Cache提升到512KB每核心</strong>、加大了微指令Cache、加大了ROB队列的大小等等数值调整。</li>
<li>加入了<strong>AVX512指令集</strong>。同时因运算AVX512中指令会提升CPU功耗，因此Ice Lake默认频率被大幅调低以保持TDP功耗。</li>
<li><strong>支持LPDDR4X内存</strong>。</li>
<li><strong>集成Thunderbolt 3.0控制器</strong>(Intel与苹果合作开发的硬件接口标准，一个多功能外设接口)。</li>
<li>基于机器学习辅助的动态调频技术2.0，其实就是<strong>基于机器学习来让CPU提前对未来进行动态睿频</strong>。</li>
</ul>
<h4 id="optimizationtiger-lake"><a class="markdownIt-Anchor" href="#optimizationtiger-lake"></a> Optimization——Tiger Lake</h4>
<p>2020年9月，Intel发布了<strong>代号Tiger Lake的第十一代Core系列微处理器</strong>，同时<strong>架构升级为Willow Cove</strong>，号称近年来处理器史上一次巨大飞跃：工艺到架构都有极大变化，升级力度在这几代酷睿中是非常明显的。</p>
<p>Tiger Lake采用10nm+工艺，首次采用全新的SuperFin晶体管技术(官方表示它甚至重新定义了FinFET工艺)；得益于先进的工艺，从上代的3.9GHz一下子提升到4.8GHz，保持功耗不变的情况下提升了20%的性能。</p>
<p>其主要特点有：</p>
<ul>
<li><strong>GPU使用全新的Xe架构，最多拥有96个EU</strong>(相比Ice Lake增多了一半)，<strong>浮点性能提升了87%，相当于入门级独显了</strong>。</li>
<li>支持<strong>AI加速指令集DLBoost</strong>，同时Intel<strong>重写了底层架构，针对全场景AI作了加强</strong>——除了已经支持的BF16，又增加了其内的<strong>VNNI、DP4A等指令集</strong>，带来了更强大的AI性能或矢量神经网络指令，支持低精度指令，可加速基于卷积神经网络的算法。</li>
<li>加入了独立的<strong>GNA 2.0(Gaussian&amp;Neural Accelerato)单元(Intel的低功耗AI加速器)</strong>，能专门针对工作流负载进行优化，如在听写、翻译或动态降噪方面帮助用户提升体验。其只需低功耗就可以高效推理计算，并且将CPU占用率降低了20%而可以全天候使用——闲时低功耗待机，忙时加速AI运算。</li>
</ul>
<h4 id="process"><a class="markdownIt-Anchor" href="#process"></a> Process</h4>
<p>还未发布。</p>
<h1 id="intelamd-roadmap将来几代架构的分析"><a class="markdownIt-Anchor" href="#intelamd-roadmap将来几代架构的分析"></a> Intel/Amd Roadmap将来几代架构的分析</h1>
<p>由于制程工艺已经抵达10nm，不断涌现的材料学与元器件方面的问题会不断制掣其工艺的提升，使难度继续增加。虽然说各界都有在挖寻各色黑科技与材料来尝试对工艺进行突破，但现实一些思考，摩尔定律的减速已经非常明显。回看Intel在22nm-14nm-10nm的痛苦过程，<strong>Intel的优势很大程度上来自于其领先的制程工艺</strong>，据查阅有说法Intel领先其他代工厂3年多，然而在14nm到10nm这根硬骨头上卡得太久太久，使<strong>Intel的工艺优势已经荡然无存了</strong>。</p>
<p>我有理由认为，芯片半导体的制程工艺精进会非常缓慢，而“多核处理器”的发展基调将会继续保持为未来7、8年的新发布微处理器的主要旋律，但是单纯叠核心数与Cache大小过于无脑。因此，基于多核的任务协调处理机制、对当下架构与老制程的进一步补充优化将会是芯片性能提升的过渡方法。</p>
<p>其次，自从AMD的APU以及Intel的核显理念与产品的推出，片内集成GPU的地位与效用也不断凸出，因此各厂家都必然会对核显的性能继续深入优化并作为卖点的宣传攻势。</p>
<p>Intel的历代Core系列的变化，从CPU到GPU再到现在新兴的AI芯片，它们已经逐渐融为一体：<strong>CPU可以提升GPU性能，GPU可以辅助AI计算，而AI芯片也可以辅助CPU处理各色新型任务</strong>。当下并行计算、图形渲染与人工智能的应用场景越来越广泛，那么面向AI的计算芯片也将会成为重非常要的市场热点。</p>
<h1 id="参考文献与网站"><a class="markdownIt-Anchor" href="#参考文献与网站"></a> 参考文献与网站</h1>
<p><a href="http://www.mcplive.cn/index.php/article/index/id/10609/viewall/1">见证&quot;芯&quot;路 30年CPU架构发展史(一)Intel</a><br>
<a href="https://cpu.zol.com.cn/46/461549_all.html">Intel芯片设计35年：从4004到80核心</a><br>
<a href="https://mp.weixin.qq.com/s/31tCRFr2UNAUvhqA7MCfRA">普及贴：CPU的发展历程（X86篇）</a><br>
<a href="https://blog.csdn.net/jhkmichael/article/details/105907377">intel和amd处理器发展历史-CSDN</a><br>
<a href="https://www.shangyexinzhi.com/article/421398.html">X86架构发展史（上）_新知</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_4004">维基百科Intel CPU 4004</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_8008">维基百科Intel CPU 8008</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_8080">维基百科Intel CPU 8080</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_8086">维基百科Intel CPU 8086</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_80286">维基百科Intel CPU 80286</a><br>
<a href="https://blog.csdn.net/qq_37653144/article/details/82818191">实模式和保护模式_CSDN</a><br>
<a href="https://blog.csdn.net/kennyrose/article/details/7563649">CPU 实模式 保护模式 和虚拟8086模式_CSDN</a><br>
<a href="https://blog.csdn.net/trochiluses/article/details/8954527">实模式与保护模式解惑之（一）——二者的起源与区别_CSDN</a><br>
<a href="https://zhuanlan.zhihu.com/p/69334474">x86-64处理器的几种运行模式</a><br>
<a href="https://www.cnblogs.com/chengxuyuancc/archive/2013/05/12/3073738.html">实模式、保护模式和虚拟模式_博客园</a><br>
<a href="https://www.cnblogs.com/xiaoxiongcanguan/p/12852788.html">80386学习（一） 80386CPU介绍_博客园</a><br>
<a href="https://stkeke.blog.csdn.net/article/details/85230687">8086架构/流水线及其优化_CSDN</a><br>
<a href="https://blog.csdn.net/qq_43401808/article/details/85230797">80286/286/Intel286 架构/流水线及其优化_CSDN</a><br>
<a href="https://zhuanlan.zhihu.com/p/27653150">80386的缓存Cache_知乎</a><br>
<a href="https://stkeke.blog.csdn.net/article/details/85231491">80486/486/Intel486 架构/流水线及其优化_CSDN</a><br>
<a href="https://markcup.top/2020/03/02/cpu%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2/">CPU发展简史_马克的杯子</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_80386">维基百科Intel CPU 80386</a><br>
<a href="https://en.wikipedia.org/wiki/Intel_80486">维基百科Intel CPU 80486</a><br>
<a href="https://en.wikipedia.org/wiki/P5_%28microarchitecture%29">维基百科P5（微体系结构）</a><br>
<a href="https://en.wikipedia.org/wiki/Pentium_Pro">维基百科Pentium Pro</a><br>
<a href="https://blog.csdn.net/qq_43401808/article/details/85232214?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161180433216780264022625%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=1">Pentium Pro架构/流水线及其优化 (3)_CSDN</a><br>
<a href="https://en.wikipedia.org/wiki/Pentium_II">维基百科Pentium Ⅱ</a><br>
<a href="https://blog.csdn.net/qq_43401808/article/details/85316606?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161182899016780271521418%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=1">Pentium II &amp; Pentium III架构/微架构/流水线 (7)_CSDN</a><br>
<a href="https://en.wikipedia.org/wiki/List_of_Intel_CPU_microarchitectures">维基百科List of Intel CPU microarchitectures</a><br>
【EM64T与AMD64】<br>
<a href="https://www.cnblogs.com/Alliswell-WP/p/x86-64.html">64位版本为什么叫amd64，而不是intel64？_博客园</a><br>
<a href="https://blog.csdn.net/x356982611/article/details/48341921">x86,amd64,x86-64,x64区别_CSDN</a><br>
<a href="https://www.cnblogs.com/yilang/p/10974327.html">常见的CPU指令集介绍_博客园</a><br>
【基础知识部分】<br>
<a href="https://www.zhihu.com/question/37849674">Socket为什么常变而PCI规范不常变化？_知乎</a><br>
<a href="https://zhuanlan.zhihu.com/p/47479121">为什么不把南桥集成进CPU？_知乎_老狼</a><br>
<a href="https://zhuanlan.zhihu.com/p/51354994">什么是CPU Die？_知乎_老狼</a><br>
<a href="https://www.zhihu.com/question/26998618">芯片里面有几千万的晶体管是怎么实现的？_知乎</a><br>
<a href="https://blog.csdn.net/stringNewName/article/details/90443939">计算机体系结构.指令集架构_CSDN</a><br>
【还没写入】<br>
<a href="http://www.mcplive.cn/index.php/article/index/id/10610/viewall/1">见证&quot;芯&quot;路 30年CPU架构发展史(二)AMD</a><br>
【Core架构】<br>
<a href="https://blog.csdn.net/qq_43401808/article/details/85451822?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161190351416780299099522%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fblog.%252522%25257D&amp;request_id=1">Pentium 4处理器架构/微架构/流水线 (3)_CSDN</a><br>
<a href="https://stkeke.blog.csdn.net/article/details/85452924">Pentium 4处理器架构/微架构/流水线 (12)_CSDN</a><br>
<a href="https://en.wikipedia.org/wiki/Pentium_M">维基百科Pentium_M</a><br>
<a href="https://en.wikipedia.org/wiki/Yonah_%28microprocessor%29">维基百科Yonah (microprocessor)</a><br>
<a href="https://www.anandtech.com/show/1083/4">Intel’s Centrino CPU (Pentium-M)_AnandTech </a><br>
<a href="http://tech.sina.com.cn/h/2007-03-31/0630277318.shtml">性能将提升45% 45nm Penryn处理器图解_新浪科技</a><br>
<a href="https://baike.baidu.com/item/Core%E5%BE%AE%E6%9E%B6%E6%9E%84/492445?fromtitle=CORE%E6%9E%B6%E6%9E%84&amp;fromid=3163328">Core微架构_百度百科</a><br>
<a href="https://zh.wikipedia.org/wiki/Intel_Tick-Tock">维基百科Intel Tick-Tock</a><br>
<a href="https://en.wikipedia.org/wiki/Tick%E2%80%93tock_model">维基百科Tick–tock model</a><br>
<a href="https://www.ithome.com/html/mac/217749.htm">Intel“Tick-Tock”进化模式失效_IT之家</a><br>
<a href="http://www.360doc.com/content/20/1028/18/72127748_942850444.shtml">Intel“Tick-Tock”已死_个人图书馆</a><br>
<a href="https://blog.csdn.net/qq_43401808/article/details/85553914">Intel® 处理器产品架构/微架构对照表_CSDN</a><br>
<a href="https://www.d3tt.com/view/111">intel 虚拟化 VT-d VT-x VT-c 有什么区别_DT33</a><br>
<a href="https://en.wikipedia.org/wiki/Nehalem_%28microarchitecture%29">维基百科Nehalem (microarchitecture)</a><br>
<a href="https://en.wikipedia.org/wiki/Sandy_Bridge">维基百科Sandy Bridge</a><br>
<a href="https://baike.baidu.com/item/QPI">QPI总线_百度百科</a><br>
<a href="https://www.expreview.com/49967-2.html">Intel真的在挤牙膏？_Expreview</a><br>
<a href="https://www.expreview.com/25926-3.html">全新Haswell架构_Expreview</a><br>
<a href="https://en.wikichip.org/wiki/intel/microarchitectures/haswell_%28client%29">Haswell - Microarchitectures - Intel_WikiChip</a><br>
<a href="https://en.wikichip.org/wiki/intel/microarchitectures/broadwell_%28client%29">Broadwell - Microarchitectures - Intel_WikiChip</a><br>
<a href="https://en.wikipedia.org/wiki/Skylake_%28microarchitecture%29">维基百科Skylake (microarchitecture)</a><br>
<a href="https://www.gcores.com/articles/124346">Intel是怎么失去自己的性能优势地位的_GAMECORES</a><br>
<a href="https://zhuanlan.zhihu.com/p/79369799">聊聊已经发布的十代酷睿处理器（2）_知乎</a></p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】世界双雄：微软和苹果</title>
    <url>/posts/05415c493fc8</url>
    <content><![CDATA[<p>转载自<a href="https://zhuanlan.zhihu.com/p/108721687">知乎</a></p>
<p>苹果和微软，这是一对缠斗了近半个世纪的欢喜冤家，先看一张对比图。</p>
<img src="https://s2.loli.net/2022/05/19/WjQY2Ja9Ruv6FSU.jpg">
<p>1975年，20岁的盖茨在哈佛上大二，被年长两岁的保罗.盖伦连哄带骗，退学后一起创立了微软。<br>
1976年，21岁的乔布斯从里德学院退学，说服了大他五岁的斯蒂芬.沃兹尼克尔，共同创建了苹果。<br>
从那时开始，这两位同龄人，正式进入个人电脑领域，带领着各自的公司，开始了近半个世纪的对决。往后的四五十年中，苹果和微软，彼此斗争，相爱相杀，共同将PC送入千家万户。<br>
也许是巧合，经历了各自的兴衰后。2020年，微软和苹果的市值双双突破1.4万亿美元，成为市值最高的IT企业，遥遥领先于第二梯队的谷歌、亚马逊。<br>
究竟是什么支持着这两个半百老人，长盛不衰，走到如今呢？</p>
<h1 id="微软"><a class="markdownIt-Anchor" href="#微软"></a> 微软</h1>
<p>让我们先从微软开始说起。</p>
<h2 id="微软诞生"><a class="markdownIt-Anchor" href="#微软诞生"></a> 微软诞生</h2>
<p>1975年，保罗.盖伦拿着Altair 8800的资料，给盖茨描绘了PC（个人电脑）的美好蓝图。<br>
戴着厚重眼镜的盖茨最终被他说服，从哈佛退学，在那一年，两人一起创办了一家公司，由保罗.盖伦提议，命名为MicroSoft。</p>
<img src="https://s2.loli.net/2022/05/19/Ta6tCpDXyMjWkgG.jpg">
<p>￼<br>
那一年，他们还在为Altair 8800电脑设计Altair BASIC编辑器，这个编辑器后来成为Microsoft BASIC，也就是MS-DOS操作系统的基础。<br>
应该说，微软的起步并不顺利，在很长的时间内，并没有拿出能攻占市场的产品，举步维艰，发展地极为缓慢。而晚它一年成立的苹果公司，已经凭借出色的产品Apple 1 和 Apple 2 ，收获了几十万的订单，业绩蒸蒸日上。<br>
直到1980年，凭借盖茨空手套白狼，拿到了巨头IBM的订单后，事业才开始有了转机。<br>
当时的巨头IBM也生产个人电脑，但由于利润稀薄，它根本看不上PC市场。盖茨前往IBM推广自己开发的Basic解释器，了解到IBM需要一个PC的操作系统。虽然两手空空，但敏锐的盖茨察觉到这是个机会，于是便接下了这份合同。<br>
离开IBM后，盖茨用5万美金的低价，从西雅图的一位年轻程序员手中，买下了86-DOS的著作权，将其改为MS-DOS后，转而再卖给了IBM。<br>
而且卖的方式很聪明，只收版权费，不卖源代码。他用这种极低的价格的方式（每个5美元），成功打入了IBM的系统。鉴于1980年代IBM的巨大影响力，兼容机泛滥成灾，因此，微软的MC-DOS系统开始占领了大量的PC市场。<br>
虽然利润微薄，但微软算是正式迈出了进军PC的第一步。<br>
也就在同一年，1980年，如日中天的苹果公司登陆纳斯达克，打破多项记录，成为了当时最大的IPO。<br>
彼时的苹果，从创立起，仅用五年时间就杀入世界五百强，风头一时无两。而微软，还是一家为能拿下IBM订单而沾沾自喜的小公司。</p>
<h2 id="乔布斯会见盖茨"><a class="markdownIt-Anchor" href="#乔布斯会见盖茨"></a> 乔布斯会见盖茨</h2>
<p>时间来到1981年，乔布斯和盖茨第一次正式会面。</p>
<img src="https://s2.loli.net/2022/05/19/BjnuTK9y4pWhMUw.jpg">
<p>那一年，乔布斯开发了颠覆DOS操作系统的全新产品，Macintosh。临近研发后期，苹果需要一些软件公司在Macintosh的系统上开发一些应用软件，由于微软做事又快又好的名声，乔布斯找到了盖茨。<br>
整个会面过程非常不愉快，26岁就位居人生巅峰的乔布斯，完全瞧不起戴着厚重眼镜、一脸书生气的盖茨。他给盖茨展示了Macintosh的操作系统，深深震撼了盖茨。<br>
这种完全图形化操作的界面，不知道要甩微软的DOS系统多少条街。<br>
虽然是一次不愉快的会面，但是敏锐而聪慧的盖茨，似乎看到了PC的未来，他决心要开发这种图形化的系统。<br>
会面结束后，盖茨表面上答应为苹果开发三款应用软件，借此机会了解苹果的系统和技术。另一方面，回到微软后，盖茨立刻开始部署了图形化界面系统的开发工作。<br>
对于盖茨和微软而言，开发图形化界面系统的工作异常漫长，在这之前，他需要抵挡苹果Macintosh的进攻，在PC领域活下去。<br>
幸运地是，命运站在了微软这边。<br>
1984年，Macintosh正式发布，由于兼容性太差，售价过高，市场反响平平。而更令人惊讶的是，1985年，乔布斯居然被苹果董事会赶出了这个自己一手创办的公司。<br>
整个80年代，苹果先后失去了灵魂人物，沃兹尼克尔和乔布斯，成为了一家平庸的公司。<br>
这让微软有了喘息的机会，由于伴上了IBM这艘大船，微软便宜的DOS系统得到迅速推广，在此后9年的版本更迭里，微软始终保证了产品的兼容性，因此留住了大量的用户。<br>
1986年，凭借着稳定的收入，微软进行了IPO，补充了血液。在这一时期，盖茨以他谦虚的态度，为微软引进了大量人才使得图形化系统的开发工作，得以快速推进。</p>
<h2 id="垄断操作系统"><a class="markdownIt-Anchor" href="#垄断操作系统"></a> 垄断操作系统</h2>
<p>1990年，微软终于推出了自己的图形化操作系统，Windows 3。凭借此前积累的众多用户，该系统一经推出，就广受好评，得到了迅速推广。<br>
从此，微软扭转了PC领域的劣势，并自此奠定了微软江湖在操作系统的霸主之位。而对应的，苹果的PC机市场份额，从这一年开始，迅速下降。<br>
可以说，虽然最早商业化图形化系统的PC来自于苹果，但将简单易用的个人电脑送入千家万户的，却是微软。<br>
得民心者得天下，微软，正式走向巅峰。<br>
在确立了操作系统一哥的地位之后，微软没有歇着，手起刀落，迅速干掉了三个竞争对手。它们分别是做表格软件的Lotus、做文字处理软件的WordPerfect、做浏览器的Netspace。<br>
由于微软早期的系统利润很低，它的收入甚至不如一家做应用软件的开发公司Lotus。但这并无妨，自从奠定了操作系统江湖之后，所有的软件公司都得依重于Windows，才能落地到用户。<br>
微软发起的这三场战争中，前两场异常轻松，甚至没开始就已经结束了。软件公司Lotus和WordPerfect，都需要在拿到微软的系统后，才能开始开发自己的软件，而等他们开始动手，微软已经把自己相应的软件给做好了，也就是后来我们所熟知的Excel、Word，占尽先机。<br>
而NetSpace（网景）之战，其实是一场经典而著名的战役。后来的IT公司，在面对微软时，都借鉴了网景的失败。<br>
微软的战略异常简单，虽然网景浏览器好用且用户量多，但需要付费。微软将自己开发的IE浏览器与Windows系统捆绑，免费提供给用户。<br>
攻城掠地，兵不血刃，网景欲哭无泪。<br>
整个90年代，微软的声誉极差，甚至引得软件公司的众怒，因为微软背靠庞大的用户群体，凭借着科技人才，迅速模仿出了大多数盈利且重要的软件产品，并后发制人，一点点蚕食了各大软件公司的市场，将后者置于死地。<br>
<strong>多年后中国的腾讯公司，深得微软真传。同样凭借着广大的用户基础，逼死了一众软件公司，并获得了抄袭之王的恶名，这是后话。</strong><br>
正是凭借着操作系统的成功，微软进一步加强了在软件上的控制力，通过几个核心付费产品（Office套件）走到了巅峰。<br>
伴随着微软的蚕食和互联网泡沫的破裂，双重夹击之下，美国破产的软件公司达到90%。<br>
严格地说，仅有的几条漏网之鱼，并不在软件行业，而在于互联网行业。比如众所周知的雅虎、谷歌。<br>
毕竟互联网不是微软的领域，入不得法门，而且这道门，让微软在后来吃尽了苦头。</p>
<h2 id="分水岭"><a class="markdownIt-Anchor" href="#分水岭"></a> 分水岭</h2>
<p>时间先回到1997年，故事的两位主角又一次有了交集，这一年，乔布斯重返苹果。<br>
此前苹果状告微软抄袭图形化系统，盖茨反驳，认为图形化界面始祖是Xerox（施乐）而非苹果，苹果自身也是抄袭者。为此，这场官司旷日持久。<br>
乔布斯重掌苹果后，几乎是用央求的态度，以及高明的谈判技巧，给盖茨打了一天的电话，提出和解。微软最终同意了和解，并为苹果注资1.5亿美元。<br>
这给命悬一线的苹果续上了命，也为之后微软的衰落埋下了伏笔。<br>
2000年，正是互联网泡沫破裂之际，微软也走到了他的巅峰时刻。由于凭借Windows系统，挤垮了众多软件公司，微软受到了反垄断调查。<br>
众多软件公司控诉微软凭借操作系统垄断，进行了不正当竞争。<br>
2000年的夏天，法庭裁定，微软的垄断行为触发了反垄断法，将强制拆分温软为两个公司。<br>
刚刚创造记录，成为第一家市值突破5000亿美元不久的微软，当天股票暴跌近一半。等到它下一次重回5000亿市值，已经是十多年后了。</p>
<img src="https://s2.loli.net/2022/05/19/UynQB3DOYaX8oqk.jpg">
<p>自那之后，盖茨第一次隐退，将CEO的位置，交给了大学同学，入职微软20年的鲍尔默。<br>
微软自此进入鲍尔默时代。</p>
<h2 id="衰落之路"><a class="markdownIt-Anchor" href="#衰落之路"></a> 衰落之路</h2>
<p>从2000年起，一直到2013年，虽然盖茨仍有实质上的干预，但一般认为，鲍尔默才是掌舵者。<br>
这是微软失去的十年，虽然坐拥Windows和Office两大利器，每年可以轻松进账百亿。但作为连续十几年股价翻番的企业，华尔街需要它有新的业务增长点。<br>
彼时的互联网明星是雅虎和谷歌，而核心杀器则是门户网站和搜索引擎。<br>
微软借着无往不利的常胜将军姿态，在这其中下了血本，先后推出了MSN、Bing。<br>
也正是这个时候开始，微软忽视了苹果，将注意力集中在了后起之秀雅虎和谷歌身上，花费了大量精力投入到门户网站MSN中，但始终如泥牛入海，泛不起波澜。</p>
<img src="https://s2.loli.net/2022/05/19/a3pdYNCtorD6znV.jpg">
<p>￼<br>
2006年起，微软又开始花大力气投入搜索，推出了后来的Bing。但同样竞争不过Google。<br>
2008年，或许是运气，也或者是远见，总之它播下了十年后的新增长点，云计算的种子，Azure。<br>
同样是这一年，盖茨二次隐退，宣布在微软的全职工作转变为兼职工作，他渐渐的转移他的职责。<br>
微软，因为追逐互联网入口，失去了更为汹涌的移动互联网机会。甚至于，由于忽略了续上命的乔布斯，被苹果的平板电脑iPad杀进了操作系统，PC的Windows系统被打开了缺口，一些轻商务人士，再也没打开过PC电脑。<br>
细数那些年最重大的科技变化，无非就是：门户网站、搜索引擎、手机系统、移动互联网。<br>
某种程度上而言，微软可能只是押错了增长点的赌注。但对于巨人而言，一旦走错，往往难以转身。<br>
鲍尔默时期的微软，确确实实是走向平庸的十年，在这一时期，不仅没有攻城略地，甚至后院起火，四面楚歌。</p>
<h2 id="走出低谷重获新生"><a class="markdownIt-Anchor" href="#走出低谷重获新生"></a> 走出低谷，重获新生</h2>
<p>2010年之后，已经输无可输的微软，终于止住了颓势。虽然它的下一个增长期来自于3年后的新一任掌门人。<br>
但这一时期，发生了太重要的事情，不得不提。<br>
2010年，微软再一次成为媒体焦点，是因为在手机系统上输给了IOS和Android后，收购了2G时代手机之王诺基亚的移动手机部门，挣扎着为Windows Phone续命。<br>
这一年，苹果的市值再次超过微软，完成了从巅峰到谷底，再重回巅峰的商业传奇，并从此一骑绝尘。令人遗憾的是，仅仅一年后，这位与微软缠斗三十多年的老对手，失去了灵魂。<br>
2011年，乔布斯逝世，苹果进入库克时代。微软和苹果的宿命之争，正式划下句号，从此开始了各自圈地的年代，业务上，几乎没有了冲突。<br>
2014年，盖茨第三次隐退，辞去微软的董事长，同时仍作为技术顾问，协助新任命的首席执行官萨帝亚·纳德拉。<br>
盖茨的这种隐退操作，在中国，很容易让人联想到2019年第三次退休的马云老师。<br>
<strong>其实退而不休，逐步放权，这一点，马云老师也是师从盖茨。</strong><br>
微软正式进入萨帝亚·纳德拉时代，<br>
应该说，在过去的那些年里，微软虽然错过了搜索、移动互联，但由萨帝亚·纳德拉带领的云计算，却一步步发展壮大，并成功帮助微软占得一席之地，位居市场份额第二，成为微软另一个稳定的盈利点。<br>
和谷歌的新任CEO皮查伊一样，纳德拉也是印度出身，走到了著名IT公司巅峰。它的一系列改革，目前来看卓有成效，比如收购了Github，拓宽了Azure的市场和服务。<br>
客观地说，微软如今重回IT之巅，纳德拉功不可没。</p>
<h2 id="微软的商业模式"><a class="markdownIt-Anchor" href="#微软的商业模式"></a> 微软的商业模式</h2>
<p>不同于纷纷驻扎硅谷的众多IT公司，微软座落于西雅图，在整个八九十年代，它是整个硅谷的公敌，硅谷的工程师总梦想着有一家硅谷企业能够击败。<br>
进入21世纪后，谷歌和苹果先后都做到了这一点。但从某种程度上说，谷歌是另外开辟了战场，并没有击败微软，只是挡住了微软的进攻。<br>
而苹果，才是那个真正被微软击败，又再次击败微软的企业。<br>
让我们来看看微软帝国的商业构成。<br>
2020年的今天，全世界市值最高的IT企业分为三个梯队。第一梯队1.4万亿美元：苹果和微软。第二梯队1万亿美元： 谷歌和亚马逊。<br>
第三梯队6千亿美元：Facebook和阿里巴巴。<br>
在这些巨头的业务中，微软的业务组成最为稳妥，企业付费产品、云计算服务、以及个人电脑服务三分天下。</p>
<img src="https://s2.loli.net/2022/05/19/vyPEnGp5mZNCJ1B.jpg">
<p>这种非单一盈利模式，同时又都是市场前一前二的行业收入，至少能保证微软活到五十岁，甚至有可能，一百岁。而通过微软2019年的财报，我们可以看出，它1.4万亿美元的市值，并非虚值，作为年营收达到1258.43亿美元，净利率31.18%的企业，年赚392亿美元，市盈率居然只有30左右，远远低于A股市场种的许多科技股。</p>
<img src="https://s2.loli.net/2022/05/19/sanURC8WS2hBLrY.jpg">
<p>更为重要的是，这种巨无霸企业，居然还有14%的年增长率。<br>
不得不说，这是一家改变了世界并赚足了钞票的企业。<br>
通过微软的案例，我们很容易看出。作为一家企业，如果掌握了行业的核心入口，进而产生垄断性优势，那么，它就可能大而不倒，并且有持续不断的现金流去开拓它的第二、第三增长点。<br>
这种性质，我们在微软身上看到，在亚马逊身上看到，谷歌身上看到，在阿里巴巴上，也看到了。</p>
<h1 id="苹果"><a class="markdownIt-Anchor" href="#苹果"></a> 苹果</h1>
<h2 id="苹果诞生"><a class="markdownIt-Anchor" href="#苹果诞生"></a> 苹果诞生</h2>
<p>1976年，从里德学院退学的乔布斯，说服了比自己大五岁的玩伴斯蒂夫·沃兹尼亚克，在自家车库，共同创立了苹果公司。</p>
<img src="https://s2.loli.net/2022/05/19/97atd52gNGLCUcm.jpg">
<p>可以说，斯蒂夫·沃兹尼亚克，是乔布斯这一生传奇的开始，也是苹果这家公司传奇的开始，是他惊人的创造力，带来了苹果早期的产品，将乔布斯和苹果送上了快车道。<br>
与苦苦摸索的微软不同，苹果几乎是先有了产品，而后才成立了公司。在公司成立当年，即1976年推出的Apple 1，虽然还很简陋，但在当时，却算得上超越时代的产品。<br>
当时大多数的电脑没有显示器，Apple I却以电视机作为显示器，算是开了低成本显示界面的市场先河。虽然设计相当简单，但它仍然是一件杰作，而且比其他同等级的主机需用的零件少，使沃兹赢得了设计大师的名誉。<br>
凭借着良好的市场反响，斯蒂夫·沃兹尼亚克用极快的速度，在1977年，就继续推出了升级版Apple 2，大获成功。<br>
整个80年代，苹果的销量达到了数百万，简直可怕。要知道，那可是在上个世纪，个人电脑才刚刚诞生的年代。<br>
正是凭借斯蒂夫·沃兹尼亚克的两款产品，在短短不到五年的时间内，苹果就成为了硅谷明星。<br>
时间来到1980年，凭借良好的表现，苹果公司正式登陆纳斯达克，创造了轰动一时的IPO记录。并且创造了另一个神话，成立五年，就闯入世界五百强。<br>
这一点，即使放在今天，也没有几家企业能够做到。更不用说同时期的微软，那一年的微软，还在为拿到IBM的个人电脑订单而暗自高兴。</p>
<h2 id="1984"><a class="markdownIt-Anchor" href="#1984"></a> 《1984》</h2>
<p>乌托邦类型小说《1984》，曾经引起了很大的反响。<br>
1984年，苹果推出了一款重磅产品，Macintosh，其颠覆程度，丝毫不亚于后来的iPhone对于传统手机的冲击。<br>
Macintosh的命名，来源于一种旭苹果（McIntosh）。这是一款图形化操作界面的电脑，在当时，使用个人电脑还必须具备足够的专业知识，才能够通过输入一行行的命令，去操纵系统。<br>
而图形化界面的推出，大大降低了使用电脑的专业程度。即使没有任何基础知识的人，也可以通过简单的接触便开始自如地使用各种功能。<br>
公平地说，这确实是一款颠覆性的商业产品。并且配合《1984》这个广告创意，在当时确实引起了非常大的轰动。</p>
<img src="https://s2.loli.net/2022/05/19/VyR6kS8XHU7iEns.jpg">
<p>很大程度上，《1984》这个广告，奠定了苹果之后的广告基因。然而很不幸的是，这几乎也成了苹果公司的分水岭。<br>
其实图形化操作界面的系统，是1979年时乔布斯在参观施乐公司时首次见到，直到1981年，才基本完成了苹果公司自己的开发。<br>
在这个阶段，苹果以雇主的身份首次与微软打交道，演示了这一产品，这为后来微软打败苹果埋下了伏笔。<br>
不过那是十年后的事了，在1984年，苹果公司的内斗开始浮出水面。<br>
此前不久，苹果的共同创始人斯蒂夫·沃兹尼亚克就因飞机失事受伤，离开了苹果。<br>
乔布斯为了公司更好地发展，请来了百事可乐的约翰·史考力出任CEO，在度过了一段短暂的蜜月期后，苹果迎来了最动荡的十年。<br>
乔布斯式的管理风格可以用暴君式来形容，加上他对产品的偏执理念，这使得他在苹果内得不到足够的人心支持。<br>
而Macintosh虽然取得了一定的成功，但却没法达到Apple 2那样的巅峰水平。以盈利为第一考虑的董事会，最终通过表决，在1985年正式驱逐了乔布斯。<br>
刚刚经历了人生巅峰的乔布斯，一气之下，几乎卖光了苹果的股份，并带走了一众人员，另起炉灶，开了一家叫NeXT的工作站公司（乔布斯离开苹果后的时光一手打造了享誉全球的皮克斯公司）。<br>
苹果公司，自此开启了失去的十年。</p>
<h2 id="重返苹果"><a class="markdownIt-Anchor" href="#重返苹果"></a> 重返苹果</h2>
<p>1997年，是香港回归的日子，也是乔布斯回归苹果的日子。<br>
在失去乔布斯的十多年里，由于一直没找到一个新的增长点，Macintosh的销量也始终不尽如人意。<br>
苹果逐渐从一家明星逐渐演变为一家二流公司。<br>
到了90年代，十年磨一剑的微软亮出它的Windows系统后，苹果彻底丢掉了它在PE界的领先地位，甚至一度落魄到连收购都无人问津的地步。<br>
另一方面，在苹果失去的这十年中，旧掌门乔布斯却发展地越发顺风顺水，他离开苹果后辗转成立的动画制作公司，皮克斯，在1995年推出了《玩具总动员》。<br>
乔布斯因此身价大增。<br>
1997年，苹果的管理层打算购买乔布斯的OPENSTEP操作系统，经过乔布斯的公关运作，苹果最终决定以收购NeXT公司的方法，获取了他们公司OPENSTEP操作系统及开发人员。<br>
这也最终导致了乔布斯回归苹果，于1997年取代阿梅里奥，成为临时CEO。<br>
乔布斯回归苹果后，进行了大刀阔斧的改革，砍掉了许多冗余的产品线。<br>
在这之后，乔布斯做的最放下身段，也是最力挽狂澜的一件事，便是和巨无霸微软和解。<br>
风水轮流转，16年后，乔布斯和盖茨的身份对调，为了资金，乔布斯放弃了图形界面的专利之争，几乎是以央求的方式给盖茨打电话，并最终得到了微软1.5亿美元的注资。<br>
这让还有90天就要破产的苹果公司缓了一口气。</p>
<h2 id="这是i时代"><a class="markdownIt-Anchor" href="#这是i时代"></a> 这是i时代</h2>
<p>2000年，纳斯达克的滑铁卢，科技股泡沫破裂，无数科技公司破产倒闭，连创造了5000亿市值神话的微软，都跌掉了一半的市值，很多人认为PC将会走向衰落。<br>
然而苹果公司却出了一个奇招，在2001年10月23日发布了第一代的iPod，一款类似于MP3的音乐播放器。</p>
<img src="https://s2.loli.net/2022/05/19/GjPWLS2MqrwcZEe.jpg">
<p>这款小小的音乐播放器，由于外观精致，经营模式独特，为音乐制作人带来了一条可以抗击盗版音乐网站的销售道路，iTunes store，颠覆了传统的音乐产业链。（一定程度上，后来的App Store也是这种商业思路的延续）<br>
小小的iPod，为苹果带来了巨大的营收，在2005年时，iPod销量达到2000万台，在公司营销中占据重要地位，拯救了苹果的产品线，并从此开启了属于苹果的“i十年”。<br>
好景不长，很快，乔布斯等人开始意识到，手机正在蚕食包括数字相机的市场份额，同样地也有可能会蚕食iPod的市场份额。于是，苹果公司开始研究可以打电话的iPod。<br>
最初他们以iPod的转轮设计为基础，但后来公司的平板触摸电脑项目启发了乔布斯，乔布斯决心将这个项目的技术应用在手机上。<br>
因此才有了以金刚玻璃为面板的多点触摸平板手机，iPhone。<br>
2007年1月9日，苹果公司正式推出第一代iPhone 2G手机，6月29日下午6时在美国正式发售（这种预售的套路后来被中国的手机企业学地淋漓尽致）。<br>
由于刚推出的iPhone上市后引发排队热潮，一些媒体甚至将其誉为“上帝手机”。<br>
毫无疑问，和以往的Apple 1、Macintosh、iPod一样，苹果公司又成功商业化了一款超越当前时代的产品。<br>
但这一次不同的是，这款产品是手机，基本上是人人都会去购买的一类电子消费品。<br>
就如同阳光、空气和水一样，作为通讯时代的载体，手机几乎等于刚需。<br>
所以，这一次，iPhone风靡全球，截止2013年4月，苹果卖出了3.56亿只iPhone。<br>
借此东风，苹果分别于2008年1月15日推出了最薄的笔记本电脑MacBook Air、2010年1月推出了平板电脑iPad（弯道超车，吞噬微软的市场）。<br>
Apple这个品牌，一度成为电子消费奢侈品的代名词，苹果迎来了它的第二次巅峰。</p>
<h2 id="库克时代"><a class="markdownIt-Anchor" href="#库克时代"></a> 库克时代</h2>
<p>2010年 苹果的市值超过微软，成为市值最高的IT企业。<br>
这一切，首先要归功于乔布斯。但其次，与乔布斯的接班人，库克，也息息相关。<br>
早在2000年的时候，苹果便聘用了提姆·库克作为运营主管。<br>
为了加强公司营运，缩短产品流转周期，库克尝试在店铺租金昂贵的地段开设专卖店，此举大获成功。</p>
<img src="https://s2.loli.net/2022/05/19/nMAIuyfBZRderxC.jpg">
￼
或许是乔布斯对自己身体状况已经有所了解，在他任期的最后一段时间内，他一手培养并几乎为库克制定了苹果未来的发展方向。
2011年8月25日，苹果宣布乔布斯辞职，并立即生效，库克接任CEO。
2011年10月4日，库克第一次产品发表会，推出iPhone 4S。
2011年10月5日下午3时左右，苹果公司的创始人，乔布斯，于美国加州的寓所逝世。
这一天，整个硅谷都在为这位传奇哀悼。
在乔布斯的带领下，苹果公司两次达到巅峰，引领了个人电脑和个人手机等电子消费品的浪潮。
并为库克留下了一家美国市值第一的上市公司。
2012年8月份，苹果公司市值升至6240亿美元，打破微软于1999年创立的最高市值记录。
乔布斯逝世后，库克兢兢业业经营着苹果公司，并没有做太多的方向性和产品性变革。
截止2020年，苹果最高市值达到了1.4万亿美元。
毫无疑问，库克领导下的苹果，依靠着Apple的品牌延续、产品升级，在手机、PC市场上始终保持着高暴利的商业模式。
但苹果却渐渐失去了颠覆创造性的能力。尤为显著的在于手机，无论是软件、硬件，都逐渐被以中国手机阵营为主的安卓联盟阵线所超越。
这些年虽然也有iPencel、AirPods这类出彩的产品，但始终没有引起更大的市场反响。
严格来说，库克并不是一位好的产品设计师，但他是一位称职的企业舵手，从后来的情况来说，在他任职的近10年时间里，苹果，始终处在美国最有价值的IT公司阵营，在市值上遥遥领先。
<h2 id="苹果的商业模式"><a class="markdownIt-Anchor" href="#苹果的商业模式"></a> 苹果的商业模式</h2>
<p>在众多IT公司中，苹果的经历，无疑是最传奇的。<br>
没有人能想到，在5岁便达到巅峰，并自此走向衰落的苹果，能在21岁时壮士断腕，重新走上巅峰之路，并在44岁之际，与老对手微软，双双走在世界之颠。<br>
从某种意义上来说，苹果并不是一家IT公司，也不是一家硬件公司、软件公司。<br>
它是一家电子消费品公司。<br>
它的根本经营模式，在于能不断推出超出市场预期、并符合市场需求的电子消费品。<br>
不论是电脑、音乐播放器、手机、平板或者其它产品，苹果始终保持软硬件一体化，闭环生态的商业模式。<br>
我们不能说这种商业模式不好，在没有大的技术革命之前，它可以活得很好，甚至只需要像当年的诺基亚一样，换换手机外壳、颜色，就可以高价接着卖所谓的新产品。</p>
<img src="https://s2.loli.net/2022/05/19/8UwGJxTimLp1Qcy.jpg">
<p>让我们看看它的产品结构，苹果公司60%的营业额来自于iPhone，7.8%来自于Mac，而余下的31.26%，也基本来自于苹果生态所带来的软件性或者平台性收入，比如App Store、iTunes等等。<br>
对于一家巨无霸公司而言，没有真正的第二盈利点，这其实有点危险。前车之鉴犹如诺基亚，巨人往往难以转身。<br>
通过2019年的财报，我们可以看出，市值约1.4万亿美元的苹果，年营收达到2601.74亿美元，净利率21.24%的企业，年赚552亿美元，市盈率只有21左右。</p>
<img src="https://s2.loli.net/2022/05/19/vPU81TwQnuX2lSs.jpg">
<p>比较不乐观的是，它的营收已经开始了负增长，成长性到了瓶颈。而与苹果市值相近的微软。营收只有1258.43亿美元，市盈率却能达到30左右，为什么呢？<br>
我想，差别主要来自于两方面，一是微软的业务更加多元化，经得起冲击，二是微软保持着14%的年增长率，未来还有上升空间。<br>
所以，目前的市值，对于苹果，是一种肯定，但也是一种提醒，如果它仍然无法找回自己电子消费品公司的定位、无法推出新的颠覆性产品，那么，苹果很可能再次走向衰落。<br>
不过，在那之前，苹果已经是一家足够传奇，可以载入商业史册的公司了。</p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>商业小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile编写(3)：条件执行和函数</title>
    <url>/posts/b643bd4a1cb0</url>
    <content><![CDATA[<p><strong>注：本系列内容大部分是基于GNU make的标准，其中cc命令默认调用Linux自带的c编译器程序</strong></p>
<ol>
<li>
<a href="/2022/05/09/makefile/" title="makefile介绍">makefile介绍</a>
</li>
<li>
<a href="/2022/05/14/makefile%E8%BF%9B%E9%98%B6/" title="makefile编写(1)：规则">makefile编写(1)：规则</a>
</li>
<li>
<a href="/2022/05/16/makefile%E7%BC%96%E5%86%99/" title="makefile编写(2)：变量">makefile编写(2)：变量</a>
</li>
<li>
<a href="/2022/05/18/makefile%E8%BF%9B%E9%98%B62/" title="makefile编写(3)：条件执行和函数">makefile编写(3)：条件执行和函数</a>
</li>
</ol>
<h1 id="makefile条件判断"><a class="markdownIt-Anchor" href="#makefile条件判断"></a> makefile条件判断</h1>
<p>makefile的条件语句可以根据一个变量的值来控制make执行或者忽略makefile的特定部分，使用条件控制可以增加处理的灵活性和高效性。条件语句可以是两个不同变量、或者变量和常量值的比较。要注意的是：条件语句只能用于控制make实际执行的makefile文件部分，无法控制规则的shell命令执行流程。</p>
<p>下面还是以一个简单的例子开始：判断$(CC)变量是否为gcc，如果是的话则使用GNU函数编译目标</p>
<pre class="line-numbers language-none"><code class="language-none">libs_for_gcc &#x3D; -lgnu
normal_libs &#x3D;
foo: $(objects)
ifeq ($(CC),gcc)
    $(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上例的这个规则中目标foo可以根据变量$(CC)值来选取不同的函数库来编译程序。可以从上面的示例中看到三个关键字：ifeq、else和endif，其中：</p>
<ul>
<li>ifeq表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起</li>
<li>else表示条件表达式为假的情况</li>
<li>endif表示一个条件语句的结束，任何一个条件语句块都应该以endif结束</li>
</ul>
<p>makefile中条件表达式工作于文本级别(条件判断处理为文本级别的处理过程)，条件的解析是由make来完成的。make是在读取并解析makefile时根据条件表达式忽略条件表达式中的某一个文本行(这句话是GNU make中文手册中的，所以说makefile的解析可能不是跳转指令，而是直接将文本行忽略？)，解析完成后保留的只有表达式满足条件所需要执行的文本行。上例还有一种更简洁实现方式：(虽然我也没看出哪里简洁)</p>
<pre class="line-numbers language-none"><code class="language-none">libs_for_gcc &#x3D; -lgnu
normal_libs &#x3D;
ifeq ($(CC),gcc)
libs&#x3D;$(libs_for_gcc)
else
libs&#x3D;$(normal_libs)
endif
foo: $(objects)
    $(CC) -o foo $(objects) $(libs)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="makefile条件判断的基本语法"><a class="markdownIt-Anchor" href="#makefile条件判断的基本语法"></a> makefile条件判断的基本语法</h2>
<p>一个简单的不包含else分支的条件判断语句的语法格式为：</p>
<blockquote>
<p>CONDITIONAL-DIRECTIVE<br>
TEXT-IF-TRUE<br>
endif</p>
</blockquote>
<p>首先看条件判断后对应的执行语句部分，表达式中TEXT-IF-TRUE可以是若干任何文本行，当条件为真时它将被make作为需要执行的一部分，当条件为假时不作为需要执行的一部分。</p>
<p>包含else的语法格式为：</p>
<blockquote>
<p>CONDITIONAL-DIRECTIVE<br>
TEXT-IF-TRUE<br>
else<br>
TEXT-IF-FALSE<br>
endif</p>
</blockquote>
<p>和TEXT-IF-TRUE一样，TEXT-IF-FALSE可以是若干任何文本行。注意两个分支的情况只是基本情况，实际上条件判断的执行文本中也可包含条件判断语句(也就是说条件语句是可以嵌套的)，从而达成多分支的效果，但是也要注意makefile是不支持elif类型的关键字的，所以需要在else后面再加上CONDITIONAL-DIRECTIVE。下面是一个简单的例子：</p>
<pre class="line-numbers language-none"><code class="language-none">TARGET_ARCH&#x3D;x86
ifeq ($(TARGET_ARCH), arm)
LOCAL_SRC_FILES :&#x3D; a
else ifeq ($(TARGET_ARCH), x86)
LOCAL_SRC_FILES :&#x3D; b
ifdef LOCAL_SRC_FILES
TARGET_ARCH&#x3D;mips
endif                        #注意每个独立的条件判读语句块必须以endif结束
else ifeq ($(TARGET_ARCH), mips)   
LOCAL_SRC_FILES :&#x3D; c
else
LOCAL_SRC_FILES :&#x3D; d
endif
test:
    @echo $(TARGET_ARCH)     #输出mips
    @echo $(LOCAL_SRC_FILES) #输出b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意else CONDITIONAL-DIRECTIVE实际上也算是makefile中条件判断的一个结构(只不过不是所有的版本都支持)，因此可以和整个条件判断语句块共享一个endif，如果碰到不支持else CONDITIONAL-DIRECTIVE类型的make时，只要在后面单独加上一个endif表示一个单独的条件语句块就可以了。</p>
<h2 id="条件判断关键字"><a class="markdownIt-Anchor" href="#条件判断关键字"></a> 条件判断关键字</h2>
<p>条件判断表达式CONDITIONAL-DIRECTIVE对于两种基本格式都是同样的，其本身可以是下面四种用于测试不同条件的关键字。<br>
ifeq关键字用来判断参数是否相等，格式如下：(ARG可以是任何变量值、常量、函数返回值结合起来的表达式文本)</p>
<blockquote>
<p>ifeq (ARG1, ARG2)<br>
ifeq ‘ARG1’ ‘ARG2’<br>
ifeq “ARG1” “ARG2”<br>
ifeq “ARG1” ‘ARG2’<br>
ifeq ‘ARG1’ “ARG2”</p>
</blockquote>
<p>ifeq条件判断表达式替换展开ARG1和ARG2后，对它们的值进行比较。如果相同则(条件为真)将TEXT-IF-TRUE作为make要执行的一部分，否则将TEXT-IF-FALSE(如果有的话)作为make要执行的一部分.</p>
<p>关键字ifneq实现的条件判断语句和ifeq的形式完全相同但意义相反，此关键字用来判断参数是否不相同，如果不同则为真。同样的条件为真时将执行TEXT-IF-TRUE控制流，反之执行TEXT-IF-FALSE控制流。</p>
<p>关键字ifdef用来判断一个变量是否已经定义，格式为：</p>
<blockquote>
<p>ifdef VARIABLE-NAME</p>
</blockquote>
<p>如果变量VAEIABLE_NAME的值非空(在makefile中只有未定义的变量以及使用未定义变量赋值的变量值为空)，那么表达式为真，将TEXT-IF-TRUE作为make要执行的一部分，否则表达式为假执行TEXT-IF-FALSE。对于ifdef关键字需要说明的是：ifdef只是测试一个变量当前<strong>是否已经定义</strong>，不是对变量进行替换展开来判断变量的值是否为空</p>
<ul>
<li>条件判断的执行还要在变量展开之前，更在规则执行之前，因此模式字符和自动化变量在条件判断中都是使用不了的</li>
<li>实际上条件判断发生在makefile读取之时，makefile中包含的文件也不能保证在条件判断中即时展开，因此不能将完整的条件判断语句分写在两个不同的makefile文件中</li>
</ul>
<p>对于变量VARIABLE-NAME，除了未定义的VARIABLE-NAME或者没有给出任何初始化值的定义，使用其它方式对它的定义都会使ifdef条件判断表达式返回真。也就是说即使通过其它方式给它赋了一个空值，ifdef也会返回真，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">foo &#x3D;
bar &#x3D; $(foo)
ifdef foo
frobozz1 &#x3D; yes
else
frobozz1 &#x3D; no
endif
ifdef bar
frobozz2 &#x3D; yes
else
frobozz2 &#x3D; no
endif
test:
    @echo $(frobozz1) $(frobozz2) #输出no yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这里也可以看出，当需要判断一个变量的值是否为空时，需要使用ifeq而不是ifdef。关键字ifndef和ifdef格式完全相同，实现的功能相反。<br>
在CONDITIONAL-DIRECTIVE这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始(不然就被认为是命令)，而注释符“#”同样也是安全的，包括else和endif也一样，只要不是以[Tab]键开始就行。</p>
<p>此外，makefile虽然没有提供逻辑或和逻辑与运算符，但可以借助于其内嵌函数和字符串拼接来实现相同的功能，比如如果让ifeq(ARG1, ARG2)和ifeq(ARG3, ARG4)达成逻辑与的关系，可以这样：</p>
<blockquote>
<p>ifeq(ARG1_ARG3,ARG2_ARG4)</p>
</blockquote>
<p>这样只有ARG1和ARG2、ARG3和ARG4同时相等时才为真，_字符起到分隔两个字串的作用，可以是任何一定不存在于两个字串中的字符。如果是ifdef条件判断的话，由于是指定变量名的方式进行判断，因此采用变量引用和函数的方式比较难以实现逻辑运算，不过可以通过条件语句嵌套的方式实现：</p>
<blockquote>
<p>ifdef VARIABLE-NAME1<br>
ifdef VARIABLE-NAME2<br>
TEXT-IF-TRUE<br>
endif<br>
else<br>
TEXT-IF-FALSE<br>
endif</p>
</blockquote>
<p>这样只有VARIABLE-NAME1和VARIABLE-NAME2同时为真才能执行true控制流，否则执行false控制流。如果想实现逻辑或关系的话可以像这样：</p>
<blockquote>
<p>ifeq($(filter-out(ARG1 ARG3,ARG2 ARG4)),)<br>
TEXT-IF-TRUE<br>
else<br>
TEXT-IF-FALSE<br>
endif</p>
</blockquote>
<p>函数filter-out会过滤掉字串ARG2 ARG4中满足模式ARG1和ARG3的字串，如果返回空串说明ARG2和ARG4一定符合模式ARG1和ARG3的其中一个。但是这种方法没有考虑的特殊情况是ARG1等于ARG4，ARG3等于ARG2的情况，所以只有在确定两组比较条件不等的情况才能使用这种方法。如果两组条件中的有相同的字串，此时条件判断语句可以这样：</p>
<blockquote>
<p>ifeq($(findstring(ARG1 ARG2_ARG3)),)</p>
</blockquote>
<p>最后，ifdef条件判断可以这样实现逻辑或(采用类似于elif的结构)：</p>
<blockquote>
<p>ifdef VARIABLE-NAME1<br>
TEXT-IF-TRUE<br>
else ifdef VARIABLE-NAME2<br>
TEXT-IF-TRUE<br>
else<br>
TEXT-IF-FALSE<br>
endif<br>
endif</p>
</blockquote>
<p>ifneq和ifndef实现逻辑运算的方法与ifeq和ifdef原理相同，只不过实现的功能相反。当然实际上除此外还有很多手段实现makefile的逻辑运算，比如可以通过shell函数内嵌Shell脚本来处理条件，部分make工具还支持and和or函数来支持逻辑运算。</p>
<h1 id="makefile函数"><a class="markdownIt-Anchor" href="#makefile函数"></a> makefile函数</h1>
<p>makefile函数提供了处理文件名、变量、文本和命令等等的方法。使用函数的makefile可以编写的更加灵活和健壮。可以在需要的地方地调用函数来处理指定<strong>文本</strong>(需要处理的文本作为函数的参数)，函数调用在调用的地方被替换为它的处理结果。函数调用(引用)的展开和变量引用展开的行为基本是相同的，而且是同步进行的。</p>
<h2 id="makefile函数的基本语法"><a class="markdownIt-Anchor" href="#makefile函数的基本语法"></a> makefile函数的基本语法</h2>
<p>函数调用的方法很像变量值引用的方法，也是以$来标识，其语法如下：</p>
<blockquote>
<p>$(FUNCTION ARGUMENTS)或${FUNCTION ARGUMENTS}</p>
</blockquote>
<p>这里FUNCTION就是函数名，ARGUMENTS是函数的参数，参数间以逗号,分隔，而函数名和参数之间以空格分隔。函数调用以$开头，以圆括号或花括号把函数名和参数括起，感觉上很像一个变量。函数中的参数可以使用变量引用，为了风格的统一，函数和变量的括号最好一样，如使用：</p>
<blockquote>
<p>$(subst a,b,$(x))</p>
</blockquote>
<p>这样的形式，而不是：</p>
<blockquote>
<p>$(subst a,b,${x})”</p>
</blockquote>
<p>虽然实际功能都一样，但良好的编写风格能够增加可读性。此外推荐在变量引用和函数引用中统一使用圆括号，这样在使用vim编写makefile时可以高亮显示make的内嵌函数。函数处理参数时如果参数中存在对其它变量或者函数的引用，首先对这些引用展开得到参数的实际内容后再进行处理，参数的展开顺序是按照参数的先后顺序进行的。参数中尽量不要出现逗号,和空格，这是因为逗号会被作为多个参数的分隔符，并且此时,的前导空格(试了下好像Tab也忽略)很多时候会被忽略，因此当有逗号或空格作为函数参数时，需要把它们赋值给一个变量，通过在函数的参数中引用这个变量来实现，例：</p>
<pre class="line-numbers language-none"><code class="language-none">comma:&#x3D; ,
empty:&#x3D;
space:&#x3D; $(empty) $(empty)
foo:&#x3D; a b c
bar1:&#x3D; $(subst $(space),$(comma),$(foo)i)
bar2:&#x3D; $(subst  ,$(comma),$(foo)i)
bar3:&#x3D; $(subst a,$(comma),$(foo)i)
bar4:&#x3D; $(subst $(space),,,$(foo)i)
bar5:&#x3D; $(subst  $(space),$(comma) ,$(foo)i)
bar6:&#x3D; $(subst $(space), ,$(foo)i)
test:
	@cat makefile
	@echo $(bar1) #将$(foo)中,换成空格的标准写法，输出结果为a,b,ci
	@echo $(bar2) #把$(space)直接写成空格则接收第一个参数时会被忽略，此时第一个参数为空字符(默认在结尾)，输出结果为a b ci,
	@echo $(bar3) #如果是正常字符的可以直接替换，输出结果为,b ci
	@echo $(bar4) #同理把$(comma)写成,则被解析为分隔符，因为subst只有三个接收参数，因此第三个,被当作第三个参数的一部分，输出结果为,abci
	@echo $(bar5) #首先在没有读入$(space)前会删去空白符，因此$(space)前面的空白符被删去；其次在第二个参数已经读入$(comma)以后，
                  #后面的空格符被当作是参数的一部分，加在$(comma)后面，因此最终输出为a, b, ci
    @echo $(bar6) #实际上此例中将空格直接作为第二个参数也是可以接收到的，subst函数做的事首先是把第三个要处理的TEXT文本中首尾空字符去掉
                  #然后将作为函数名和参数间分隔符的空格去掉，而第二个参数夹在中间，因此它是可以接收到空格的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="makefile常用函数"><a class="markdownIt-Anchor" href="#makefile常用函数"></a> makefile常用函数</h2>
<h3 id="makefile文本处理函数"><a class="markdownIt-Anchor" href="#makefile文本处理函数"></a> makefile文本处理函数</h3>
<p>常用的内嵌文本处理函数有以下11个函数。</p>
<h4 id="字符串替换函数subst"><a class="markdownIt-Anchor" href="#字符串替换函数subst"></a> 字符串替换函数subst</h4>
<ul>
<li>$(subst FROM,TO,TEXT)</li>
<li>功能：把字串TEXT中的FROM字符串替换成TO</li>
<li>返回：替换过后的字符串</li>
<li>示例：
<ul>
<li>$(subst ee,EE,feet on the street)</li>
<li>把feet on the street中的ee替换成EE，返回结果是fEEt on the strEEt</li>
</ul>
</li>
</ul>
<h4 id="模式字符串替换函数patsubst"><a class="markdownIt-Anchor" href="#模式字符串替换函数patsubst"></a> 模式字符串替换函数patsubst</h4>
<ul>
<li>$(patsubst PATTERN,REPLACEMENT,TEXT)</li>
<li>功能：搜索TEXT中以空格分开的<strong>单词</strong>，将否符合模式TATTERN的单词替换为REPLACEMENT。参数PATTERN中可以使用模式通配符%表示任意长度的字串，如果REPLACEMENT中也包含%，那么REPLACEMENT中的这个%将是PATTERN中的那个%所代表的字串</li>
<li>返回：替换过后的字符串</li>
<li>说明：参数TEXT的单词之间的多个空格在处理时被合并为一个空格，并忽略前导和结尾空格</li>
<li>示例：
<ul>
<li>$(patsubst %.c,%.o,x.c.c bar.c)</li>
<li>把字串x.c.c bar.c符合模式[%.c]的单词替换成[%.o]，返回结果是x.c.o bar.o</li>
<li>实际上变量的替换引用就是靠patsubst函数实现的，$(VAR:PATTERN=REPLACEMENT)实际就等价于$(patsubst PATTERN,REPLACEMENT,$(VAR))</li>
</ul>
</li>
<li>如果PATTERN中没有使用%，则在实现时自动加上，也就是$(VAR::SUFFIX=REPLACEMENT)等价于$(patsubst %SUFFIX,%REPLACEMENT,$(VAR))</li>
<li>比如：$(objects:.o=.c)等价于$(patsubst %.o,%.c,$(objects))</li>
</ul>
<h4 id="去空格函数strip"><a class="markdownIt-Anchor" href="#去空格函数strip"></a> 去空格函数strip</h4>
<ul>
<li>$(strip STRINT)</li>
<li>功能：去掉STRINT字串中<strong>开头和结尾</strong>的空字符</li>
<li>返回：去掉空格的字符串值</li>
<li>说明：空字符包括空格、[Tab]等不可显示字符</li>
<li>示例：
<ul>
<li>$(strip a b c )</li>
<li>把字串a b c 去开头和结尾的空格，结果是<strong>a b c</strong>(这么说的话难道说lexer调用的就是这个函数？)</li>
<li>strip函数经常用在条件判断语句的表达式中，确保表达式比较的可靠和健壮</li>
</ul>
</li>
</ul>
<h4 id="查找字符串函数findstring"><a class="markdownIt-Anchor" href="#查找字符串函数findstring"></a> 查找字符串函数findstring</h4>
<ul>
<li>$(findstring FIND,IN)</li>
<li>功能：在字串IN中查找FIND字串</li>
<li>返回：如果找到则返回FIND，否则返回空字符串</li>
<li>说明：IN中可以包含空格、[Tab]，搜索需要是严格的文本匹配</li>
<li>示例：
<ul>
<li>$(findstring a,a b c)返回a字符</li>
<li>$(findstring a,b c)返回“”字符串(空字符串)</li>
</ul>
</li>
</ul>
<h4 id="过滤函数filter"><a class="markdownIt-Anchor" href="#过滤函数filter"></a> 过滤函数filter</h4>
<ul>
<li>$(filter PATTERN…,TEXT)</li>
<li>功能：以PATTERN模式过滤TEXT中的单词，保留符合模式PATTERN的单词，可以有多个PATTERN，PATTERN之间使用空格分隔</li>
<li>返回：符合模式PATTERN的字串</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">sources :&#x3D; foo.c bar.c baz.s ugh.h
foo: $(sources)
    cc $(filter %.c %.s,$(sources)) -o foo
# $(filter %.c %.s,$(sources))返回值为foo.c bar.c baz.s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="反过滤函数filter-out"><a class="markdownIt-Anchor" href="#反过滤函数filter-out"></a> 反过滤函数filter-out</h4>
<ul>
<li>$(filter-out PATTERN…,TEXT)</li>
<li>功能：过滤掉TEXT中所有符合模式PATTERN的单词，保留不符合此模式的单词，可以有多个PATTERN，PATTERN之间使用空格分隔</li>
<li>返回：不符合模式PATTERN的字串。</li>
<li>示例：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">objects&#x3D;main1.o foo.o main2.o bar.o
mains&#x3D;main1.o main2.o
# $(filter-out $(mains),$(objects))返回值是foo.o bar.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="排序函数sort"><a class="markdownIt-Anchor" href="#排序函数sort"></a> 排序函数sort</h4>
<ul>
<li>$(sort LIST)</li>
<li>功能：给字串LIST中的<strong>单词</strong>以首字母为准按升序进行排序，去掉重复的单词</li>
<li>返回：排序后的空格分割的没有重复单词的字串</li>
<li>示例：
<ul>
<li>$(sort foo bar lose)返回bar foo lose</li>
</ul>
</li>
</ul>
<h4 id="取单词函数word"><a class="markdownIt-Anchor" href="#取单词函数word"></a> 取单词函数word</h4>
<ul>
<li>$(word N,TEXT)</li>
<li>功能：取字符串TEXT中第N个<strong>单词</strong>，N的值<strong>从1开始</strong></li>
<li>返回：字串TEXT中第N个单词</li>
<li>说明：如果N值大于字串TEXT中单词的数目，返回空字符串，如果N为0则出错</li>
<li>示例：
<ul>
<li>$(word 2, foo bar baz)返回值是bar</li>
</ul>
</li>
</ul>
<h4 id="取字串函数wordlist"><a class="markdownIt-Anchor" href="#取字串函数wordlist"></a> 取字串函数wordlist。</h4>
<ul>
<li>$(wordlist S,E,TEXT)</li>
<li>功能：从字串TEXT中取出从S开始到E的单词串，S和E表示单词在字串中的下标+1，都是从1开始的数字</li>
<li>返回：字串TEXT中从第S到E(包括E)的单词字串</li>
<li>说明：当S比TEXT中的单词数大时返回空串，如果E大于TEXT单词数，返回从S开始到TEXT结束的单词串，如果S大于E，返回空串，如果S或E为0错误</li>
<li>示例：
<ul>
<li>$(wordlist 2, 3, foo bar baz)返回值是bar baz</li>
</ul>
</li>
</ul>
<h4 id="统计单词数目函数words"><a class="markdownIt-Anchor" href="#统计单词数目函数words"></a> 统计单词数目函数words</h4>
<ul>
<li>$(words TEXT)</li>
<li>功能：统计TEXT中的单词个数</li>
<li>返回：TEXT中的单词数</li>
<li>示例：
<ul>
<li>$(words, foo bar baz)返回值是3</li>
<li>如果要取TEXT中最后的一个单词可以这样：$(word $(words TEXT),TEXT)</li>
</ul>
</li>
</ul>
<h4 id="取首单词函数firstword"><a class="markdownIt-Anchor" href="#取首单词函数firstword"></a> 取首单词函数firstword</h4>
<ul>
<li>$(firstword TEXT)</li>
<li>功能：取字串TEXT中的第一个单词</li>
<li>返回：字串TEXT的第一个单词</li>
<li>示例：
<ul>
<li>$(firstword foo bar)返回值是foo</li>
<li>这个函数的实现应该是$(word 1,TEXT)</li>
</ul>
</li>
</ul>
<h4 id="一个简单的应用用vpath中的值生成cflags的查找路径"><a class="markdownIt-Anchor" href="#一个简单的应用用vpath中的值生成cflags的查找路径"></a> 一个简单的应用：用VPATH中的值生成CFLAGS的查找路径</h4>
<pre class="line-numbers language-none"><code class="language-none">VPATH&#x3D;src:..&#x2F;includes
override CFLAGS+&#x3D;$(patsubst %,-I%,$(subst :, ,$(VPATH)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中$(subst :, ,$(VPATH))返回src… /includes，$(patsubst %,-I%,src… /includes)返回-Isrc -I…/inludes，也就是gcc指定头文件路径的编译参数的形式。</p>
<h3 id="文件名操作函数"><a class="markdownIt-Anchor" href="#文件名操作函数"></a> 文件名操作函数</h3>
<p>makefile支持一些针对于文件名的处理函数，这些函数主要用来对一系列空格分割的文件名进行转换，参数被作为若干个文件名进行处理并返回空格分隔的多个文件名序列。由于这类函数操作的对象是文件名，因此在参数首尾的空白符都要删掉。</p>
<h4 id="取目录函数dir"><a class="markdownIt-Anchor" href="#取目录函数dir"></a> 取目录函数dir</h4>
<ul>
<li>$(dir NAMES…)</li>
<li>功能：从文件名序列NAMES…中取出目录部分，目录部分是指最后一个反斜杠/之前的部分，如果没有反斜杠，那么返回./</li>
<li>返回：文件名序列NAMES…的目录部分(包括最后一个/)</li>
<li>示例：
<ul>
<li>$(dir src/foo.c hacks)返回值是src/ ./</li>
</ul>
</li>
</ul>
<h4 id="取文件名函数notdir"><a class="markdownIt-Anchor" href="#取文件名函数notdir"></a> 取文件名函数notdir</h4>
<ul>
<li>$(notdir NAMES…)</li>
<li>功能：从文件名序列NAMES…中取出非目录部分，非目录部分是指最后一个反斜杠/之后的部分</li>
<li>返回：返回文件名序列NAMES…的非目录部分(不包括最后一个/)</li>
<li>示例：
<ul>
<li>$(notdir src/foo.c hacks)返回值是foo.c hacks</li>
</ul>
</li>
</ul>
<h4 id="取后缀函数suffix"><a class="markdownIt-Anchor" href="#取后缀函数suffix"></a> 取后缀函数suffix</h4>
<ul>
<li>$(suffix NAMES…)</li>
<li>功能：从文件名序列NAMES…中取出各个文件名的后缀，后缀是文件名中最后一个以点.开始的部分(包含点号)</li>
<li>返回：文件名序列NAMES…的后缀序列，如果文件没有后缀则返回空字串</li>
<li>示例：
<ul>
<li>$(suffix src/foo.c src-1.0/bar.c hacks)返回值是.c .c</li>
</ul>
</li>
</ul>
<h4 id="取前缀函数basename"><a class="markdownIt-Anchor" href="#取前缀函数basename"></a> 取前缀函数basename</h4>
<ul>
<li>$(basename NAMES…)</li>
<li>功能：从文件名序列NAMES…中取出各个文件名的前缀部分，前缀部分指的是文件名中最后一个点号之前的部分</li>
<li>返回：文件名序列NAMES…的前缀序列，如果文件没有前缀则返回空字串</li>
<li>示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是src/foo src-1.0/bar hacks</li>
</ul>
<h4 id="加后缀函数addsuffix"><a class="markdownIt-Anchor" href="#加后缀函数addsuffix"></a> 加后缀函数addsuffix</h4>
<ul>
<li>$(addsuffix SUFFIX,NAMES…)</li>
<li>功能：把后缀SUFFIX加到NAMES…中的每个单词后面</li>
<li>返回：加过后缀的文件名序列</li>
<li>示例：
<ul>
<li>$(addsuffix .c,foo bar)返回值是foo.c bar.c</li>
</ul>
</li>
</ul>
<h4 id="加前缀函数addprefix"><a class="markdownIt-Anchor" href="#加前缀函数addprefix"></a> 加前缀函数addprefix</h4>
<ul>
<li>$(addprefix PREFIX,NAMES…)</li>
<li>功能：把前缀PREFIX加到NAMES…中的每个单词前面</li>
<li>返回：返回加过前缀的文件名序列</li>
<li>示例：
<ul>
<li>$(addprefix src/,foo bar)返回值是src/foo src/bar</li>
</ul>
</li>
</ul>
<h4 id="连接函数join"><a class="markdownIt-Anchor" href="#连接函数join"></a> 连接函数join</h4>
<ul>
<li>$(join LIST1,LIST2)</li>
<li>功能：把LIST2中的单词对应地加到LIST1的单词后面，比如将LIST2中的第一个单词追加LIST1第一个单词字后合并为一个单词，LIST2第二个单词追加到LIST第二个单词后……以此类推</li>
<li>返回：单空格分隔的合并后的文件名序列</li>
<li>说明：如果LIST1和LIST2中的文件名数目不一致时，两者中多余部分将被作为返回序列的一部分(类似于归并)</li>
<li>示例：
<ul>
<li>$(join aaa bbb , 111 222 333)返回值是aaa111 bbb222 333</li>
</ul>
</li>
</ul>
<h4 id="获取匹配模式文件名函数wildcard"><a class="markdownIt-Anchor" href="#获取匹配模式文件名函数wildcard"></a> 获取匹配模式文件名函数wildcard</h4>
<ul>
<li>$(wildcard PATTERN)</li>
<li>功能：列出当前目录下所有符合模式PATTERN(注意wildcard的模式一般指使用通配符)格式的文件名</li>
<li>返回：空格分割的、存在于<strong>当前目录</strong>下的所有符合模式PATTERN的文件名</li>
<li>说明：在makefile变量的定义和函数引用时，通配符将失效，这种情况下如果需要通配符有效就需要使用函数wildcard</li>
<li>示例：
<ul>
<li>$(wildcard *.c)返回值为当前目录下所有.c源文件列表</li>
</ul>
</li>
</ul>
<h3 id="特殊函数"><a class="markdownIt-Anchor" href="#特殊函数"></a> 特殊函数</h3>
<h4 id="遍历函数foreach"><a class="markdownIt-Anchor" href="#遍历函数foreach"></a> 遍历函数foreach</h4>
<p>foreach函数和别的函数非常的不一样，因为这个函数是用来做循环控制流用的。makefile中的foreach函数几乎是仿照于Unix标准Shell(/bin/sh)中的for语句，或是C-Shell(/bin/csh)中的foreach语句而构建的，它的语法是：</p>
<blockquote>
<p>$(foreach VAR,LIST,TEXT)</p>
</blockquote>
<p>这个函数的工作过程是这样的：</p>
<ul>
<li>如果存在变量或者函数的引用，首先展开变量VAR和LIST的引用，而TEXT中的变量引用不展开</li>
<li>执行时把LIST中使用空格分隔的单词依次取出赋值给变量VAR</li>
<li>执行TEXT表达式，返回一个字符串</li>
<li>重复执行直到LIST的最后一个单词为空时结束</li>
<li>TEXT所返回的每个字符串所组成的整个字符串(以空格分隔)将会是foreach函数的返回值</li>
</ul>
<p>需要注意的是，TEXT中的变量或者函数引用在执行时才被展开，因此如果在TEXT中存在对VAR的引用，那么VAR的值在每一次展开时将会到得到不同的值，同时VAR参数是一个临时的局部变量，当foreach函数执行完后，参数VAR的变量将不在作用，其作用域只在foreach函数当中。一般在foreach函数时，VAR最好是一个变量名(虽然VAR在foreach函数中扮演的角色更像是一个中间变量或者“容器”，但还是建议命名尽量见名知义)，LIST可以是一个表达式，而TEXT中一般会使用VAR这个参数来依次枚举LIST中的单词，下面举例说明：</p>
<blockquote>
<p>names := a b c d<br>
files := $(foreach n,$(names),$(n).o)</p>
</blockquote>
<p>上例中，$(name)中的单词会被挨个取出并依次赋值给变量n，$(n).o每次通过$(n)展开后得出一个单词，将所有单词以空格分隔，最后作为foreach函数的返回，所以$(files)的值是a.o b.o c.o d.o。当函数的TEXT表达式过于复杂时，可以通过定义一个中间变量代表表达式的一部分，并在TEXT中引用这个变量，比如：</p>
<blockquote>
<p>find_files=$(wildcard $(dir)/*)<br>
dirs:=a b c d<br>
files:=$(foreach,dir,$(dirs),$(find_files))</p>
</blockquote>
<p>需要注意，上例定义的是递归展开的变量find_files，保证了定义时变量值中的引用不展开，而是在表达式被函数处理时才展开(如果这里使用直接展开式的定义将是无效的表达式，因为find_files中需要dir的引用，而后者是foreach函数中的局部变量)。</p>
<h4 id="条件判断函数if"><a class="markdownIt-Anchor" href="#条件判断函数if"></a> 条件判断函数if</h4>
<p>if函数提供了一个在函数上下文中实现条件判断的功能，很像makefile所支持的条件语句——ifeq或ifdef，它的语法是：</p>
<blockquote>
<p>$(if CONDITION,THEN-PART[,ELSE-PART])</p>
</blockquote>
<p>if函数可以包含else部分或是不含，即if函数的参数可以是两个也可以是三个。CONDITION参数是if的表达式，如果为<strong>非空字符串</strong>则返回真。注意跟ifdef不一样，if函数无所谓变量是否定义，只要是完全由空字符组成就返回真。条件表达式CONDITION决定了函数的返回值只能是THEN-PART或ELSE-PART两个之一的计算结果，并且两者只会有一个被计算，当CONDITION返回真时则计算THEN-PART，否则计算ELSE-PART，最后的结果将被作为if函数的返回值，如果CONDITION为假(空字符串)，并且此时ELSE-PART没有被定义那么函数返回空字串，比如：</p>
<blockquote>
<p>OBJ:=foo.c<br>
OBJ:=$(if $(OBJ),$(OBJ)) 此时OBJ返回值为foo.c，如果变量OBJ值为空的话则函数返回空字串</p>
</blockquote>
<h4 id="变量定义查询函数origin"><a class="markdownIt-Anchor" href="#变量定义查询函数origin"></a> 变量定义查询函数origin</h4>
<p>origin函数不像其它的函数，它并不操作变量的值，只是告诉你你的这个变量是哪里来的，也就是变量的出处(定义方式)，其语法是：</p>
<blockquote>
<p>$(origin VARIABLE)</p>
</blockquote>
<p>VARIBLE是一个变量名而不是变量引用，因此通常origin函数的VARIABLE中不包含$，除非此变量名是一个由变量引用拼接的变量名。origin函数会以其返回值来告诉这个变量的定义方式，下面是origin函数的返回值:</p>
<ul>
<li>undefined：VARIABLE从来没有定义过，返回undefined</li>
<li>default：VARIABLE是一个默认的定义(内嵌变量)，比如CC这个变量，如果在makefile中重新定义这些变量，其定义方式将相应发生变化</li>
<li>environment：VARIABLE是一个环境变量，并且当makefile被执行时，-e参数没有被指定</li>
<li>environment override：VARIABLE是一个系统环境变量，并且makefile中存在一个同名的变量定义，make执行时使用-e使环境变量值替代了文件中的变量定义</li>
<li>file：VARIABLE变量被定义在makefile中</li>
<li>command line：VARIABLE变量是在命令行定义的</li>
<li>override：VARIABLE是被override指示符重新定义的</li>
<li>automatic：VARIABLE是一个命令运行中的自动化变量</li>
</ul>
<p>这些信息对于编写Makefile是非常有用的，例如，假设有一个makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量bletch，而系统中也有一个环境变量bletch，假设此时想判断一下如果变量值来源于环境变量，那么就把其重定义了，如果来源于Make.def或是命令行等非默认环境的，那么就不重新定义它，于是在makefile中可以这样写：</p>
<blockquote>
<p>ifdef bletch<br>
ifeq “$(origin bletch)” “environment”<br>
bletch = barf, gag, etc.<br>
endif<br>
endif</p>
</blockquote>
<p>当然，直接使用override关键字同样可以重写变量，不过用override同时会把从命令行等其他地方定义的变量都覆盖掉，而采用origin函数可以结合条件判断进行更灵活的重定义。<br>
(个人测试下觉得这个案例有问题：如果不指定-e那么环境变量本来就会被覆盖，如果指定-e不用override的话bletch那里是重写不了的)</p>
<h4 id="自己定义函数引用函数call"><a class="markdownIt-Anchor" href="#自己定义函数引用函数call"></a> 自己定义函数引用函数call</h4>
<p>call函数是唯一一个可以创建定制化参数函数引用的函数，使用这个函数可以实现对用户自己定义函数的引用。可以将一个变量定义为一个复杂的表达式，在表达式中可以定义许多参数，然后用call函数来向表达式传递参数，根据不同参数进行展开来获得不同的结果，其语法是：</p>
<blockquote>
<p>$(call VARIABLE,PARAM1,PARAM2,…)</p>
</blockquote>
<p>当make执行这个函数时，VARIABLE参数中的临时变量如$(1)，$(2)，$(3)…等(如果只有一位数字的话不加括号也可以，另外序号只表示参数的次序，并不一定与VARIABLE中的变量引用同名)，会被参数PARAM1，PARAM2依次取代，而VARIABLE的返回值就是call函数返回值。同origin函数一样，call函数中VARIBLE也是变量名字而不是引用(call函数做的实际上就类似于使用参数对VARIABLE进行嵌套引用)。call函数对参数的数目没有限制，也可以没有参数值(当然没有参数值的call没有任何实际存在的意义)，执行时变量VARIABLE中有效的临时变量在call函数上下文中被展开(同样的，VARIABLE必须用递归赋值，因为其一定会用到call函数内定义的临时局部变量)，变量定义中的$(1)作为第一个参数，将call函数参数值中的第一个参数赋值给它，变量中的$(2)一样被赋值为call函数的第二个参数值，依此类推(变量$(0)代表变量VARIABLE本身)，之后对变量VARIABLE表达式的计算值，得到函数返回结果，例如：</p>
<blockquote>
<p>reverse = $(1) $(2)<br>
foo = $(call reverse,a,b)<br>
#此时foo的值就是a b</p>
</blockquote>
<p>当然参数的次序是可以自定义的，不一定是数字序号的顺序，如：</p>
<blockquote>
<p>reverse = $(2) $(1)<br>
foo = $(call reverse,a,b)<br>
#此时的foo的值就是b a</p>
</blockquote>
<p>下面以一个例子来简要说明一下自定义函数的方法，假设需要定义一个函数pathsearch可以在PATH路径中搜索第一个指定的程序：<br>
首先参考下PATH变量的格式：</p>
<img src="https://s2.loli.net/2022/05/20/exBzMLNhDYIwURG.png">
<p>发现路径之间使用:分隔，目录名后面不带/，因此首先可以对变量名进行一步处理：</p>
<blockquote>
<p>dir_name=$(addsuffix /,$(subst :, ,$(PATH)))</p>
</blockquote>
<p>这样使用PATH中的路径构造出了一个文件名序列。同时还需要让pathsearch能够接收call参数以指定路径下的程序名，因此可以在此基础上做下修改，在后面添加一个参数：</p>
<blockquote>
<p>dir_name=$(addsuffix /$(1),$(subst :, ,$(PATH)))</p>
</blockquote>
<p>接下来就可以完成pathsearch的定义，在工作目录匹配符合PATH路径的文件，取其中第一个：</p>
<blockquote>
<p>pathsearch=$(firstword $(wildcard $(dir_name)))</p>
</blockquote>
<p>通过call函数可以实现搜索制定程序路径的功能：</p>
<blockquote>
<p>LS=$(call pathsearch,ls)</p>
</blockquote>
<p>变量VARIBLE不仅可以是自定义函数引用，还可以是makefile的内嵌函数，此时call函数的PARAM参数会按顺序传递给内嵌函数的参数)，不过这种情况对PARAM参数的使用需要注意，因为不合适或不正确的参数将会导致函数的返回值难以预料。函数call还可以套嵌使用，此时每一层call函数的调用都为它自己的局部变量$(1)等赋值，并且覆盖上一层函数为它所赋的值，比如：</p>
<blockquote>
<p>map = $(foreach a,$(2),$(call $(1),$(a)))<br>
o = $(call map,origin,o map MAKE)</p>
</blockquote>
<p>此例中，$(call map,origin,o map MAKE)这个函数调用使用了变量map所定义的表达式，两个参数分别为origin函数调用和字串o map MAKE，首先进行第一次展开后外层call函数调用变为$(foreach a,o map MAKE,$(origin $(a)))，此就变成了一个foreach函数调用，返回结果为file file default。</p>
<h4 id="取变量文本值函数value"><a class="markdownIt-Anchor" href="#取变量文本值函数value"></a> 取变量文本值函数value</h4>
<p>value函数提供了一种在<strong>不对变量进行展开</strong>的情况下获取变量值的方法，语法格式为：</p>
<blockquote>
<p>$(value VARIABLE)</p>
</blockquote>
<p>VARIABLE是变量名字使用value函数取这个变量进行取值时得到的是不包含任何引用的字面。注意这并不是说value函数会取消之前已经执行过的替换扩展，此时与变量定义方式是相关的，如果定义一个直接展开的变量，那么在定义过程中直接对其它变量的引用进行替换而得到自身的值，value函数取到的值是替换过后的变量值，但是如果定义的是一个递归展开，那么value取值时就不会展开，而是将定义的字面值返回，比如：</p>
<pre class="line-numbers language-none"><code class="language-none">FO&#x3D;$PATH
FOO:&#x3D;P$(FO)
FOOO&#x3D;$(echo 123)
all:
    @echo $(value FOO)   #输出PATH
    @echo $(value FOOO)  #输出123
# 首先FO&#x3D;$PATH因为没加括号，所以FO相当于$(P)ATH等于ATH
# FOO:&#x3D;P$(FO)，定义时就已经展开为PATH，value返回字面值PATH
# FOOO&#x3D;$(echo 123)在定义时不会展开，因此value返回未展开的字面值$(echo 123)，相当于在Shell中执行echo 123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="构造依赖关系链函数eval"><a class="markdownIt-Anchor" href="#构造依赖关系链函数eval"></a> 构造依赖关系链函数eval</h4>
<p>eval其实在<strong>函数式语言</strong>里面很常见。LISP系语言的解释器，最终执行的是一个apply-eval递归，所以eval就是求值的意思。实际上不只是LISP，可以说任意解释器最终都是apply-eval递归，bash里面也有eval，只不过在LISP里面这种apply-eval通过其(语法…)形式，更加显式地表达出来了，所以LISP里的apply-eval也更著名。makefile中的eval函数是一个非常特殊的函数，使用它可以在makefile中构造一个<strong>可变的规则结构关系(依赖关系链)</strong>，其中可以使用其它变量和函数。eval函数对它的参数进行展开，展开的结果作为makefile的一部分，make可以对展开内容进行语法解析，展开的结果可以包含一个新<strong>变量、目标、隐含规则或者是显式规则</strong>等。eval函数执行时会对它的参数进行两次展开，第一次展开过程是由函数本身完成的，第二次是函数展开后的结果被作为makefile内容时由make解析时展开的，所以基于这一点在eval函数的参数中存在的引用应该使用$$来代替$，并且经常使用函数value来取一个变量的文本值。语法格式如下：</p>
<blockquote>
<p>$(eval TEXT)</p>
</blockquote>
<p>eval函数非常常见的应用是对于自定义宏包的二次展开，下面是一个简单的例子用以说明：</p>
<pre class="line-numbers language-none"><code class="language-none">###############################################
pointer :&#x3D; pointed_value
define foo
var :&#x3D; 123
arg :&#x3D; $1
$$($1) :&#x3D; ooooo
endef
#$(info $(call foo,pointer))
#$(eval $(call foo,pointer))
target:
        @echo -----------------------------
        @echo var: $(var), arg: $(arg)
        @echo pointer: $(pointer), pointed_value: $(pointed_value)
        @echo done.
        @echo -----------------------------
###############################################
#执行$(info $(call foo,pointer))的输出结果：   
#-----------------------------
#var: , arg:      
#从中可以看直接执行$(call foo,pointer)的话返回结果时对宏包foo进行第一次求值
#而foo求值的过程只是将其中的参数展开就结束了，返回的相当于是一个makefile的代码块，并没有执行
#pointer: pointed_value, pointed_value:
#done.
#-----------------------------
#执行$(eval $(call foo,pointer))的输出结果：
#-----------------------------
#var: 123, arg: pointer
#eval函数的作用就是进行二次展开，相当于将foo的结果在进行一次展开(求值)，这时foo中的变量就被成功赋值了
#pointer: pointed_value, pointed_value: ooooo
#done.
#-----------------------------
###############################################<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面通过一个逻辑较完整的案例来说明eval函数的用法(来自GNU make手册)：</p>
<pre class="line-numbers language-none"><code class="language-none"># sample Makefile 
PROGRAMS &#x3D; server client 
server_OBJS &#x3D; server.o server_priv.o server_access.o 
server_LIBS &#x3D; priv protocol  
client_OBJS &#x3D; client.o client_api.o client_mem.o 
client_LIBS &#x3D; protocol 
# Everything after this is generic 
.PHONY: all 
all: $(PROGRAMS) 
define PROGRAM_template 
$(1): $$($(1)_OBJS) $$($(1)_LIBS:%&#x3D;-l%) 
ALL_OBJS +&#x3D; $$($(1)_OBJS) 
endef 
$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog)))) 
$(PROGRAMS): 
    $(LINK.o) $^ $(LDLIBS) -o $@ 
clean: 
    rm -f $(ALL_OBJS) $(PROGRAMS)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中$(LINK.o)为$(CC) $(LDFLAGS)，对所有的.o文件和指定的库文件进行链接，这个makefile的关键点在于</p>
<blockquote>
<p>$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog))))</p>
</blockquote>
<p>可以二次展开(展开并执行)为：</p>
<blockquote>
<p>server:$(server_OBJS) -l$(server_LIBS)<br>
client:$(client_OBJS) -l$(client_LIBS)<br>
ALL_OBJS=server_OBJS client_OBJS</p>
</blockquote>
<h4 id="shell函数"><a class="markdownIt-Anchor" href="#shell函数"></a> shell函数</h4>
<p>shell函数也不像其它的函数，顾名思义它的参数应该就是操作系统Shell的命令，它和反引号`是相同的功能，也就是说shell函数把系统执行Shell命令后的输出作为函数返回。make仅对shell函数的返回结果进行处理，将函数返回结果中的所有换行符\n或者一对\n\r替换为单空格，去掉末尾的回车符号\n或者\n\r。进行函数展开式时，它所调用的命令(它的参数)得到执行。</p>
<p>于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：<br>
contents := $(shell cat foo)<br>
files := $(shell echo *.c)<br>
注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>
]]></content>
      <categories>
        <category>应用程序开发</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>makefile</tag>
        <tag>编译原理实例</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】PowerPC、X86和ARM架构区别</title>
    <url>/posts/9296819e5610</url>
    <content><![CDATA[<p>在嵌入式领域，存在着三种处理器通用的架构，PowerPC、X86、ARM，本文将对这三种架构进行对比分析。</p>
<h1 id="powerpc"><a class="markdownIt-Anchor" href="#powerpc"></a> PowerPC</h1>
<h2 id="powerpc的由来"><a class="markdownIt-Anchor" href="#powerpc的由来"></a> PowerPC的由来</h2>
<p>1975年，IMB公司801小型计算机工程在RISC机体系结构方面做了许多开创性试验。801计算机与贝克莱大学的RISC处理器引起了RISC机革新运动，然而801计算机仅仅是一个用来演示某种概念的原型机。801工程的成功致使IBM公司开发一种商业的RISC工作站产品，这就是RT PC。<br>
RT PC于1986年诞生，它采用了801的体系结构概念，成为一个实际产品。RT PC未获得商业成功，它有许多性能相当或更好的竞争产品。1990年IBM公司在总结了801和RT PC两产品经验教训的基础上生产了第3个产品即IBM RISC SYSTEM/6000。它是一个类似RISC的超标量计算机，市场定位是高性能工作站。此产品推介后不久，IBM公司开始把这种计算机称为Power结构。<br>
1991年，IBM公司与MOTOROLA公司(摩托罗拉公司，6800系列微处理器开发商)、苹果公司(该公司将MOTOROLA芯片装入Macintosh计算机)结成联盟，出产了一系列用PowerPC结构实现的系列计算机，以争抗x86处理器所占有的压倒优势的市场。这种结构源于Power结构，并做了改动(包括消除故障，增加原先缺少的关键技术特色，去除某些指令，放宽技术条件)，从而实现了更高的执行效率。到1995年初，PowerPC系微机有四个产品先后问世。</p>
<ul>
<li>601：第1个PowerPC产品，它的目标是让PowerPC结构尽快地占领市场，601是32位计算机。其时钟速度可达80MHz，每个时钟周期可执行3条指令</li>
<li>603：设计目标是低端台式机，便携机和笔记本电脑，它也是32位计算机，性能与601相当，但价格低并且执行效率更高。它的时钟速度为80MHz，每个时钟周期执行两条指令，适用于低能耗要求的计算机。</li>
<li>604：设计目标是台式计算机和低端服务器，也是32位计算机，但是604使用了更先进的超标量设计技术，以获取更高的性能。604的时钟速度为100MHz，每个时钟周期可执行4条指令</li>
<li>620：设计目标是高端服务器。PowerPC系列机中的第1个使用全64位结构的产品，它包含64位寄存器和64位总线宽度</li>
</ul>
<p>PowerPC是三家公司联盟推出的系列微处理器产品。尽管PowerPC产品都具有基本一致的体系结构，但是具体规格型号却与制造公司有关，由制造公司决定。一般而言，IMB公司生产的PowerPC芯片有PPC的简称，MOTOROLA公司生产的PowerPC芯片有MPC的简称。例如Motorola MPC620时钟速度为125MHz，每个时钟周期可执行4条指令，它是第一个采用真正64位地址总线的PowerPC微处理器，性能指标大大优于同时期的Pentium芯片</p>
<h2 id="微处理器市场中powerpc的地位"><a class="markdownIt-Anchor" href="#微处理器市场中powerpc的地位"></a> 微处理器市场中PowerPC的地位</h2>
<p>从最早的PowerPC601产品诞生起，PowerPC在市场上就一直处于激烈的竞争之中。1994年是PowerPC和Pentium的决战年。从技术性能指标上看，PowerPC和Pentium各有千秋，PowerPC的性能价格比甚至比Pentuim高出80%。这两个芯片的制造商都为自己的产品投入了大量的资金进行广告宣传，进行激烈的市场竞争。这场市场竞争不仅仅是PowerPC和Pentium的竞争，也是它们所代表的当时RISC技术和CISC技术的竞争，以及这两大产品生产集团WINTEL和AIM的竞争。<br>
在1994年大搏斗中，Pentium芯片占了上风，在随后的几年里越发风光一时，到目前为止已成为世界微处理器市场的主导产品。现在，在Pentium芯片或X86芯片的周围，全球有几千家厂家为其开发配套硬件、软件和提供服务。相反，尽管近几年来PowerPC也获得了一定的市场份额，大约每年占百分之十几，但是围绕PowerPC开发硬软件的公司只有几百家，市场占有率始终没有明显的增长。AIM联盟对自己的PowerPC产品的态度也几经曲折，从92年满怀信心到96年失望动摇，97年以后到现在又重建信心继续投入研发和市场竞争。<br>
分析近年来PowerPC的市场表现，我们可以得出以下几个观点。</p>
<ul>
<li>保护用户原先在硬件和软件上的投资是处理器开发重中之重。众所周知，Pentium是向下兼容处理芯片，用户在8088、8086、80286、80386、80486微处理器芯片上所做的投资都能得到保持。在这方面Pentium占据上风，它留住了大量的X86产品的老用户。而PowerPC是相对独立的微处理器芯片，如果用户买了基于PowerPC的计算机产品，那么这些用户原先在计算机软件硬件方面的投资就难于保持，这是PowerPC参与微处理器市场竞争的薄弱环节。</li>
<li>对于一个新体系结构的微处理器，如果没有强有力的软件开发力量做后盾，就很难引起用户的兴趣，建立起使用信心。Pentium新芯片的每一次推出都有Microsoft公司的软件开发支持。而AIM联盟在PowerPC芯片上投入的软件开发力量有限，许多软件尤其是Windows95/98和Windows NT环境下的软件在PowerPC硬件环境下不能运行，这使得Power-PC失去了相当大的市场份额。</li>
<li>从技术上讲，PowerPC所代表的RISC技术还没有取得刚出现时人们所期待的那样大的技术优势。1994年PowerPC刚进入市场时，它带着人们对RISC技术优势巨大期望的光环。然而，这四五年来，Pentium芯片一次又一次地大量集成复杂指令并且获得市场认同致使人们对RISC技术的重要性产生了动摇。虽然Pentium也带有RISC指令，但本质上讲它是CISC型处理器。Pentium的市场成功向人们表明CISC处理器仍然具有强大的生命力。<br>
九十年代的的计算机体系结构的一个显著发展动向是CISC与RISC共存并且相互渗透。我们注意到在新型号PowerPC芯片中也集成了复杂指令。例如1998年Motorola公司为PowerPC开发了一种所谓的“AltiVec”新技术，不仅增加了MMX多媒体指令集，而且包括了联网和电话功能。现在这一技术已得到Apple和IBM的支持。“AltiVec”的出现标志着在技术进步方面PowerPC紧追Pentium不舍，两个处理器的技术竞争与市场角逐在更高层次上继续展开。</li>
</ul>
<h1 id="x86架构"><a class="markdownIt-Anchor" href="#x86架构"></a> X86架构</h1>
<h2 id="x86架构的由来"><a class="markdownIt-Anchor" href="#x86架构的由来"></a> X86架构的由来</h2>
<p>1978年6月8日，Intel发布了新款16位微处理器8086，同时也开创了一个新时代：X86架构诞生了。X86指的是特定微处理器执行的一些计算机语言指令集，定义了芯片的基本使用规则，一如今天的X64、IA64等。<br>
事实上，8086处理器发布之初并没有获得太多的关注，开始也没有被大范围采用，但它在PC业界的地位怎么形容都不为过，这就是因为它带来了X86。它不仅成就了Intel如日中天的地位，也成为了一种业界标准，即使在当今强大的多核心处理器上也能看到X86的身影。<br>
在30年的发展当中，X86家族不断壮大，从桌面转战笔记本、服务器、超级计算机、编写设备，期间还挫败或者限制了很多竞争对手的发展，让不少处理器厂商及其架构技术成为历史名字，即使有些封闭发展的也难以为继，比如苹果就已经放弃了PowerPC。<br>
当然，我们不能忘了X86-64和EM64T的斗争。2003年，AMD推出了业界首款64位处理器Athlon 64，也带来了X86-64，即X86指令集的64位扩展超集，具备向下兼容的特点。当时Intel也在推行64位技术，但是其IA64架构并不兼容X86，只是用在服务器Itanim上。为了和AMD展开竞争，Intel也在2004年推出了自己的64位版X86，也就是EM64T。这其实也证明，X86指令集的弹性完全可以拿来对付Intel，所以即使Intel统治了整个市场，其它公司依然可以改变X86的发展方向。<br>
X86是一个Intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合，X与处理器没有任何关系，它是一个对所有*86系统的简单的通配符定义，例如：i386、586、奔腾。由于早期Intel的CPU编号都是如8086、80286来编号，这整个系列的CPU都是指令兼容的，所以都用X86来标识所使用的指令集，如今的奔腾、P2、P4、赛扬系列都是支持X86指令系统的，所以都属于X86家族。</p>
<h2 id="x86架构展望"><a class="markdownIt-Anchor" href="#x86架构展望"></a> X86架构展望</h2>
<p>Intel推出X86架构已满30年了，同486相比，Pentium向前迈进了一大步，而PⅡ的前进步伐则没有这么大了，X86 CPU的发展似乎已到了尽头。Intel非常清楚，是X86指令集限制了CPU性能的进一步提高，因此，他们正同惠普共同努力开发下一代指令集架构（Instruction Set Architecture，ISA):EPIC(Explicitly Parallel InstructionComputing，显性并行指令计算)。对Intel而言，IA－64（Intel的64位架构）是下一个10到15年的架构。新的ISA将使英特尔摆脱X86架构的限制，从而设计出超越所有现有RISC CPU和X86 CPU的新型处理器。那么EPIC的先进之处在什么地方呢？为什么英特尔会放弃使它成为芯片巨人的X86架构呢？<br>
IA－32的问题我们知道，工程师可以通过提高每个时钟的指令执行数来提高性能，Intel新的指令集的首要目的在于，让指令更容易解码，更容易并行执行。这样就可以不受限制地开发新型处理器。但是，对工程师而言，兼容8086的X86指令集一直是必须完成的任务。毕竟，兼容前代产品是使英特尔成长壮大起来的关键因素，而且还可以保护用户原先的投资和使用数以百万计应用软件。既然如此，为什么又要放弃整个X86指令集重新开始呢？X86的不足在什么地方？</p>
<ul>
<li>可变的指令长度：X86指令的长度是不定的，而且有几种不同的格式，结果造成X86 CPU的解码工作非常复杂，为了提高CPU的工作频率，不得不延长CPU中的流水线，而过长的流水线在分支预测出错的情况下，又会带来CPU工作停滞时间较长的弊端</li>
<li>寄存器的贫乏：X86指令集架构只有8个通用寄存器，而且实际只能使用6个。这种情况同现代的超标量CPU极不适应，虽然工程师们采用寄存器重命名的技术来弥补这个缺陷，但造成了CPU过于复杂，流水线过长的局面</li>
<li>内存访问：X86指令可访问内存地址，而现代RISC CPU则使用LOAD/STORE模式，只有LOAD和STORE指令才能从内存中读取数据到寄存器，所有其他指令只对寄存器中的操作数计算。在CPU的速度是内存速度的5倍或5倍以上的情况下，后一种工作模式才是正途</li>
<li>浮点堆栈：X87 FPU是目前最慢的FPU，主要的原因之一就在于X87指令使用一个操作数堆栈。如果没有足够多的寄存器进行计算，你就不得不使用堆栈来存放数据，这会浪费大量的时间来使用FXCH指令（即把正确的数据放到堆栈的顶部）</li>
<li>4GB限制：这似乎不是问题，但是，在2000年前，主流PC只有4MB内存，现在绝大部分PC装备了2G以上的内存，是以前的512倍，所以，PC内存突破16GB绝对不会令人惊讶，大型服务器已经使用了32GB以上的内存，突破64GB内存的情况已经出现</li>
<li>芯片变大：所有用于提高X86 CPU性能的方法，如寄存器重命名、巨大的缓冲器、乱序执行、分支预测、X86指令转化等等，都使CPU的芯片面积变得更大，也限制了工作频率的进一步提高，而额外集成的这些晶体管都只是为了解决X86指令的问题</li>
</ul>
<h1 id="arm架构"><a class="markdownIt-Anchor" href="#arm架构"></a> ARM架构</h1>
<h2 id="arm的由来"><a class="markdownIt-Anchor" href="#arm的由来"></a> ARM的由来</h2>
<p>1978年12月5日，物理学家赫尔曼·豪泽（HermannHauser）和工程师Chris Curry，在英国剑桥创办了CPU公司（Cambridge Processing Unit），主要业务是为当地市场供应电子设备。1979年，CPU公司改名为Acorn公司。<br>
起初，Acorn公司打算使用摩托罗拉公司的16位芯片，但是发现这种芯片太慢也太贵。“一台售价500英镑的机器，不可能使用价格100英镑的CPU！”他们转而向Intel公司索要80286芯片的设计资料，但是遭到拒绝，于是被迫自行研发。<br>
1985年，RogerWilson和Steve Furber设计了他们自己的第一代32位、6M Hz的处理器，Roger Wilson和Steve Furber 用它做出了一台RISC指令集的计算机，简称ARM（Acorn RISC Machine）。这就是ARM这个名字的由来。<br>
RISC的全称是“精简指令集计算机”（reduced instruction set computer），它支持的指令比较简单，所以功耗小、价格便宜，特别适合移动设备。早期使用ARM芯片的典型设备，就是苹果公司的牛顿PDA。<br>
20世纪80年代后期，ARM很快开发成Acorn的台式机产品，形成英国的计算机教育基础。<br>
1990年11月27日，Acorn公司正式改组为ARM计算机公司。苹果公司出资150万英镑，芯片厂商VLSI出资25万英镑，Acorn本身则以150万英镑的知识产权和12名工程师入股。公司的办公地点非常简陋，就是一个谷仓。<br>
20世纪90年代，ARM32位嵌入式RISC(Reduced lnstruction SetComputer)处理器扩展到世界范围，占据了低功耗、低成本和高性能的嵌入式系统应用领域的领先地位。ARM公司既不生产芯片也不销售芯片，它只出售芯片技术授权。</p>
<h2 id="arm的前景"><a class="markdownIt-Anchor" href="#arm的前景"></a> ARM的前景</h2>
<p>微软公司（2011年）宣布，下一版Windows将正式支持ARM处理器。这是计算机工业arm处理器发展历史上的一件大事，标识着x86处理器的主导地位发生动摇。在移动设备市场，ARM处理器的市场份额超过90%；在服务器市场，2011年就会有2.5GHz的服务器上市；在桌面电脑市场，又有了微软的支持。ARM成为主流，恐怕指日可待。难怪有人惊呼，Intel公司将被击败！ARM微处理器核技术广泛应用于便携式通信产品、手持运算、多媒体和嵌入式解决方案等领域，已成为RISC的标准。<br>
与这场轰轰烈烈的变革相比，它的主角ARM公司却没有受到太多的关注，显得不太起眼。这家远离硅谷、位于剑桥大学的英国公司，到底是怎么走到今天的，居然能将芯片巨人Intel拉下马？<br>
展望未来，即使Intel成功地实施了Atom战略，将X86芯片的功耗和价格大大降低，它与ARM竞争也将非常吃力。因为ARM的商业模式是开放的，任何厂商都可以购买授权，所以未来并不是Intel vs ARM，而是Intel vs 世界上所有其他半导体公司。那样的话，Intel的胜算能有多少呢？<br>
2012年10月29日AMD做出了一个震惊业界的宣布：AMD将会设计基于64-bit ARM架构的处理器，首先从云和数据中心服务器领域开始。AMD、ARM在服务器领域的合作已经得到了戴尔、惠普两大服务器厂商，以及服务器系统厂商RedHat的鼎力支持，新的生态系统已具雏形，AMD能否借此东山再起？ <br>
AMD的首批ARM处理器于2014年问世，仍将披挂Opteron皓龙品牌。这种64位的多核心SoC会针对数据中心中份额最大的密集型高能效服务器进行优化，提供现代计算体验，并整合收购而来的SeaMicro Freedom超级计算光纤互联技术。</p>
<h1 id="对比"><a class="markdownIt-Anchor" href="#对比"></a> 对比</h1>
<h2 id="powerpc架构相比于arm的优势"><a class="markdownIt-Anchor" href="#powerpc架构相比于arm的优势"></a> PowerPC架构相比于ARM的优势</h2>
<p>powerpc芯片凭借其出色的性能和高度整合和技术先进特性在网络通信应用，工业控制应用，家用数字化，网络存储领域，军工领域,电力系统控制等都具有非常广泛的应用。<br>
由于PowerPC相对ARM器件来说价格稍贵，另外ARM开发工具盗版到处都是，所以在中国目前来说PowerPC不是很普及，但在一些欧美国家应用很广泛的。个人觉得PowerPC相对ARM优势有下面几点说明：</p>
<ul>
<li>整合度高以及技术先进性，现在Freescale PowerPC处理器集成USB、PCI、DDR控制器、SATA控制器、千兆网口控制器、CAN控制器、RapidIO以及PCI_Express控制器，IEEE1588通信协议，支持各种通信协议CPM协处理器、DMA、SPI、I2C.UART等，客户无须设计复杂的外围电路，减少设计复杂程度以及物料使用，ARM这点比不上</li>
<li>芯片可选范围大，性能高，升级容易，从50M-1.7G都有处理器，而且PowerPC将向多核处理器发展，如已经推出集成双e500 coreMPC8572，MIPS性能高达6897，ARM我看频率是1G的都没有，ARM大概是1.1MIPS/MHz，Power Architecture是大于2.0MIPS/MHz，所以PowerPC在高端嵌入式应用，占有很大比例，ARM这点比不上</li>
<li>开发难度方面，PowerPC处理器开发难度并不是很高，只不过因为开发的人少，所以中文资料相对较少，另外开发工具也不象ARM那么多盗版的，所以总有些人抱怨PowerPC处理器开发难度大，其实如Freescale都免费给客户提供Datasheet，设计详细文档给用户，而且最底层驱动，Freesclae都已经开发好，你可以在他们论坛上提问，或者发邮件给技术支持，他们很快都能回复的，相信以后用的人会越来越多</li>
<li>价格方面，总有人抱怨说PowerPC处理器价格贵，相对ARM来说，同样频率的，可能会贵点，但是如果是MIPS/MHz性能比较以及整合的外围电路来说，PowerPC还是有一定优势的，Freescale也意识到这个问题，所以推出了像工作频率低点的MPC8313，MPO8323等低价格处理器，另外如coldfire也推出低价格处理器，随着Freescale后面产品继续推出，PowerPC处理器价格会越来越便宜</li>
</ul>
<p>PowerPC的结构尤其在功耗方面的束缚可能导致其在嵌入式领域没有如ARM那样大的伸缩性，二者定位不同：</p>
<ul>
<li>ARM面向的低端消费类市场，拼的是功耗；PowerPC面向的是中高端市场，比的是性能，好像还没看到谁的手机是PowerPC的，也没有看到谁家企业级以上的交换机是用ARM做的</li>
<li>PowerPC在嵌入式领域的应用是在中高端的，不在消费领域，比如企业级以上的交换机，大机架上铲平，对功耗应该是考虑次要的，这类产品都是由单独的AC/DC的电源，而且机箱中一般都有风扇，所以功耗应该不是问题，ARM都是面向消费电子的</li>
</ul>
<p>ARM在消费电子领域的优势非常明显，如此流行的原因我认为有三个方面：价格便宜、配套IP完备、集成使用方便。<br>
至于性能和低功耗方面，ARM要弱于PowerPC。Power系列的芯片主要用于交换机、网络处理器、及sony的游戏机等应用上，这类的应用场合对处理器的性能要求非常强烈，ARM难以胜任。ARM和MIPS在消费领域存在着竞争，MIPS阵营的产品在功耗和面积上具有优势，但MIPS提供的开发工具不如ARM便捷。</p>
<h2 id="powerpc架构与x86架构的区别"><a class="markdownIt-Anchor" href="#powerpc架构与x86架构的区别"></a> Powerpc架构与X86架构的区别</h2>
<p>PowerPC和Intel x86对比，要看怎么比了。<br>
首先，在高端服务器领域，PowerPC的大规模SMP系统性能（目前最高的power795可以配置256个4GHz处理核心）即使8路E7 v2顶配，120个核心也是难以望其项背的，当然低端入门级领域Intel在同等价格的前提下性能有很大优势也是事实(企业级市场Intel产品线的价格还是很宜人的)。<br>
其次，PowerPC系统在硬件层面的可靠性、可用性、可维护性（业界俗称RAS）方面明显强于X86系统，Intel只提供处理器，整机需要厂商自己去设计，中小厂商基本靠Intel的公版方案做白牌装机商，只有大品牌（比如IBM HP之类）才有自己的独道设计，X86的杂牌军和IBM从芯片开始设计的整机方案无法相比。<br>
第三，PowerPC机器一般运行AIX系统居多，少数Linux系统；x86基本运行Win和Linux系统。AIX在系统稳定性、软件方案集成度（例如HA软件、备份软件、集群文件系统等等）、厂商技术支持能力强于开放平台。<br>
第四，商用IT系统的用户选用什么平台主要看软件需求，有些要求7*24不能宕机不能丢数据的关键性应用在操作系统选择方面有很大的局限性（例如银行、电信等等），这些领域X86想获得机会，需要依靠应用软件移植和Win/Linux这类开放OS可靠性大幅提升才有可能完成，无论哪一个都不是容易做到的。<br>
PowerPC和sparc、安腾是UNIX界的三驾马车，共同支撑起绝大部分企业的关键性应用平台，xeon从低端起家，逐渐向中端蚕食，高端市场目前还无力企及。软件层面，UNIX平台的缩水和Win/Linux的进取是不可逆转的趋势。PowerPC和X86的对比，单纯对比芯片本身意义不大，也和普通消费者没有直接关系。</p>
<h3 id="硬件体系"><a class="markdownIt-Anchor" href="#硬件体系"></a> 硬件体系</h3>
<p>从处理能力来说，单Hz的处理能力X86已经超过了PowerPC系列，这是毋庸置疑的。但是PowerPC有其明显的优点。它采用了标准的SMP结构，也就是说对于内存来说所有CPU访问的速度都是一致的，而X86采用了NUMA结构，这就是说CPU和内存是分区的，每个CPU访问自己的这部分内存特别快，但是如果需要访问其它部分那就要走QPI总线（现在已经在不断改进了），这也客观上造成了随着CPU数量的增多，处理能力的增长Power系列的线性程度远好于X86（这也是为什么很少会用4路以上的X86服务器）。而且作为小型机，封闭系统，其设计更加完整紧凑，综合起来性能强于X86。</p>
<h3 id="软件体系"><a class="markdownIt-Anchor" href="#软件体系"></a> 软件体系</h3>
<p>硬件体系是自己的，操作系统也是自己的（AIX等），所以整合起来PowerPC系列的整体稳定性要强于X86服务器，而且运维也方便（特别是对于一些外围硬件，如果使用IBM更加容易用），抗压能力也强（小型机90%的CPU占用率，运行几个星期可能都OK，X86几天就估计出问题了）但是PowerPC系列的小型机的价格太高了，而且已经赶不上技术的变化了，由于Google的崛起，云计算的兴盛，现在的分布式系统的成熟度越来越高，系统已经越来越不依赖几台小型机来提供稳定可靠性，而是通过集群来提供，性能也能够通过分布式的处理来解决。<br>
所以X86的使用越来越广泛，而最新的一些低成本但是能够带来高效能的新技术都在X86体系下得到应用（X86市场占有率高，也开放），而PowerPC系列由于其封闭的特性，反而难以得到应用，所以PowerPC系列的小型机优势越来越不明显，已经在逐渐退出历史舞台了。</p>
<h3 id="面临的共同问题"><a class="markdownIt-Anchor" href="#面临的共同问题"></a> 面临的共同问题</h3>
<p>性能瓶颈———报酬递减法则：尽管CPU时钟频率不断提高，但其实际处理能力却并没有成比例提高，例如一个2GHz CPU的处理能力并不是一个1GHz CPU的两倍，目前还很难解释产生这种现象的原因。<br>
另外因为内存的处理能力（performance）与CPU的处理能力（performance）不匹配，CPU大部分时间在等待，不做任何事情（HP估计服务器的CPU这种不做任何事情的时间占70%）。<br>
这种内存的延迟是不可能消除，因此当程序需要CPU访问大量内存时，这种内存延迟将极大地影响程序的运行，此时CPU处理能力不能接近其真实的处理能力。当然CPU的cache能够减少这种延迟的影响，提高处理能力，但是cache的提升效果极大的依赖于cache的类型和软件使用的算法。<br>
目前在X86系列CPU中，一些新技术的应用，对CPU的处理能力只有些许的提高，这些新技术所以被应用，多源于Intel和AMD竞争的结果。现在CPU的时钟已经变得非常高了，处理能力不等比例增长问题也变得更加严重，这意味着提高时钟频率对提高整体的处理能力收效甚微。SPEC Benchmark测试表明：在DELL工作站上面当增加50%的CPU时钟频率，同时辅助以hyper-threading技术时，CPU处理能力只有26%的增加，而在Itanium 2 CPU系统上面，时钟频率只提高11%，但是cache增加一倍，CPU处理能力提高50%。但是cache增加到一定程度以后，对性能的影响又会减弱。<br>
当然，CPU的处理能力与很多因素相关，比如cache的大小、cache的设计、内存接口、编译器及其设置、程序语言和程序编写员等因素。有些时候，换一种编写语言都比换CPU更好，有时候换个编程人员就能获得很大提高。<br>
总之，无论是X86还是PowerPC处理器，由于时钟频率和cache等因素的非线性影响，处理器性能的提高遇到严重挑战，两者遇到的瓶颈与挑战是相同的。</p>
<h3 id="处理能力performance比较"><a class="markdownIt-Anchor" href="#处理能力performance比较"></a> 处理能力(Performance)比较</h3>
<p>90年代末期，AMD成为Intel公司的强有力竞争者，两个公司都致力于开发新型的更快速的X86 CPU。这种激烈的竞争，导致X86处理器的处理能力飞速的提高，一度极大的超过了RISC处理器（如果你相信Benchmark的话）。然而RISC处理器厂商也意识到这个问题，开始设计生产更快的RISC处理器。但是具有讽刺意味的是，当把这些CPU按照相同的几何学构造以后，运行最快的Alpha 21364使用的却是7年前的核设计的。<br>
尽管PowerPC处理器最初设计目标是桌面系统，但是它最大的应用却是更关心功耗的嵌入式应用。PowerPC G4处理器使用低速的单数据速率（single datarate）总线，而不象X86处理器使用的是双数据速率甚至四数据速率（double or quad data rate）总线，这个方面PowerPC没法与X86竞争。目前PowerPC的处理器在主频上没法和X86处理器相比，但是根据报酬递减法则这种高主频并不能反映处理器的真实处理能力。X86处理器的确非常快速，但是并没有你想象的那么快。</p>
<h3 id="矢量处理比较"><a class="markdownIt-Anchor" href="#矢量处理比较"></a> 矢量处理比较</h3>
<p>矢量处理也叫做SIMD（SingleInstruction Multiple Data），用来进行一些专门的处理，使用它可以使这些处理性能成倍的提高。<br>
X86和PowerPC都有这样的矢量单元，以支持矢量指令，X86处理器上是MMX，MMX2，SSE和SSE2。这些矢量单元有8个128位寄存器，但是这些寄存器不能同时执行浮点指令。X86处理器的浮点单元功能一直非常弱，现在X86处理器都使用SSE进行浮点运算，甚至于Intel公司投资开发编译器使处理器自动使用SSE单元进行浮点运算，而不管编程人员是否愿意这样。<br>
PowerPC从一开始就有更好的矢量处理能力，当Apple，IBM和Motorola修订PowerPC指令集时就考虑矢量处理能力，并增加了Altivec单元。Altivec单元具有32个128位寄存器，PowerPC从G4开始就集成Altivec单元，并在以后的版本继续集成AltiVec单元，同样的在970中也集成AltiVec单元。<br>
因为Altivec对内存需要更苛刻，G4的总线接口降低了Altivec性能，但是Altivec比SSE具有更多的寄存器，因此Altivec不需要频繁的访问内存，而SSE恰恰通过频繁的访问内存来提高处理能力。Altivec单元能独立操作并同时进行浮点运算。</p>
<h3 id="功耗比较"><a class="markdownIt-Anchor" href="#功耗比较"></a> 功耗比较</h3>
<p>X86和PowerPC最大的不同在于功耗，由于PowerPC是为嵌入式应用设计，并且主要用于嵌入式系统，因此具有很低的功耗。X86处理器恰恰相反，由于采用古老的效率低下的体系结构，具有很高的功耗，在X86处理器中，一切新技术的目的都是为了增加处理能力和时钟主频，这进一步增加了处理器功耗。3GHz Pentium 4处理器与1GHz的PowerPC G4(7447)处理器比较，在功耗上相差10 多倍。<br>
G4的最大功耗是10w，Intel不公布功耗的图表，只给出了热能消耗等级，这个数字大约为30w，低于最大功耗数值，按照这个热能等级图表，P4 3GHz处理器的设计功率额度为81.9w，但是实际的最大功率应该达到并可能超过100w。单个P4 3GHz处理器的功耗是一个Pegasos主板的4倍，而这种主板上面还包括一个1G的G4处理器。</p>
<h3 id="为何苹果放弃powerpc采用x86架构"><a class="markdownIt-Anchor" href="#为何苹果放弃powerpc采用x86架构"></a> 为何苹果放弃Powerpc采用X86架构</h3>
<p>除了能耗太高之外，导致笔记电脑使用时间无法延长也是个阻碍发展的原因之一。<br>
PowerPC的使用范围除了苹果电脑之外，其他厂商使用的比例极低，导致研发成本与实际销售获利彼此的拉扯，反观Intel持续以高效能、极短的开发周期，不断推出新的内核，更换Intel以商业角度其实颇为合理。最重要还有软体上的考量，苹果的作业系统本身，到了OS 9的时候已经面临难以大幅提升效能、无法轻易相容与其他Wintel电脑的刻板印象，这时候Steve Job回来苹果，并带回了离开苹果时所经营的NeXT系统(一个源自于UNIX分支的系统)这也是为什么苹果系统叫OS X而不叫OS10的原因，而UNIX系统是可以经由调整相容于Intel或PowerPC(早期的Linux都会有Intel版本或PPC-PowerPC版本)<br>
相信苹果从一开始开发Mac OS X就已经在铺陈更换Intel内核所需的研究。很多使用者对于使用苹果电脑会无法使用原本在Windows下的软件功能感到忧心，一旦使用相容于Intel的内核，除了调整作业系统以适用于Intel，另外好处是，在Mac环境下使用Windows也就不是难事了。<br>
现在苹果使用者大幅提升，有非常多正是因为苹果电脑除了自身系统外却也能兼顾原本Windows环境而勇于转换平台的使用者，不是吗。<br>
就现在来说当初老乔全面转向Intel平台降低了多方面的门槛：</p>
<ul>
<li>价格：PPC是当年apple价格高企的原因之一，就总体价格而言Intel平台成本比PowerPC低的多，配置上也更容易多样化，且Intel迭代速度快容易刺激销售增长</li>
<li>软件：编程语言方面我没有发言权，但相信Intel架构的普及率降低了软件的开发门槛，而且现在的app比PPC时代多的多</li>
<li>市场：对市场受众而言Intel平台的apple更具有亲和力，兼容性好、用不惯OS X分分钟就能装Windows，消费者可以很放心地入手，市场占有率也由此大幅度提升</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】Explorer.exe到底是什么？为什么从Windows 95开始一直传承至今？</title>
    <url>/posts/433fc2487d31</url>
    <content><![CDATA[<p>转自<a href="https://www.zhihu.com/question/310462143/answer/584141216">知乎：韩朴宇</a></p>
<h1 id="explorerexe"><a class="markdownIt-Anchor" href="#explorerexe"></a> explorer.exe</h1>
<p>是Windows95到Windows Me，Windows NT4到Windows10的默认shell(代替了Windows3.2的程序管理器)，同时也是默认的文件管理器(代替了<a href="https://github.com/Microsoft/winfile">WinFile</a>)。</p>
<p>explorer负责了任务栏，开始菜单，桌面的显示，同时也是文件管理器，功能复杂，实现起来更加复杂(尤其是Windows10，包含了很多UWP组件，稳定性差)。explorer提供了接口可以被第三方DLL注入，因此更会降低稳定性，一旦explorer主进程崩溃，桌面和任务栏就会消失(一般会自动重启)也因为explorer提供了用户打开其他程序的主要方式(开始菜单/固定到任务栏/桌面)，Windows10的任务管理器定位到explorer.exe时结束进程会变成重启进程。</p>
<p>shell是操作系统提供给用户的交互程序，分为图形shell和命令行shell两种。shell直译就是壳，即内核外层的东西。<br></p>
<img src="https://pic2.zhimg.com/50/v2-9c6232de3a7146f09f83ebb8e662340c_720w.jpg?source=1940ef5c">
￼
<center>https://zh.wikipedia.org/wiki/Shell</center><br>
<p>常见的命令行shell有Windows的cmd.exe，powershell，Unix下的Bash，Zsh，Fish。Windows Server，Windows PE默认使用cmd作为shell，开机后只有一个命令行的窗口。命令行shell没有多任务能力，一次只能显示一个文本程序，现在很少有人只使用命令行操作计算机。</p>
<p>桌面系统的图形shell则比较复杂，可以分为多个组件：桌面，任务栏/dock，开始菜单/Launcher，通知区域等。桌面经常由文件管理器负责，例如Windows的explorer，macOS的finder，通常显示/Users/&lt;User&gt;/Desktop下的文件，这些图标的操作方式一般和文件管理器内部没有差别。</p>
<p>Windows的任务栏由explorer负责，而macOS的dock程序坞是独立的程序/System/Library/CoreServices/Dock.app</p>
<p>Windows的开始菜单在Windows7及之前是explorer的一部分。Windows8中“开始”改成了类似移动端的开始屏幕，Windows10改成了独立的UWP，但是和explorer仍有密切的关系，比如开始菜单卡死了可以重启explorer解决。macOS的Luncher启动台是独立的程序/Applications/Launchpad.app。</p>
<p>Windows的通知区域是任务栏的一部分，而macOS则是独立在顶栏的右半部分。</p>
<p>Explorer包含了很多的功能，而且可以通过各种手段插入插件，因此稳定性不如macOS这种分离式设计。当然，我仍然觉得Windows的多任务管理比macOS直观。<br>
移动操作系统的用户界面相比更加简化，只有启动器/主屏幕/开始屏幕（上香）和多任务界面。</p>
<h1 id="历史内容"><a class="markdownIt-Anchor" href="#历史内容"></a> 历史内容</h1>
<p>观察早期的Windows可以看到explorer是怎么成为shell的<br></p>
<img src="https://pic3.zhimg.com/50/v2-b70bacb42e43ff8aa02d47cb550d0df0_720w.jpg?source=1940ef5c">
￼
<center>Windows 2的画图，后面的窗口是shell“MS-DOS可执行程序”，具有文件管理功能，启动程序需要双击exe，左下角的是最小化的“写字板”</center><br>
<img src="https://pic1.zhimg.com/50/v2-6794323abfe4daa11544936f23fad980_720w.jpg?source=1940ef5c">
￼
<center>“程序管理器”是Windows3.x，WindowsNT3.x的shell，左下方的图标是最小化的文件管理器，相比于Windows2，程序管理器具有快捷方式的功能，把安装好的程序放到了程序组中，而不必找到exe文件双击执行</center><br>
<img src="https://pica.zhimg.com/50/v2-09183deb0373cfc44bcde96e0f633a3f_720w.jpg?source=1940ef5c">
￼
<center>Windows3的“文件管理器”，和“程序管理器”不是一个程序</center><br>
<img src="https://pica.zhimg.com/50/v2-b8b1a2a85f09dd2839999ab33a3e11f0_720w.jpg?source=1940ef5c">
￼
<center>Windows95，左上角是点击“我的电脑”打开的资源管理器，右面的是开始菜单里的Windows exploring，下面的是Windows3时代的文件管理器（winfile，现已开源）</center><br>
<p>Windows95虽然是16/32位混合系统，但是开始菜单/任务栏/桌面/资源管理器4功能于一体的explorer一直延续到Windows10.<br>
Explorer.exe早在Windows 95（Chicago）开发早期就引入了</p>
<img src="https://pica.zhimg.com/50/v2-573436a68d70b24e0f2b9cc7470bdcf1_720w.jpg?source=1940ef5c">
￼
<center>Windows Chicago 4.0.58s，此时explorer叫cabinet，开始按钮有3个，任务栏没有完工，时间1993-08-09</center><br>
<img src="https://pic2.zhimg.com/50/v2-dfea339b0d27f18fe847849acb77c61d_720w.jpg?source=1940ef5c">
￼
<center>右上角的关闭按钮是后来加入的，早期Windows程序使用双击左上角的-退出</center><br>
<img src="https://pic3.zhimg.com/50/v2-dceadcf9d9a9a94f96815a357452542d_720w.jpg?source=1940ef5c">
￼
<center>关于</center><br>
<img src="https://pica.zhimg.com/50/v2-5e996cbe7c78044260d6250d621cc34c_720w.jpg?source=1940ef5c">
￼
<center>Windows Chicago 4.00.81基本完工，时间1994-01-19</center><br>
<p>这是ReactOS的explorer的源代码，和Windows Server2003很接近<br>
<a href="https://github.com/reactos/reactos/tree/master/base/shell/explorer">reactos/reactos</a><br></p>
<img src="https://pic1.zhimg.com/50/v2-305e5730558fd4389160f990ef19766c_720w.jpg?source=1940ef5c">
￼
<center>在桌面上，macOS的菜单栏显示finder的菜单</center><br>
<img src="https://pic1.zhimg.com/50/v2-0e613ac20e55bab50fa72f1116476e54_720w.jpg?source=1940ef5c">
￼
<center>3个app</center><br>
<p>使用的模拟器：<br>
windows2/3 <a href="https://www.pcjs.org/">The Original IBM PC in a Web Browser</a><br>
Windows95 <a href="https://archive.org/details/win95_in_dosbox">win95</a><br>
Windows Chicago的更多信息<br>
<a href="https://www.thecollectionbook.info/windows/95">The Collection Book</a><br>
<a href="https://betawiki.net/wiki/Windows_95">Windows 95 - BetaWiki</a></p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile编写(2)：变量</title>
    <url>/posts/a441fae22eb2</url>
    <content><![CDATA[<p><strong>注：本系列内容大部分是基于GNU make的标准，其中cc命令默认调用Linux自带的c编译器程序</strong></p>
<ol>
<li>
<a href="/2022/05/09/makefile/" title="makefile介绍">makefile介绍</a>
</li>
<li>
<a href="/2022/05/14/makefile%E8%BF%9B%E9%98%B6/" title="makefile编写(1)：规则">makefile编写(1)：规则</a>
</li>
<li>
<a href="/2022/05/16/makefile%E7%BC%96%E5%86%99/" title="makefile编写(2)：变量">makefile编写(2)：变量</a>
</li>
<li>
<a href="/2022/05/18/makefile%E8%BF%9B%E9%98%B62/" title="makefile编写(3)：条件执行和函数">makefile编写(3)：条件执行和函数</a>
</li>
</ol>
<h1 id="makefile变量"><a class="markdownIt-Anchor" href="#makefile变量"></a> makefile变量</h1>
<p>在makefile中的定义的变量从效果和实现来看比较像c/c++语言中的宏，它代表一个文本字串(没有数据类型)，可以使用在目标文件、依赖文件、命令或是makefile的其它部分中，在makefile中执行时其会自动地展开在引用的地方。但是与c/c++的宏所不同的是，makefile的变量值是可以在文中改变的，具有“变量”的性质(其实只要把makefile的执行过程单纯类比于c程序的预处理过程，会发现两者并没什么不同)。下面给出一个简单的例子：</p>
<pre class="line-numbers language-none"><code class="language-none"># 变量会在使用它的地方精确地展开，就像c&#x2F;c\++中的宏一样
f &#x3D; c
prog.o : prog.$(f)
    $(f)$(f) -$(f) prog.$(f)
# 展开后得到：
prog.o : prog.c
    cc -c prog.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例仅仅是为了说明变量展开的过程，实际编程肯定不会这样做。</p>
<h2 id="makefile变量的基本语法"><a class="markdownIt-Anchor" href="#makefile变量的基本语法"></a> makefile变量的基本语法</h2>
<p>在makefile中，自定义变量的命名可以包含字符、数字，下划线(可以是数字开头)，但不应该有:、#、=或空字符(空格、换行、Tab等)。变量是大小写敏感的，foo、Foo和FOO是三个不同的变量名(与UNIX的风格一致)。传统的makefile的变量名是全大写的命名方式，但还是推荐使用驼峰命名，如：MakeFlags，这样可以避免与预定义环境变量冲突而覆盖掉后者。<br>
定义变量的基本语法如下：</p>
<blockquote>
<p>变量的名称=值列表</p>
</blockquote>
<p>值列表中既可以是零项，又可以是一项或者是多项。等号左右的空白符没有明确的要求，因为make解析时多余的空白符会被自动删除，变成Shell的赋值形式。注意makefile变量值都是字符串，所以任何情况下都不要额外加&quot;&quot;和’’(除非是在Shell命令中)，否则会被单纯的看作是字面值本身加上引号。<br>
引用变量时的格式为：</p>
<blockquote>
<p>$(值列表)或${值列表T}</p>
</blockquote>
<p>存在一个特殊情况，就是在之前定义f=c的例子中，变量f不加括号实际是一样的：</p>
<ul>
<li>变量名为单字符的情况下，直接使用$x的格式就可以实现变量引用
<ul>
<li>自动化变量其实也是使用这种格式</li>
</ul>
</li>
<li>多字符变量的引用必须使用括号，否则make将把变量名的首字母作为作为变量而不是整个字符串
<ul>
<li>比如$PATH会被解释为$§后面再加一个ATH符号</li>
<li>这一点和Shell中变量引用方式不同，Shell中$xx可以直接引用变量xx</li>
</ul>
</li>
</ul>
<p>不过为了更加安全地使用，一般还是推荐一律给变量加括号。<br>
另外还存在的一种特殊情况是在命令中使用变量，是完全可以按照Shell命令的形式写的。只不过由于makefile中符号$有特殊的含义(元字符)，不能直接按照Shell脚本的格式写，否则默认是在按照makefile的形式引用变量。此时需要使用两个连续的$$“转义”符号$，这样变量就会被解析为Shell脚本的$xx形式。(同理，在规则中需要使用符号$的地方，都需要使用两个连续的$$)</p>
<h2 id="makefile变量赋值"><a class="markdownIt-Anchor" href="#makefile变量赋值"></a> makefile变量赋值</h2>
<p>makefile中支持四种变量基本赋值方式。第一种方式是简单的使用=号，可以用一个或多个字串为变量赋值，也可以用其他<strong>变量引用</strong>赋值。注意，在这种情况下如果用变量值来定义变量的话，<strong>右侧变量可以定义在文件的任何一处</strong>，也就是说=右侧不一定非要是已定义的值，也可以用后面定义的值，如：</p>
<pre class="line-numbers language-none"><code class="language-none">foo &#x3D; $(bar)
bar &#x3D; $(ugh)
ugh &#x3D; Huh?
all:
    echo $(foo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>执行make all将会打印出的变量$(foo)的值是Huh? ($(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是Huh?)，可见变量是可以使用后面的变量来定义的。这主要是因为脚本语言都是不需要提前声明变量的，而Shell的特点是只要变量第一次出现就<strong>默认创建</strong>，如果没有给出初始化值则变量会被赋予一个<strong>空字符串</strong>。之后的过程与宏展开类似，make在读入所有变量以后，将变量最终的值展开在所有引用处(作用域内)。不过这也带来了一个严重的问题，那就是可能形成递归定义，如：</p>
<pre class="line-numbers language-none"><code class="language-none">CFLAGS &#x3D; $(CFLAGS) -O
A &#x3D; $(B)
B &#x3D; $(A)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这相当于形成了循环依赖，make将会报错。另外如果在变量中使用函数时，使用=赋值这种方式效率很低，并且可能发生不可预知的错误，因为这两个函数调用将会因为递归调用而不可控。因此，=赋值在makefile中又被称为递归赋值，赋值语句可能影响多个变量，所有定值变量相关的其他定值变量都受影响。<br>
为了避免上面的这些情况，可以使用make中的:=操作符来=定义变量，使用方法如：</p>
<pre class="line-numbers language-none"><code class="language-none">x :&#x3D; foo
y :&#x3D; $(x) bar
x :&#x3D; later
# 其等价于：
# y :&#x3D; foo bar
# x :&#x3D; later<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>反之，如果是这样的话：</p>
<pre class="line-numbers language-none"><code class="language-none">y :&#x3D; $(x) bar
x :&#x3D; foo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时y的值是bar，而不是foo bar，也就是说并不是与最终的赋值相同(变量的值在程序中不同位置是不同的)。:=与c/c++等语言中常规理解的赋值方式是一致的，只对赋值语句之后的变量有效，这种赋值方式又称为覆盖赋值。<br>
一个特别的用法是借助:=定义一个空字符变量：</p>
<blockquote>
<p>nullstring :=<br>
space := $(nullstring) # end of the line</p>
</blockquote>
<p>此例中nullstring是一个空变量，其中什么也没有，而space值是一个空格。因为在操作符的右边是很难描述一个空格的(make会默认删除)，因此先用一个空变量来标明变量的值，而后面采用#注释符来表示变量定义的终止，这样就可以定义出值是一个空格的变量(这是我自己测试的结果，推测可能是跟c语言注释一样被转换为一个空格了)。注意这里关于#的使用，如果这样定义一个变量：</p>
<blockquote>
<p>dir := /foo/bar    # directory to put the frobs in</p>
</blockquote>
<p>dir这个变量的值是/foo/bar后面还跟个空格，如果使用这样的变量$(dir)/file来指定目录那么是错误的，因此在赋值语句时一定不要在同行写注释时加上空格(除非想在变量值中增加空字符)。</p>
<p>此外还有两种常用的赋值操作符是?=和+=。?=表示条件赋值，如果变量未定义则使用符号中的值定义变量，如果该变量已经赋值(只要是显式的赋值就算，哪怕是空串)则该赋值语句无效，如：</p>
<pre class="line-numbers language-none"><code class="language-none">FOO ?&#x3D; bar
# 实际上这条语句等价于：
# ifeq ($(origin FOO), undefined)
# FOO &#x3D; bar
# endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>+=表示追加赋值，被赋值的变量用空格隔开的方式在原本值后面追加一个新值，因此：</p>
<pre class="line-numbers language-none"><code class="language-none">objects &#x3D; main.o foo.o bar.o utils.o
objects +&#x3D; another.o
# 等价于
# objects &#x3D; main.o foo.o bar.o utils.o another.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：</p>
<ul>
<li>如果变量之前没有定义过，那么+=会自动变成=</li>
<li>如果前面变量上次被=或?=赋值过，那么+=会以=的方式(可以由之后的值在此展开)在后面追加内容，并且+=的结果可以作为递归赋值的在所有引用处展开</li>
<li>如果前面变量上次被:=赋值过，那么+=会以:=的方式(直接用变量当前值展开)在后面追加内容</li>
</ul>
<p>下面是一个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">variable1 :&#x3D; $(variable3)value1
variable1 +&#x3D; $(variable3)
variable2 &#x3D; $(variable3)
variable2 ?&#x3D; another
variable2 +&#x3D; $(variable3)
variable3 +&#x3D; value3
variable3 &#x3D; more
variable3 +&#x3D; value3
test:
    @echo $(variable1)
    @echo $(variable2)
    @echo $(variable3)
# 输出结果为：
#value1
more value3 more value3
more value3
# 因此这段makefile等价于：
# variable1 :&#x3D; value1                   此时$(variable3)为空串
# variable1 :&#x3D; value1                   +&#x3D;在此处追加一个空串$(variable3)
# variable2 &#x3D; $(variable3) $(variable3) variable2上次是?&#x3D;赋值，所以variable2此时值为$(variable3)，+&#x3D;按递归的方式再追加一个$(variable3)
# variable3 &#x3D; more                      variable3先被+&#x3D;赋值为value3，&#x3D;将之前+&#x3D;的值覆盖为more
# variable3 &#x3D; mare value3               variable3在上一步的基础上追加一个value3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="变量替换引用"><a class="markdownIt-Anchor" href="#变量替换引用"></a> 变量替换引用</h2>
<p>在makefile中可以替换变量中共有的部分，其格式为：</p>
<blockquote>
<p>$(var:a=b) 或是 ${var:a=b}</p>
</blockquote>
<p>上面的意思是把变量var中所有以a字符为后缀的字串替换为b结尾。结尾的含义是空格(一般Tab也算)之前(变量值多个字之间使用空格分开)。而对于变量其它部分的a字符不进行替<br>
换，比如：</p>
<blockquote>
<p>foo := a.o b.o c.o<br>
bar := $(foo:.o=.c)</p>
</blockquote>
<p>此例中先定义了一个$(foo)变量，第二行的意思是把$(foo)中所有以.o字串结尾全部替换成.c，所以$(bar)的值就是a.c b.c c.c。注意括号中的变量使用的是变量名而不是变量名的引用，变量名的后面要使用冒号和参数选项分开，表达式中间不能使用空格。另外一种常用的变量替换是与模式字符结合起来使用(形式与规则目标依赖关系中的静态模式相同)，如：</p>
<blockquote>
<p>foo := a.o b.o c.o<br>
bar := $(foo:%.o=%.c)</p>
</blockquote>
<p>这个例子中加不加%都是一样的，不过加上%在这种替换中能起到的作用并不仅于此。实际中对变量值的操作往往不只是修改后缀字符，可能改变字串中的不同位置的字符，比如：(加上%还可以匹配前缀)</p>
<pre class="line-numbers language-none"><code class="language-none">foo:&#x3D;a123c a1234c a12345c
obj1&#x3D;$(foo:a%c&#x3D;x%y)
obj2&#x3D;$(foo:a%c&#x3D;x5%y)
obj3&#x3D;$(foo:a1%c&#x3D;x%5y)
obj4&#x3D;$(foo:a%5c&#x3D;x5%y)
obj5&#x3D;$(foo:a%2%c&#x3D;x5%3%y)
All:
	@cat makefile  
	@echo $(obj1)  # 输出x123y x1234y x12345y
	@echo $(obj2)  # 输出x123y x1234y x12345y
	@echo $(obj3)  # 输出x5123y x51234y x512345y
	@echo $(obj4)  # 输出a123c a1234c x51234y
    @echo $(obj5)  # 输出a123c a1234c a12345c(我自己的测试结果，看来一个模式中不能有多个\% \?)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到<br>
实际上，变量的替换引用其实是函数patsubst的一个简化实现，在make中两者的行为是一致的。</p>
<h2 id="变量嵌套引用"><a class="markdownIt-Anchor" href="#变量嵌套引用"></a> 变量嵌套引用</h2>
<p>变量嵌套引用可以理解为“把变量的值再当成变量”，先看一个例子：</p>
<blockquote>
<p>x = y<br>
y = z<br>
a := $($(x))</p>
</blockquote>
<p>此例中，$(x)的值是y，所以$($(x))就是$(y)，于是$(a)的值就是z，注意这里是x=y而不是x=$(y)。使用更多层次进行嵌套也是一样的，比如：</p>
<blockquote>
<p>x = $(y)<br>
y = z<br>
z = u<br>
u = Hello<br>
a := $($($(x)))#输出为Hello</p>
</blockquote>
<p>这里的$($($(x)))被替换成了$($(z))，因为$(z)值是u，所以最终结果是：a:=$(u)，也就是Hello。使用变量时并不是只能引用一个变量，可以有多个变量的引用以及任意的文本字符，最后变量的引用是其中所有字符展开后的结果，比如：</p>
<blockquote>
<p>first_second = Hello<br>
a = first<br>
b = second<br>
all = $($a_$b)</p>
</blockquote>
<p>上例中$a_$b组成了first_second，于是$(all)的值就是Hello。因为展开后的字串是变量引用的形式，所以这种嵌套引用同样可以用在表达式左值：</p>
<blockquote>
<p>dir = foo<br>
$(dir)_sources := $(wildcard $(dir)/*.c)</p>
</blockquote>
<p>上例中定义了三个变量：dir、foo_sources和foo_print。<br>
要注意区分变量的嵌套引用和变量的递归赋值：</p>
<ul>
<li>嵌套引用是用一个变量表示另外一个变量，然后进行多层的引用</li>
<li>递归展开的变量表示当一个变量存在对其它变量的引用时，对此变量的替换方式</li>
<li>两种方式是完全可以混用的，比如可以在定义个一个递归展开式变量时使用套嵌引用的方式</li>
</ul>
<p>实际使用应该尽量避免过多使用变量嵌套引用，在必须要使用的时候应该做到嵌套层数越少越好，因为使用这种方法表达会比较复杂，可读性不好。</p>
<h2 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h2>
<p>make运行时的系统环境变量可以在make开始运行时被载入到makefile文件中，但是如果makefile中已定义了这个变量，或这个变量由make在命令行中带入，那么系统的环境变量的值将被覆盖(除非make指定了-e参数(在实现上类似于在命令中设置环境变量的值)，那么系统环境变量值将覆盖makefile中定义的变量)。比如当在不同的makefile中指定一部分统一的编译选项(或者说命令行参数)，那么只要设置一个环境变量就可以在读取的所有makefile中默认使用这个变量，在make中已经分别用CFLAGS和LDFLAGS定义了编译选项(-c、-o、-I、-S等)和链接选项(-L、-static等)，如：</p>
<pre class="line-numbers language-none"><code class="language-none">CFLAGS &#x3D; -g -I.&#x2F;include 
LDFLAGS &#x3D; -L.&#x2F;lib
ALL:
    $(CC) $(CFLAGS) $(LDFLAGS) main.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果makefile中定义了CFLAGS和LDFLAGS，那么则会使用makefile中的这些变量，如果没有定义则使用此时系统环境变量CFLAGS的值。当make嵌套调用时，上层makefile中定义的环境变量会传递到下层的makefile中，默认情况下只有通过这种方式或者在make命令中设置的变量会被传递，而定义在文件中的变量，如果要向下层makefile传递，则需要使用export关键字来声明。但是<strong>不推荐</strong>使用环境变量的方式(注意make做的只是引用并在局部覆盖环境变量，如果要修改或添加环境变量的话是Shell才能做的事)来完成普通变量的工作，特别是在make的嵌套调用中，任何一个环境变量的错误定义都对系统上的所有make产生影响，甚至是毁坏性的。因为环境变量具有全局的特征，所以尽量不要污染环境变量，大多数的合格系统管理员都应该明白环境变量对系统是多么的重要。</p>
<h3 id="override指示符"><a class="markdownIt-Anchor" href="#override指示符"></a> override指示符</h3>
<p>如果变量是在make命令参数中设置的，那么makefile对这个变量的赋值会被忽略。实际上从这里可以看出虽然环境变量和make命令中的变量都会从外部向makefile中引入变量，但两者的行为是有差异的：</p>
<ul>
<li>环境变量是把已经定义好的值引入到makefile中，如果makefile中存在同名变量则会在局部将其覆盖</li>
<li>make命令中设置的变量是将makefile中的同名变量用其值直接替换</li>
</ul>
<p>如果想在makefile中设置这类参数的值，或者说不希望makefile的变量定义被替代，那么可以在makefile中使用指示符override来对这个变量进行声明，其语法是：</p>
<blockquote>
<p>override &lt;variable&gt; = &lt;value&gt;<br>
override &lt;variable&gt; := &lt;value&gt;<br>
override &lt;variable&gt; += &lt;more text&gt;</p>
</blockquote>
<p>从另外一个角度来说，override是实现了在makefile中增加或者修改命令行参数的一种机制。通常可能会有这样的需求：通过命令行来指定一些附加的编译参数，对一些通用参数或者必需的编译参数在makefile中指定，而在命令中指定一些特殊的参数，对于这种需求就可以使用指示符override来实现(通用的直接写在命令中，特殊的在makefile中追加)，如：</p>
<pre class="line-numbers language-none"><code class="language-none">EXEF &#x3D; foo 
override CFLAGS +&#x3D; -Wall –g 
...
$(EXEF) : foo.c
    $(CC) $(CFLAGS) $(addsuffix .c,$@) –o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假设一般情况下默认以-O2优化级别进行编译，那么执行makefile时只需用：</p>
<blockquote>
<p>make CFLAGS=-O2</p>
</blockquote>
<p>此时既可以-O2优化级别进行编译，同时又加入了该makefile目标文件编译时的特殊要求-Wall -g。</p>
<h2 id="目标指定变量"><a class="markdownIt-Anchor" href="#目标指定变量"></a> 目标指定变量</h2>
<p>正常在makefile中定义一个变量，那么这个变量对此makefile的所有规则都是有效的，在整个文件都可以访问这些变量，它就像是一个“全局变量”（仅限于定义那个makefile中的所有规则，如果需要对其它的makefile有效，需要使用export声明)，类似于c语言中外部静态变量，使用static声明的全局变量）。不过在makefile中同样可以为某个目标设置局部变量，这种变量被称为目标指定变量，可以和“全局变量”同名，因为它的作用范围只在指定它的规则的上下文中有效，不会影响规则链以外的全局变量的值。其语法是：</p>
<blockquote>
<p>&lt;target …&gt; : &lt;variable-assignment&gt;<br>
&lt;target …&gt; : override &lt;variable-assignment&gt;</p>
</blockquote>
<p>&lt;variable-assignment&gt;可以是任何有效的赋值表达式。这个特性非常有用，比如设置了这样一个变量，这个变量可以作用到由这个目标所引发的所有的规则中去：</p>
<pre class="line-numbers language-none"><code class="language-none">prog : CFLAGS &#x3D; -g
bar : CFLAGS &#x3D; -Wall -g
prog : prog.o foo.o
    $(CC) $(CFLAGS) prog.o foo.o
prog.o : prog.c
    $(CC) $(CFLAGS) prog.c
foo.o : foo.c
    $(CC) $(CFLAGS) foo.c
bar : bar.o
    $(CC) $(CFLAGS) bar.o
bar.o : bar.c
    $(CC) $(CFLAGS) bar.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此例中不管全局的$(CFLAGS)值是什么，在prog目标文件以及其所<strong>引发的所有规则</strong>中(prog.o foo.o的规则)，$(CFLAGS)值都是-g，而bar目标文件所引发的规则中$(CFLAGS)值为-Wall -g。</p>
<h3 id="模式指定变量"><a class="markdownIt-Anchor" href="#模式指定变量"></a> 模式指定变量</h3>
<p>makefile中的规则可以使用模式字符以匹配任何非空字符串，模式字符%也可以用在目标指定变量中，此时称为模式指定变量。模式指定变量的好处在于可以给定一种模式，把变量定义在符合这种模式的所有目标上。模式指定变量的语法与目标指定变量一致，唯一区别是这里的目标是一个或者多个模式目标，比如可以如下方式给所有以[.o]结尾的目标文件定义目标变量：</p>
<blockquote>
<p>%.o : CFLAGS = -O</p>
</blockquote>
<p>对于同一个目标指定变量，如果使用追加方式赋值，它的局部变量值是：为所有规则定义的全局值+引发它所在规则被执行的目标所指定的值+它所符合的模式指定值+此目标所指定的值。</p>
<h2 id="多行变量"><a class="markdownIt-Anchor" href="#多行变量"></a> 多行变量</h2>
<p>还有一种设置变量值的方法是使用define关键字，使用define关键字设置变量值可以包含换行符，这样打包起来的变量可以称为宏包，命令包的实现其实就是一个这样的变量。define指示符后面跟的是变量的名字，然后重起一行定义变量的值，定义是以endef关键字结束，其工作方式和=操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以用define定义的多行变量中没有以[Tab]键开头，那么make就不会把其认为是命令，下面的这个示例展示了define的用法：</p>
<pre class="line-numbers language-none"><code class="language-none">define two-lines
    echo foo
    echo $(bar)
endef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于多行变量定义，同样可以使用override指示符，如：</p>
<pre class="line-numbers language-none"><code class="language-none">override define foo
bar
endef<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>应用程序开发</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>makefile</tag>
        <tag>编译原理实例</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】命令行界面(CLI)、终端(Terminal)、Shell、TTY的区别</title>
    <url>/posts/05eccd173a33</url>
    <content><![CDATA[<p>虽然这个话题已是老生常谈，搜索一下应该也能找到大把的相关文章。不过难得提到了这方面，就趁此机会把我的理解写下来，一来看看我是不是真正理解了，二来看看我能不能把它们之间的区别讲得更加简明易懂。</p>
<h1 id="太长不看"><a class="markdownIt-Anchor" href="#太长不看"></a> 太长不看</h1>
<ul>
<li>命令行界面(CLI)=使用文本命令进行交互的用户界面</li>
<li>终端(Terminal)=TTY=文本输入/输出环境</li>
<li>控制台(Console)=一种特殊的终端</li>
<li>Shell=命令行解释器，执行用户输入的命令并返回结果</li>
</ul>
<h1 id="什么是命令行界面"><a class="markdownIt-Anchor" href="#什么是命令行界面"></a> 什么是命令行界面？</h1>
<p>命令行界面，通俗来讲，就是你看过的那种满屏幕都是字符的界面。</p>
<blockquote>
<p>命令行界面(英语：Command-line Interface，缩写：CLI)是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予&gt; 以执行。 —— 摘自 <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2">Wikipedia</a></p>
</blockquote>
<p>相信大家对于影视作品中出现的那种，某黑客/程序员/安全专家坐在电脑前猛敲键盘、屏幕上放眼望去全是滚动的字符的场景不会感到陌生。这种靠一行行命令的输入输出进行交互的用户界面，就叫做命令行界面。</p>
<img src="https://s2.loli.net/2022/05/15/t2nxs3rTi74AmGQ.jpg">
<center>▲ 电影「黑客帝国」剧照</center>
<p>在图形用户界面(GUI)已经完全普及的今天，普通用户在日常使用电脑的过程中几乎不用手动输入任何命令，大部分操作都是点点鼠标就能完成，而熟练使用命令行操作似乎已经成为高逼格的代名词。但事实上，现在依然有着很多的软件开发者、系统管理员，或者是高级用户在使用命令行界面操作计算机。其中很大一个原因，就是效率：在熟记命令的前提下，使用命令行界面往往要比使用图形用户界面来得快。<br>
举个栗子，我要把当前目录下的(包括嵌套的子目录)所有*.tpl文件的后缀名修改为*.blade.php，如果不使用命令行，该怎么做？手动修改肯定不至于，但也得去网上找找相关软件，得要注意下载来源是否靠谱(像我这样有点洁癖的选手还得去找绿色版)，下载后还要手动指定文件路径、重命名模板…<br>
而使用命令行的话(这里以Ubuntu上的Bash为例)，只需运行这么一句：</p>
<blockquote>
<p>rename “s/\.tpl$/\.blade.php/” ./**/*.tpl</p>
</blockquote>
<p>命令行操作的高效率等优点，也是现在许多图形化的计算机系统依然没有放弃提供命令行操作方式的原因。就连Windows都有自带cmd.exe和PowerShell等命令行程序(事实上你在搜索「批量重命名」时，可以看到很多方案都是通过「Windows 命令提示符」实现的)。</p>
<h1 id="终端-人与机器交互的接口"><a class="markdownIt-Anchor" href="#终端-人与机器交互的接口"></a> 终端 —— 人与机器交互的接口</h1>
<p>终端(Terminal)，其词汇本身的意义为「终点站；末端；(电路)的端子，线接头」。而在计算机领域，终端则是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。也就是说，终端只是一种用于与计算机进行交互的输入输出设备，其本身并不提供运算处理功能。想要充分理解终端，我们得回溯历史，去看看终端的起源。</p>
<h2 id="历史上的终端"><a class="markdownIt-Anchor" href="#历史上的终端"></a> 历史上的终端</h2>
<p>在大型机(Mainframe)和小型机(Minicomputer)的时代里，计算机曾经非常昂贵且巨大，不像现在这样人手一台。这些笨重的计算机通常被安置在单独的房间内，而操作计算机的人们坐在另外的房间里，通过某些设备与计算机进行交互。这种设备就叫做终端(Terminal)，也叫终端机。</p>
<img src="https://s2.loli.net/2022/05/15/Olrc3HLhw5KSUAG.jpg">
￼
<center>▲ ASR-33 电传打字机(图片来源：Flickr – Marcin Wichary，CC-BY-2.0])</center>
<p>早期的终端一般是一种叫做电传打字机(Teletype)的设备。为啥呢？因为Unix的创始人Ken Thompson和Dennis Ritchie想让Unix成为一个多用户系统。多用户系统就意味着要给每个用户配置一个终端，每个用户都要有一个显示器、一个键盘。但当时所有的计算机设备都非常昂贵(包括显示器)，而且键盘和主机是集成在一起的，根本没有独立的键盘。后来他们机智地找到了一样东西，那就是<a href="https://en.wikipedia.org/wiki/Teletype_Model_33">ASR-33电传打字机</a>。虽然电传打字机原本的用途是在电报线路上收发电报，但是它既有可以发送信号的键盘，又能把接收到的信号打印在纸带上，完全可以作为人机交互设备使用。而且最重要的是，价格低廉。😛<br>
于是他们把很多台ASR-33连接到计算机上，让每个用户都可以在终端登录并操作主机。就这样他们创造了计算机历史上第一个真正的多用户操作系统Unix，而电传打字机就成为了第一个Unix终端。<br>
想知道用电传打字机做终端是一种怎样的体验？这里有一个 <a href="https://www.youtube.com/watch?v=MikoF6KZjm0">很炫酷的演示视频</a>。</p>
<h2 id="控制台-console-是什么"><a class="markdownIt-Anchor" href="#控制台-console-是什么"></a> 控制台 (Console) 是什么？</h2>
<p>上面我们说过，在历史上，终端是连接到计算机上的一种带输入输出功能的外设。但是有一个终端与众不同，它与计算机主机是一体的，是计算机的一个组成部分。这个特殊的终端就叫做控制台(Console)。<br>
顾名思义，控制台是用于管理主机的，只能给系统管理员使用，有着比普通终端更大的权限。一台计算机上一般只有一个控制台，但是可以连接很多个终端。<br>
 <br>
<code>&lt;img src=&quot;https://s2.loli.net/2022/05/15/OCJgVAIsdvcGiax.jpg&quot;/&gt;</code></p>
<center>▲ 左边的是 Console，右边的是 Terminal(图片来源：带你逛西雅图活电脑博物馆)</center>
<p>放在现在我们可能难以理解为什么会有控制台和终端的区分，不过就像上一节所说的，当时都是很多个用户通过终端去访问一台计算机，而专门管理那些大块头机器的系统管理员另有其人。普通用户用的就是普通的终端，而系统管理员用的终端比较牛逼，所以就被叫做控制台啦(笑)。<br>
不过随着个人计算机的普及，控制台(Console)与终端(Terminal)的概念已经逐渐模糊。在现代，我们的键盘与显示器既可以认为是控制台，也可以认为是普通的终端。当你在管理系统时，它们是控制台；当你在做一般的工作时(浏览网页、编辑文档等)，它们就是终端。我们自己既是一般用户，也是系统管理员。<br>
因此，现在Console与Terminal基本被看作是同义词。</p>
<h2 id="字符终端与图形终端"><a class="markdownIt-Anchor" href="#字符终端与图形终端"></a> 字符终端与图形终端</h2>
<p>终端也有不同的种类。<br>
字符终端(Character Terminal)也叫文本终端(Text Terminal)，是只能接收和显示文本信息的终端。早期的终端全部是字符终端。字符终端也分为哑终端(Dumb Terminal)和所谓的智能终端(Intelligent Terminal)，因为后者可以理解转义序列、定位光标和显示位置，比较聪明，而哑终端不行。</p>
<img src="https://s2.loli.net/2022/05/15/6ZIDo5ibGjRaY7S.jpg">
<center>▲ DEC VT100 终端(图片来源：Flickr – Jason Scott，CC-BY-2.0)</center>
<p>DEC公司在1978年制造的<a href="https://en.wikipedia.org/wiki/VT100">VT100</a>，由于其设计良好并且是第一批支持ANSI转义序列与光标控制的智能终端，获得了空前的成功。VT100不仅是史上最流行的字符终端，更是成为了字符终端事实上的标准。<br>
随着技术的进步，图形终端(Graphical Terminal)也开始出现在公众的视野中。图形终端不但可以接收和显示文本信息，也可以显示图形与图像。著名的图形终端有Tektronix 4010系列。不过现在专门的图形终端已经极为少见，他们基本上已经被全功能显示器所取代。</p>
<h2 id="终端模拟器-terminal-emulator"><a class="markdownIt-Anchor" href="#终端模拟器-terminal-emulator"></a> 终端模拟器 (Terminal Emulator)</h2>
<p>随着计算机的进化，我们已经见不到专门的终端硬件了，取而代之的则是键盘与显示器。<br>
但是没有了终端，我们要怎么与那些传统的、不兼容图形接口的命令行程序(比如说GNU工具集里的大部分命令)交互呢？这些程序并不能直接读取我们的键盘输入，也没办法把计算结果显示在我们的显示器上……(图形界面的原理我这里就不多说了，它们编程的时候图形接口还在娘胎里呢！)<br>
这时候我们就需要一个程序来模拟传统终端的行为，即终端模拟器(Terminal Emulator)。<br>
严格来讲，Terminal Emulator 的译名应该是「终端仿真器」。<br>
对于那些命令行(CLI)程序，终端模拟器会「假装」成一个传统终端设备；而对于现代的图形接口，终端模拟器会「假装」成一个GUI程序。一个终端模拟器的标准工作流程是这样的：</p>
<ul>
<li>捕获你的键盘输入</li>
<li>将输入发送给命令行程序(程序会认为这是从一个真正的终端设备输入的)</li>
<li>拿到命令行程序的输出结果(STDOUT以及STDERR)</li>
<li>调用图形接口(比如X11)，将输出结果渲染至显示器</li>
</ul>
<p>终端模拟器有很多，这里就举几个经典的例子：</p>
<ul>
<li>GNU/Linux：gnome-terminal、Konsole</li>
<li>macOS：Terminal.app、iTerm2</li>
<li>Windows：<a href="https://zh.wikipedia.org/wiki/Win32%E6%8E%A7%E5%88%B6%E5%8F%B0">Win32控制台</a>、ConEmu等</li>
</ul>
<img src="https://s2.loli.net/2022/05/15/7nU6uxcWBLhCS5A.png">
￼
<center>▲ 我正在使用的终端模拟器：Hyper 与 wsl-terminal</center>
<p>在专门的终端硬件已经基本上仅存于计算机博物馆的现代，人们通常图省事儿，直接称呼终端模拟器为「终端」。</p>
<h2 id="终端窗口-terminal-window-与虚拟控制台-virtual-console"><a class="markdownIt-Anchor" href="#终端窗口-terminal-window-与虚拟控制台-virtual-console"></a> 终端窗口 (Terminal Window) 与虚拟控制台 (Virtual Console)</h2>
<p>大部分终端模拟器都是在图形用户界面(GUI)中运行的，但是也有例外。<br>
比如在GNU/Linux操作系统中，按下Ctrl+Alt+F1,F2…F6等组合键可以切换出好几个黑不溜秋的全屏终端界面，而按下Ctrl+Alt+F7才是切换回图形界面。不过不要被它们唬着了，虽然它们并不运行在图形界面中，但其实它们也是终端模拟器的一种。</p>
<img src="https://s2.loli.net/2022/05/15/GeKpnkBMSi9s42j.png">
￼
<center>▲ 一个正在显示系统启动信息的虚拟控制台(图片来源：hacktolive.org，GPLv2)</center>
<p>这些全屏的终端界面与那些运行在GUI下的终端模拟器的唯一区别就是它们是由操作系统内核直接提供的。这些由内核直接提供的终端界面被叫做虚拟控制台(Virtual Console)，而上面提到的那些运行在图形界面上的终端模拟器则被叫做终端窗口(Terminal Window)。除此之外并没有什么差别。<br>
当然了，因为终端窗口是跑在图形界面上的，所有如果图形界面宕掉了那它们也就跟着完蛋了。这时候你至少还可以切换到Virtual Console去救火，因为它们由内核直接提供，只要系统本身不出问题一般都可用(笑)。</p>
<h1 id="那么-tty-又是什么"><a class="markdownIt-Anchor" href="#那么-tty-又是什么"></a> 那么 TTY 又是什么？</h1>
<p>简单来说，tty就是终端的统称。<br>
为什么呢？看了上面的终端一节的同学应该知道，最早的Unix终端是ASR-33电传打字机。而电传打字机(Teletype/Teletypewriter)的英文缩写就是tty，即tty这个名称的来源。<br>
由于Unix被设计为一个多用户操作系统，所以人们会在计算机上连接多个终端(在当时，这些终端全都是电传打字机)。Unix系统为了支持这些电传打字机，就设计了名为tty的子系统(没错，因为当时的终端全都是tty，所以这个系统也被命名为了tty，就是这么简单粗暴)，将具体的硬件设备抽象为操作系统内部位于/dev/tty*的设备文件。<br>
为什么要把电传打字机这个硬件设备抽象成「tty 设备」文件呢？有兴趣的同学可以去了解一下Unix操作系统中Everything is a file的概念。</p>
<img src="https://s2.loli.net/2022/05/15/ARD5Bys1LE7wIWd.png">
￼
<center>▲ 还记得上面我们说过的特殊的终端，也就是通过Ctrl+Alt+F1-6呼出的那些虚拟控制台(Virtual Console)吗？其对应的就是上图中的tty1到tty6。</center>
<p>随着计算机的发展，终端设备已经不再限制于电传打字机，但是tty这个名称还是就这么留了下来。久而久之，它们的概念就混淆在了一起。所以在现代，tty设备就是终端设备，终端设备就是tty设备，无需区分。<br>
由于早期计算机上的<a href="https://en.wikipedia.org/wiki/Serial_port">串行端口(Serial Port)</a>最大的用途就是连接终端设备，所以当时的Unix会把串口上的设备也同样抽象为tty设备(位于/dev/ttyS*）。因此，现在人们也经常将串口设备称呼为tty设备。<br>
在tty子系统中后来还衍生出了pty、ptmx、pts等概念，这里就不详细展开了。有兴趣的同学可以参考一下这篇文章：<a href="https://segmentfault.com/a/1190000009082089">Linux TTY/PTS 概述</a>。</p>
<h1 id="shell-提供用户界面的程序"><a class="markdownIt-Anchor" href="#shell-提供用户界面的程序"></a> Shell —— 提供用户界面的程序</h1>
<p>大家都知道，操作系统有一个叫做内核(Kernel)的东西，它管理着整台计算机的硬件，是现代操作系统中最基本的部分。但是，内核处于系统的底层，是不能让普通用户随意操作的，不然一个不小心系统就崩溃啦！<br>
但我们总还是要让用户操作系统的，怎么办呢？这就需要一个专门的程序，它接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。这个提供用户界面的程序被叫做Shell(壳层)。<br>
其实Shell只是提供了一个用户操作系统的入口，我们一般是通过Shell去调用其他各种各样的应用程序，最后来达成我们的目的。比如说我们想要知道一个文件的内容，我们会在Shell中输入命令</p>
<blockquote>
<p>cat foo.txt</p>
</blockquote>
<p>然后Shell会帮我们运行cat这个程序，cat再去调用内核提供的open等系统调用来获取文件的内容。虽然并不是Shell直接去与内核交互，但广义上可以认为是Shell提供了与内核交互的用户界面。<br>
至于为什么叫做Shell，看下图就知道啦。是不是很像一层壳呢？</p>
<p><code>&lt;img src=&quot;https://s2.loli.net/2022/05/15/PIihnf7j1mgRGAu.png&quot;/&gt;</code>￼</p>
<p>Shell通常可以分为两种：命令行Shell与图形Shell。顾名思义，前者提供一个命令行界面(CLI)，后者提供一个图形用户界面(GUI)。Windows下的explorer.exe就是一个典型的图形Shell(没错，它确实是，因为它接受来自你的指令，并且会帮你与内核交互完成你的指令)。<br>
常见或历史上知名的命令行Shell有：</p>
<ul>
<li>适用于Unix及类Unix系统：
<ul>
<li>sh(Bourne shell)，最经典的Unix shell</li>
<li>bash(Bourne-Again shell)，目前绝大多数Linux发行版的默认shell</li>
<li>zsh(Z shell)，我个人最喜欢的shell</li>
<li>fish(Friendly interactive shell)，专注于易用性与友好用户体验的shell</li>
</ul>
</li>
<li>Windows下的cmd.exe(命令提示符)与PowerShell<br>
还有其他各种五花八门的 Shell 程序，这里就不一一列举了，有兴趣的自己去搜一搜吧。😛</li>
</ul>
<h1 id="shell-与终端的分工"><a class="markdownIt-Anchor" href="#shell-与终端的分工"></a> Shell 与终端的分工</h1>
<p>现在我们知道，终端干的活儿是从用户这里接收输入(键盘、鼠标等输入设备)，扔给Shell，然后把Shell返回的结果展示给用户(比如通过显示器)。而Shell干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。<br>
不过Shell与终端的分工有一些容易混淆的地方，这里以例子进行说明：</p>
<ul>
<li>终端将用户的键盘输入转换为控制序列(除了字符以外的按键，比如左方向键 转换为 ^[[D )，Shell则解析并执行收到的控制序列(比如^[[D 转换为 将光标向左移动的操作)</li>
<li>不过也有例外，比如终端在接收到Ctrl+C组合键时，不会把这个按键转发给当前的程序，而是会发送一个SIGINT信号(默认情况下，这会导致进程终止)。其他类似的特殊组合键有Ctrl-Z与Ctrl-\等，可以通过stty -a命令查看当前终端的设置</li>
</ul>
<img src="https://s2.loli.net/2022/05/15/lZosqNutxdj8n3R.png">
<ul>
<li>Shell发出类似「把前景色改为红色(控制序列为 \033[31m)」「显示 foo」等指令
<ul>
<li>终端接收这些指令，并且照着Shell说的做，于是你就看到了终端上输出了一行红色的foo</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/15/cbHu8x3ZqlIhQ5X.png">
 
- 除非被重定向，否则Shell永远不会知道它所执行命令的输出结果。我们可以在终端窗口中上下翻页查看过去的输出内容，这完全是终端提供的feature，与Shell没有半毛钱关系
- 命令提示符(Prompt)是一个完全的Shell概念，与终端无关
- 行编辑、输入历史与自动补全等功能是由Shell提供的(比如fish这个Shell就有着很好用的历史命令与命令自动补全功能)。不过终端也能自己实现这些功能，比如说XShell这个终端模拟器就可以在本地写完一行命令，然后整条发送给远程服务器中的Shell(在连接状况不佳时很有用，不然打个字都要卡半天)
- 终端中的复制粘贴功能(Shift+Insert或者鼠标右键等)基本上都是由终端提供的。举个例子，Windows默认的终端对于复制粘贴的支持很屎，而换一个终端(例如ConEmu)后就可以很好地支持复制粘贴。不过Shell以及其他命令行程序也可以提供自己的复制粘贴机制(例如vim)
<h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1>
<p>计算机史这玩意，有趣是挺有趣的，就是查起资料来太费脑子。<br>
为了不误人子弟，在这篇博文写作的过程中我也查阅了各种各样的文档和史料，力求内容的准确性。不过能力所限，如果文章中仍有出现谬误，欢迎在下方评论区批评指正。</p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>计算机小知识</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile编写(1)：规则</title>
    <url>/posts/9372e87b32cb</url>
    <content><![CDATA[<p><strong>注：本系列内容大部分是基于GNU make的标准，其中cc命令默认调用Linux自带的c编译器程序</strong></p>
<ol>
<li>
<a href="/2022/05/09/makefile/" title="makefile介绍">makefile介绍</a>
</li>
<li>
<a href="/2022/05/14/makefile%E8%BF%9B%E9%98%B6/" title="makefile编写(1)：规则">makefile编写(1)：规则</a>
</li>
<li>
<a href="/2022/05/16/makefile%E7%BC%96%E5%86%99/" title="makefile编写(2)：变量">makefile编写(2)：变量</a>
</li>
<li>
<a href="/2022/05/18/makefile%E8%BF%9B%E9%98%B62/" title="makefile编写(3)：条件执行和函数">makefile编写(3)：条件执行和函数</a>
</li>
</ol>
<h1 id="makefile规则"><a class="markdownIt-Anchor" href="#makefile规则"></a> makefile规则</h1>
<p>makefile规则包含两个部分，</p>
<ul>
<li>目标依赖关系</li>
<li>生成目标的方法(命令)</li>
</ul>
<p>下面用一个简单的规则来说明这两种组成部分：</p>
<pre class="line-numbers language-none"><code class="language-none">foo.o: foo.c defs.h # foo模块
    cc -c -g foo.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此例中foo.o是目标，foo.c和defs.h是目标所依赖的源文件，其中foo.c包含了defs.h头文件，只有一个命令cc -c -g foo.c。这个规则的目标依赖关系和生成方法分别是：</p>
<ul>
<li>foo.o依赖于foo.c和defs.h，如果foo.c和defs.h的文件日期比foo.o文件日期要新或是foo.o不存在，那么目标依赖关系发生
<ul>
<li>这就是为什么要在依赖文件中加入.h文件，虽然不加一样可以编译(因为.h已经在预处理时被包含进.c中了)，但是此时.h中的修改将不会导致重新编译</li>
</ul>
</li>
<li>后面的cc命令指示如何利用foo.c和defs.h生成foo.o文件的生成方法</li>
</ul>
<p>在makefile中，规则编写的顺序是很重要的，因为makefile中只应该有一个<strong>最终目标</strong>(也就是.DEFAULT_GOAL的值)，其它的目标都是被这个目标所依赖派生出来的，所以一定要让make知道你的最终目标是什么。一般来说定义在makefile中的目标可能会有很多，但是<strong>第一条规则</strong>中的目标将被确立为最终的目标，如果第一条规则中的目标有很多个，那么<strong>第一个目标</strong>(默认目标)会成为最终的目标，make最终完成的也就是这个目标。当然这是说的默认情况，是指直接使用make命令而没有显式指定目标文件名的情况，如果在make后加上目标名字就可以指定任何makefile中的目标。</p>
<ul>
<li>除了以-打头，或是包含了=的目标，因为有这些字符的目标会被解析成命令行参数或变量</li>
<li>即使没有被明确写出来的目标也可以成为make的最终目标，也就是说只要make可以找到其隐含规则推导，那么这个隐含目标同样可以被指定成终极目标</li>
</ul>
<h2 id="makefile规则的基本语法"><a class="markdownIt-Anchor" href="#makefile规则的基本语法"></a> makefile规则的基本语法</h2>
<p>规则的基本语法：</p>
<blockquote>
<p>targets : prerequisites<br>
[Tab键]command<br>
…</p>
</blockquote>
<p>或是这样：</p>
<blockquote>
<p>targets : prerequisites ; command<br>
[Tab键]command<br>
…</p>
</blockquote>
<p>简单分析一下：</p>
<ul>
<li>targets是文件名，以空格分开，可以使用通配符；一般来说，目标基本上是一个文件，但也有可能是多个文件</li>
<li>command是命令
<ul>
<li>如果其不与target:prerequisites在一行，那么必须以[Tab键]开头</li>
<li>如果和prerequisites在一行，那么可以用分号做为分隔(如果没有prerequisites的话分号都省了)</li>
</ul>
</li>
<li>prerequisites也就是目标所依赖的文件(或依赖目标)</li>
</ul>
<h3 id="makefile规则中的通配符和模式字符"><a class="markdownIt-Anchor" href="#makefile规则中的通配符和模式字符"></a> makefile规则中的通配符和模式字符</h3>
<p>makefile支持shell通配符：*、?、[list]，(makefile支持shell命令，所以shell支持的通配符在makefile应该是同样适用的)。转义字符同样是有效的，比如文件名中有通配符*，那么可以用\*来表达*字符原本的意思，而不使用通配符*的语义。<br>
注意通配符并不是可以用在任何地方，基本上只能用在makefile规则中，其它上下文中不应直接使用通配符(尤其是在变量定义中直接使用通配符是不会展开的)</p>
<ul>
<li>可以用在规则的目标依赖关系中，make在读取makefile时自动对其进行展开</li>
<li>可以出现在规则的命令中(显然shell命令是支持通配符的)，在命令执行时展开</li>
</ul>
<p>除此外规则的目标依赖关系中还支持模式字符%，使用%定义的规则可以称为模式规则。带有模式字符%的目标被用来匹配一个目标文件名，可以匹配任何非空字符串。规则的依赖文件中同样可以使用%，<strong>依赖文件中%的取值情况由目标中的%来决定</strong>，如：</p>
<pre class="line-numbers language-none"><code class="language-none">%.o : %.c
    cc -o $@ $&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个模式规则的含义是编译make搜索到的所有.c文件。如果模式规则的依赖不包含%时代表的是所有与模式匹配的目标都依赖于指定的依赖文件。模式字符%的匹配和替换发生在规则中所有变量和函数引用展开之后，变量和函数的展开一般发生在make读取makefile时，而模式规则中的%的匹配和替换则发生在make执行规则时。</p>
<p>注意：模式字符%和通配符*的功能看似很像，实则完全不同</p>
<ul>
<li>%可以表达一种特定的生成规则，它会同时影响规则中的目标和依赖</li>
<li>而通配符只是文件名格式的匹配和扩展，实际上在规则层面上并没有任何影响</li>
</ul>
<h2 id="makefile规则中的目标依赖关系"><a class="markdownIt-Anchor" href="#makefile规则中的目标依赖关系"></a> makefile规则中的目标依赖关系</h2>
<h3 id="目标文件和依赖文件的路径搜索"><a class="markdownIt-Anchor" href="#目标文件和依赖文件的路径搜索"></a> 目标文件和依赖文件的路径搜索</h3>
<p>在一些工程中有大量的源文件，通常的做法是把这许多的源文件分类，并存放在不同的目录中。当make需要去找寻文件的目标依赖关系时，虽然可以在文件前加上路径，但最好是把路径告诉make，让make自动去找。makefile文件中的特殊变量VPATH(看到这种格式就该知道是make预定义的环境变量)就是完成这个功能的，如果当前环境没有定义这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了VPATH变量，那么make就会在当前目录找不到指定文件的情况下，到VPATH指定的目录中去寻找文件。<br>
注意：</p>
<ul>
<li>当前目录永远是搜索优先权最高的地方</li>
<li>make搜索目标和依赖文件的路径与其命令执行的路径不是一个概念，后者是由Shell决定的</li>
</ul>
<p>VPATH的定义中，使用空格或者冒号:将多个目录分开，搜索的顺序按照定义中的目录顺序进行，如：</p>
<blockquote>
<p>VPATH = src:…/headers<br>
VPATH = src:… headers</p>
</blockquote>
<p>此例的定义指定两个目录，src和…/headers，make会按照这个顺序进行搜索。</p>
<p>另一个设置文件搜索路径的方法是使用make的vpath关键字，和上面提到的VPATH很类似。vpath可以指定不同模式的文件在不同的目录搜索，如果搜索条件中没有包含模式，那么搜索的文件就是具体的文件名称。它的使用方法主要有三种，假设&lt;pattern&gt;指定了要搜索文件集的模式(也就是带模式字符的文件名)，而&lt;directories&gt;则指定了的文件集的搜索目录：</p>
<ul>
<li>为符合模式的文件指定搜索目录，多路径的用法和VPATH差不多，都是使用空格或者是冒号将文件名分隔开</li>
</ul>
<blockquote>
<p>vpath [&lt;pattern1&gt;:&lt;pattern2&gt;:…] &lt;directories&gt;</p>
</blockquote>
<ul>
<li>清除符合模式的文件的搜索目录，vpath不加目标目录单独使用的意思是清除模式已被设置的文件搜索路径。</li>
</ul>
<blockquote>
<p>vpath [&lt;pattern1&gt;:&lt;pattern2&gt;:…]</p>
</blockquote>
<ul>
<li>清除所有已被设置好了的文件搜索目录</li>
</ul>
<blockquote>
<p>vpath</p>
</blockquote>
<p>可以连续地使用vpath语句以指定不同搜索策略。如果连续的vpath语句中指定类相同的模式，那么make会按照vpath语句的先后顺序来执行搜索。如：</p>
<blockquote>
<p>vpath %.c foo:bar<br>
vpath %.c blish</p>
</blockquote>
<p>表示匹配到的.c结尾的文件，先在foo目录搜索，然后是bar目录，最后是blish目录。</p>
<p>使用VPATH还是vpath的搜索方法，主要是基于是否需要加入搜索条件。如果搜索路径下的文件较少，或者是搜索的文件不能使用模式符表示，可以考虑用VPATH，当然多数情况用vpath更好，因为可以过滤掉不符合条件的文件，搜索效率更高。</p>
<h3 id="伪目标文件"><a class="markdownIt-Anchor" href="#伪目标文件"></a> 伪目标文件</h3>
<p>伪目标文件并不是一个文件而只是一个标签。所谓的伪目标可以这样来理解，它并不会创建目标文件，定义它的目的只是<strong>单纯想去执行目标的命令</strong>。make无法生成伪目标文件的依赖关系，因此就没法通过默认目标的依赖关系链来执行，只有通过显式地指明这个“目标”才能让其生效。<br>
伪目标文件的取名不能和已有文件名重名。为了避免和文件重名的这种情况，可以使用一个特殊的标记.PHONY来显示地指明一个目标是伪目标，以向make说明不管是否有这个文件，这个目标就是伪目标。最典型的一个例子就是make clean，由于考虑到项目可能要重编译，因此基本都会在makefile设定这个规则以便清楚之前生成的文件，如：</p>
<pre class="line-numbers language-none"><code class="language-none">.PHONY : clean
clean:
    rm *.o temp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>只要有.PHONY的声明，不管是否有clean文件，要运行clean的规则只有通过make clean命令。<br>
伪目标一般没有依赖的文件，但是实际也可以为伪目标指定依赖文件。伪目标同样可以作为最终目标，只要将其放在第一个。一个典型应用就是，如果你的makefile需要一次生成若干个可执行文件，但是想简单地用一个make命令就完成所有最终目标文件的构建，并且都写在一个makefile中，那么可以使用伪目标all来实现，如：</p>
<pre class="line-numbers language-none"><code class="language-none">all : prog1 prog2 prog3
.PHONY : all
prog1 : prog1.o utils.o
    cc -o prog1 prog1.o utils.o
prog2 : prog2.o
    cc -o prog2 prog2.o
prog3 : prog3.o sort.o utils.o
    cc -o prog3 prog3.o sort.o utils.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件，将重建规则放到makefile中，约定使用all伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个make命令，就会同时生成三个可执行文件，并且由于伪目标all每次都是直接被执行，因此就相当于永远最新，所以每次它所依赖的三个可执行文件都会重新生成。all这个名字是GNU make里面约定俗称的命名，一般作为makefile的默认目标。在上例中可以使用以下命令生成三个目标：</p>
<blockquote>
<p>make<br>
make all</p>
</blockquote>
<p>也可以单独编译这三个中的任意一个源文件：</p>
<blockquote>
<p>make prog1<br>
make prog2<br>
make prog3</p>
</blockquote>
<p>伪目标文件不仅可以有依赖文件，也可以成为别的文件的依赖(所以除了不指定生成文件外，伪目标具有普通的目标相似的特性)。看下面的例子：</p>
<pre class="line-numbers language-none"><code class="language-none">.PHONY: cleanall cleanobj cleandiff
cleanall : cleanobj cleandiff
    rm program
cleanobj :
    rm *.o
cleandiff :
    rm *.diff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>cleanobj和cleandiff这两个伪目标有点像“子程序”的意思。可以通过输入make cleanall、make cleanobj和makecleandiff等命令来达到清除不同种类文件的目的。</p>
<p>伪目标文件的另一种使用的场合是在make的并行和递归执行的过程中，此情况下一般会存在一个变量，定义为所有需要make的子目录。对多个目录进行make的实现，可以在一个规则的命令行中使用 shell循环来完成，如：</p>
<pre class="line-numbers language-none"><code class="language-none">SUBDIRS&#x3D;foo bar baz
subdirs:
    for dir in $(SUBDIRS);do $(MAKE) -C $$dir;done  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>代码表达的意思是当前目录下存在三个子文件目录，每个子目录文件都有相对应的makefile文件，代码中实现的部分是用当前目录下的makefile控制其它子模块中的makefile的运行，但是这种实现方法存在以下几个问题：</p>
<ul>
<li>当子目录执行make出现错误时，make不会退出。就是说，在对某个目录执行make失败以后，会继续对其他的目录进行make。因此如果最终执行失败，很难根据错误提示定位出哪个目录的makefile有错误，这样给问题定位造成很大的困难。为了解决问题可以在命令部分加入错误检测，在命令执行的错误后主动退出。但是如果在执行make时使用了-k选项，此方式将失效。</li>
<li>另外一个问题就是使用这种shell循环方式时，没有用到make对目录的并行处理功能，由于规则的命令是一条完整的shell命令，不能被并行处理</li>
</ul>
<h3 id="多目标文件规则"><a class="markdownIt-Anchor" href="#多目标文件规则"></a> 多目标文件规则</h3>
<p>makefile中可能出现多个规则的目标同时依赖于一个文件，并且生成命令大体类似。于是这时就可将这些生成命令和目标依赖关系差不多的规则合并起来。不过多个目标生成规则的执行命令只能是同一个，虽然这可能会带来麻烦，不过好在这时可以使用自动化变量$@表示目前规则中所有的目标的集合，所以至少在语法上实行的通的，如：</p>
<pre class="line-numbers language-none"><code class="language-none">bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) &gt; $@
# 上述规则等价于：
bigoutput : text.g
    generate text.g -big &gt; bigoutput
littleoutput : text.g
    generate text.g -little &gt; littleoutput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，$(subst output,$@)表示执行一个makefile的函数subst，后面括号内的为传入参数。这个函数是截取字符串的意思，$@表示目标的集合，就像一个数组，$@依次取出目标，并执于命令。通过适当的利用函数使得这条多目标文件规则只用了一条命令就完成了多个单目标规则所完成的事。</p>
<h3 id="静态模式规则"><a class="markdownIt-Anchor" href="#静态模式规则"></a> 静态模式规则</h3>
<p>直接定义多目标规则的话只能所有目标共享一组依赖和命令，这样的规则不够灵活和有弹性，并且目标依赖关系和命令的编写也比较繁琐和受限，而采用静态模式可以更好地定义多目标的规则。静态规则主要就是借助%模式符使得多个目标可以根据名字来自动构造出对应的依赖文件，相当于是一个过滤器，它只需要一组命令中的依赖文件具有相似模式而不是完全相同。静态模式的基本语法格式为：</p>
<blockquote>
<p>&lt;targets…&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns …&gt;<br>
&lt;commands&gt;</p>
</blockquote>
<p>其中：</p>
<ul>
<li>targets定义了一系列的目标文件，是目标的一个集合</li>
<li>target-pattern和prereq-patterns</li>
</ul>
<p>首先再详细说明一下模式字符%的用法：<br>
首先从目标模式target-pattern的目标名字中抽取一部分字符串(称为“茎”)。使用“茎”替代依赖模式(prereq-patterns)中的相应部分来产生对应目标的依赖文件。举个例子来说明，如果target-parrtern定义成%.o，则集合中都是以.o结尾的，如果prereq-patterns定义成%.c和.h(从patterns一词就可以看出依赖模式可以有多种)，意思是对target-parrtern所形成的目标集进行二次定义，其推导方法是取target-pattern模式中的%(也就是去掉了[.o]这个扩展名)，并为其加上[.c,.h]的扩展名，形成的新集合。“目标模式”或是“依赖模式”中都应有%这个字符(当然依赖模式里没有也是合法的)，如果文件名中有%那么可以使用反斜杠\进行转义，来表示真实的%字符。看一个例子：</p>
<pre class="line-numbers language-none"><code class="language-none">objects &#x3D; foo.o bar.o
all: $(objects)
$(objects): %.o: %.c %.h
    $(CC) -c $(CFLAGS) $&lt; -o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例中指明<strong>目标从($object)中获取</strong>，%.o表示所有以.o结尾的目标也就是foo.o和bar.o，推导出的依赖文件就是foo.c和bar.c。命令中的$&lt;和$@则是自动化变量，$&lt;表示所有的依赖目标集。于是，上面的规则展开后等价于下面的规则：</p>
<pre class="line-numbers language-none"><code class="language-none">foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果模式目标很多，比如有几百个的话，那么只要用这种很简单的静态模式规则就可以写完很多规则，可以极大提升效率。静态模式规则的用法很灵活，可以实现很多强大的功能。</p>
<p>注意：在使用静态模式规则时，指定的目标必须和目标模式相匹配，否则在执行make时将会报错。在指定目标集方面静态规则与正常的多目标文件规则是一致的，这很好理解因为如果有目标没法跟模式匹配的话，就说明它很可能不适用于该规则，在规则构建时这个目标无法生成。换句话说模式字符%在静态规则里面仅使用了其推导依赖的能力，并不能用到它匹配筛选的能力。如果存在一个文件列表，其中只有一部分符合某种模式，这种情况下可以使用filter函数对这个文件列表进行分类，在分类之后对确定的某一类使用模式规则，例如：</p>
<pre class="line-numbers language-none"><code class="language-none">files &#x3D; foo.elc bar.o lose.o
$(filter %.o,$(files)): %.o: %.c
    $(CC) -c $(CFLAGS) $&lt; -o $@
$(filter %.elc,$(files)): %.elc: %.el
    emacs -f batch-byte-compile $&lt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="自动生成目标依赖关系"><a class="markdownIt-Anchor" href="#自动生成目标依赖关系"></a> 自动生成目标依赖关系</h3>
<p>如果是一个大型工程则必需清楚哪些源文件包含了哪些头文件，并且在加入或删除头文件时，都需要小心地修改makefile，这是一个很不具有可维护性的工作。为了避免这种繁重而又容易出错的事，可以使用c/c<ins>编译的一个功能，大多数的c/c</ins>编译器都支持一个-M的选项，即自动搜索源文件中包含的头文件并生成一个目标依赖关系，需要注意的是，如果你使用GCC编译器需要用-MM参数，不然-M参数会将标准库的头文件也包含进来，例如：(这只是最简单的例子，甚至源文件都没有包含自己的头文件)</p>
<img src="https://s2.loli.net/2022/05/15/od8Xvuj2BptCkUc.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/15/mHxWawEj9IDRu18.png" width="50%" height="50%">
<p>这是由编译器生成的目标依赖关系，这样一来就不必再手动编写若干文件的目标依赖关系，直接将其引入makefile中就可以了。不过GNU组织推荐的方法是把编译器为源文件自动生成的目标依赖关系专门放到一个文件中，也就是为每个[.c]文件生成一个[.d]的makefile文件，[.d]文件中就存放对应[.c]文件的目标依赖关系。然后在主makefile文件中写出[.c]文件和[.d]文件的目标依赖关系，让make自动更新[.d]文件并包含在主Makefile中，这样就可以达到自动化生成每个文件目标依赖关系的效果了，例：</p>
<pre class="line-numbers language-none"><code class="language-none">%.d: %.c
    @set -e; rm -f $@; \
    $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.; \
    sed &#39;s,$∗\.o[ :]*,\1.o $@ : ,g&#39; &lt; $@.&gt; $@; \
    rm -f $@.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例这个规则的意思是：</p>
<ul>
<li>指定目标依赖关系：所有的[.d]文件依赖于[.c]文件</li>
<li>set -e表示执行这段脚本文件时有异常则退出，rm -f $@的意思是删除所有的目标文件
<ul>
<li>set -e前加上@表示shell在解释命令时不打印命名信息(通常，make会把其要执行的命令在执行前输出到屏幕上)</li>
</ul>
</li>
<li>使用编译程序的-M选项生成此规则中依赖文件(也就是[.c]文件)的目标依赖关系，重定向输出到临时文件$@.中
<ul>
<li>.表示在目标文件格式后面加上随机编号，比如filename.d.12345</li>
</ul>
</li>
<li>sed命令表示根据命令提供的规则来处理文本文件，接下来借助sed命令将$@.中的内容替换后重定向到目标文件$@中</li>
<li>最后删除所有临时文件</li>
</ul>
<p>总而言之，这个模式要做的事就是在makefile的目标依赖关系中加入[.d]文件的依赖，即把目标依赖关系：</p>
<blockquote>
<p>main.o : main.c defs.h</p>
</blockquote>
<p>转成：</p>
<blockquote>
<p>main.o main.d : main.c defs.h</p>
</blockquote>
<p>此时[.d]文件会自动更新，然后自动生成，还可以在这个[.d]文件中加入目标依赖关系的同时，将包括生成的命令一并加入，让每个[.d]文件都包含一个完赖的规则。一旦完成这个工作，接下来就把这些自动生成的规则放进主makefile中，需要注意的是文件的包含次序，因为最先载入的[.d]文件中最终目标会成为默认目标，所以包含语句必须要放到主makefile目标的后面。下面是一个逻辑相对完整的makefile：</p>
<pre class="line-numbers language-none"><code class="language-none">SRCS:&#x3D;$(wildcard *.c)
OBJS&#x3D;$(SRC:.c&#x3D;.o)
all: dep main
.PHONY:all
dep:%d:%c
    @set -e;rm -f $@; \
    cc -MM $(CPPFLAGS) $&lt; &gt; $@.; \ 
    sed &#39;s&#x2F;$∗\.o[ :]*&#x2F; \1.o $@ : &#x2F;g&#39; &lt; $@. &gt; $@; \
    rm -f $@.
main:$(OBJS)
    cc -o main $^
include $(SRCS:.c&#x3D;.d)
clean:
    rm -f *.o *.d main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>包含.d文件的makefile是典型的有可能存在重建过程的makefile。make在读入所有makefile文件之后，首先将所读取的每个makefile作为一个目标，寻找更新它们的规则。如果存在一个更新某一个makefile文件明确规则或者隐含规则，就去更新对应的makefile文件，完成对所有的makefile文件的更新之后，make清除本次执行的状态重新读取一遍所有的makefile文件，然后再开始执行生成规则(因为所有makefile都被更新过一遍，一般到这里是不需要再重建一次的，除非是极个别情况)。在本例中：</p>
<ul>
<li>.d文件被包含进主makefile，并且存在以它们作为目标的规则的情况</li>
<li>如果.d文件还不存在，或者时间戳早于其依赖的.c和.h文件，说明.c在还没编译或在上次编译后更新过，所以此时需要创建或更新.d文件</li>
<li>.d文件更新后，重建主makefile(重新读取所有makefile文件)</li>
<li>此时.d已经是最新，所以直接将其内容(.c文件的目标依赖关系)展开在include处</li>
</ul>
<h2 id="makefile规则中的命令"><a class="markdownIt-Anchor" href="#makefile规则中的命令"></a> Makefile规则中的命令</h2>
<h3 id="命令的执行"><a class="markdownIt-Anchor" href="#命令的执行"></a> 命令的执行</h3>
<p>makefile规则中的命令本身(当然指的是经过make处理后的形式)和Shell的命令是一致的。当目标依赖关系成立时(依赖时间戳新)，make会顺序执行命令，每条命令的开头必须以[Tab]键开头，除非命令紧跟在目标依赖关系后的分号之后。在命令行之间的空字符会被忽略，但是如果该字符是以Tab键开头的，那么make会认为其是一个空命令。需要注意的是在makefile中只能在规则中执行Shell脚本，其他地方的命令都是无效的。<br>
在不同系统的Shell本身也有所区别</p>
<ul>
<li>在类UNIX系统中make一般是使用环境变量SHELL中所定义的系统Shell来执行命令(除非显式地特别指定一个其它Shell)，Shell程序一般存放在/bin目录下
<ul>
<li>注意在GNU make中默认是/bin/sh，不像其他的绝大多数变量只可以直接从同名的系统环境变量那里获得，make的环境变量SHELL没有使用环境变量的定义</li>
<li>因为系统环境变量SHELL指定的那个程序被用来作为用户和系统交互的接口程序，对于不存在直接交互过程的make显然不合适，因此在make中环境变量SHELL被定义为/bin/sh</li>
</ul>
</li>
<li>Windows没有SHELL环境变量(Windows的cmd.exe支持的是DOS体系的命令)，当然这个可以自定义，假设有这个变量的情况下
<ul>
<li>make首先在SHELL指定路径中找寻命令解释器，如果找不到会在当前盘符中的当前目录中寻找，如果再找不到其会在PATH环境变量中所定义的所有路径中寻找</li>
<li>如果还没有找到，其会给定义的命令解释器名称加上诸如.exe、.com、.bat、.sh等后缀再找</li>
</ul>
</li>
</ul>
<p>另外，如果要让上一条命令的结果应用在下一条命令时，应该使用分号分隔这两条命令。比如第一条命令是cd命令，并且希望第二条命令在切换后的目录上运行：</p>
<pre class="line-numbers language-none"><code class="language-none">exec:
    cd &#x2F;home&#x2F;hchen
    pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此时在命令行窗口中执行make exec时，pwd会打印出当前makefile所在目录，也就是cd命令的结果并没有影响到下一条命令。</p>
<pre class="line-numbers language-none"><code class="language-none">exec:
    cd &#x2F;home&#x2F;hchen; pwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在第二个例子中，cd命令就可以起到作用，pwd会打印出/home/hchen。因为在makefile中执行shell命令，<strong>每行都会创建一个子shell进程来执行，执行完后就默认exit后回到父进程</strong>，所以不同行的命令之间无法直接通信，当然也不存在依赖。这也是为什么很多makefile中有很多行的末尾都是“; \”，以此来保证代码是一行而不是多行，这样一个规则的命令可以在一个进程中执行。</p>
<h3 id="命令回显"><a class="markdownIt-Anchor" href="#命令回显"></a> 命令回显</h3>
<p>通常make工具会把其要执行的命令在执行前回显到命令行窗口中。当加一个@字符在命令前时，那么这个命令将不被make显示出来，最具代表性的例子是用这个功能来向屏幕显示一些信息。如：</p>
<blockquote>
<p>@echo 正在编译XXX模块…</p>
</blockquote>
<p>当make执行时，会输出“正在编译XXX模块…”的字串，但不会回显命令信息，如果没有@那么make将输出：</p>
<blockquote>
<p>echo 正在编译XXX模块…<br>
正在编译XXX模块…</p>
</blockquote>
<p>如果make执行时，带入make参数-n或--just-print，那么其只是回显命令但不会执行命令，这个功能有利于调试makefile，看看命令是执行起来是什么样子或是什么顺序的。而make参数-s或--slient则是全面禁止命令的回显。</p>
<h3 id="错误处理"><a class="markdownIt-Anchor" href="#错误处理"></a> 错误处理</h3>
<p>每当命令运行完后，make会检测每个命令的<strong>返回码</strong>，如果命令返回成功信号(类似于exit 0)，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算成功完成了。如果一个规则中的某个命令非正常地退出了(命令返回码非零)，那么make就会终止执行当前规则，而这将很有可能终止所有规则的执行。</p>
<ul>
<li>除非使用make的-k或是--keep-going参数，这个参数的意思是如果某规则中的命令出错了，那么就终止该规则的执行但继续执行其它规则</li>
<li>另外makefile中存在规则并发执行的方法，此时终止一个另一个还可以执行</li>
</ul>
<p>但是有些时候，命令的非正常返回并不表示就是程序是错误的。例如mkdir命令一定需要建立一个目录，如果目录不存在那么mkdir成功执行，如果目录存在，那么就出错了。但是之所以使用mkdir的目的就是保证这样一个目录而已，此时并不希望因mkdir出错而终止规则的运行。为了达到这一目的可以在命令前加一个减号-(在Tab键之后)，标记为忽略命令错误，如：</p>
<pre class="line-numbers language-none"><code class="language-none">clean:
    -rm -f *.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在命令前加-是在命令级别上忽略错误的方法，此外还存在不同级别的方法也可以忽略错误，可以根据不同情况具体设置：</p>
<ul>
<li>一个全局的办法是给make加上-i或--ignore-errors参数，那么makefile中所有命令都会忽略错误</li>
<li>如果将目标声明为.IGNORE，那么这个目标所在的规则中所有命令将会忽略错误</li>
</ul>
<h3 id="命令中嵌套执行makefile"><a class="markdownIt-Anchor" href="#命令中嵌套执行makefile"></a> 命令中嵌套执行makefile</h3>
<p>很多时候不同模块或是不同功能的源文件划分在不同的目录中，此时可以在每个目录中都编写一个该目录的makefile，这有利于让makefile更加地简洁，而不至于把所有东西全部堆砌在一个makefile中，这个方法对于模块编译和分段编译有着非常大的好处。例如，有一个子目录subdir，这个目录下有一个makefile文件来指明这个目录下文件的编译规则，那么主makefile可以这样编写：</p>
<pre class="line-numbers language-none"><code class="language-none">subsystem:
    cd subdir &amp;&amp; $(MAKE)  # &amp;&amp;第一条命令返回真后，第二条命令才能够被执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其等价于：</p>
<pre class="line-numbers language-none"><code class="language-none">subsystem:
    $(MAKE) -C subdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>定义$(MAKE)变量的意思是将make需要的一些参数定义好，这样比较利于维护。环境变量CURDIR代表make的当前工作目录，除非在makefile中对此变量进行显式的赋值操作将其改为其他目录。当使用make的选项-C时，make执行命令时就会切换到指定的目录中，CURDIR变量被重新赋值为指定目录。这两个例子的意思都是先进入subdir目录，然后执行make命令，这就是嵌套执行make，一般将这个正在执行的makefile叫做“总控makefile”。总控makefile的<strong>环境变量</strong>可以传递到下级makefile中，但是不会覆盖下层的makefile中所定义的变量，除非指定了-e参数。如果需要传递某些变量到下级makefile中，那么可以这样声明：</p>
<blockquote>
<p>export&lt;variable …&gt;</p>
</blockquote>
<p>如果不想让某些变量传递到下级makefile中，可以这样声明：</p>
<blockquote>
<p>unexport&lt;variable …&gt;</p>
</blockquote>
<p>如果需要传递所有的变量，那么只要一个export关键字就行了，后面什么都不用跟，表示传递所有的变量。需要注意的是有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管是否export，其值总是传递到下层makefile中。特别是MAKEFLAGS变量，其中包含了make的参数信息，如果执行总控makefile时有make参数或是在上层makefile中定义了这个变量，那么MAKEFLAGS变量会将这些参数传递到下层makefile中。如果不想往下层传递MAKEFLAGS参数，那么可以这样：</p>
<pre class="line-numbers language-none"><code class="language-none">subsystem:
    cd subdir &amp;&amp; $(MAKE) MAKEFLAGS&#x3D;#这种情况下如果还想重写MAKEFLAGS值需要用override<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>另外makefile中有几个特别的参数默认就不会往下传递，它们是-C、-f、-h、-o、-W。注意，如果定义了环境变量MAKEFLAGS，那么要确信其中的选项是所有makefile都会用到的，尤其是有-t、-n、-q等参数，否则很容易出现让人迷惑的情况。</p>
<p>-w或--print-directory参数会在make的过程中输出一些关于目前工作目录的信息。比如，如果下级目录与主控目录不是一个，下级makefile目录是/home/hetumessi，使用make -w执行主控makefile，那么当进入该目录时会在命令行窗口看到：</p>
<blockquote>
<p>make: Entering directory /home/hetuemssi</p>
</blockquote>
<p>而在执行完成下层makefile后离开目录时会看到：</p>
<blockquote>
<p>make: Leaving directory /home/hetumessi</p>
</blockquote>
<p>当使用-C参数指定make下层makefile时，-w会被自动打开，除非参数中有-s、--slient或是--no-print-directory，那么此时-w是失效的。</p>
<h3 id="定义命令包"><a class="markdownIt-Anchor" href="#定义命令包"></a> 定义命令包</h3>
<p>如果makefile中总是出现一些相同的命令序列(不过一般都是定义在一行的)，那么可以为这些命令序列定义一个变量(多行变量)。定义这种命令序列的语法以define开始，以endef结束(定义多行变量也是以这种方式)，如：</p>
<pre class="line-numbers language-none"><code class="language-none">define run-yacc
    yacc $(firstword $^)
    mv y.tab.c $@
endef

foo.c : foo.y
    $(run-yacc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里run-yacc是这个命令包的名字，不能和makefile中其他变量重名。在define和endef中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成y.tab.c的文件，所以第二行的命令就修改一个这个文件的名字。使用这个命令包就像使用变量一样。make在执行命令包时，命令包中的每个命令会被依次顺序执行。</p>
]]></content>
      <categories>
        <category>应用程序开发</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>makefile</tag>
        <tag>编译原理实例</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】好好地做一万个小时比看起来更难完成</title>
    <url>/posts/010e578ad717</url>
    <content><![CDATA[<p>Malcolm Gladwell在《离群索居》（Outliers）一书中说，要真正掌握某件事情，需要10000小时的练习。其实，10000只是一个粗略的数字，而且这句话的含义也被过度简化了。我已经断断续续进行了40多年的编程。可能已经写了10000个小时的代码，但我甚至还未能成为一个优秀的程序员，更别提成为大师级的程序员了。<br>
　　我认为有以下几个原因。首先，在这10000小时中，我主要学习了4种不同的编程语言，以及其他一些辅助语言。我从一种语言换到另一种语言时，发现它们有的概念可以互通，有的完全不同。而有趣的是，在这种语言中没有意义的概念可能用来构建它。<br>
　　例如，JavaScript没有本地链接列表实现，但如果在V8 GitHub库的src目录下搜索“链表”，会发现有76个commit提到了它。即使它们在语言本身中没有用C的链接列表，但会在引擎下使用C的链接列表。<br>
　　每种语言都有自己的语法和特殊的实现方式，这些是必须要学习的，而不仅仅只是学习其概念。一种语言的最佳实践方式对于另一种语言来说可能不是最好的。在编译语言上我从来没有花过很多时间，几乎总是使用解释型语言，如BASIC、PHP、JavaScript、Python。我学习过C#和Java，用Rust做过Hello World，但在Linux中从源码编译对我来说十分困难，所以我通常只是下载源码，按照教程中的指示操作，然后祈祷代码能够运行。<br>
　　其他的技能：<br>
　　除了学习这些语言，我还学习了服务器技术和系统架构的基本概念，不是从编程的角度，而是从网络管理员或者说系统管理员的角度。而且无论是建立一个大型网站，在Flash中创建矢量图并将其渲染成位图，还是学习通过AWS解决方案架构师助理认证，我都已经做了很多次。但是很多东西我已经忘记了。我已经学会了这些语言的框架和库，如JavaScript的React和JQuery以及PHP的Laravel…然后也忘记了许多，因为我为完成一个项目学习了它们，然后就没有再使用它们。<br>
　　<strong>遗忘是常态</strong><br>
　　即使写了10000小时的代码，也不意味着你能够轻易地在不同语言之间转换。当你真的进行转换的时候，你会发现10000小时没有那样神奇的魔力，因为另一个不可避免的原因：记忆衰退。正如我所说的，如果我停止使用一种语言，甚至只是停止使用它的一个功能一段时间，我就会像忘记“高中西班牙语”一样忘记它。我在高中时读完了西班牙语3级，在大学时考过了西班牙语4级，并获得了A。而现在，我可能只记得不到10%的内容。<br>
　　例如，我几乎完全忘记了怎样使用常规动词连接过去式，更不用说不规则动词了。但是因为我以前练习的足够多，我知道自己的不足之处，所以我可能比刚开始学习的人更快地恢复以前的知识，但可能需要几个月的强化练习才能全部恢复。<br>
　　十年前，我精通PHP，在一个定制的MVC框架中工作（由其他人创建），使用Doxygen来映射类的继承层次，并使用JQuery来构建前端的交互性。但我在7年前没用过PHP了，转而使用Node。现在，我需要花5分钟并且改正了一些语法错误，才在刚才提到的PHP副本中正确地写出一个Hello World。<br>
￼<br>
<img src="https://s2.loli.net/2022/05/14/vVDL1TYQ7uNXBej.png"></p>
<p>去年12月时，我为freeCodeCamp的前端库认证建立了五个React项目，但在那之后，我就没有再编码React项目了。过去了两个月，当我开始准备面试的时候，我觉得我就像是React新手。如果我看到自己写的代码，能够很快理解。但是因为很多东西都只是我准备的辅助工具，很多我都忘光了，所以我需要回到文档中去开始一个新的React项目再开始工作。和新手相比，我只是走得更快。<br>
　　这就是新手和已经入门了的区别。一万个小时可以让你成为一个小提琴大师。但是如果你每隔500小时就换一次乐器，并想要成为整个交响乐团的主角，那你不一定能够更胜一筹。所以为了强化和拓展你的技能，<strong>练习不仅要广泛，而且要持续</strong>。<br>
　　逻辑上的矛盾：<br>
　　10000小时是什么样的概念？是5年每周工作40小时，两年休息1周（假期、病假和休假都在这2周内）。你会发现有的工作招聘时要求在一个3年的框架内有5年的经验。5年似乎是成为专家所需的标准时间。因为对框架的无知和这种简化的标准，就会产生逻辑上的矛盾，一言以蔽之。<br>
　　<strong>工作中的一万个小时≠一万个小时的实践</strong><br>
　　一个专业的开发人员，有多少的工作时间是花在电子邮件和会议上的？又有多少时间在真正编码和思考编码问题？当我在微软写文档的时候，我的经理说，不管怎么算，你一天中大概只有一半的时间花在实际的生产工作上。其余的时间会花在一些琐事上，比如回复电子邮件、开会、进度/状态报告、在IM上回答随机问题或者和别人闲聊…<br>
　　所以我只有20%的时间是在写代码，因为其他80%的时间是在写文档和教程，这意味着我平均每天只写了一个小时的代码。在使用浏览器中的开发工具进行调试方面，我曾经是个天才，因为我在这方面经验丰富，还经常为新版本进行更新。但是，虽然当时所有的开发控制台的快捷键，我都烂熟于心，但在我离开微软的7年后，我基本上已经把它们忘得一干二净了。<br>
　　事实上，自从我进入开发人员关系部后，我每天花了10-20%的时间写代码，其余的时间写教程，为会议讲座和网络研讨会制作文件，制定建立和培养开发人员社区的战略，制定展示新功能的最佳方法，以及处理各种人——产品经理、内部工程师、外部开发人员、产品营销经理、需求生成和社交媒体经理、律师、公关和公司政策执行者的问题。<br>
　　一万小时不都用来学习新事物<br>
　　最后要记住的是，你<strong>不会花整整一万个小时学习新东西</strong>。如果你在学习小提琴，你可能会花上几百个小时来学习一些初级的作品。在你学习新东西之前，你已经掌握了一些初级的东西，并且在反复练习直至完美的过程中，<br>
　　学到很多，并且将你学到的这些用于学习新事物。所以这一万个小时中的大部分时间都是强化的。<br>
　　在编程中，这就像多次编写相同的To Do单页应用程序。前几次你可以参考教程，但最终你必须能够在没有任何参考的情况下写出它。这就像一边看着乐谱一边慢慢演奏《欢乐颂》，然后记住如何演奏，然后准备在演奏会上演奏。<br>
　　但是，当你需要在截止日期前交付一个项目时，你有多长时间来进行强化练习？在许多公司，不会给你提供扩展技能和强化编码的时间，需要你利用额外的时间来完成。一些公司会给你10%的时间或20%的时间来做独立的项目，但很少有公司希望你把这些时间花在单纯的练习上。<br>
　　新的框架、新的最佳实践方法、新的语言、新的模式产生的速度不断加快，在这种情况下，仅仅是在新的方面取得合格的成绩，都会像和职业选手一样演奏《欢乐颂》的困难。<br>
　　总结：<br>
　　你需要平衡强化和探索的时间，特别是当你每天编码的时间少于50%的时候。你必须不断地通过练习来进行强化，建立心理肌肉记忆，直到你能在睡梦中解决它们。小提琴几百年来都没有实质性的变化，但编程却在不断变化。成为一个特定语言的大师级程序员意味着要坚持更长的时间。<strong>你不得不在非工作时间进行强化练习</strong>，完成任务，努力成为一个优秀的程序员，或者跳槽到另一个能够给你充足时间练习的公司。<br>
　　哪怕你5年或者10年后都没有成为大师级的程序员，也没有关系，因为好好地做一万个小时比看起来更难完成。</p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业论文-开题报告篇</title>
    <url>/posts/3aee3b98bbe7</url>
    <content><![CDATA[<p>毕业论文要开始准备了，虽然知道早晚躲不过，但还是一点动手开干的欲望也没有。今天早上8点到了图书馆就打开知网看论文，然后一上午四个半小时坐在桌子前看了三章，看完了连题目都忘了叫啥了。。。。明天早起开组会老师还说要拿出成熟方案，不过以目前的形势看估计把我砍成几个人用也拿不出所谓成熟报告了，估计又得拿东拼西凑的东西去糊弄她，哎生死由命了。。。。。</p>
<p>一上午各种折腾，看看这看看那，反正就是不能静下心深入进去看文献本身。算算时间离开题报告汇报也不远了，也就是说几周内要写好大几千字，现在连点思路都没有，还不能水，真愁死个人。听说上届有外审没过的可能延毕了。。。。。。。。。。。。。。。</p>
<hr>
<p>下面是开题报告相关的一些资源和相关用法，记录在此以作备忘：</p>
<hr>
<p>开题报告格式，每个学校都不一样，我网上搜了几个latex模板，如果有学校要用latex或者有需要自定义模板的可以参考一下(反正学校肯定也有教程就是了)，当然基本上有名的学校肯定都会有自己公开的模板发不出来，随便搜下就可以了。可以提前写点东西什么的熟悉一下也行，LaTex本身也是标记语言，上手应该挺快的 (不过感觉完全没有md好用，尤其是编译套件我感觉lj的一批，可能也是没太深入接触的原因)</p>
<p><a href="https://github.com/tuna/thuthesis">清华大学学位论文Latex模板</a><br>
<a href="https://github.com/mohuangrui/ucasproposal">国科大官方开题报告LaTex模板</a><br>
<a href="https://github.com/TheNetAdmin/zjuthesis">浙江大学学位论文Latex模板</a><br>
<a href="https://github.com/BITNP/BIThesis">北理工非官方LaTeX模板集</a></p>
<p>清华大学图书馆的LaTex讲座：<br>
<a href="https://stu.cs.tsinghua.edu.cn/~harry/latex-talk.pdf">清华大学图书馆专题培训讲座《如何使用LaTeX排版论文》</a></p>
<p>编辑器还有编译环境我用的是vsc的扩展插件(<s>这么看可能我的糟糕体验是微软的锅</s>)，也可以使用在线编辑环境<a href="https://cn.overleaf.com/">overleaf</a>，或者下载<a href="https://tug.org/texlive/">tex live</a>搭建本地编辑环境。(<a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/">清华镜像</a>)</p>
<p>LaTex素材和模板网站推荐：<br>
中文网站：<a href="https://www.latexstudio.net/">LaTex工作室</a><br>
英文网站：<a href="http://www.latextemplates.com/">LaTeX Templates</a><br>
推荐那个英文网站，不论是模板质量、用户友好度都远超国内那个，而且<strong>免费且不用注册</strong></p>
<p>LaTex的使用教程：<br>
<a href="https://www.latex-project.org/help/documentation/">LaTex官方文档</a>，没有中文的，看着太费劲了而且这玩意儿除非想自己开发否则没必要花太多精力死扣的。<br>
具体的教程也可以参考这个网站<a href="https://www.latexstudio.net/hulatex/tutorial/ChineseBase.htm">LaTeX编辑部</a></p>
<p>使用LaTex的主要难点：</p>
<ul>
<li>公式：推荐一个<a href="https://www.latexlive.com/">在线编辑网站</a>，无需注册在线就能用，主要是有在线预览功能可以写好公式后复制回自己的文章中</li>
<li>表格：LaTex最反人类的一部分没有之一，原以为md的表格语法已经够恶心人的了，这个绝对要在md的基础乘∞次幂，<s>甚至我感觉不如用word的表格做完截图插进去</s>。不过一般模板里面这方面都会定制好，所以倒也不一定有那么麻烦，不过还是推荐一个<a href="https://www.tablesgenerator.com/">在线表格绘制网站</a>，这个个网站可以手动输入，同时也支持导入excel。</li>
<li>包管理问题：很多模板的包依赖问题都没有处理好需要自己手动引入，导致编译各种报错，有时候完全莫名其妙，所以这种出了问题还是谨慎谷歌或百度吧</li>
<li>参考文献：这一点倒确实是个人感觉下来LaTex最大的优势所在。主要有两种方法引入参考文献：
<ul>
<li>一是像md一样在文中直接列出文献信息，然后再引用地方插入标签就好</li>
<li>二是使用BibTex，注意这是个额外的编译器专门用来编译.bib文件的，这种名字的文件里面存放的是要引入的参考文献，一般模板都会专门保留个目录找到就行了。找好参考文献后直接在文章里面要引用的部分插入标签，它就自动帮你按顺序插入文献，而且同时在后面你定义的文献列表中把刚插入的那篇列到最后。</li>
<li>使用BibTex有个坑的地方在于国内多数学术数据库不支持导出这种格式。。。。这种个人建议直接中文的在百度学术上搜，英文的在谷歌学术上搜，这两个都是支持导出BibTex格式的。此外还有一个叫zotero的浏览器插件，可以抓取知网上论文信息，支持导出BibTex。</li>
</ul>
</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>毕业论文</category>
      </categories>
      <tags>
        <tag>毕业论文</tag>
      </tags>
  </entry>
  <entry>
    <title>18.Document Distance</title>
    <url>/posts/41d64c1efff2</url>
    <content><![CDATA[<h1 id="document-distance"><a class="markdownIt-Anchor" href="#document-distance"></a> Document Distance</h1>
<p>这个应该是目前发的里面最难搞的一个了，至今还不知道怎么ac</p>
<p>Plagiarism is a form of academic dishonesty. To fight with such misconducts, plagiarism checkers are developed to compare any submitted article with all the articles stored in a database. The key is that given two documents, how to judge their similarity, or in other words, document distance? The document distance can be measured with their word metrics. In this project, you are supposed to write a program to calculate the distance of any given pair of documents. Some important terms are defined as follows:</p>
<ul>
<li>Word: is a continuous sequence of alphanumeric characters. For example, the phrase “the course data structure is fun” consists of 6 distinct words. Here we can assume that no word contains more than 20 characters.</li>
<li>Word frequency: denoted by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mi>D</mi></msub><mo stretchy="false">(</mo><mi>w</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F_D(w)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span> is the number of times the word w occurs in a document D.</li>
<li>Document distance metric: is defined to be the inner product of the two vectors containing the word frequencies for all words in two documents. Denote the frequency vector for document Di by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>D</mi><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>⋯</mo><mo separator="true">,</mo><msub><mi>F</mi><mi>i</mi></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mi>n</mi></msub><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">F(Di)=(F_i(w_1),⋯,F_i(w_n))^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span>, then the metric is given by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>i</mi><mo>:</mo><mn>1</mn><mo>→</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∑</mo><msub><mi>F</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo><msub><mi>F</mi><mn>2</mn></msub><mo stretchy="false">(</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(F(D_1),F(D_2))=(i:1\rightarrow n)∑F_1(w_i)F_2(w_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>. In other words, the document distance metric is the projection of vector <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(D_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> onto <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(D_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, or vice versa.</li>
<li>Angle metric: is the angle between the vectors <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(D_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(D_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> which gives an indication of overlap between the two documents <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">D_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">D_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. The angle can be computed by the following formula:<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>r</mi><mi>c</mi><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mo>∣</mo><mo>∣</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∣</mo><mo>∣</mo><mo>⋅</mo><mo>∣</mo><mo>∣</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∣</mo><mo>∣</mo><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>D</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">θ(D_1,D_2)=arccos(∣∣F(D_1)∣∣⋅∣∣F(D_2)∣∣(F(D_1),F(D_2)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>π</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">θ∈[0,π/2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">]</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo><mo>∣</mo><mo>⋅</mo><mo>∣</mo><mo>∣</mo></mrow><annotation encoding="application/x-tex">∣∣⋅∣∣</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">⋅</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span></span></span> can be any norm of a vector. To be more specific, here we use the 2-norm which is defined by <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∣</mo><mo>∣</mo><mi>F</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo>∣</mo><mo>∣</mo><mo>=</mo><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">∣∣F(D)∣∣=(F(D),F(D))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line of input contains a positive integer N (≤100) which is the number of text files to be processed. Then N blocks follow, each contains a file. The first line of each file contains the title of the article (string of no more than 6 characters without any space), and the last line contains a single character #. After the file blocks, there is a line containing a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo separator="true">,</mo><mn>000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤100,000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, followed by M lines of inquiries. Each inquiry gives a pair of file names separated by a space. The size of the largest test case is about 1 MB.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each inquiry, print in a line Case #: *, where # is the test case number starting from 1 and * is the document distance value accurate up to 3 decimal places. Note: Your stemming algorithm must be able to handle “es”, “ed”, “ing”, “ies” and must be case-insensitive. Stop words are not supposed to be ignored and must be treated as normal words.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">3
A00
A B C
#
A01
B C D
#
A02
A C
D A
#
2
A00 A01
A00 A02<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">Case 1: 0.841
Case 2: 0.785<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="仅供参考"><a class="markdownIt-Anchor" href="#仅供参考"></a> 仅供参考</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 此题满分35分，最终得分只有19分，鲜绿的大✖️极其醒目 *&#x2F;
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
&#x2F;&#x2F;struct passage to store data
struct Passage&#123;
    char Name[5];
    char Word[100];
    int weight[100];
&#125;;
struct Passage F[100];
int main()&#123;
    double ModuleOfVector(int file); &#x2F;&#x2F;tow functions to calculate results
    double MultOfVectors(int file1,int file2);
    int NumOfFiles; &#x2F;&#x2F;number of files.
    double result[100]; &#x2F;&#x2F;store the result[i] for case i
    int i,j,m,n;
    int file1,file2,Case; &#x2F;&#x2F;file number and case number
    char f1[5],f2[5]; &#x2F;&#x2F;store the name of file1 and file2 (when compare)
    int flag;
    scanf(&quot;%d&quot;,&amp;NumOfFiles); &#x2F;&#x2F;input the number of files
    for(i&#x3D;0;i&lt;NumOfFiles;i++)&#123;
        &#x2F;&#x2F;Input data in to Passage b
        scanf(&quot;%s&quot;,F[i].Name);
        getchar(); &#x2F;&#x2F;This getchar() can free the &#39;\n&#39; in cache. Otherwise it will assign to the next scanf of getchar operation.
        j&#x3D;0; &#x2F;&#x2F;initialize input
        F[i].Word[j] &#x3D; getchar();
        while(F[i].Word[j] !&#x3D; &#39;#&#39;)&#123;
            if(F[i].Word[j]&#x3D;&#x3D;&#39;\n&#39; || F[i].Word[j]&#x3D;&#x3D;&#39; &#39;)
                j--;
            j++;
            scanf(&quot;%c&quot;,&amp;F[i].Word[j]);
        &#125;
        if(j &#x3D;&#x3D; 0) &#x2F;&#x2F;if a file is empty
            printf(&quot;File is null!\n&quot;);
        &#x2F;&#x2F;Calcute the weight of word. If two word are the same, the later one&#39;s weight will be 0.
        for(m&#x3D;0;m&lt;j;m++)&#123;
            F[i].weight[m] &#x3D; 0;
            for(n&#x3D;0;n&lt;j;n++)&#123;
                if(F[i].Word[m] &#x3D;&#x3D; F[i].Word[n])
                    F[i].weight[m]++;
            &#125;
            for(n&#x3D;0;n&lt;j;n++)&#123;
                if(F[i].Word[m] &#x3D;&#x3D; F[i].Word[n])
                    if(F[i].weight[m] &gt; 1 &amp;&amp; m &gt; n)&#123;
                        F[i].weight[m]&#x3D;0;
                        break;
                    &#125;
            &#125;
        &#125;
    &#125;
    &#x2F;&#x2F;input the number of case
    scanf(&quot;%d&quot;,&amp;Case);
    for(i&#x3D;0;i&lt;Case;i++)&#123;
        &#x2F;&#x2F;Input the name of two files. Find their number.
        scanf(&quot;%s%s&quot;,f1,f2);
        flag&#x3D;0;
        for(j&#x3D;0;j&lt;NumOfFiles;j++)&#123;
            if(strcmp(F[j].Name,f1) &#x3D;&#x3D; 0)&#123;
                file1&#x3D;j;
                flag++;
            &#125;
            if(strcmp(F[j].Name,f2) &#x3D;&#x3D; 0)&#123;
                file2&#x3D;j;
                flag++;
            &#125;
        &#125;
        if(flag !&#x3D; 2) &#x2F;&#x2F;if any one in the two files doesn&#39;t exist. print &quot;File not exist!\n &quot;
            printf(&quot;File not exist!\n&quot;);
        result[i] &#x3D; acos(MultOfVectors(file1,file2) &#x2F; (ModuleOfVector(file1)*ModuleOfVector(file2))); &#x2F;&#x2F;Use acos() to calculate the result
    &#125;
    &#x2F;&#x2F;print result of cases
    for(i&#x3D;0;i&lt;Case;i++)
        printf(&quot;Case %d: %.3lf\n&quot;,i+1 ,result[i]);
    &#x2F;&#x2F;print result in suitable form
    return 0;
    &#125;
    &#x2F;&#x2F;This function returns the module of vector
    double ModuleOfVector(int file)&#123;
    int i&#x3D;0;
    double module&#x3D;0;
    while(F[file].Word[i] !&#x3D; &#39;#&#39;)&#123;
        module +&#x3D; F[file].weight[i]*F[file].weight[i];
        i++;
    &#125;
    return sqrt(module);
&#125;
&#x2F;&#x2F;This function returns the multiplication of vectors
double MultOfVectors(int file1,int file2)&#123;
    int i,j;
    double mult&#x3D;0;
    for(i&#x3D;0;F[file1].Word[i] !&#x3D; &#39;#&#39;;i++ )
        for(j&#x3D;0;F[file2].Word[j] !&#x3D; &#39;#&#39;;j++ )&#123;
            if(F[file1].Word[i] &#x3D;&#x3D; F[file2].Word[j])&#123;
                mult +&#x3D; F[file1].weight[i] * F[file2].weight[j];
            &#125;
        &#125;
    return mult;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>17.Color the tree、Self-printable B+ Tree</title>
    <url>/posts/beb87d22ffa2</url>
    <content><![CDATA[<h1 id="color-the-tree"><a class="markdownIt-Anchor" href="#color-the-tree"></a> Color the Tree</h1>
<p>There is a kind of balanced binary search tree named red-black tree in the data structure.<br>
It has the following 5 properties:<br>
(1) Every node is either red or black.<br>
(2) The root is black.<br>
(3) Every leaf (NULL) is black.<br>
(4) If a node is red, then both its children are black.<br>
(5) For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.<br>
For each given binary search tree, you are supposed to tell if it is possible to color the nodes and turn it into a legal red-black tree.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains several test cases. The first line gives a positive integer K (≤10) which is the total number of cases. For each case,the first line gives a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of nodes in the binary search tree. The second line gives the postorder traversal sequence of the tree. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, print in a line Yes if the given tree can be turned into a legal red-black tree, ## or No if not.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">3
9
1 4 5 2 8 15 14 11 7
9
1 4 5 8 7 2 15 14 11
8
6 5 8 7 11 17 15 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">Yes
No
Yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="参考代码转"><a class="markdownIt-Anchor" href="#参考代码转"></a> 参考代码(转)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;
#include &lt;cstdio&gt;
using namespace std;
typedef long long ll;
const int maxn&#x3D;111;
struct node
&#123;
    int l,r,tol;
&#125;stu[maxn];
int n,a[maxn],root,tot;
void handle(int l,int r,int pre)
&#123;
    if(l&#x3D;&#x3D;r) return ;
    int pos&#x3D;r;
    for(int i&#x3D;r-1;i&gt;&#x3D;l;--i) if(a[i]&gt;a[r]) pos&#x3D;i;
    if(pos&#x3D;&#x3D;r)&#123;
        int cnt&#x3D;++tot;
        stu[cnt].l&#x3D;0;
        stu[cnt].r&#x3D;0;
        handle(l,pos-1,cnt);
        stu[pre].l&#x3D;cnt;
    &#125;
    else if(pos&#x3D;&#x3D;l)&#123;
        int cnt&#x3D;++tot;
        stu[cnt].l&#x3D;0;
        stu[cnt].r&#x3D;0;
        handle(pos,r-1,cnt);
        stu[pre].r&#x3D;cnt;
    &#125;
    else&#123;
        int cnt&#x3D;++tot;
        stu[cnt].l&#x3D;0;
        stu[cnt].r&#x3D;0;
        handle(l,pos-1,cnt);
        stu[pre].l&#x3D;cnt;
        cnt&#x3D;++tot;
        stu[cnt].l&#x3D;0;
        stu[cnt].r&#x3D;0;
        handle(pos,r-1,cnt);
        stu[pre].r&#x3D;cnt;
    &#125;
&#125;
vector&lt;int&gt; solve(vector&lt;int&gt; p,vector&lt;int&gt; q)
&#123;
    vector&lt;int&gt; res;
    res.clear();
    for(int i&#x3D;0;i&lt;(int)p.size();++i)&#123;
        int u&#x3D;p[i];
        for(int j&#x3D;0;j&lt;(int)q.size();++j)&#123;
            if(u&#x3D;&#x3D;q[j])&#123;
                res.push_back(u);
                break;
            &#125;
        &#125;
    &#125;
    return res;
&#125;
int tol;
vector&lt;int&gt; red[maxn],black[maxn];
bool flag;
void dfs(int cur)
&#123;
    if(flag&#x3D;&#x3D;false) return ;
    if(stu[cur].l&gt;0 &amp;&amp; stu[cur].r&gt;0)&#123;
        dfs(stu[cur].l);
        if(flag&#x3D;&#x3D;false) return ;
        dfs(stu[cur].r);
        if(flag&#x3D;&#x3D;false) return ;
        vector&lt;int&gt; x&#x3D;solve(black[stu[stu[cur].l].tol],black[stu[stu[cur].r].tol]);
        int cnt&#x3D;++tol;
        stu[cur].tol&#x3D;cnt;
        red[cnt]&#x3D;x;
        black[cnt].clear();
        vector&lt;int&gt; y&#x3D;solve(black[stu[stu[cur].l].tol],red[stu[stu[cur].r].tol]);
        vector&lt;int&gt; z&#x3D;solve(red[stu[stu[cur].l].tol],black[stu[stu[cur].r].tol]);
        vector&lt;int&gt; w&#x3D;solve(red[stu[stu[cur].l].tol],red[stu[stu[cur].r].tol]);
        set&lt;int&gt; se;
        se.clear();
        for(int i&#x3D;0;i&lt;(int)x.size();++i) se.insert(x[i]);
        for(int i&#x3D;0;i&lt;(int)y.size();++i) se.insert(y[i]);
        for(int i&#x3D;0;i&lt;(int)z.size();++i) se.insert(z[i]);
        for(int i&#x3D;0;i&lt;(int)w.size();++i) se.insert(w[i]);
        set&lt;int&gt;::iterator it;
        for(it&#x3D;se.begin();it!&#x3D;se.end();++it)&#123;
            black[cnt].push_back((*it)+1);
        &#125;
        if((int)red[cnt].size()&#x3D;&#x3D;0 &amp;&amp; (int)black[cnt].size()&#x3D;&#x3D;0)&#123;
            flag&#x3D;false;
            return ;
        &#125;
    &#125;
    else if(stu[cur].l&gt;0)&#123;
        dfs(stu[cur].l);
        if(flag&#x3D;&#x3D;false) return ;
        int id&#x3D;stu[stu[cur].l].tol;
        bool have0&#x3D;false;
        for(int i&#x3D;0;i&lt;(int)red[id].size();++i)&#123;
            if(red[id][i]&#x3D;&#x3D;0)&#123;
                have0&#x3D;true;
                break;
            &#125;
        &#125;
        if(have0&#x3D;&#x3D;false)&#123;
            flag&#x3D;false;
            return ;
        &#125;
        int cnt&#x3D;++tol;
        stu[cur].tol&#x3D;cnt;
        red[cnt].clear();
        black[cnt].clear();
        black[cnt].push_back(1);
    &#125;
    else if(stu[cur].r&gt;0)&#123;
        dfs(stu[cur].r);
        if(flag&#x3D;&#x3D;false) return ;
        int id&#x3D;stu[stu[cur].r].tol;
        bool have0&#x3D;false;
        for(int i&#x3D;0;i&lt;(int)red[id].size();++i)&#123;
            if(red[id][i]&#x3D;&#x3D;0)&#123;
                have0&#x3D;true;
                break;
            &#125;
        &#125;
        if(have0&#x3D;&#x3D;false)&#123;
            flag&#x3D;false;
            return ;
        &#125;
        int cnt&#x3D;++tol;
        stu[cur].tol&#x3D;cnt;
        red[cnt].clear();
        black[cnt].clear();
        black[cnt].push_back(1);
    &#125;
    else&#123;
        int cnt&#x3D;++tol;
        stu[cur].tol&#x3D;cnt;
        red[cnt].clear();
        red[cnt].push_back(0);
        black[cnt].clear();
        black[cnt].push_back(1);
    &#125;
&#125;
int main()
&#123;
    int t;
    for(scanf(&quot;%d&quot;,&amp;t);t;--t)&#123;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i&#x3D;1;i&lt;&#x3D;n;++i)&#123;
            scanf(&quot;%d&quot;,&amp;a[i]);
        &#125;
        tot&#x3D;0;
        root&#x3D;++tot;
        stu[root].l&#x3D;0;
        stu[root].r&#x3D;0;
        handle(1,n,1);
        flag&#x3D;true;
        tol&#x3D;0;
        dfs(root);
        if(flag) printf(&quot;Yes\n&quot;);
        else printf(&quot;No\n&quot;);
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="我自己的版本有两个测试点过不去"><a class="markdownIt-Anchor" href="#我自己的版本有两个测试点过不去"></a> 我自己的版本(有两个测试点过不去)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;queue&gt;
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#define MAXNODES 35
using namespace std;
typedef struct RBnode*nodeptr;
struct RBnode&#123;
    nodeptr parent,leftchild,rightchild;
    int value,color;
&#125;;
enum color&#123;black,red&#125;;
void posttolevel(int,int),solve(int);
bool judgeRB(nodeptr);
queue&lt;int&gt;levelorder;
int postorder[MAXNODES];
nodeptr buildRB(nodeptr),insertRB(nodeptr,int);
int main()&#123;
    int totalcases,nodes,nodevalue;
    scanf(&quot;%d&quot;,&amp;totalcases);
    for(int i&#x3D;0;i&lt;totalcases;i++)&#123;
        scanf(&quot;%d&quot;,&amp;nodes);
        for(int j&#x3D;0;j&lt;nodes;j++)scanf(&quot;%d&quot;,&amp;postorder[j]);
        solve(nodes);
    &#125;
&#125;
void solve(int nodes)&#123;
    levelorder.push(postorder[nodes-1]);
    posttolevel(0,nodes-1);
    nodeptr btree&#x3D;nullptr;
    btree&#x3D;buildRB(btree);
    if(judgeRB(btree))printf(&quot;Yes\n&quot;);
    else printf(&quot;No\n&quot;);
&#125;
bool judgeRB(nodeptr root)&#123;
    if(root-&gt;value&gt;0)&#123;
        if(root-&gt;color&#x3D;&#x3D;red&amp;&amp;root-&gt;parent-&gt;color&#x3D;&#x3D;red)return false;
        return judgeRB(root-&gt;leftchild)&amp;&amp;judgeRB(root-&gt;rightchild);
    &#125;
    return true;
&#125;
void posttolevel(int start,int end)&#123;
    if(start&gt;end)return;
    int i&#x3D;start,pivot&#x3D;0;
    for(;postorder[i]&lt;postorder[end];i++);
    pivot&#x3D;i;
    if(pivot&gt;start)levelorder.push(postorder[pivot-1]);
    if(pivot&lt;end)levelorder.push(postorder[end-1]);
    posttolevel(start,pivot-1);
    posttolevel(pivot,end-1);
&#125;
nodeptr buildRB(nodeptr root)&#123;
    while(!levelorder.empty())&#123;
        root&#x3D;insertRB(root,levelorder.front());
        levelorder.pop();
    &#125;
    return root;
&#125;
nodeptr insertRB(nodeptr root,int insertvalue)&#123;
    if(!root)&#123;
        root&#x3D;(nodeptr)malloc(sizeof(struct RBnode));
        root-&gt;leftchild&#x3D;(nodeptr)malloc(sizeof(struct RBnode));
        root-&gt;rightchild&#x3D;(nodeptr)malloc(sizeof(struct RBnode));
        root-&gt;parent&#x3D;nullptr,root-&gt;leftchild-&gt;parent&#x3D;root-&gt;rightchild-&gt;parent&#x3D;root;
        root-&gt;value&#x3D;insertvalue,root-&gt;leftchild-&gt;value&#x3D;root-&gt;rightchild-&gt;value&#x3D;-1;
        root-&gt;color&#x3D;root-&gt;leftchild-&gt;color&#x3D;root-&gt;rightchild-&gt;color&#x3D;black;
    &#125;
    if(root-&gt;value&lt;0)&#123;
        root-&gt;leftchild&#x3D;(nodeptr)malloc(sizeof(struct RBnode));
        root-&gt;rightchild&#x3D;(nodeptr)malloc(sizeof(struct RBnode));
        root-&gt;leftchild-&gt;parent&#x3D;root-&gt;rightchild-&gt;parent&#x3D;root;
        root-&gt;value&#x3D;insertvalue,root-&gt;leftchild-&gt;value&#x3D;root-&gt;rightchild-&gt;value&#x3D;-1;
        root-&gt;color&#x3D;red,root-&gt;leftchild-&gt;color&#x3D;root-&gt;rightchild-&gt;color&#x3D;black;
        if(root-&gt;parent-&gt;color&#x3D;&#x3D;red)&#123;
            nodeptr grandparent&#x3D;root-&gt;parent-&gt;parent,
                    leftancle&#x3D;grandparent-&gt;leftchild,rightancle&#x3D;grandparent-&gt;rightchild;
            if(root-&gt;parent-&gt;value&lt;grandparent-&gt;value&amp;&amp;rightancle-&gt;color&#x3D;&#x3D;red)&#123;
                root-&gt;parent-&gt;color&#x3D;rightancle-&gt;color&#x3D;black;
                if(grandparent-&gt;parent)grandparent-&gt;color&#x3D;red;
            &#125;else if(root-&gt;parent-&gt;value&gt;grandparent-&gt;value&amp;&amp;leftancle-&gt;color&#x3D;&#x3D;red)&#123;
                root-&gt;parent-&gt;color&#x3D;leftancle-&gt;color&#x3D;black;
                if(grandparent-&gt;parent)root-&gt;parent-&gt;parent-&gt;color&#x3D;red;
            &#125;
        &#125;
    &#125;else if(root-&gt;value&gt;insertvalue)root-&gt;leftchild&#x3D;insertRB(root-&gt;leftchild,insertvalue);
    else if(root-&gt;value&lt;insertvalue)root-&gt;rightchild&#x3D;insertRB(root-&gt;rightchild,insertvalue);
    return root;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="self-printable-b-tree"><a class="markdownIt-Anchor" href="#self-printable-b-tree"></a> Self-printable B+ Tree</h1>
<p>In this project, you are supposed to implement a B+ tree of order 3, with the following operations: initialize, insert (with splitting) and search. The B+ tree should be able to print out itself.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains a positive number <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the number of integer keys to be inserted. Then a line of the N positive integer keys follows. All the numbers in a line are separated by spaces.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, insert the keys into an initially empty B+ tree of order 3 according to the given order. Print in a line Key X is duplicated where X already exists when being inserted. After all the insertions, print out the B+ tree in a top-down lever-order format as shown by the samples.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">6
7 8 9 10 7 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">Key 7 is duplicated
[9]
[4,7,8][9,10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 1 4 5 9 2 6 8 7 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">[6]
[2,4][8]
[0,1][2,3][4,5][6,7][8,9]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-input-3"><a class="markdownIt-Anchor" href="#sample-input-3"></a> Sample Input 3</h2>
<pre class="line-numbers language-none"><code class="language-none">3
1 2 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output-3"><a class="markdownIt-Anchor" href="#sample-output-3"></a> Sample Output 3</h2>
<pre class="line-numbers language-none"><code class="language-none">[1,2,3]    <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;queue&gt;
#define MAXINPUT 10050
#define INIFINITY 65535
using namespace std;
typedef struct Bplusnode*Bplusptr;
struct Bplusnode&#123;
    int keys[4];
    bool flag;
    Bplusptr parent,sibling,childs[4];
&#125;;
enum flag&#123;leaf,nonleaf&#125;;
int inputvalue[MAXINPUT];
queue&lt;Bplusptr&gt;printerqueque;
Bplusptr initializeBplustree(int),searchBplustree(Bplusptr,int),insertBplustree(Bplusptr,int);
void printBplustree(Bplusptr);
int main()&#123;
    int inputnodes;
    scanf(&quot;%d&quot;,&amp;inputnodes);
    for(int i&#x3D;0;i&lt;inputnodes;i++)scanf(&quot;%d&quot;,&amp;inputvalue[i]);
    Bplusptr tree&#x3D;nullptr;
    for(int i&#x3D;0;i&lt;inputnodes;i++)
        tree&#x3D;insertBplustree(searchBplustree(tree,inputvalue[i]),inputvalue[i]);
    printBplustree(tree);
    return 0;
&#125;
Bplusptr initializeBplustree(int flag)&#123;
    auto root&#x3D;(Bplusptr)malloc(sizeof(struct Bplusnode));
    root-&gt;parent&#x3D;root-&gt;sibling&#x3D;nullptr;
    root-&gt;flag&#x3D;flag;
    for(int i&#x3D;0;i&lt;4;i++)root-&gt;keys[i]&#x3D;INIFINITY,root-&gt;childs[i]&#x3D;nullptr;
    return root;
&#125;
Bplusptr searchBplustree(Bplusptr root,int searchvalue)&#123;
    if(!root)return nullptr;
    if(root-&gt;flag)&#123;
        if(root-&gt;keys[0]&gt;searchvalue)root&#x3D;searchBplustree(root-&gt;childs[0],searchvalue);
        else if(root-&gt;keys[1]&gt;searchvalue)root&#x3D;searchBplustree(root-&gt;childs[1],searchvalue);
        else root&#x3D;searchBplustree(root-&gt;childs[2],searchvalue);
    &#125;
    return root;
&#125;
Bplusptr insertBplustree(Bplusptr root,int insertvalue)&#123;
    if(!root)root&#x3D;initializeBplustree(leaf);
    int insertpos&#x3D;0;
    if(!root-&gt;flag)&#123;
        for(;insertvalue&gt;&#x3D;root-&gt;keys[insertpos];insertpos++)if(root-&gt;keys[insertpos]&#x3D;&#x3D;insertvalue)&#123;
                printf(&quot;Key %d is duplicated\n&quot;,insertvalue);
                insertpos&#x3D;-1;break;
            &#125;
        if(insertpos&gt;&#x3D;0)&#123;
            for(int i&#x3D;2;i&gt;&#x3D;insertpos;i--)root-&gt;keys[i+1]&#x3D;root-&gt;keys[i];
            root-&gt;keys[insertpos]&#x3D;insertvalue;
        &#125;
        if(root-&gt;keys[3]&lt;INIFINITY)&#123;
            Bplusptr nextleaf&#x3D;initializeBplustree(leaf),parent&#x3D;root-&gt;parent;
            nextleaf-&gt;sibling&#x3D;root-&gt;sibling;
            root-&gt;sibling&#x3D;nextleaf;
            for(int i&#x3D;0;i&lt;2;i++)nextleaf-&gt;keys[i]&#x3D;root-&gt;keys[i+2],root-&gt;keys[i+2]&#x3D;INIFINITY;
            if(parent)&#123;
                nextleaf-&gt;parent&#x3D;parent;
                for(insertpos&#x3D;0;root-&gt;keys[0]&gt;&#x3D;parent-&gt;keys[insertpos];insertpos++);
                for(int i&#x3D;3;i&gt;insertpos;i--)parent-&gt;childs[i]&#x3D;parent-&gt;childs[i-1];
                parent-&gt;childs[insertpos+1]&#x3D;nextleaf;
                for(int i&#x3D;0;i&lt;3;i++)if(parent-&gt;childs[i+1])parent-&gt;keys[i]&#x3D;parent-&gt;childs[i+1]-&gt;keys[0];
            &#125;else&#123;
                root-&gt;parent&#x3D;nextleaf-&gt;parent&#x3D;initializeBplustree(nonleaf);
                root-&gt;parent-&gt;childs[0]&#x3D;root,root-&gt;parent-&gt;childs[1]&#x3D;root-&gt;sibling;
                root-&gt;parent-&gt;keys[0]&#x3D;nextleaf-&gt;keys[0];
            &#125;
        &#125;
        if(root-&gt;parent)root&#x3D;insertBplustree(root-&gt;parent,insertvalue);
    &#125;else&#123;
        if(root-&gt;keys[2]&lt;INIFINITY)&#123;
            Bplusptr nextnonleaf&#x3D;initializeBplustree(nonleaf),parent&#x3D;root-&gt;parent;
            nextnonleaf-&gt;sibling&#x3D;root-&gt;sibling;
            root-&gt;sibling&#x3D;nextnonleaf;
            nextnonleaf-&gt;keys[0]&#x3D;root-&gt;keys[2],root-&gt;keys[2]&#x3D;INIFINITY;
            for(int i&#x3D;0;i&lt;2;i++)&#123;
                nextnonleaf-&gt;childs[i]&#x3D;root-&gt;childs[i+2],root-&gt;childs[i+2]-&gt;parent&#x3D;nextnonleaf;
                root-&gt;childs[i+2]&#x3D;nullptr;
            &#125;
            if(parent)&#123;
                nextnonleaf-&gt;parent&#x3D;parent;
                for(;root-&gt;keys[1]&gt;parent-&gt;keys[insertpos];insertpos++);
                for(int i&#x3D;2;i&gt;&#x3D;insertpos;i--)parent-&gt;keys[i]&#x3D;parent-&gt;keys[i-1];
                parent-&gt;keys[insertpos]&#x3D;root-&gt;keys[1],root-&gt;keys[1]&#x3D;INIFINITY;
                for(int i&#x3D;3;i&gt;insertpos;i--)parent-&gt;childs[i]&#x3D;parent-&gt;childs[i-1];
                parent-&gt;childs[insertpos+1]&#x3D;nextnonleaf;
            &#125;else&#123;
                root-&gt;parent&#x3D;nextnonleaf-&gt;parent&#x3D;initializeBplustree(nonleaf);
                root-&gt;parent-&gt;childs[0]&#x3D;root,root-&gt;parent-&gt;childs[1]&#x3D;nextnonleaf;
                root-&gt;parent-&gt;keys[0]&#x3D;root-&gt;keys[1],root-&gt;keys[1]&#x3D;INIFINITY;
            &#125;
        &#125;
        if(root-&gt;parent)root&#x3D;insertBplustree(root-&gt;parent,insertvalue);
    &#125;
    return root;
&#125;
void printBplustree(Bplusptr root)&#123;
    printerqueque.push(root);
    while(!printerqueque.empty())&#123;
        int flag&#x3D;0;
        printf(&quot;[&quot;);
        for(int i&#x3D;0;i&lt;3;i++)&#123;
            int printnum&#x3D;printerqueque.front()-&gt;keys[i];
            if(printnum&lt;INIFINITY)&#123;
                if(!flag)&#123;
                    printf(&quot;%d&quot;,printnum);
                    flag&#x3D;1;
                &#125;else printf(&quot;,%d&quot;,printnum);
            &#125;
        &#125;
        printf(&quot;]&quot;);
        if(!printerqueque.front()-&gt;sibling)printf(&quot;\n&quot;);
        for(int i&#x3D;0;i&lt;3;i++)&#123;
            if(printerqueque.front()-&gt;childs[i])printerqueque.push(printerqueque.front()-&gt;childs[i]);
            else break;
        &#125;
        printerqueque.pop();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>16.hashing简单版、hashing复杂版、串的模式匹配</title>
    <url>/posts/362db4955964</url>
    <content><![CDATA[<h1 id="hashing"><a class="markdownIt-Anchor" href="#hashing"></a> Hashing</h1>
<p>The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be H(key)=key%TSize where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime.<br>
If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">MSize (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mi>M</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤MSize)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span> which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-” instead.</p>
<h2 id="参考代码转"><a class="markdownIt-Anchor" href="#参考代码转"></a> 参考代码(转)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#define MSIZE 10050
using namespace std;
int msize,n,num,htable[MSIZE];
void insert(int);
bool isprime(int);
int main()&#123;
cin&gt;&gt;msize&gt;&gt;n;
while(!isprime(msize))msize++;
for(int i&#x3D;0;i&lt;n;i++)&#123;
    cin&gt;&gt;num;
    insert(num);
    if(i&lt;n-1)cout&lt;&lt;&#39; &#39;;
&#125;
cout&lt;&lt;endl;
&#125;
bool isprime(int m)&#123;
int i;
if(m&#x3D;&#x3D;1)return false;
for(i&#x3D;sqrt(m);i&gt;1;i--)if(!(m%i))return false;
return true;
&#125;
void insert(int key)&#123;
for(int d&#x3D;0;d&lt;msize;d++)&#123;
    int pos&#x3D;(key+d*d)%msize;
    if(!htable[pos])&#123;
        htable[pos]&#x3D;key;
        cout&lt;&lt;pos;
        return;
    &#125;
&#125;
cout&lt;&lt;&#39;-&#39;;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="hashing-hard-version"><a class="markdownIt-Anchor" href="#hashing-hard-version"></a> Hashing - Hard Version</h1>
<p>Given a hash table of size N, we can define a hash function H(x)=x%N. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers. However, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, which is the size of the hash table. The next line contains N integers, separated by a space. A negative integer represents an empty cell in the hash table. It is guaranteed that all the non-negative integers are distinct in the table.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, print a line that contains the input sequence, with the numbers separated by a space. Notice that there must be no extra space at the end of each line.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">11
33 1 13 12 34 38 27 22 32 -1 21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">1 13 12 21 33 34 38 27 22 32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<ul>
<li>已知H(x)=x%N以及用线性探测解决冲突问题</li>
<li>先给出散列映射的结果，反求输入顺序
<ul>
<li>当元素x被映射到H(x)位置，发现这个位置已经有y了，则y一定是在x之前被输入的</li>
<li>————————&gt;拓扑排序!!!</li>
</ul>
</li>
</ul>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#include&lt;stack&gt;
#define range 1050
using namespace std;
int n,num,htable[range],temp[range],output[range],myhash(int),cmp(const void*,const void*);
stack&lt;int&gt;s1,s2;
void insert(int),hashing();
bool find(int);
int main()&#123;
    cin&gt;&gt;n;
    int i,j;
    for(i&#x3D;0,j&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;num;
        htable[i]&#x3D;num;
        if(num&gt;0)output[j++]&#x3D;num;
    &#125;
    qsort(output,j,sizeof(int),cmp);
    for(i&#x3D;j-1;i&gt;&#x3D;0;i--)s1.push(output[i]);
    hashing();
&#125;
int cmp(const void*num1,const void*num2)&#123;
    return *(int*)num1-*(int*)num2;
&#125;
int myhash(int key)&#123;
    return key%n;
&#125;
bool find(int key)&#123;
    int pos&#x3D;myhash(key);
    while(temp[pos]&amp;&amp;temp[pos]!&#x3D;key)++pos%&#x3D;n;
    if(key&#x3D;&#x3D;htable[pos])&#123;
        temp[pos]&#x3D;key;
        return true;
    &#125;
    return false;
&#125;
void hashing()&#123;
    int i&#x3D;0;
    while(!s1.empty())&#123;
        while(!find(s1.top()))s2.push(s1.top()),s1.pop();
        output[i++]&#x3D;s1.top(),s1.pop();
        while(!s2.empty())s1.push(s2.top()),s2.pop();
    &#125;
    for(int j&#x3D;0;j&lt;i-1;j++)cout&lt;&lt;output[j]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;output[i-1]&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="kmp-串的模式匹配"><a class="markdownIt-Anchor" href="#kmp-串的模式匹配"></a> KMP 串的模式匹配</h1>
<p>给定两个由英文字母组成的字符串String和Pattern，要求找到Pattern在String中第一次出现的位置，并将此位置后的String的子串输出。如果找不到，则输出“Not Found”。<br>
本题旨在测试各种不同的匹配算法在各种数据情况下的表现。各组测试数据特点如下：<br>
数据0：小规模字符串，测试基本正确性；<br>
数据1：随机数据，String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn></mrow><annotation encoding="application/x-tex">10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>；<br>
数据2：随机数据，String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">10^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>；<br>
数据3：随机数据，String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>；<br>
数据4：随机数据，String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>；<br>
数据5：String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；测试尾字符不匹配的情形；<br>
数据6：String长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>，Pattern长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>；测试首字符不匹配的情形。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入第一行给出 String，为由英文字母组成的、长度不超过10^6的字符串。第二行给出一个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>，为待匹配的模式串的个数。随后N行，每行给出一个Pattern，为由英文字母组成的、长度不超过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>的字符串。每个字符串都非空，以回车结束。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>对每个Pattern，按照题面要求输出匹配结果。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">abcabcabcabcacabxy
3
abcabcacab
cabcabcd
abcabcabcabcacabxyz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">abcabcacabxy
Not Found
Not Found<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
#define range 100500
using namespace std;
int n,mynext[range];
string str,ptn;
void kmp(string),match(string);
int main()&#123;
    cin&gt;&gt;str&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;ptn;
        kmp(ptn);
    &#125;
&#125;
void kmp(string ptn)&#123;
    int s&#x3D;0,p&#x3D;0,lens&#x3D;str.size(),lenp&#x3D;ptn.size();
    match(ptn);
    while(s&lt;lens&amp;&amp;p&lt;lenp)&#123;
        if(str[s]&#x3D;&#x3D;ptn[p])s++,p++;
        else if(p&gt;0)p&#x3D;mynext[p-1]+1;
        else s++;
    &#125;
    if(lenp&#x3D;&#x3D;p)cout&lt;&lt;str.substr(s-p)&lt;&lt;endl;
    else cout&lt;&lt;&quot;Not Found&quot;&lt;&lt;endl;
&#125;
void match(string ptn)&#123;
    mynext[0]&#x3D;-1
    for(int i&#x3D;1;i&lt;ptn.size();i++)&#123;
        int j&#x3D;mynext[i-1];
        while(j&gt;&#x3D;0&amp;&amp;ptn[i]!&#x3D;ptn[j+1])j&#x3D;mynext[j];
        if(ptn[i]&#x3D;&#x3D;ptn[j+1])mynext[i]&#x3D;j+1;
        else mynext[i]&#x3D;-1;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】对话Linus Torvalds：大多黑客甚至连指针都未理解</title>
    <url>/posts/12becdf9bb70</url>
    <content><![CDATA[<p>几周前，Linus Torvalds在Slashdot上回答了一些问题。其中有一条引发了开发者们的强烈关注，当被问到他心目中的内核开发者时，他说自己这些日子已经不怎么看代码了，除非是帮别人审查。他稍微暂停了一下，坦言那些“狡猾”的通过文件名查找高速缓存又抱怨自己能力一般的内核“恶魔”(黑客)才是他欣赏的。<br>
他说：<br>
我真的希望更多人能理解真正核心的低层代码。不是无锁名字查找那种大而复杂的代码，只是正确的使用指针的指针而已。比如，我曾看见过许多人通过跟踪上一页条目删除一个单向链接的列表项，然后删除该条目。</p>
<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">if (prev)  
    prev-&gt;next &#x3D; entry-&gt;next;  
else  
    list_head &#x3D; entry-&gt;next;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>每当我看到这些的代码，我会说：“此人不了解指针”。这还是一个可悲的、常见的问题。<br>
如果开发者能够理解指针，只需要使用“指向该条目的指针”并初始化list_head，然后贯穿列表，此时无需使用任何条件语句即可删除该条目，只需通过 *pp = entry-&gt;next。<br>
我想我理解指针，但不幸的是，如果要实现删除函数，我会一直保持跟踪前面的列表节点。这里是代码草稿：</p>
<p><strong>不理解指针的人</strong>做法：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct node  
&#123;  
    struct node * next;  
    ....  
&#125; node;  
 
typedef bool (* remove_fn)(node const * v);  
 
&#x2F;&#x2F; Remove all nodes from the supplied list for which the   
&#x2F;&#x2F; supplied remove function returns true.  
&#x2F;&#x2F; Returns the new head of the list.  
node * remove_if(node * head, remove_fn rm)  &#x2F;&#x2F;rm是判定这个结点要不要删除
&#123;  
    for (node * prev &#x3D; NULL, * curr &#x3D; head; curr !&#x3D; NULL; )  
    &#123;  
        node * next &#x3D; curr-&gt;next;  
        if (rm(curr))    &#x2F;&#x2F;如果满足rm就删除curr，如果curr是头结点就把head指向curr-&gt;next
        &#123;  
            if (prev)                   
                prev-&gt;next &#x3D; curr-&gt;next;  
            else  
                head &#x3D; curr-&gt;next;  
            free(curr);  
        &#125;  
        else             &#x2F;&#x2F;如果不满足就向下遍历
            prev &#x3D; curr;  
            curr &#x3D; next;  
    &#125;  
    return head;         &#x2F;&#x2F;看起来感觉没毛病
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个链表很简单，但可以把每个节点的指针和sentinel值构建成了一个完美的结构体，但是修改这个表的代码需要很精妙。难怪链表功能会常出现在许多面试环节中。<br>
上面执行的代码是处理从列表头中删除任何节点所需的条件。<br>
现在，让我们好好记住<strong>Linus Torvalds的执行代码</strong>。在这种情况下，我们通过一个指针指向列表头来贯穿列表遍历修改。</p>
<p>Two star programming：</p>
<pre class="line-numbers language-none"><code class="language-none">void remove_if(node ** head, remove_fn rm)  &#x2F;&#x2F;Linus的方法是用二重指针遍历链表
&#123;  
    for (node** curr &#x3D; head; *curr; )  
    &#123;  
        node * entry &#x3D; *curr;              &#x2F;&#x2F;使用一个指针记录当前结点
        if (rm(entry))  
        &#123;  
            *curr &#x3D; entry-&gt;next;           &#x2F;&#x2F;注意关键来了：如果满足rm，将二重指针当前指向的值改写为下个结点，然后删除当前结点
            free(entry);  
        &#125;  
        else  
            curr &#x3D; &amp;entry-&gt;next;           &#x2F;&#x2F;如果不满足就使用二重指针向下遍历
    &#125;  
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好多了！最关键的部分在于：<strong>链表中的链接都是指针</strong>，因此二重指针是修改链表的首选方案。<br>
改进版的remove_if()是一个使用双重星号的例子，双重星号象征着两重间接寻址，再加一个星（third star）又会太过多余。</p>
<p>个人认为其实这篇文章的根本是在说遍历一个类似的容器时，应该使用指针进行遍历，同时通过指针访问结点值进行修改。即便是数组这种最基本的结构，本质上还是靠指向元素的指针来访问元素。即使上例中所谓“不理解指针的人”的做法非常普遍，甚至绝大多数大公司和教材中都是用这样的方法遍历链表，但仔细想想这种方法每次都要操作两个结构体指针一个元素一个元素地往下赋值，效率并没有使用二重指针高。</p>
<center>
<div class="hide-block"><button type="button" class="hide-button" style="background-color: [#FFA500];color: [#8B4513]">[来自大佬的问候😄]
    </button><div class="hide-content"><p><img src="https://www.ubuntizando.com/wp-content/uploads/2012/10/linus-torvalds-ssd.jpg" alt></p>
</div></div>
</center>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>名人事迹</tag>
      </tags>
  </entry>
  <entry>
    <title>15.Insert or Merge、Insertion or Heap Sort、Sort with Swap(0, i)</title>
    <url>/posts/1c0e07d7660d</url>
    <content><![CDATA[<h1 id="insert-or-merge"><a class="markdownIt-Anchor" href="#insert-or-merge"></a> Insert or Merge</h1>
<p>According to Wikipedia:<br>
Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.<br>
Merge sort works as follows: Divide the unsorted list into N sublists, each containing 1 element (a list of 1 element is considered sorted). Then repeatedly merge two adjacent sublists to produce new sorted sublists until there is only 1 sublist remaining.<br>
Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>. Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, print in the first line either “Insertion Sort” or &quot;Merge Sort&quot;to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resuling sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">Insertion Sort
1 2 3 5 7 8 9 4 6 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">Merge Sort
1 2 3 8 4 5 7 9 0 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>本题关键在于对插入排序和归并排序的理解，并不一定定需要对依次对整个排序过程完全模拟</p>
<h3 id="插入排序特点"><a class="markdownIt-Anchor" href="#插入排序特点"></a> 插入排序特点</h3>
<ul>
<li>已经排好序的部分呈现为递增，并且从头开始直到非递增的部分以后就是未排序的，未排序的部分与原始序列相同
<ul>
<li>实际上是向一个空序列中每次添加一个元素，然后对这个序列进行排序)</li>
</ul>
</li>
</ul>
<h3 id="归并排序特点"><a class="markdownIt-Anchor" href="#归并排序特点"></a> 归并排序特点</h3>
<ul>
<li>以length=1开始进行分组(实际上length为2才涉及到排序的问题)，然后将排好序的组合并后再两两归并
<ul>
<li>直到最终合并为一个单一的序列(length=n)</li>
<li>题干声明本题有唯一解，所以在归并过程中一定会出现与partial result相同的序列</li>
</ul>
</li>
</ul>
<h3 id="如何区分简单插入排序和非递归的归并排序"><a class="markdownIt-Anchor" href="#如何区分简单插入排序和非递归的归并排序"></a> 如何区分简单插入排序和非递归的归并排序</h3>
<ul>
<li>插入排序：前面有序，后面没变化</li>
<li>归并排序：分段有序(每个固定长度的归并段内均有序)</li>
</ul>
<h3 id="捏软柿子算法"><a class="markdownIt-Anchor" href="#捏软柿子算法"></a> “捏软柿子”算法</h3>
<ul>
<li>判断是否插入排序
<ul>
<li>从左向右扫描，直到发现顺序不对，跳出循环</li>
<li>从跳出地点继续向右扫描，与原序列比对，发现不同则判断为“非”</li>
<li>循环自然结束，则判断为“是”，返回跳出地点</li>
</ul>
</li>
<li>如果是插入排序的话，则从跳出地点开始进行一趟插入</li>
</ul>
<h3 id="判断归并段的长度"><a class="markdownIt-Anchor" href="#判断归并段的长度"></a> 判断归并段的长度</h3>
<ul>
<li>从头开始连续有序的子列长度
<ul>
<li>反例：如果从开始扫描的话得出的归并段长度为4(1,2,8,9)，但是明显后面以4为归并长度的子列不是有序的</li>
</ul>
</li>
</ul>
<blockquote>
<p>2 1 8 9 6 5 3 4<br>
1 2 8 9 5 6 3 4</p>
</blockquote>
<ul>
<li>所有连续有序子列的最短长度？
<ul>
<li>反例：这种情况续有序子列的最短长度为2(5,10)，但从一个子段来看归并长度明显应该是4，之所以因为最后的子列元素没满。另外，即使不算最后一个子列，这种情况依然错误，因为这个算法是找最短长度，所以几乎一定会是2或1</li>
</ul>
</li>
</ul>
<blockquote>
<p>4 2 1 3 13 14 12 11 8 9 7 6 10 5<br>
1 2 3 4 11 12 13 14 6 7 8 9 5 10</p>
</blockquote>
<ul>
<li>从原始序列出发，模拟归并排序并跟原始序列相比较，直到与原序列相等后再做一次归并
<ul>
<li>for(l=2;l&lt;=N;l*=2);</li>
<li>由于题目中给出的是排序过程中的结果，因此对于归并排序来说一般第一趟归并长度是2，所以每两个一组的数据一定是有序的</li>
<li>继续判断归并段长度，判断在每两个一组的情况下组间是否有序，以1 2 3 4 11 12 13 14 6 7 8 9 5 10为例
<ul>
<li>判断(2,3)，(12,13)，(7,8)之间是否有序，如果有序说明归并段长度为4也满足</li>
<li>同理，继续往下判断归并段长度为8,……的情况</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试数据"><a class="markdownIt-Anchor" href="#测试数据"></a> 测试数据</h3>
<ul>
<li>最小N的情况
<ul>
<li>由于题目中明确了数据可以区分插入排序和归并排序，因此N最小为4</li>
<li>插入排序的第1步，此时什么都没改变，与原序列相同</li>
<li>归并排序的第1步，所有都变了</li>
</ul>
</li>
<li>尾部子列没有变化，但是前面变了的情况
<ul>
<li>这种属于归并排序的情况，因此本题无法使用从后往前扫描发现顺序没变就认为是插入排序的算法(这种算法本来就完全错误)</li>
<li>最大N的情况</li>
</ul>
</li>
</ul>
<h2 id="ac代码转"><a class="markdownIt-Anchor" href="#ac代码转"></a> ac代码(转)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define maxcount 105
using namespace std;
int n,initial[maxcount],partial[maxcount];
void IorM();
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;initial[i];
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;partial[i];
    IorM();
    for(int i&#x3D;0;i&lt;n-1;i++)cout&lt;&lt;initial[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;initial[n-1];
&#125;
void IorM()&#123;
    int i,j;        
    for(i&#x3D;1;i&lt;n&amp;&amp;partial[i-1]&lt;&#x3D;partial[i];i++);     &#x2F;&#x2F;注意i的取值，这种情况下i取到的是正好是递增结束元素的下标
    for(j&#x3D;i;j&lt;n&amp;&amp;partial[j]&#x3D;&#x3D;initial[j];j++);       &#x2F;&#x2F;检查非递增部分partial是否和intial相同，如果相同说明是插入排序
    if(j&#x3D;&#x3D;n)&#123;
        cout&lt;&lt;&quot;Insertion Sort&quot;&lt;&lt;endl;
        sort(initial,initial+i+1);                  &#x2F;&#x2F;对0到i+1的initial排序，即相当于在i的基础上再进行一次插入
    &#125;else&#123;
        cout&lt;&lt;&quot;Merge Sort&quot;&lt;&lt;endl;
        int length&#x3D;1,flag&#x3D;1;                        &#x2F;&#x2F;设置flag信号，当flag&#x3D;1时说明结果还不相等，继续进行迭代
        while(flag)&#123;
            flag&#x3D;0;
            for(i&#x3D;0;i&lt;n;i++)if(initial[i]!&#x3D;partial[i])flag&#x3D;1;
            length*&#x3D;2;                              &#x2F;&#x2F;对length进行处理，每次循环乘2
            for(i&#x3D;0;i&lt;n&#x2F;length;i++)sort(initial+i*length,initial+(i+1)*length); &#x2F;&#x2F;对每个相邻的length长度的子列进行归并
            sort(initial+n&#x2F;length*length,initial+n); &#x2F;&#x2F;对最后一个剩余的元素数量不满的组进行归并
        &#125;
    &#125;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="insertion-or-heap-sort"><a class="markdownIt-Anchor" href="#insertion-or-heap-sort"></a> Insertion or Heap Sort</h1>
<p>According to Wikipedia:<br>
Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. Each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.<br>
Heap sort divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. It involves the use of a heap data structure rather than a linear-time search to find the maximum.<br>
Now given the initial sequence of integers, together with a sequence which is a result of several iterations of some sorting method, can you tell which sorting method we are using?</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>. Then in the next line, N integers are given as the initial sequence. The last line contains the partially sorted sequence of the N numbers. It is assumed that the target sequence is always ascending. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, print in the first line either “Insertion Sort” or “Heap Sort” to indicate the method used to obtain the partial result. Then run this method for one more iteration and output in the second line the resulting sequence. It is guaranteed that the answer is unique for each test case. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h2 id="sample-input-1-2"><a class="markdownIt-Anchor" href="#sample-input-1-2"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1-2"><a class="markdownIt-Anchor" href="#sample-output-1-2"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">Insertion Sort
1 2 3 5 7 8 9 4 6 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-input-2-2"><a class="markdownIt-Anchor" href="#sample-input-2-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 1 2 8 7 5 9 4 6 0
6 4 5 1 0 3 2 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2-2"><a class="markdownIt-Anchor" href="#sample-output-2-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">Heap Sort
5 4 3 1 0 2 6 7 8 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#define Maxcount 105
using namespace std;
int n,init[Maxcount],partial[Maxcount],insort[Maxcount],hesort[Maxcount];
void IorH(),percdown(int,int);
bool insertion(),heap();
int main(int argc,char*argv[])&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;init[i];
    for(int i&#x3D;0;i&lt;n;i++)insort[i]&#x3D;hesort[i]&#x3D;init[i];
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;partial[i];
    IorH();
&#125;
void IorH()&#123;
    if(insertion())&#123;
        cout&lt;&lt;&quot;Insertion Sort&quot;&lt;&lt;endl;
        for(int i&#x3D;0;i&lt;n-1;i++)cout&lt;&lt;insort[i]&lt;&lt;&#39; &#39;;
        cout&lt;&lt;insort[n-1]&lt;&lt;endl;
    &#125;else if(heap())&#123;
        cout&lt;&lt;&quot;Heap Sort&quot;&lt;&lt;endl;
        for(int i&#x3D;0;i&lt;n-1;i++)cout&lt;&lt;hesort[i]&lt;&lt;&#39; &#39;;
        cout&lt;&lt;hesort[n-1]&lt;&lt;endl;
    &#125;
&#125;
bool insertion()&#123;
    int i,j;
    for(i&#x3D;1;i&lt;n&amp;&amp;partial[i-1]&lt;&#x3D;partial[i];i++);
    for(j&#x3D;i;j&lt;n&amp;&amp;partial[j]&#x3D;&#x3D;init[j];j++);
    if(j&#x3D;&#x3D;n)&#123;
        sort(insort,insort+i+1);
        return true;
    &#125;
    return false;
&#125;
bool heap()&#123;
    for(int i&#x3D;n&#x2F;2-1;i&gt;&#x3D;0;i--)percdown(i,n);
    for(int i&#x3D;n-1;i&gt;0;i--)&#123;
        int j,tmp&#x3D;hesort[0];
        hesort[0]&#x3D;hesort[i],hesort[i]&#x3D;tmp;
        percdown(0,i);
        for(j&#x3D;0;j&lt;n&amp;&amp;hesort[j]&#x3D;&#x3D;partial[j];j++);
        if(j&#x3D;&#x3D;n)&#123;
            tmp&#x3D;hesort[0];
            hesort[0]&#x3D;hesort[i-1],hesort[i-1]&#x3D;tmp;
            percdown(0,i-1);
            return true;
        &#125;
    &#125;
    return false;
&#125;
void percdown(int root,int size)&#123;
    int parent,child,tmp&#x3D;hesort[root];
    for(parent&#x3D;root;parent*2+1&lt;size;parent&#x3D;child)&#123;
        child&#x3D;parent*2+1;
        if(hesort[child+1]&gt;hesort[child]&amp;&amp;child&lt;size-1)child++;
        if(tmp&gt;&#x3D;hesort[child])break;
        else hesort[parent]&#x3D;hesort[child];
    &#125;
    hesort[parent]&#x3D;tmp;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="sort-with-swap0-i"><a class="markdownIt-Anchor" href="#sort-with-swap0-i"></a> Sort with Swap(0, i)</h1>
<p>Given any permutation of the numbers {0, 1, 2,…, N−1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>
<blockquote>
<p>Swap(0, 1) =&gt; {4, 1, 2, 0, 3}<br>
Swap(0, 3) =&gt; {4, 1, 2, 3, 0}<br>
Swap(0, 4) =&gt; {0, 1, 2, 3, 4}</p>
</blockquote>
<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.</p>
<h2 id="input-specification-3"><a class="markdownIt-Anchor" href="#input-specification-3"></a> Input Specification</h2>
<p>Each input file contains one test case, which gives a positive <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> followed by a permutation sequence of {0, 1, …, N−1}. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification-3"><a class="markdownIt-Anchor" href="#output-specification-3"></a> Output Specification</h2>
<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">10
3 5 7 2 6 4 9 0 8 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
<p>表排序的物理排序(将序列分为环，根据环数计算交换次数)</p>
<ul>
<li>在计算环时，要将已经纳入某个环中的数记录下来。如果每次都重复计算的话可能会超时</li>
<li>环的分类
<ul>
<li>序列中只有单元环(没有多元环，此时每个数都已经在自己的位置上，不需要交换)</li>
<li>序列中只有一个多元环(0一定在这个多元环中，此时只需计算环内的交换次数即可，不需要与别的环进行交换)
<ul>
<li>此时总交换次数=多元环内交换次数=多元环元素个数-1
<ul>
<li>多元环元素个数=n-单元环元素个数，因此总交换次数=n-single-1</li>
</ul>
</li>
</ul>
</li>
<li>序列中存在多个多元环，此时要先将0与其他多元环元素进行一次交换，相当于把多个多元环组合为一个大的多元环
<ul>
<li>多元环间交换次数=多元环个数-1</li>
<li>此时总交换次数=多元环间交换次数+大多元环元素交换次数=多元环个数-1+多元环元素个数-1
<ul>
<li>总交换次数=n-single-multiple-2</li>
</ul>
</li>
<li>0在第0个位置的时候，由于本题只能换0，所以必须将0换到其他的多元环中，此时0本身实际相当于一个多元环(multiple++)
<ul>
<li>存在一种特殊情况：序列没有其他多元环，此时不需要交换，0也不需要看作多元环</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define maxcount 105000
using namespace std;
int n,table[maxcount],flag[maxcount],swap0andi();
void swap(int*,int*);
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;table[i];
    cout&lt;&lt;swap0andi()&lt;&lt;endl;
&#125;
void swap(int*num1,int*num2)&#123;
    int tmp&#x3D;*num1;
    *num1&#x3D;*num2,*num2&#x3D;tmp;
&#125;
int swap0andi()&#123;
    int right&#x3D;0,tmp,circle&#x3D;0;
    for(int i&#x3D;1;i&lt;n;i++)if(table[i]&#x3D;&#x3D;i)flag[i]&#x3D;1,right++;
    if(!table[0]&amp;&amp;right&lt;n-1)&#123;
        for(tmp&#x3D;1;tmp&lt;n&amp;&amp;flag[tmp];tmp++);
        swap(table[0],table[tmp]);
        circle++;
    &#125;
    for(int i&#x3D;0;i&lt;n;i++)if(!flag[i])&#123;
        tmp&#x3D;i,flag[tmp]&#x3D;1;
        for(int j&#x3D;table[tmp];j!&#x3D;tmp;j&#x3D;table[j])flag[j]&#x3D;1;
        circle++;
    &#125;
    if(circle&#x3D;&#x3D;0)return 0;
    else if(circle&#x3D;&#x3D;1)return n-right-1;
    else return n-right+circle-2;
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>14.公路村村通、关键活动、How Long Does It Take</title>
    <url>/posts/fb2aa5920eaa</url>
    <content><![CDATA[<h1 id="公路村村通"><a class="markdownIt-Anchor" href="#公路村村通"></a> 公路村村通</h1>
<p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入数据包括城镇数目正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>和候选道路数目<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>3</mn><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M(≤3N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出−1，表示需要建设更多公路。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">6 15
1 2 5
1 3 3
1 4 7
1 5 4
1 6 2
2 3 4
2 4 6
2 5 2
2 6 6
3 4 6
3 5 1
3 6 1
4 5 10
4 6 8
5 6 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">12<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;(prim版本)
#include&lt;iostream&gt;
#define INFINITY 65535
#define MaxVertexNum 1005
using namespace std;
int G[MaxVertexNum][MaxVertexNum],dist[MaxVertexNum],nv,ne,findmindist();
void buildgraph(),prim();
int main()&#123;
    cin&gt;&gt;nv&gt;&gt;ne;
    buildgraph();
    prim();
&#125;
void buildgraph()&#123;
    int v1,v2;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)for(int j&#x3D;1;j&lt;&#x3D;nv;j++)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;0;i&lt;ne;i++)&#123;
        cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;G[v1][v2];
        G[v2][v1]&#x3D;G[v1][v2];
    &#125;
&#125;
int findmindist()&#123;
    int mindist&#x3D;INFINITY,mini&#x3D;-1;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(dist[i]&amp;&amp;dist[i]&lt;mindist)mindist&#x3D;dist[i],mini&#x3D;i;
    if(mindist&lt;INFINITY)return mini;
    return -1;
&#125;
void prim()&#123;
    int totalweight&#x3D;0,count&#x3D;0;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)dist[i]&#x3D;G[1][i];
    dist[1]&#x3D;0,count++;
    while(true)&#123;
        int v&#x3D;findmindist();
        if(v&lt;0)break;
        totalweight+&#x3D;dist[v],count++;
        dist[v]&#x3D;0;
        for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(dist[i]&amp;&amp;G[v][i]&lt;INFINITY)
            if(dist[i]&gt;G[v][i])dist[i]&#x3D;G[v][i];
    &#125;
    if(count&lt;nv)cout&lt;&lt;-1;
    else cout&lt;&lt;totalweight;
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;(kruskal版本)
#include&lt;iostream&gt;
#define MaxVertexNum 1005
using namespace std;
typedef struct&#123;
    int v1,v2,price;
&#125;road;
road roads[MaxVertexNum*3];
int nv,ne,set[MaxVertexNum],findset(int*,int),cmp(const void*,const void*);
void initedge(),kruskal(),unionset(int,int);
int main()&#123;
    cin&gt;&gt;nv&gt;&gt;ne;
    initedge();
    kruskal();
&#125;
void initedge()&#123;
    for(int i&#x3D;0;i&lt;ne;i++)cin&gt;&gt;roads[i].v1&gt;&gt;roads[i].v2&gt;&gt;roads[i].price;
&#125;
int cmp(const void*a,const void*b)&#123;
    return((road*)a)-&gt;price-((road*)b)-&gt;price;
&#125;
int findset(int*set,int x)&#123;
    if(set[x]&lt;0)return x;
    return set[x]&#x3D;findset(set,set[x]);
&#125;
void unionset(int root1,int root2)&#123;
    if(set[root1]&gt;set[root2])&#123;
        set[root2]+&#x3D;set[root1];
        set[root1]&#x3D;root2;
    &#125;else&#123;
        set[root1]+&#x3D;set[root2];
        set[root2]&#x3D;root1;
    &#125;
&#125;
void kruskal()&#123;
    int count&#x3D;0,totalweight&#x3D;0;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)set[i]&#x3D;-1;
    qsort(roads,ne,sizeof(road),cmp);
    for(int i&#x3D;0;i&lt;ne&amp;&amp;count&lt;nv-1;i++)&#123;
        int root1&#x3D;findset(set,roads[i].v1),root2&#x3D;findset(set,roads[i].v2);
        if(root1!&#x3D;root2)&#123;
            unionset(root1,root2);
            count++,totalweight+&#x3D;roads[i].price;
        &#125;
    &#125;
    if(count&lt;nv-1)cout&lt;&lt;-1;
    else cout&lt;&lt;totalweight;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="关键活动"><a class="markdownIt-Anchor" href="#关键活动"></a> 关键活动</h1>
<p>假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和C程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如C程序设计和数据结构两门课，必须先学习前者。但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务A依赖于子任务B，子任务B依赖于子任务C，子任务C又依赖于子任务A”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。<br>
任务调度问题中，如果还给出了完成每个子任务需要的时间，则我们可以算出完成整个工程需要的最短时间。在这些子任务中，有些任务即使推迟几天完成，也不会影响全局的工期；但是有些任务必须准时完成，否则整个项目的工期就要因此延误，这种任务就叫“关键活动”。请编写程序判定一个给定的工程项目的任务调度是否可行；如果该调度方案可行，则计算完成整个工程项目需要的最短时间，并输出所有的关键活动。</p>
<h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h2>
<p>输入第1行给出两个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>和M，其中N是任务交接点（即衔接相互依赖的两个子任务的节点，例如：若任务2要在任务1完成后才开始，则两任务之间必有一个交接点）的数量。交接点按1~N编号，M是子任务的数量，依次编号为1~M。随后M行，每行给出了3个正整数，分别是该任务开始和完成涉及的交接点编号以及该任务所需的时间，整数间用空格分隔。</p>
<h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h2>
<p>如果任务调度不可行，则输出0；否则第1行输出完成整个工程项目需要的时间，第2行开始输出所有关键活动，每个关键活动占一行，按格式“V-&gt;W”输出，其中V和W为该任务开始和完成涉及的交接点编号。关键活动输出的顺序规则是：任务开始的交接点编号小者优先，起点编号相同时，与输入时任务的顺序相反。</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">7 8
1 2 4
1 3 3
2 4 5
3 4 3
4 5 1
4 6 6
5 7 5
6 7 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">17
1-&gt;2
2-&gt;4
4-&gt;6
6-&gt;7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;
#define MaxVertexNum 105
#define INFINITY 65535
using namespace std;
int nv,ne,maxve,G[MaxVertexNum][MaxVertexNum],indegree[MaxVertexNum],ve[MaxVertexNum],vl[MaxVertexNum];
typedef struct&#123;
    int start,end,ee,el;
&#125;activity;
vector&lt;activity&gt;project;
void buildgraph(),crticlepath();
bool toposort();
int main()&#123;
    cin&gt;&gt;nv&gt;&gt;ne;
    buildgraph();
    crticlepath();
&#125;
void buildgraph()&#123;
    int start,end;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)for(int j&#x3D;1;j&lt;&#x3D;nv;j++)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;0;i&lt;ne;i++)&#123;
        cin&gt;&gt;start&gt;&gt;end&gt;&gt;G[start][end];
        activity act;
        act.start&#x3D;start,act.end&#x3D;end;
        project.push_back(act);
    &#125;
&#125;
bool toposort()&#123;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)for(int j&#x3D;1;j&lt;&#x3D;nv;j++)if(G[i][j]&lt;INFINITY)indegree[j]++;
    queue&lt;int&gt;q;
    stack&lt;int&gt;s;
    int count&#x3D;0;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(!indegree[i])q.push(i);
    while(!q.empty())&#123;
        int v&#x3D;q.front();
        s.push(v),q.pop(),count++;
        for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(G[v][i]&lt;INFINITY)&#123;
            if(!--indegree[i])q.push(i);
            if(ve[i]&lt;ve[v]+G[v][i])ve[i]&#x3D;ve[v]+G[v][i];
        &#125;
    &#125;
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(ve[i]&gt;maxve)maxve&#x3D;ve[i];
    for(int i&#x3D;1;i&lt;&#x3D;nv;i++)vl[i]&#x3D;maxve;
    while(!s.empty())&#123;
        int v&#x3D;s.top();
        s.pop();
        for(int i&#x3D;1;i&lt;&#x3D;nv;i++)if(G[v][i]&lt;INFINITY)
            if(vl[v]&gt;vl[i]-G[v][i])vl[v]&#x3D;vl[i]-G[v][i];
    &#125;
    if(count&lt;nv-1)return false;
    return true;
&#125;
void crticlepath()&#123;
    if(toposort())&#123;
        activity tmp;
        cout&lt;&lt;maxve&lt;&lt;endl;
        for(auto &amp;i:project)i.ee&#x3D;ve[i.start],i.el&#x3D;vl[i.end]-G[i.start][i.end];
        for(int i&#x3D;1;i&lt;project.size();i++)for(int j&#x3D;0;j&lt;project.size()-i;j++)
            if(project[j].start&gt;project[j+1].start)tmp&#x3D;project[j],project[j]&#x3D;project[j+1],project[j+1]&#x3D;tmp;
        for(int i&#x3D;1;i&lt;project.size();i++)if(project[i].start&#x3D;&#x3D;project[i+1].start)
            tmp&#x3D;project[i],project[i]&#x3D;project[i+1],project[i+1]&#x3D;tmp;
        for(auto i:project)if(i.ee&#x3D;&#x3D;i.el)cout&lt;&lt;i.start&lt;&lt;&quot;-&gt;&quot;&lt;&lt;i.end&lt;&lt;endl;
    &#125;else cout&lt;&lt;0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="how-long-does-it-take"><a class="markdownIt-Anchor" href="#how-long-does-it-take"></a> How Long Does It Take</h1>
<p>Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of activity check points (hence it is assumed that the check points are numbered from 0 to N−1), and M, the number of activities. Then M lines follow, each gives the description of an activity. For the i-th activity, three non-negative numbers are given: S[i], E[i], and L[i], where S[i] is the index of the starting check point, E[i] of the ending check point, and L[i] the lasting time of the activity. The numbers in a line are separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">9 12
0 1 6
0 2 4
0 3 5
1 4 1
2 4 1
3 5 2
5 4 0
4 6 9
4 7 7
5 7 4
6 8 2
7 8 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">18<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">4 5
0 1 1
0 2 2
2 1 3
1 3 4
3 2 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2:</h2>
<pre class="line-numbers language-none"><code class="language-none">Impossible<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#define INFINITY 65535
#define MaxVertexNum 105
using namespace std;
int G[MaxVertexNum][MaxVertexNum],ve[MaxVertexNum],indegree[MaxVertexNum],nv,ne;
void buildgraph(),topsort();
int main()&#123;
    cin&gt;&gt;nv&gt;&gt;ne;
    buildgraph();
    topsort();
&#125;
void buildgraph()&#123;
    int v1,v2;
    for(int i&#x3D;0;i&lt;nv;i++)for(int j&#x3D;0;j&lt;nv;j++)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;0;i&lt;ne;i++)cin&gt;&gt;v1&gt;&gt;v2&gt;&gt;G[v1][v2];
&#125;
void topsort()&#123;
    int count&#x3D;0,comptime&#x3D;0;
    queue&lt;int&gt;q;
    for(int i&#x3D;0;i&lt;nv;i++)for(int j&#x3D;0;j&lt;nv;j++)if(G[i][j]&lt;INFINITY)indegree[j]++;
    for(int i&#x3D;0;i&lt;nv;i++)if(!indegree[i])q.push(i);
    while(!q.empty())&#123;
        int v&#x3D;q.front();
        q.pop(),count++;
        for(int i&#x3D;0;i&lt;nv;i++)if(G[v][i]&lt;INFINITY)&#123;
            if(!--indegree[i])q.push(i);
            if(ve[i]&lt;ve[v]+G[v][i])ve[i]&#x3D;ve[v]+G[v][i];
        &#125;
    &#125;
    if(count&lt;nv-1)cout&lt;&lt;&quot;Impossible&quot;;
    else&#123;
        for(int i&#x3D;0;i&lt;nv;i++)if(ve[i]&gt;comptime)comptime&#x3D;ve[i];
        cout&lt;&lt;comptime;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>13.Subway Map、Public Bike Management</title>
    <url>/posts/46af663a24e4</url>
    <content><![CDATA[<h1 id="subway-map"><a class="markdownIt-Anchor" href="#subway-map"></a> Subway Map</h1>
<p>In the big cities, the subway systems always look so complex to the visitors. To give you some sense, the following figure shows the map of Beijing subway. Now you are supposed to help people with your computer skills! Given the starting position of your user, your task is to find the quickest way to his/her destination.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤ 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of subway lines. Then N lines follow, with the i-th (i=1,⋯,N) line describes the i-th subway line in the format:</p>
<blockquote>
<p>M S[1] S[2] … S[M]</p>
</blockquote>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤ 100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> is the number of stops, and S[i]'s (i=1,⋯,M) are the indices of the stations (the indices are 4-digit numbers from 0000 to 9999) along the line. It is guaranteed that the stations are given in the correct order – that is, the train travels between S[i] and S[i+1] (i=1,⋯,M−1) without any stop. Note: It is possible to have loops, but not self-loop (no train starts from S and stops at S without passing through another station).<br>
Each station interval belongs to a unique subway line. Although the lines may cross each other at some stations (so called “transfer stations”), no station can be the conjunction of more than 5 lines. After the description of the subway, another positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤ 10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> is given. Then K lines follow, each gives a query from your user: the two indices as the starting station and the destination, respectively. The following figure shows the sample map. Note: It is guaranteed that all the stations are reachable, and all the queries consist of legal station numbers.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each query, first print in a line the minimum number of stops. Then you are supposed to show the optimal path in a friendly format as the following:</p>
<blockquote>
<p>Take Line#X1 from S1 to S2.<br>
Take Line#X2 from S2 to S3.<br>
…</p>
</blockquote>
<p>where Xi’s are the line numbers and Si’s are the station indices. Note: Besides the starting and ending stations, only the transfer stations shall be printed.<br>
If the quickest path is not unique, output the one with the minimum number of transfers, which is guaranteed to be unique.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">4
7 1001 3212 1003 1204 1005 1306 7797
9 9988 2333 1204 2006 2005 2004 2003 2302 2001
13 3011 3812 3013 3001 1306 3003 2333 3066 3212 3008 2302 3010 3011
4 6666 8432 4011 1306
3
3011 3013
6666 2001
2004 3001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">2
Take Line#3 from 3011 to 3013.
10
Take Line#4 from 6666 to 1306.
Take Line#3 from 1306 to 2302.
Take Line#2 from 2302 to 2001.
6
Take Line#2 from 2004 to 1204.
Take Line#1 from 1204 to 1306.
Take Line#3 from 1306 to 3001.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;unordered_map&gt;
#include&lt;vector&gt;
#define INFINITY 65535
using namespace std;
unordered_map&lt;int,int&gt;lines;           &#x2F;&#x2F;路线map
bool visited[10100];                   &#x2F;&#x2F;记录站点是否访问过
vector&lt;int&gt;path,tempath;               &#x2F;&#x2F;最终路径和每次dfs的备选路径
vector&lt;vector&lt;int&gt;&gt;v(10100);           &#x2F;&#x2F;图
int mincnt,mintransfer,Start,End,n;    &#x2F;&#x2F;最少途径站点数、最少换乘次数、起点、终点、路线条数
void buildgraph();
int transfercnt(vector&lt;int&gt;);          &#x2F;&#x2F;该函数用于求解换乘次数，参数传入的值为备选路径tempath
void SubwayMap();
void dfs(int,int);
&#x2F;&#x2F; DFS是一个递归函数，考虑递归边界和递归式，
&#x2F;&#x2F; 递归边界就是到达起点，而递归式更新mincnt和mintransfer以及选择最优路径
&#x2F;&#x2F; 用tempPath来存放最短的路径，在访问v顶点时就可以把该顶点加入到tempPath中，执行递归式
&#x2F;&#x2F; 注意之前需要将起点也加入到tempPath中
int main()&#123;
    cin&gt;&gt;n;
    buildgraph();
    SubwayMap();
    return 0;
&#125;
void buildgraph()&#123;
    int m,pre,temp;
    for(int i&#x3D;0;i&lt;n;i++)&#123;              &#x2F;&#x2F;建图
        cin&gt;&gt;m&gt;&gt;pre;                   &#x2F;&#x2F;输入每条路线的站点数m和第一个站点pre
        for(int j&#x3D;1;j&lt;m;j++)&#123;          &#x2F;&#x2F;输入剩下的m-1个站点temp
            cin&gt;&gt;temp;
            v[pre].push_back(temp);    &#x2F;&#x2F;将pre和temp之间相互增加一条边
            v[temp].push_back(pre);
            lines[pre*10000+temp]&#x3D;lines[temp*10000+pre]&#x3D;i+1;
            &#x2F;&#x2F;记录路线，map第一个关键字前四位为第一个站点，后四位为第二个站点，第二个关键字代表第几条路线
            pre&#x3D;temp;                  &#x2F;&#x2F;将temp换为pre，从而将路线上的每两个站点之间增加一条边
        &#125;
    &#125;
&#125;
void SubwayMap()&#123;
    int k;
    cin&gt;&gt;k;                            &#x2F;&#x2F;输入query个数
    for(int i&#x3D;0;i&lt;k;i++)&#123;
        cin&gt;&gt;Start&gt;&gt;End;               &#x2F;&#x2F;输入每个query中的起点和终点
        mincnt&#x3D;mintransfer&#x3D;INFINITY;   &#x2F;&#x2F;初始化mincnt和mintransfer
        tempath.clear();               &#x2F;&#x2F;清空
        tempath.push_back(Start);      &#x2F;&#x2F;先将起点压入tempath
        visited[Start]&#x3D;true;           &#x2F;&#x2F;将起点标记为已访问
        dfs(Start,0);                  &#x2F;&#x2F;dfs求解最优路径
        visited[Start]&#x3D;false;          &#x2F;&#x2F;将起点重新标记为false，准备求解下一个query
        cout&lt;&lt;mincnt&lt;&lt;endl;            &#x2F;&#x2F;输出最少途经站点
        int preline&#x3D;0,pretransfer&#x3D;Start;&#x2F;&#x2F;定义两个变量用于输出当前路线和站点
        for(int j&#x3D;1;j&lt;path.size();j++)if(lines[path[j-1]*10000+path[j]]!&#x3D;preline)&#123;
        &#x2F;&#x2F;如果上一组路线与当前路线不同，按要求的格式输出
                if(preline)printf(&quot;Take Line#%d from %04d to %04d.\n&quot;,preline,pretransfer,path[j-1]);
                preline&#x3D;lines[path[j-1]*10000+path[j]],pretransfer&#x3D;path[j-1];
            &#125;
        printf(&quot;Take Line#%d from %04d to %04d.\n&quot;,preline,pretransfer,End);&#x2F;&#x2F;最后输出到终点的那一条边
    &#125;
&#125;
void dfs(int node,int cnt)&#123;
    if(node&#x3D;&#x3D;End)&#123;
        if(cnt&lt;mincnt||(cnt&#x3D;&#x3D;mincnt&amp;&amp;transfercnt(tempath)&lt;mintransfer))
            mincnt&#x3D;cnt,mintransfer&#x3D;transfercnt(tempath),path&#x3D;tempath;
        return;
        &#x2F;&#x2F;递归出口为node等于终点，同时更新mincnt和mintransfer，选出途径路径和换成次数最少的路径
    &#125;
    for(int i:v[node])if(!visited[i])&#123;&#x2F;&#x2F;遍历图中未访问站点i，注意这里遍历的是图v的第一个下标
            visited[i]&#x3D;true;          
            tempath.push_back(i);     &#x2F;&#x2F;将i压入tempath
            dfs(i,cnt+1);             &#x2F;&#x2F;递归，途经站点数cnt+1
            visited[i]&#x3D;false;
            tempath.pop_back();       &#x2F;&#x2F;递归结束后将站点重新设置为未访问，并弹出tempath，准备求解下一个query
    &#125;
&#125;
int transfercnt(vector&lt;int&gt;a)&#123;
&#x2F;&#x2F;该函数用于求解换乘次数，a传入的值为备选路径tempath
    int cnt&#x3D;-1,preline&#x3D;0;             &#x2F;&#x2F;换乘次数初始化为-1
    for(int i&#x3D;1;i&lt;a.size();i++)&#123;
        if(lines[a[i-1]*10000+a[i]]!&#x3D;preline)cnt++;&#x2F;&#x2F;每当tempath中相邻两个站点之间的路线与preline不等时换乘次数+1
        preline&#x3D;lines[a[i-1]*10000+a[i]];&#x2F;&#x2F;preline更新为上一组站点的路线
    &#125;
    return cnt;                      &#x2F;&#x2F;返回换乘次数
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="public-bike-management"><a class="markdownIt-Anchor" href="#public-bike-management"></a> Public Bike Management</h1>
<p>There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city. The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well. When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S3, we have 2 different shortest paths:</p>
<blockquote>
<p>PBMC -&gt; S1-&gt; S3.</p>
</blockquote>
<p>In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S1and then take 5 bikes to S3, so that both stations will be in perfect conditions.</p>
<blockquote>
<p>PBMC -&gt; S2-&gt; S3.</p>
</blockquote>
<p>This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 4 numbers: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Cmax(≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, always an even number, is the maximum capacity of each station; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of stations; Sp, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers Ci(i=1,⋯,N) where each Ci is the current number of bikes at Si respectively. Then M lines follow, each contains 3 numbers:</p>
<blockquote>
<p>Si, Sj, and Tij</p>
</blockquote>
<p>which describe the time Tij taken to move betwen stations Si and Sj. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format:</p>
<blockquote>
<p>0−&gt;S1−&gt;⋯−&gt;Sp.</p>
</blockquote>
<p>Finally after another space, output the number of bikes that we must take back to PBMC after the condition of Sp is adjusted to perfect. Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">10 3 3 5
6 7 0
0 1 1
0 2 1
0 3 3
1 3 1
2 3 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">3 0-&gt;2-&gt;3 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>求给定源点和终点之间的最短距离</p>
<ul>
<li>坑点1：三个标尺，标尺一为dist(源点和终点之间的时间花销最短)，标尺二和三分别为从pbmc发出和回收的自行车数量最少</li>
<li>坑点2：发出和回收是按沿途站点依次进行的，因此路径上回收到的自行车只能补充后面的站点，不能补充前面的站点</li>
<li>坑点3：最少发出和回收数量minsend和minback不符合最优子结构，不可以用dijkstra直接求解
<ul>
<li>即后一个结点的状态不可能由前面的结点推出，不是简单的线性相加关系)</li>
</ul>
</li>
<li>因此本题考虑用dijkstra+dfs的方法求解，djkstra计算dist最短的路径，dfs选择minsend和minback</li>
</ul>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;
#define MaxVertexNum 550
#define INFINITY 65535
using namespace std;
int capacity,stations,pstation,roads,minsend,minback,
    G[MaxVertexNum][MaxVertexNum],dist[MaxVertexNum];
vector&lt;int&gt;pre[MaxVertexNum],path,tempath;
double station[MaxVertexNum];
bool collected[MaxVertexNum]&#x3D;&#123;false&#125;;
void buildgraph();
void pbm();
void dijkstra(int);
void dfs(int);
int findmindist();
int main(int argc,char*argv[])&#123;
    cin&gt;&gt;capacity&gt;&gt;stations&gt;&gt;pstation&gt;&gt;roads;
    buildgraph();
    pbm();
&#125;
void buildgraph()&#123;
    int s,e,t;
    for(int i&#x3D;0;i&lt;&#x3D;stations;i++)for(int j&#x3D;0;j&lt;&#x3D;stations;j++)if(i!&#x3D;j)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;1;i&lt;&#x3D;stations;i++)&#123;
        cin&gt;&gt;station[i];
        station[i]-&#x3D;capacity&#x2F;2.0;
    &#125;
    for(int i&#x3D;0;i&lt;roads;i++)&#123;
        cin&gt;&gt;s&gt;&gt;e&gt;&gt;t;
        G[s][e]&#x3D;G[e][s]&#x3D;t;
    &#125;
&#125;
void pbm()&#123;
    minsend&#x3D;minback&#x3D;INFINITY;
    stack&lt;int&gt;stk;
    dijkstra(0);
    dfs(pstation);
    cout&lt;&lt;minsend&lt;&lt;&#39; &#39;;
    for(int i:path)stk.push(i);
    while(stk.size()&gt;1)&#123;
        cout&lt;&lt;stk.top()&lt;&lt;&quot;-&gt;&quot;;
        stk.pop();
    &#125;
    cout&lt;&lt;pstation&lt;&lt;&#39; &#39;&lt;&lt;minback&lt;&lt;endl;
&#125;
void dijkstra(int s)&#123;
    for(int i&#x3D;0;i&lt;&#x3D;stations;i++)&#123;
        dist[i]&#x3D;G[s][i];
        if((double)G[s][i]&lt;INFINITY)pre[i].push_back(s);
    &#125;
    dist[s]&#x3D;0,collected[s]&#x3D;true;
    while(true)&#123;
        int v&#x3D;findmindist();
        if(v&lt;0)break;
        collected[v]&#x3D;true;
        for(int i&#x3D;0;i&lt;&#x3D;stations;i++)if(!collected[i]&amp;&amp;(double)G[v][i]&lt;INFINITY)&#123;
            if(dist[i]&gt;dist[v]+G[v][i])&#123;
                dist[i]&#x3D;dist[v]+G[v][i];
                pre[i].clear(),pre[i].push_back(v);
            &#125;else if(dist[i]&#x3D;&#x3D;dist[v]+G[v][i])pre[i].push_back(v);
        &#125;
    &#125;
&#125;
int findmindist()&#123;
    int mind&#x3D;INFINITY,mini&#x3D;-1;
    for(int i&#x3D;0;i&lt;&#x3D;pstation;i++)if(!collected[i]&amp;&amp;mind&gt;dist[i])
        mind&#x3D;dist[i],mini&#x3D;i;
    if((double)mind&lt;INFINITY)return mini;
    return -1;
&#125;
void dfs(int node)&#123;
    tempath.push_back(node);
    if(node&#x3D;&#x3D;0)&#123;
        int thisend&#x3D;0,thisback&#x3D;0;
        for(int i&#x3D;(int)tempath.size()-1;i&gt;&#x3D;0;i--)&#123;
            int id&#x3D;tempath[i];
            if(station[id]&gt;0)thisback+&#x3D;(int)station[id];
            else&#123;
                if(thisback+station[id]&gt;&#x3D;0)thisback+&#x3D;(int)station[id];
                else thisend-&#x3D;(int)(thisback+station[id]),thisback&#x3D;0;
            &#125;
        &#125;
        if(minsend&gt;thisend||(minsend&#x3D;&#x3D;thisend&amp;&amp;minback&gt;thisback))
            minsend&#x3D;thisend,minback&#x3D;thisback,path&#x3D;tempath;
        tempath.pop_back();
        return;
    &#125;
    for(int i:pre[node])dfs(i);
    tempath.pop_back();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>12.救邦德复杂版、Gas Station、条条大路通罗马</title>
    <url>/posts/77fbe98da0de</url>
    <content><![CDATA[<h1 id="saving-james-bond-hard-version"><a class="markdownIt-Anchor" href="#saving-james-bond-hard-version"></a> Saving James Bond - Hard Version</h1>
<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x,y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">17 15
10 -21
10 21
-40 10
30 -50
20 40
35 10
0 -10
-25 22
40 -40
-30 30
-10 22
0 11
25 21
25 10
10 10
10 35
-30 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">4
0 11
10 21
10 35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">4 13
-12 12
12 12
-12 -12
12 -12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="参考代码"><a class="markdownIt-Anchor" href="#参考代码"></a> 参考代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;stack&gt;
#define MaxVertexNum 101
using namespace std;
typedef struct Point&#123;
    int x,y;
&#125;point;
double G[MaxVertexNum][MaxVertexNum];
point P[MaxVertexNum];
void Dijikstra(int,int,int),BuildGraph(int,int),Save007(int,int);
double canjump(point,point,int),dist[MaxVertexNum]&#x3D;&#123;0&#125;;
int FindMindist(int),path[MaxVertexNum][MaxVertexNum];
bool canescape(point,int),firstjump(point,int),collected[MaxVertexNum]&#x3D;&#123;false&#125;;
int main(int argc,char*argv[]) &#123;
    int n,jump;
    cin&gt;&gt;n&gt;&gt;jump;
    BuildGraph(n,jump);
    Save007(n,jump);
&#125;
void BuildGraph(int n,int jump)&#123;
    int i,j;
    for(i&#x3D;1;i&lt;&#x3D;n;i++)cin&gt;&gt;P[i].x&gt;&gt;P[i].y;
    for(i&#x3D;0;i&lt;&#x3D;n;i++)for(j&#x3D;0;j&lt;&#x3D;n;j++)if(i!&#x3D;j)G[i][j]&#x3D;INFINITY;
    for(i&#x3D;1;i&lt;&#x3D;n;i++)for(j&#x3D;1;j&lt;&#x3D;n;j++)if(i!&#x3D;j&amp;&amp;canjump(P[i],P[j],jump)!&#x3D;0)
                G[i][j]&#x3D;G[j][i]&#x3D;canjump(P[i],P[j],jump);
&#125;
void Save007(int n,int jump)&#123;
    int i,j,mini&#x3D;1,minj;
    stack&lt;int&gt; s;
    double mind&#x3D;INFINITY;
    for(i&#x3D;1;i&lt;&#x3D;n;i++)if(!collected[i]&amp;&amp;firstjump(P[i],jump))&#123;
            for(j&#x3D;1;j&lt;&#x3D;n;j++)dist[j]&#x3D;INFINITY;
            Dijikstra(i,n,jump);
            for(j&#x3D;1;j&lt;&#x3D;n;j++)if(canescape(P[j],jump)&amp;&amp;mind&gt;dist[j])mind&#x3D;dist[j],mini&#x3D;i,minj&#x3D;j;
    &#125;
    if(mind&lt;INFINITY)&#123;
        for(i&#x3D;minj;i!&#x3D;mini;i&#x3D;path[mini][i])s.push(i);
        s.push(mini);
        cout&lt;&lt;s.size()+1&lt;&lt;endl;
        while(!s.empty())&#123;
            cout&lt;&lt;P[s.top()].x&lt;&lt;&#39; &#39;&lt;&lt;P[s.top()].y&lt;&lt;endl;
            s.pop();
        &#125;
    &#125;else cout&lt;&lt;0&lt;&lt;endl;
&#125;
bool firstjump(point p,int jump)&#123;
    return sqrt(pow(p.x,2)+pow(p.y,2))&lt;&#x3D;jump;
&#125;
bool canescape(point p,int jump)&#123;
    return (p.x+jump&gt;&#x3D;50||p.x-jump&lt;&#x3D;-50||p.y+jump&gt;&#x3D;50||p.y-jump&lt;&#x3D;-50);
&#125;
double canjump(point p1,point p2,int jump)&#123;
    double d;
    if((d&#x3D;(sqrt(pow(p1.x-p2.x,2)+pow(p1.y-p2.y,2))))&lt;&#x3D;jump)return d;
    return 0;
&#125;
int FindMindist(int n)&#123;
    double mindist&#x3D;INFINITY;
    int mini&#x3D;1;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(!collected[i]&amp;&amp;dist[i]&lt;mindist)
        mindist&#x3D;dist[i],mini&#x3D;i;
    if(mindist&lt;INFINITY)return mini;
    else return -1;
&#125;
void Dijikstra(int s,int n,int jump)&#123;
    int count&#x3D;2;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
        dist[i]&#x3D;G[s][i];
        if(dist[i]&lt;INFINITY)path[s][i]&#x3D;s;
        else path[s][i]&#x3D;-1;
    &#125;
    dist[s]&#x3D;0,collected[s]&#x3D;true;
    while(true)&#123;
        int v &#x3D; FindMindist(n);
        collected[v]&#x3D;true,count++;
        if (v &lt; 0)break;
        for (int i &#x3D; 1; i &lt;&#x3D; n; i++)
            if (!collected[i] &amp;&amp; G[v][i] &lt; INFINITY)
                if (dist[i] &gt; dist[v] + G[v][i]) &#123;
                    dist[i] &#x3D; dist[v] + G[v][i];
                    path[s][i] &#x3D; v;
                &#125;
    &#125;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="gas-station"><a class="markdownIt-Anchor" href="#gas-station"></a> Gas Station</h1>
<p>A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range. Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 4 positive integers: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the total number of houses; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the total number of the candidate locations for the gas stations; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the number of roads connecting the houses and the gas stations; and DS, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM.Then K lines follow, each describes a road in the format</p>
<blockquote>
<p>P1 P2 Dist</p>
</blockquote>
<p>where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output No Solution.</p>
<h2 id="sample-input-1-2"><a class="markdownIt-Anchor" href="#sample-input-1-2"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">4 3 11 5
1 2 2
1 4 2
1 G1 4
1 G2 3
2 3 2
2 G2 1
3 4 2
3 G3 2
4 G1 3
G2 G1 1
G3 G2 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1-2"><a class="markdownIt-Anchor" href="#sample-output-1-2"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">G1
2.0 3.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-input-2-2"><a class="markdownIt-Anchor" href="#sample-input-2-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">2 1 2 10
1 G1 9
2 G1 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2-2"><a class="markdownIt-Anchor" href="#sample-output-2-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">No Solution<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>本题输出的是Gas Station与全部居民楼中的最短距离中距离最长的候选点，Gas Station与居民楼的距离最长不能超过ds，否则直接淘汰该候选点。如果该距离相等的话找到其中距离居民楼的平均距离最短的候选点输出，两种距离都相等的话输出序号最小的那一个候选点。在计算Gas Station与居民楼距离的时候需要将m个候选Gas Station全部纳入图中，因为输入中给出了居民楼和候选地址之间的边，但是计算平局距离和最短距离时只能在Gas Station与居民楼的距离中计算。输入中存在字符’G’，因此存储输入的变量类型为char[]，因为n&lt;=1000，所以数组长度至少为4。</p>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#define MaxHouses 1000
#define MaxStation 10
#define INFINITY 65535
using namespace std;
int G[MaxHouses+MaxStation+1][MaxHouses+MaxStation+1],dist[MaxHouses+MaxStation+1];
bool collected[MaxHouses+MaxStation+1];
void Buildgraph(int,int,int,int);
void GasStation(int,int,int);
bool Dijkstra(int,int,int,int);
int FindMindist(int,int,int);
int main(int argc,char*argv[]) &#123;
    int n,m,k,ds;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;ds;
    Buildgraph(n,k,m,ds);
    GasStation(n,ds,m);
&#125;
void Buildgraph(int n,int k,int m,int ds)&#123;
    int g1,g2,l;char s1[5],s2[5];
    for(int i&#x3D;1;i&lt;&#x3D;n+m;i++)for(int j&#x3D;1;j&lt;&#x3D;n+m;j++)if(i!&#x3D;j)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;1;i&lt;&#x3D;k;i++)&#123;
        cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;l;
        g1&#x3D;(s1[0]&#x3D;&#x3D;&#39;G&#39;?atoi(s1+1)+n:atoi(s1));
        g2&#x3D;(s2[0]&#x3D;&#x3D;&#39;G&#39;?atoi(s2+1)+n:atoi(s2));
        G[g1][g2]&#x3D;G[g2][g1]&#x3D;l;
    &#125;
&#125;
void GasStation(int n,int ds,int m)&#123;
    double mina&#x3D;INFINITY;int mini&#x3D;0,mind&#x3D;0;
    for(int i&#x3D;n+1;i&lt;&#x3D;n+m;i++)&#123;
        for(int j&#x3D;1;j&lt;&#x3D;n+m;j++)collected[j]&#x3D;false;
        if(Dijkstra(n,m,i,ds))&#123;
            int min&#x3D;INFINITY;double ave&#x3D;0;
            for(int j&#x3D;1;j&lt;&#x3D;n;j++)&#123;
                ave+&#x3D;dist[j];
                if(min&gt;dist[j]&amp;&amp;i!&#x3D;j)min&#x3D;dist[j];
            &#125;
            ave&#x3D;ave&#x2F;n;
            if(mind&lt;min||(mind&#x3D;&#x3D;min&amp;&amp;mina&gt;ave))mina&#x3D;ave,mind&#x3D;min,mini&#x3D;i;
        &#125;
    &#125;
    if(mina&lt;INFINITY)&#123;
        cout&lt;&lt;&#39;G&#39;&lt;&lt;mini-n&lt;&lt;endl;
        printf(&quot;%.1f %.1f\n&quot;,(double)mind,mina);
    &#125;else cout&lt;&lt;&quot;No Solution&quot;&lt;&lt;endl;
&#125;
bool Dijkstra(int n,int m,int s,int ds)&#123;
    for(int i&#x3D;1;i&lt;&#x3D;n+m;i++)dist[i]&#x3D;G[s][i];
    collected[s]&#x3D;true,dist[s]&#x3D;0;
    while(true)&#123;
        int v&#x3D;FindMindist(n,m,ds);
        if(v&lt;0)break;
        collected[v]&#x3D;true;
        for(int i&#x3D;1;i&lt;&#x3D;n+m;i++)if(!collected[i]&amp;&amp;G[v][i]&lt;INFINITY)
            if(dist[i]&gt;dist[v]+G[v][i])dist[i]&#x3D;dist[v]+G[v][i];
    &#125;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)if(dist[i]&gt;ds)return false;
    return true;
&#125;
int FindMindist(int n,int m,int ds)&#123;
    int mind&#x3D;INFINITY,mini&#x3D;-1;
    for(int i&#x3D;1;i&lt;&#x3D;n+m;i++)if(!collected[i]&amp;&amp;mind&gt;dist[i])
        mind&#x3D;dist[i],mini&#x3D;i;
    if(mind&lt;INFINITY)return mini;
    return -1;
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="all-roads-lead-to-rome"><a class="markdownIt-Anchor" href="#all-roads-lead-to-rome"></a> All Roads Lead to Rome</h1>
<p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p>
<h2 id="input-specification-3"><a class="markdownIt-Anchor" href="#input-specification-3"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>200</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (2≤N≤200)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N−1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format City1 City2 Cost. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p>
<h2 id="output-specification-3"><a class="markdownIt-Anchor" href="#output-specification-3"></a> Output Specification</h2>
<p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommanded. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique. \Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommanded route. Then in the next line, you are supposed to print the route in the format :</p>
<blockquote>
<p>City1-&gt;City2-&gt;…-&gt;ROM.</p>
</blockquote>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">6 7 HZH
ROM 100
PKN 40
GDN 55
PRS 95
BLN 80
ROM GDN 1
BLN ROM 1
HZH PKN 1
PRS ROM 2
BLN HZH 2
PKN GDN 1
HZH PRS 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">3 3 195 97
HZH-&gt;PRS-&gt;ROM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
<p>在Dijkstra算法，上增加了相等时的两次特判及不同最短路径条数的计算</p>
<h2 id="参考代码-2"><a class="markdownIt-Anchor" href="#参考代码-2"></a> 参考代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;stack&gt;
#define INFINITY 65535
#define MaxCities 205
using namespace std;
typedef struct City&#123;
    string name;
    int happiness;
&#125;city;
city cities[MaxCities];
int G[MaxCities][MaxCities],cost[MaxCities],paths[MaxCities],
    num[MaxCities],happiness[MaxCities],path[MaxCities];
bool collected[MaxCities]&#x3D;&#123;false&#125;;
void BuildGraph(int,int);
void LeadtoRome(int);
void Dijkstra(int,int);
int FindMindist(int);
int main(int argc,char*argv[]) &#123;
    int n,k;
    string start;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;start;
    cities[n-1].name&#x3D;start;
    BuildGraph(n,k);
    LeadtoRome(n);
&#125;
void BuildGraph(int n,int k)&#123;
    string c1,c2;int d,i1,i2;
    for(int i&#x3D;0;i&lt;n-1;i++)cin&gt;&gt;cities[i].name&gt;&gt;cities[i].happiness;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;0;j&lt;n;j++)if(i!&#x3D;j)G[i][j]&#x3D;INFINITY;
    for(int i&#x3D;0;i&lt;k;i++)&#123;
        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;d;
        for(int j&#x3D;0;j&lt;n;j++)
            if(c1&#x3D;&#x3D;cities[j].name)i1&#x3D;j;
            else if(c2&#x3D;&#x3D;cities[j].name)i2&#x3D;j;
        G[i1][i2]&#x3D;G[i2][i1]&#x3D;d;
    &#125;
&#125;
void LeadtoRome(int n)&#123;
    stack&lt;int&gt; s;int ave&#x3D;0,count&#x3D;1,rom;
    Dijkstra(n,n-1);
    for(int i&#x3D;0;i&lt;n-1;i++)if(cities[i].name&#x3D;&#x3D;&quot;ROM&quot;)rom&#x3D;i;
    for(int i&#x3D;path[rom];i!&#x3D;n-1;i&#x3D;path[i],count++)&#123;
        s.push(i);
        ave+&#x3D;happiness[i];
    &#125;
    printf(&quot;%d %d %d %d\n&quot;,num[rom],cost[rom],happiness[rom],(ave+cities[rom].happiness)&#x2F;count);
    cout&lt;&lt;cities[n-1].name&lt;&lt;&quot;-&gt;&quot;;
    while(!s.empty())&#123;
        cout&lt;&lt;cities[s.top()].name&lt;&lt;&quot;-&gt;&quot;;
        s.pop();
    &#125;
    cout&lt;&lt;&quot;ROM&quot;&lt;&lt;endl;
&#125;
void Dijkstra(int n,int s)&#123;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cost[i]&#x3D;G[s][i],num[i]&#x3D;1,happiness[i]&#x3D;cities[i].happiness;
        if(cost[i]&lt;INFINITY)path[i]&#x3D;s,paths[i]&#x3D;1;
        else path[i]&#x3D;-1;
    &#125;
    collected[s]&#x3D;true,cost[s]&#x3D;0,paths[s]&#x3D;0;
    while(true)&#123;
        int v&#x3D;FindMindist(n);
        collected[v]&#x3D;true;
        if(v&lt;0)break;
        for(int i&#x3D;0;i&lt;n;i++)if(!collected[i]&amp;&amp;G[v][i]&lt;INFINITY)&#123;
                if(cost[i]&gt;cost[v]+G[v][i])
                    cost[i]&#x3D;cost[v]+G[v][i],num[i]&#x3D;num[v],path[i]&#x3D;v,
                    paths[i]&#x3D;paths[v]+1,happiness[i]&#x3D;happiness[v]+cities[i].happiness;
                else if(cost[i]&#x3D;&#x3D;cost[v]+G[v][i])&#123;
                    num[i]+&#x3D;num[v];
                    if(happiness[i]&lt;happiness[v]+cities[i].happiness)
                        happiness[i]&#x3D;happiness[v]+cities[i].happiness,path[i]&#x3D;v,paths[i]&#x3D;paths[v]+1;
                    else if(happiness[i]&#x3D;&#x3D;happiness[v]+cities[i].happiness&amp;&amp;
                    happiness[i]&#x2F;paths[i]&lt;(happiness[v]+cities[i].happiness)&#x2F;(paths[v]+1))path[i]&#x3D;v,paths[i]&#x3D;paths[v]+1;
                &#125;
        &#125;
    &#125;
&#125;
int FindMindist(int n)&#123;
    int minc&#x3D;INFINITY,mini&#x3D;-1;
    for(int i&#x3D;0;i&lt;n;i++)if(!collected[i]&amp;&amp;minc&gt;cost[i])
        minc&#x3D;cost[i],mini&#x3D;i;
    if(minc&lt;INFINITY)return mini;
    else return -1;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>11.列出连通集、Forwards on Weibo、旅游规划</title>
    <url>/posts/731ce70d9f1f</url>
    <content><![CDATA[<h1 id="列出连通集"><a class="markdownIt-Anchor" href="#列出连通集"></a> 列出连通集</h1>
<p>给定一个有N个顶点和E条边的无向图，请用DFS和BFS分别列出其所有的连通集。假设顶点从0到N−1编号。进行搜索时，假设我们总是从编号最小的顶点出发，按编号递增的顺序访问邻接点。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入第1行给出2个整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>0</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(0&lt;N≤10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>和E，分别是图的顶点数和边数。随后E行，每行给出一条边的两个端点。每行中的数字之间用1空格分隔。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>按照&quot;{ v1 v2 … vk}&quot;的格式，每行输出一个连通集。先输出DFS的结果，再输出BFS的结果。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">8 6
0 7
0 1
2 0
4 1
2 4
3 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">&#123; 0 1 4 2 7 &#125;
&#123; 3 5 &#125;
&#123; 6 &#125;
&#123; 0 1 2 7 4 &#125;
&#123; 3 5 &#125;
&#123; 6 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#define maxinte 10
using namespace std;
void BuildMGraph();
void printdb();
void DFS(int);
void BFS(int);
int MGraph[maxinte][maxinte],Ne,Nv;
bool visited[maxinte];
int main()&#123;
    BuildMGraph();
    printdb();
&#125;
void BuildMGraph()&#123;
    cin&gt;&gt;Nv&gt;&gt;Ne;
    int v1,v2;
    for(int i&#x3D;0;i&lt;Nv;i++)for(int j&#x3D;0;j&lt;Nv;j++)MGraph[i][j]&#x3D;0;
    for(int i&#x3D;0;i&lt;Ne;i++)&#123;
        cin&gt;&gt;v1&gt;&gt;v2;
        MGraph[v1][v2]&#x3D;MGraph[v2][v1]&#x3D;1;
    &#125;
&#125;
void printdb()&#123;
    for(int j&#x3D;0;j&lt;Nv;j++)visited[j]&#x3D;false;
    for(int i&#x3D;0;i&lt;Nv;i++)
        if(!visited[i])&#123;
            cout&lt;&lt;&quot;&#123; &quot;;
            DFS(i);
            cout&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl;
        &#125;
    for(int j&#x3D;0;j&lt;Nv;j++)visited[j]&#x3D;false;
    for(int i&#x3D;0;i&lt;Nv;i++)
        if(!visited[i])&#123;
            cout&lt;&lt;&quot;&#123; &quot;;
            BFS(i);
            cout&lt;&lt;&quot;&#125;&quot;&lt;&lt;endl;
        &#125;
&#125;
void DFS(int v)&#123;
    visited[v]&#x3D;true;
    cout&lt;&lt;v&lt;&lt;&#39; &#39;;
    for(int i&#x3D;0;i&lt;Nv;i++)
        if(MGraph[v][i]!&#x3D;0&amp;&amp;!visited[i])DFS(i);
&#125;
void BFS(int v)&#123;
    queue&lt;int&gt; q;
    int w;
    q.push(v);
    visited[v]&#x3D;true;
    while(!q.empty())&#123;
        v&#x3D;q.front(),q.pop();
        cout&lt;&lt;v&lt;&lt;&#39; &#39;;
        for(int i&#x3D;0;i&lt;Nv;i++)
            if(MGraph[v][i]!&#x3D;0&amp;&amp;!visited[i])&#123;
                visited[i]&#x3D;true;
                q.push(i);
            &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="forwards-on-weibo"><a class="markdownIt-Anchor" href="#forwards-on-weibo"></a> Forwards on Weibo</h1>
<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:</p>
<blockquote>
<p>M[i] user_list[i]</p>
</blockquote>
<p>where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M[i] (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID’s for query.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">7 3
3 2 3 4
0
2 5 6
2 3 1
2 3 4
1 4
1 5
2 2 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">4
5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="题意分析"><a class="markdownIt-Anchor" href="#题意分析"></a> 题意分析</h2>
<p>本题输入给出的是关注的人，注意转发微博是关注的人转发被关注的人，所以边的方向应该是关注指向被关注</p>
<ul>
<li>可以理解为关注的人本身是不知道有什么人关注了他自己的)</li>
<li>输出是是在给定层数l限制下最多能有多少人转发
<ul>
<li>即与给定顶点之间路径长度不超过l的结点个数</li>
</ul>
</li>
</ul>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#define MaxUsers 1000
using namespace std;
typedef int Vertex;
typedef struct AdjVNode *PtrToAdjVNode;
typedef struct LGNode *PtrToLGNode;
typedef struct Vnode AdjList[MaxUsers+1];
typedef PtrToLGNode LGraph;
struct AdjVNode&#123;
    Vertex AdjV;
    PtrToAdjVNode Next;
&#125;;
struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
&#125;;
struct LGNode&#123;
    int Nv,Ne;
    AdjList G;
&#125;;
LGraph CreatelGraph(int);
void InsertEdge(LGraph,int,int);
LGraph BuildLGraph(int);
void ForwardsonWeibo(LGraph,int,bool*);
int BFS(LGraph,int,int,bool*);
int main(int argc,char*argv[]) &#123;
    int l,n;
    cin&gt;&gt;n&gt;&gt;l;
    bool visited[n+1];
    LGraph L&#x3D;BuildLGraph(n);
    ForwardsonWeibo(L,l,visited);
&#125;
LGraph BuildLGraph(int n)&#123;
    int user,userl;
    LGraph L&#x3D;CreatelGraph(n);
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
        cin &gt;&gt; user;
        for(int j&#x3D;1; j &lt;&#x3D;user; j++)&#123;
            cin&gt;&gt;userl;
            InsertEdge(L,i,userl);
        &#125;
    &#125;
    return L;
&#125;
LGraph CreatelGraph(int n)&#123;
    auto L&#x3D;new struct LGNode;
    for(int i&#x3D;0;i&lt;&#x3D;n;i++)L-&gt;G[i].FirstEdge&#x3D; nullptr;
    L-&gt;Nv&#x3D;n,L-&gt;Ne&#x3D;0;
    return L;
&#125;
void InsertEdge(LGraph L,int user,int userl)&#123;
    auto newnode&#x3D;new struct AdjVNode;
    newnode-&gt;AdjV&#x3D;user;
    newnode-&gt;Next&#x3D;L-&gt;G[userl].FirstEdge;
    L-&gt;G[userl].FirstEdge&#x3D;newnode;
    L-&gt;Ne++;
&#125;
void ForwardsonWeibo(LGraph L,int l,bool*visited)&#123;
    int n,v;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;v;
        for(int j&#x3D;1;j&lt;&#x3D;L-&gt;Nv;j++)visited[j]&#x3D; false;
        cout&lt;&lt;BFS(L,v,l,visited)&lt;&lt;endl;
    &#125;
&#125;
int BFS(LGraph L,int v,int l,bool*visited)&#123;
    int last&#x3D;v,tail,level&#x3D;0,count&#x3D;0;
    PtrToAdjVNode w;
    queue&lt;int&gt; q;
    q.push(v);
    visited[v]&#x3D;true;
    while(!q.empty())&#123;
        v&#x3D;q.front(),q.pop();
        w&#x3D;L-&gt;G[v].FirstEdge;
        while(w) &#123;
            if (!visited[w-&gt;AdjV]) &#123;
                q.push(w-&gt;AdjV);
                visited[w-&gt;AdjV] &#x3D; true, count++, tail &#x3D; w-&gt;AdjV;
            &#125;
            w &#x3D; w-&gt;Next;
        &#125;
        if(v&#x3D;&#x3D;last)level++,last&#x3D;tail;
        if(level&#x3D;&#x3D;l)break;
    &#125;
    return count;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="旅游规划"><a class="markdownIt-Anchor" href="#旅游规划"></a> 旅游规划</h1>
<p>有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。</p>
<h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h2>
<p>输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(2≤N≤500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。</p>
<h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h2>
<p>在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">4 5 0 3
0 1 1 20
1 3 2 30
0 3 4 10
0 2 2 20
2 3 1 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">3 40<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<ul>
<li>城市为结点</li>
<li>公路为边
<ul>
<li>权重1：距离</li>
<li>权重2：收费</li>
</ul>
</li>
<li>单源最短路
<ul>
<li>Dijkstra——距离</li>
<li>等距离时按收费更新</li>
</ul>
</li>
</ul>
<h3 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h3>
<pre class="line-numbers language-none"><code class="language-none">void Dijkstra(Vertex S)
&#123;
    while(1)
    &#123;
        v&#x3D;未收录顶点中dist最小者;
        if(这样的v不存在)
            break;
        collected[w]&#x3D;&#x3D;true;
        for(v的每个邻接点w)
            if(collected[w]&#x3D;&#x3D;false)
                if(dist[v]+E(v,w)&lt;dist[w])
                &#123;
                    dist[w]&#x3D;dist[v]+E(v,w);
                    path[w]&#x3D;v;
                    cost[w]&#x3D;cast[v]+C(v,w);
                &#125;
                else if((dist[v]+E(v,w)&#x3D;&#x3D;dist[w])
                        &amp;&amp;(cost[v]+C(v,w)&lt;cost[w]))
                &#123;
                    cost[w]&#x3D;cost[v]+C(v,w);
                &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="其他类似问题"><a class="markdownIt-Anchor" href="#其他类似问题"></a> 其他类似问题</h3>
<ul>
<li>要求数最短路径有多少条
<ul>
<li>count[s]=1;</li>
<li>如果找到更短路：count[w]=count[v];</li>
<li>如果找到等长路：count[w]+=count[v];</li>
</ul>
</li>
<li>要求边数最少得最短路(本质上等价于dist，只不过每新增一条边的权重均为1)
<ul>
<li>count[s]=0;</li>
<li>如果找到更短路：count[w]=count[v]+1;</li>
<li>如果找到等长路：count[w]=count[v]+1;</li>
</ul>
</li>
</ul>
<h2 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define MaxCities 500
#define INFINITY 65535
using namespace std;
typedef struct&#123;
    int length,price;
&#125;highway;
highway G[MaxCities][MaxCities];
bool collected[MaxCities]&#x3D;&#123;false&#125;;
int dist[MaxCities],price[MaxCities];
void Buildgraph(int,int);
int FindMindistprice(int);
void Dijkstra(int,int);
void selectpath(int,int,int);
int main(int argc,char*argv[]) &#123;
    int N,M,S,D;
    cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D;
    Buildgraph(M,N);
    selectpath(N,S,D);
&#125;
void Buildgraph(int m,int n)&#123;
    int c1,c2;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;0;j&lt;n;j++)&#123;
        G[i][j].length&#x3D;G[i][j].price&#x3D;INFINITY;
        G[j][i]&#x3D;G[i][j];
    &#125;
    for(int i&#x3D;0;i&lt;m;i++)&#123;
        cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;G[c1][c2].length&gt;&gt;G[c1][c2].price;
        G[c2][c1]&#x3D;G[c1][c2];
    &#125;
&#125;
void selectpath(int n,int s,int d)&#123;
    for(int i&#x3D;0;i&lt;n;i++)dist[i]&#x3D;price[i]&#x3D;INFINITY;
    Dijkstra(s,n);
    cout&lt;&lt;dist[d]&lt;&lt;&#39; &#39;&lt;&lt;price[d]&lt;&lt;endl;
&#125;
int FindMindistprice(int n)&#123;
    int mind&#x3D;INFINITY,minp&#x3D;INFINITY,mini&#x3D;0;
    for(int i&#x3D;0;i&lt;n;i++)if(!collected[i]&amp;&amp;(mind&gt;&#x3D;dist[i]||(mind&#x3D;&#x3D;dist[i]&amp;&amp;minp&gt;price[i])))
        mind&#x3D;dist[i],mini&#x3D;i,minp&#x3D;price[i];
    if(mind&lt;(int)INFINITY)return mini;
    return -1;
&#125;
void Dijkstra(int s,int n)&#123;
    for(int i&#x3D;0;i&lt;n;i++)dist[i]&#x3D;G[s][i].length,price[i]&#x3D;G[s][i].price;
    collected[s]&#x3D;true,dist[s]&#x3D;price[s]&#x3D;0;
    while(true)&#123;
        int v&#x3D;FindMindistprice(n);
        collected[v]&#x3D;true;
        if(v&lt;0)break;
        for(int i&#x3D;0;i&lt;n;i++)if(!collected[i]&amp;&amp;G[v][i].length&lt;(int)INFINITY)
            if (dist[i]&gt;dist[v]+G[v][i].length||(dist[i]&#x3D;&#x3D;dist[v]+G[v][i].length&amp;&amp;price[i]&gt;price[v]+G[v][i].price))
                dist[i]&#x3D;dist[v]+G[v][i].length,price[i]&#x3D;price[v]+G[v][i].price;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>10.Huffman Codes、PAT Judge</title>
    <url>/posts/d675f3d012cb</url>
    <content><![CDATA[<h1 id="huffman-codes"><a class="markdownIt-Anchor" href="#huffman-codes"></a> Huffman Codes</h1>
<p>In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string “aaaxuaxz”, we can observe that the frequencies of the characters ‘a’, ‘x’, ‘u’ and ‘z’ are 4, 2, 1 and 1, respectively. We may either encode the symbols as {‘a’=0, ‘x’=10, ‘u’=110, ‘z’=111}, or in another way as {‘a’=1, ‘x’=01, ‘u’=001, ‘z’=000}, both compress the string into 14 bits. Another set of code can be given as {‘a’=0, ‘x’=11, ‘u’=100, ‘z’=101}, but {‘a’=0, ‘x’=01, ‘u’=011, ‘z’=001} is NOT correct since “aaaxuaxz” and “aazuaxax” can both be decoded fromthe code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line gives an integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>63</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (2≤N≤63)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>, then followed by a line that contains all the N distinct characters and their frequencies in the following format:</p>
<blockquote>
<p>c[1] f[1] c[2] f[2] … c[N] f[N]</p>
</blockquote>
<p>where c[i] is a character chosen from {‘0’ - ‘9’, ‘a’ - ‘z’, ‘A’ - ‘Z’, ‘_’}, and f[i] is the frequency of c[i] and is an integer no more than 1000. The next line gives a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, then followed by M student submissions. Each student submission consists of N lines, each in the format:</p>
<blockquote>
<p>c[i] code[i]</p>
</blockquote>
<p>where c[i] is the i-th character and code[i] is an non-empty string of no more than 63 '0’s and '1’s.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, print in each line either “Yes” if the student’s submission is correct, or “No” if not.<br>
Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
4
A 00000
B 00001
C 0001
D 001
E 01
F 10
G 11
A 01010
B 01011
C 0100
D 011
E 10
F 11
G 00
A 000
B 001
C 010
D 011
E 100
F 101
G 110
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">Yes
Yes
No
No<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<h3 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h3>
<p>计算WPL</p>
<pre class="line-numbers language-none"><code class="language-none">int GetWPL(HuffmanTree T,int depth)
&#123;
    if(!T-&gt;Left&amp;&amp;!T-&gt;Right)return depth*T-&gt;Weight;
    else return GetWPL(T-&gt;Left,depth+1)+GetWPL(T-&gt;Right,depth+1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对每位同学的提交，检查</p>
<ul>
<li>长度是否正确，注意：Code[i]的最大长度为N-1</li>
<li>建树过程中检查是否满足前缀码要求</li>
</ul>
<h2 id="参考代码记得当时有两个样例没通过"><a class="markdownIt-Anchor" href="#参考代码记得当时有两个样例没通过"></a> 参考代码：(记得当时有两个样例没通过)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define Maxchar 63
#define MaxStu 1000
#define MINDATA -1
using namespace std;
typedef struct HeapStruct_Huff* MinHeap;
typedef struct HuffmanNode* HuffmanTree;
typedef int ElementType;
struct HeapStruct_Huff&#123;
    HuffmanTree *Elements;
    int Size,Capicity;
&#125;;
struct HuffmanNode&#123;
    ElementType weight;
    HuffmanTree Left,Right;
&#125;;
MinHeap CreateMinHeap();
HuffmanTree CreateHuffmanTree();
void BuildMinHeap(MinHeap,int,const int* cf);
void InsertHeap(MinHeap,HuffmanTree);
HuffmanTree DeleteHeap(MinHeap);
HuffmanTree BuildHuffmanTree(MinHeap,int,const int* cf);
int HuffmanWPL(HuffmanTree,int);
void StuWPL(int,int,int*,string[][Maxchar],const int* cf);
bool isprefix(string*,int);
int main(int argc,char*argv[]) &#123;
    char c;
    int n,stu,hwpl,swpl[MaxStu],char_freq[Maxchar];
    MinHeap H&#x3D;CreateMinHeap();
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;c&gt;&gt;char_freq[i];
    HuffmanTree T&#x3D;BuildHuffmanTree(H,n,char_freq);
    hwpl&#x3D;HuffmanWPL(T,0);
    cin&gt;&gt;stu;
    for(int i&#x3D;0;i&lt;stu;i++)swpl[i]&#x3D;0;
    string stud[stu][Maxchar];
    StuWPL(stu,n,swpl,stud,char_freq);
    for(int i&#x3D;0;i&lt;stu;i++)&#123;
        if(!isprefix(stud[i],n)&amp;&amp;swpl[i]&#x3D;&#x3D;hwpl)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    &#125;
&#125;
HuffmanTree CreateHuffmanTree()&#123;
    auto T&#x3D;new struct HuffmanNode;
    T-&gt;Left&#x3D;T-&gt;Right&#x3D; nullptr;
    return T;
&#125;
MinHeap CreateMinHeap()&#123;
    auto H&#x3D;(MinHeap) malloc(sizeof (struct HeapStruct_Huff));
    H-&gt;Elements&#x3D; (HuffmanTree*) malloc(sizeof (HuffmanTree)*(Maxchar+1));
    H-&gt;Size&#x3D;0,H-&gt;Capicity&#x3D;Maxchar;
    H-&gt;Elements[0]&#x3D;CreateHuffmanTree();
    H-&gt;Elements[0]-&gt;weight&#x3D;MINDATA;
    H-&gt;Elements[0]-&gt;Left&#x3D;H-&gt;Elements[0]-&gt;Right&#x3D; nullptr;
    return H;
&#125;
void InsertHeap(MinHeap H,HuffmanTree T)&#123;
    int i;
    for(i&#x3D;++H-&gt;Size;T-&gt;weight&lt;H-&gt;Elements[i&#x2F;2]-&gt;weight;i&#x2F;&#x3D;2)
        H-&gt;Elements[i]&#x3D;H-&gt;Elements[i&#x2F;2];
    H-&gt;Elements[i]&#x3D;T;
&#125;
HuffmanTree DeleteHeap(MinHeap H)&#123;
    int parent,child;
    HuffmanTree minnode&#x3D;H-&gt;Elements[1],tmp&#x3D;H-&gt;Elements[H-&gt;Size--];
    for(parent&#x3D;1;parent*2&lt;&#x3D;H-&gt;Size;parent&#x3D;child)&#123;
        child&#x3D;parent*2;
        if(child!&#x3D;H-&gt;Size&amp;&amp;(H-&gt;Elements[child]-&gt;weight&gt;H-&gt;Elements[child+1]-&gt;weight))child++;
        if(tmp-&gt;weight&lt;&#x3D;H-&gt;Elements[child]-&gt;weight)break;
        else H-&gt;Elements[parent]&#x3D;H-&gt;Elements[child];
    &#125;
    H-&gt;Elements[parent]&#x3D;tmp;
    return  minnode;
&#125;
void BuildMinHeap(MinHeap H,int n,const int* cf)&#123;
    int i,parent,child;
    for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
        H-&gt;Elements[i]&#x3D;CreateHuffmanTree();
        H-&gt;Elements[i]-&gt;weight&#x3D;cf[i-1];
        H-&gt;Size++;
    &#125;
    for(i&#x3D;H-&gt;Size&#x2F;2;i&gt;0;i--) &#123;
        HuffmanTree tmp&#x3D;H-&gt;Elements[i];
        for(parent&#x3D;i;parent*2&lt;&#x3D;H-&gt;Size;parent&#x3D;child) &#123;
            child&#x3D;parent*2;
            if(child!&#x3D;H-&gt;Size&amp;&amp;(H-&gt;Elements[child]-&gt;weight&gt;H-&gt;Elements[child+1]-&gt;weight))child++;
            if(tmp-&gt;weight&lt;&#x3D;H-&gt;Elements[child]-&gt;weight)break;
            else H-&gt;Elements[parent]&#x3D;H-&gt;Elements[child];
        &#125;
        H-&gt;Elements[parent]&#x3D;tmp;
    &#125;
&#125;
HuffmanTree BuildHuffmanTree(MinHeap H,int n,const int* cf)&#123;
    HuffmanTree T;
    BuildMinHeap(H,n,cf);
    while(H-&gt;Size&gt;1)&#123;
        T&#x3D;CreateHuffmanTree();
        T-&gt;Left&#x3D;DeleteHeap(H);
        T-&gt;Right&#x3D;DeleteHeap(H);
        T-&gt;weight&#x3D;T-&gt;Left-&gt;weight+T-&gt;Right-&gt;weight;
        InsertHeap(H,T);
    &#125;
    T&#x3D;DeleteHeap(H);
    return T;
&#125;
int HuffmanWPL(HuffmanTree T,int deep)&#123;
    static int hwpl;
    if(T)&#123;
        if(!T-&gt;Left&amp;&amp;!T-&gt;Right)hwpl+&#x3D;deep*T-&gt;weight;
        HuffmanWPL(T-&gt;Left,deep+1);
        HuffmanWPL(T-&gt;Right,deep+1);
    &#125;
    return hwpl;
&#125;
void StuWPL(int stu,int n,int* swpl,string stud[][Maxchar],const int* cf)&#123;
    int i,j;char c;
    for(i&#x3D;0;i&lt;stu;i++)for(j&#x3D;0;j&lt;n;j++)cin&gt;&gt;c&gt;&gt;stud[i][j];
    for(i&#x3D;0;i&lt;stu;i++)for(j&#x3D;0;j&lt;n;j++)swpl[i]+&#x3D;cf[j]*(int)stud[i][j].size();
&#125;
bool isprefix(string* stud,int n)&#123;
    int i;
    string maxstring;
    for(i&#x3D;0;i&lt;n;i++)if(stud[i].size()&gt;maxstring.size())maxstring&#x3D;stud[i];
    for(i&#x3D;0;i&lt;n;i++)&#123;
        int j&#x3D;0;
        if(stud[i]!&#x3D;maxstring&amp;&amp;stud[i][0]&#x3D;&#x3D;maxstring[0])
            for(;stud[i][j]&amp;&amp;stud[i][j]&#x3D;&#x3D;maxstring[j];j++);
        if(!stud[i][j])return true;
    &#125;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="pat-judge"><a class="markdownIt-Anchor" href="#pat-judge"></a> PAT Judge</h1>
<p>The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 3 positive integers, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the total number of users, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span>, the total number of problems, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format:</p>
<blockquote>
<p>user_id problem_id partial_score_obtained</p>
</blockquote>
<p>where partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, you are supposed to output the ranklist in the following format:</p>
<p>rank user_id total_score s[1] … s[K] where rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-” must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted.<br>
The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist.</p>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">7 4 20
20 25 25 30
00002 2 12
00007 4 17
00005 1 19
00007 2 25
00005 1 20
00002 2 2
00005 1 15
00001 1 18
00004 3 25
00002 2 25
00005 3 22
00006 4 -1
00001 2 18
00002 1 20
00004 1 15
00002 4 18
00001 3 4
00001 4 2
00005 2 -1
00004 2 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">1 00002 63 20 25 - 18
2 00005 42 20 0 22 -
2 00007 42 - 25 - 17
2 00001 42 18 18 4 2
5 00004 40 15 0 25 -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
<p>此题坑点：</p>
<ul>
<li>提交不通过编译的得分是-1，但最后输出时显示是0分，只有完全没做过的题显示’-’</li>
<li>一个人只有提交过通过了编译的答案(最低分0分)才能在榜单上显示</li>
<li>如果一个人对同一题多次提交过满分，该题满分次数只算一次</li>
<li>榜单排序规则是
<ul>
<li>第一关键字是总得分，总得分相同的排名相同</li>
<li>相同总得分虽然排名相同，但仍然存在先后顺序
<ul>
<li>第二关键字是题目满分个数</li>
<li>第三关键字是id顺序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="参考代码好像也是有测试点过不了"><a class="markdownIt-Anchor" href="#参考代码好像也是有测试点过不了"></a> 参考代码(好像也是有测试点过不了)</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
#define marks 5
#define users 1050
#define missioins 10050
using namespace std;
typedef struct input&#123;
    int id,prob,mark;
&#125;input;
typedef struct output&#123;
    int id,tol,perf;
&#125;output;
input inputs[missioins];
output outputs[users];
int n,m,k,fullmark[marks],compare(const void*,const void*),ranks[users][marks+4];
void patjudge();
int main()&#123;
    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;
    for(int i&#x3D;0;i&lt;k;i++)cin&gt;&gt;fullmark[i];
    for(int i&#x3D;0;i&lt;m;i++)cin&gt;&gt;inputs[i].id&gt;&gt;inputs[i].prob&gt;&gt;inputs[i].mark;
    patjudge();
&#125;
int compare(const void*node1,const void*node2)&#123;
    int comp&#x3D;-1;
    if(((output*)node1)-&gt;tol&lt;((output*)node2)-&gt;tol)comp&#x3D;1;
    else if(((output*)node1)-&gt;tol&#x3D;&#x3D;((output*)node2)-&gt;tol)&#123;
        if(((output*)node1)-&gt;perf&lt;((output*)node2)-&gt;perf)comp&#x3D;1;
        else if(((output*)node1)-&gt;perf&#x3D;&#x3D;((output*)node2)-&gt;perf)
            if(((output*)node1)-&gt;id&gt;((output*)node2)-&gt;id)comp&#x3D;1;
    &#125;
    return comp;
&#125;
void patjudge()&#123;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;1;j&lt;k+1;j++)ranks[i][j]&#x3D;-2;
    for(int i&#x3D;0,l&#x3D;0,j;i&lt;m;i++)&#123;
        int flag&#x3D;0;
        for(j&#x3D;0;j&lt;&#x3D;l;j++)if(ranks[j][0]&#x3D;&#x3D;inputs[i].id)&#123;
            if(inputs[i].mark&gt;ranks[j][inputs[i].prob])&#123;
                if(inputs[i].mark&gt;&#x3D;0)ranks[j][k+3]&#x3D;1;
                if(inputs[i].mark&#x3D;&#x3D;fullmark[inputs[i].prob-1])ranks[j][k+1]++;
                ranks[j][inputs[i].prob]&#x3D;inputs[i].mark;
            &#125;
            flag&#x3D;1;
        &#125;
        if(!flag)&#123;
            ranks[l][0]&#x3D;inputs[i].id;
            if(inputs[i].mark&gt;&#x3D;0)ranks[l][k+3]&#x3D;1;
            if(inputs[i].mark&#x3D;&#x3D;fullmark[inputs[i].prob-1])ranks[l][k+1]++;
            ranks[l++][inputs[i].prob]&#x3D;inputs[i].mark;
        &#125;
    &#125;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;1;j&lt;&#x3D;k;j++)&#123;
        if(ranks[i][j]&gt;0)ranks[i][k+2]+&#x3D;ranks[i][j];
        else if(ranks[i][j]&#x3D;&#x3D;-1)ranks[i][j]&#x3D;0;
    &#125;
    for(int i&#x3D;0;i&lt;n;i++)outputs[i].id&#x3D;ranks[i][0],outputs[i].tol&#x3D;ranks[i][k+2],outputs[i].perf&#x3D;ranks[i][k+1];
    qsort(outputs,n,sizeof(output),compare);
    int nums&#x3D;0;
    for(int i&#x3D;0;i&lt;n;i++)if(ranks[i][k+3]&#x3D;&#x3D;1)nums++;
    for(int i&#x3D;0,num&#x3D;1;i&lt;nums;i++)&#123;
        if(i&gt;0&amp;&amp;outputs[i].tol&lt;outputs[i-1].tol)num&#x3D;i+1;
        cout&lt;&lt;num&lt;&lt;&#39; &#39;;
        printf(&quot;%05d &quot;,outputs[i].id);
        cout&lt;&lt;outputs[i].tol&lt;&lt;&#39; &#39;;
        for(int j&#x3D;0;j&lt;n;j++)if(ranks[j][0]&#x3D;&#x3D;outputs[i].id)&#123;
            for(int l&#x3D;1;l&lt;k;l++)&#123;
                if(ranks[j][l]&gt;&#x3D;0)cout&lt;&lt;ranks[j][l]&lt;&lt;&#39; &#39;;
                else cout&lt;&lt;&quot;- &quot;;
            &#125;
            if(ranks[j][k]&gt;&#x3D;0)cout&lt;&lt;ranks[j][k]&lt;&lt;endl;
            else cout&lt;&lt;&#39;-&#39;&lt;&lt;endl;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>9.List leaves、Tree Traversals Again、</title>
    <url>/posts/e07bd7854727</url>
    <content><![CDATA[<h1 id="list-leaves"><a class="markdownIt-Anchor" href="#list-leaves"></a> List Leaves</h1>
<p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line gives a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>10</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N−1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-” will be put at the position. Any pair of children are separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">8
1 -
- -
0 -
2 7
- -
- -
5 -
4 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">4 1 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#define MaxTree 10
#define Tree int
#define Null -1
using namespace std;
struct TreeNode
&#123;
    Tree Left;
    Tree Right;
&#125;T[MaxTree];
Tree BuildTree(struct TreeNode[]);
void leaves(Tree);
int main()
&#123;
    Tree R;
    R&#x3D;BuildTree(T);
    leaves(R);
&#125;
Tree BuildTree(struct TreeNode T[])
&#123;
    int i,N,check[MaxTree];
    char cl,cr;
    Tree Root;
    cin&gt;&gt;N;
    if(!N)return Null;
    for(i&#x3D;0;i&lt;N;i++)check[i]&#x3D;0;
    for(i&#x3D;0;i&lt;N;i++) &#123;
        cin&gt;&gt;cl&gt;&gt;cr;
        if (cl !&#x3D; &#39;-&#39;) &#123;
            T[i].Left &#x3D; cl - &#39;0&#39;;
            check[T[i].Left] &#x3D; 1;
        &#125; else T[i].Left &#x3D; Null;
        if (cr !&#x3D; &#39;-&#39;) &#123;
            T[i].Right &#x3D; cr - &#39;0&#39;;
            check[T[i].Right] &#x3D; 1;
        &#125; else T[i].Right &#x3D; Null;
    &#125;
    for(i&#x3D;0;i&lt;N;i++)if(!check[i])break;
    Root&#x3D;i;
    return Root;
&#125;
void leaves(Tree R)&#123;
    queue&lt;int&gt; q;
    int flag&#x3D;0;
    q.push(R);
    while(!q.empty())&#123;
        if(T[q.front()].Left!&#x3D;Null)q.push(T[q.front()].Left);
        if(T[q.front()].Right!&#x3D;Null)q.push(T[q.front()].Right);
        if(T[q.front()].Left&#x3D;&#x3D;Null&amp;&amp;T[q.front()].Right&#x3D;&#x3D;Null)&#123;
            if(!flag)&#123;
                cout&lt;&lt;q.front();
                flag&#x3D;1;
            &#125;
            else cout&lt;&lt;&#39; &#39;&lt;&lt;q.front();
        &#125;
        q.pop();
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="tree-traversals-again"><a class="markdownIt-Anchor" href="#tree-traversals-again"></a> Tree Traversals Again</h1>
<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p>
<p>(图片暂时找不到了😳囧…)</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format:<br>
“Push X” where X is the index of the node being pushed onto the stack;<br>
or “Pop” meaning to pop one node from the stack.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification</h2>
<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">6
Push 1
Push 2
Push 3
Pop
Pop
Push 4
Pop
Pop
Push 5
Push 6
Pop
Pop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">3 4 2 6 5 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>实际上在输入格式中Push的过程是二叉树前序遍历的结果，Pop的过程是二叉树的中序遍历的结果<br>
如因此题目的意思变成已知二叉树的前序遍历和中序遍历求二叉树的后序遍历</p>
<pre class="line-numbers language-none"><code class="language-none">void solve(int prel,int postl,int inl,int n)
&#123; &#x2F;&#x2F;只需要获得前序的第一个结点下标以及子树的结点数，然后在中序序列中操作即可
    if(!n)return;
    if(n&#x3D;&#x3D;1)
    &#123;
        post[postl]&#x3D;pre[prel];
        return;
    &#125;
    int root&#x3D;pre[prel];
    post[postl+n-1]&#x3D;root;
    for(int i&#x3D;0;i&lt;n;i++)if(in[inl+i]&#x3D;&#x3D;root)break;
    int l&#x3D;i,r&#x3D;n-l-1;
    solve(prel+1,inl,postl,l);
    solve(prel+l+1,inl+l+1,postl+l,r);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;string&gt;
#define MaxTree 30
using namespace std;
int inorder[MaxTree],preorder[MaxTree],postorder[MaxTree];
void getseries(int);
void post(int, int, int);
int main()
&#123;
    int n;
    cin&gt;&gt;n;
    getseries(n);
    post(0,0,n-1);
&#125;
void getseries(int n)&#123;
    stack&lt;int&gt; s;
    int i&#x3D;0,j&#x3D;0,nu;string str;
    while(i&lt;n||j&lt;n)&#123;
        cin&gt;&gt;str;
        if(str&#x3D;&#x3D;&quot;Push&quot;)&#123;
            cin&gt;&gt;nu;
            s.push(nu);
            preorder[i++]&#x3D;nu;
        &#125;
        if(str&#x3D;&#x3D;&quot;Pop&quot;)&#123;
            inorder[j++]&#x3D;s.top();
            s.pop();
        &#125;
    &#125;
&#125;
void post(int root, int start, int end) &#123;  &#x2F;&#x2F;root为根结点，start和end是中序序列的开始和结尾
    &#x2F;&#x2F;用分而治之的策略，使用先序序列第一个元素(根结点)对中序序列的划分出的左右子树的两个中序序列递归进行划分，直到划分到只剩一个
    &#x2F;&#x2F;如果给出后序和中序，求先序，也是一样的，只是变成用后序序列的最后一个元素划分中序序列
    &#x2F;&#x2F;中序序列是必须知道的，因为没有中序序列，就没法把二叉树划分成根和左右子树
    if(start &gt; end)return;
    int i &#x3D; start;
    static int flag&#x3D;0;
    while(i &lt; end &amp;&amp; inorder[i] !&#x3D; preorder[root]) i++;     &#x2F;&#x2F;找到中序序列中的根结点下标
    post(root + 1, start, i - 1);                           &#x2F;&#x2F;左子树求后序序列，root+1为左子树先序序列中的根结点
    post(root + 1 + i - start, i + 1, end);   &#x2F;&#x2F;右子树求后序序列，i-start是左子树结点个数，root+1+i-start是右子树先序根结点
    if(!flag)&#123;
        cout&lt;&lt;preorder[root];
        flag&#x3D;1;
    &#125;else cout&lt;&lt;&#39; &#39;&lt;&lt;preorder[root];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="complete-binary-search-tree"><a class="markdownIt-Anchor" href="#complete-binary-search-tree"></a> Complete Binary Search Tree</h1>
<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:<br>
The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>
<h2 id="input-specification-3"><a class="markdownIt-Anchor" href="#input-specification-3"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤1000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>. Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>
<h2 id="output-specification-3"><a class="markdownIt-Anchor" href="#output-specification-3"></a> Output Specification</h2>
<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>
<h2 id="sample-input-3"><a class="markdownIt-Anchor" href="#sample-input-3"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">10
1 2 3 4 5 6 7 8 9 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output-3"><a class="markdownIt-Anchor" href="#sample-output-3"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">6 3 8 1 5 7 9 0 2 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
<p>完全二叉搜索树将给定的序列通过某种组织方式使其既是一棵完全二叉树又是一棵二叉搜索树</p>
<h3 id="树的表示法链表vs数组"><a class="markdownIt-Anchor" href="#树的表示法链表vs数组"></a> 树的表示法：链表vs数组</h3>
<ul>
<li>需要的操作
<ul>
<li>填写数字(某种遍历) —— 完全二叉树，不浪费空间</li>
<li>层序遍历 —— 直接顺序输出</li>
</ul>
</li>
<li>数组完胜</li>
</ul>
<h3 id="核心算法"><a class="markdownIt-Anchor" href="#核心算法"></a> 核心算法</h3>
<pre class="line-numbers language-none"><code class="language-none">void solve(int Aleft,int Aright,TRoot)   
&#123;&#x2F;&#x2F;排序后的输入序列A，从A中选出正确的根结点填入T[TRoot]中
    &#x2F;&#x2F;初始调用为solve(0,n-1,0);
    n&#x3D;Aright-Aleft+1;       &#x2F;&#x2F;计算出输入序列的结点数
    if(!n)return;           &#x2F;&#x2F;n为0时结束递归调用
    L&#x3D;GetLeftLength(n);     &#x2F;&#x2F;计算出n个结点的树其左子树有多少个结点
    T[TRoot]&#x3D;A[Aleft+L];    &#x2F;&#x2F;ALeft+左子树结点个数就是序列中根结点的下标
    LeftTRoot&#x3D;TRoot*2+1;    &#x2F;&#x2F;左子树的根结点下标为TRoot*2+1(整个树的根结点下标为0)
    RightTRoot&#x3D;LeftTRoot+1; &#x2F;&#x2F;右子树根结点下标为TRoot*2+1
    solve[Aleft,Aleft+L-1,LeftTRoot];    &#x2F;&#x2F;在左右子树递归调用此过程
    solve[Aleft+L+1,Aright,RightTRoot];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="计算左子树的规模getleftlength"><a class="markdownIt-Anchor" href="#计算左子树的规模getleftlength"></a> 计算左子树的规模GetLeftLength()</h3>
<p>完全二叉树前h-1层的总结点个数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(2^h-1)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> (h从1开始)。因此左子树的结点数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo>−</mo><mn>1</mn><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n=2^{h-2}-1+x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9324379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，x为最下面一层的结点个数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0\leq x\leq2^{h-2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mo stretchy="false">⌊</mo><mi>l</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">h=⌊lg(n+1)⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">⌋</span></span></span></span><br>
不过到这里x的值不一定等于x(最下一层结点数)，此时有两种情况：x超过左子树的叶子结点数，x不超过左子树的叶子结点数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><msup><mn>2</mn><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x=min(x,2^{h-2})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0991079999999998em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<h2 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;cmath&gt;
#define MAXLINE 1000
#define min(a,b) ((a)&lt;(b)?(a):(b))
using namespace std;
typedef struct TreeNode *BinTree;
typedef int ElementType;
struct TreeNode &#123;
    ElementType val;
    BinTree left,right;
    TreeNode(int x):val(x),left(NULL),right(NULL)&#123;&#125;
&#125;;
int pre[MAXLINE],in[MAXLINE],lev[MAXLINE];
void CBST(int*,int,int,int);
int partiation(int*,int,int);
void qksort(int*,int,int);
BinTree create(int*,int*,int,int,int,int);
void levelorder(BinTree);
int main() &#123;
    int i,n,v[MAXLINE];
    cin&gt;&gt;n;
    for(i&#x3D;0;i&lt;n;i++)cin&gt;&gt;v[i];
    qksort(v,0,n-1);
    CBST(v,n,0,n-1);
    BinTree BT&#x3D; create(pre,in,0,n-1,0,n-1);
    levelorder(BT);
    for(i&#x3D;0;i&lt;n-1;i++)cout&lt;&lt;lev[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;lev[n-1];
&#125;
int partiation(int* v,int start,int end)&#123;
    if(v&#x3D;&#x3D;NULL||start&lt;0||start&gt;end)return -1;
    int pivot&#x3D;v[start];
    while(start&lt;end)&#123;
        for(;v[end]&gt;&#x3D;pivot&amp;&amp;start&lt;end;end--);
        v[start]&#x3D;v[end];
        for(;v[start]&lt;pivot&amp;&amp;start&lt;end;start++);
        v[end]&#x3D;v[start];
    &#125;
    v[start]&#x3D;pivot;
    return start;
&#125;
void qksort(int*v,int start,int end)&#123;
    if(end-start&lt;1)return;
    int pivot&#x3D; partiation(v,start,end);
    if(pivot&gt;start+1)qksort(v,start,pivot-1);
    if(pivot&lt;end-1)qksort(v,pivot+1,end);
&#125;
void CBST(int*v,int n,int start,int end)&#123;
    int h,pivot;
    static int i&#x3D;0,j&#x3D;0;
    if(end-start&lt;1)&#123;
        pre[i++]&#x3D;in[j++]&#x3D;v[start];
        return;
    &#125;
    for(h&#x3D;0;(int)pow(2,h)&lt;n+1;h++);
    pivot&#x3D;start+(min(pow(2,h-2),(int)pow(2,h-1)-(int)pow(2,h)+1+n))+(int)pow(2,h-2)-1;
    pre[i++]&#x3D;v[pivot];
    if(pivot-start&gt;0)CBST(v,pivot-start,start,pivot-1);
    in[j++]&#x3D;v[pivot];
    if(end-pivot&gt;0)CBST(v,end-pivot,pivot+1,end);
&#125;
BinTree create(int*pre,int*in,int ps,int pe,int is,int ie)&#123;
    if(ps&gt;pe)return nullptr;
    TreeNode* node &#x3D; new TreeNode(pre[ps]);
    int pos;
    for(int i&#x3D;is;i&lt;&#x3D;ie;i++)
        if(in[i]&#x3D;&#x3D;node-&gt;val)&#123;
            pos&#x3D;i;
            break;
    &#125;
    node-&gt;left&#x3D;create(pre,in,ps+1,ps+pos-is,is,pos-1);
    node-&gt;right&#x3D;create(pre,in,pe-ie+pos+1,pe,pos+1,ie);
    return node;
&#125;
void levelorder(BinTree BT)&#123;
    queue&lt;BinTree&gt; q;
    int i&#x3D;0;
    BinTree T&#x3D;BT;
    q.push(T);
    while(!q.empty())&#123;
        T&#x3D;q.front();
        q.pop();
        lev[i++]&#x3D;T-&gt;val;
        if(T-&gt;left)q.push(T-&gt;left);
        if(T-&gt;right)q.push(T-&gt;right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>8.二分查找、有序链表的合并、最大子列和、反转链表、删除序列</title>
    <url>/posts/e8a0a8aad392</url>
    <content><![CDATA[<h1 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h1>
<h2 id="二分查找伪代码"><a class="markdownIt-Anchor" href="#二分查找伪代码"></a> 二分查找伪代码</h2>
<pre class="line-numbers language-none"><code class="language-none">int binarysearch(int i,int array[],int up,int bottom)&#123;
    int Mid &#x3D; (up + bottom) &#x2F; 2;
    if      下界超过上界时，说明没有找到，返回错误状态-1
    else if x比中间位置的数字大，则以M为新bottom值重新查找，递归调用 binarysearch(i,array,mid-1,bottom)
    else if x比中间位置的数字小，则以M为新up重新查找，递归调用 binarysearch(i,array,up,mid+1)
    else if x与中间位置的数字相等，则返回数字位置 Mid+1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p>函数接口定义：</p>
<pre class="line-numbers language-none"><code class="language-none">Position BinarySearch( List L, ElementType X );
其中List结构定义如下：
typedef int Position;
typedef struct LNode *List;
struct LNode &#123;
    ElementType Data[MAXSIZE];
    Position Last; &#x2F;&#x2F; 保存线性表中最后一个元素的位置
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>L是用户传入的一个线性表，其中ElementType元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数BinarySearch要查找X在Data中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记NotFound。</p>
<p>裁判测试程序样例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAXSIZE 10
#define NotFound 0
typedef int ElementType;

typedef int Position;
typedef struct LNode *List;
struct LNode &#123;
    ElementType Data[MAXSIZE];
    Position Last; &#x2F;&#x2F; 保存线性表中最后一个元素的位置
&#125;;

List ReadInput(); &#x2F;&#x2F; 裁判实现，细节不表。元素从下标1开始存储
Position BinarySearch( List L, ElementType X );

int main()
&#123;
    List L;
    ElementType X;
    Position P;

L &#x3D; ReadInput();
    scanf(&quot;%d&quot;, &amp;X);
    P &#x3D; BinarySearch( L, X );
    printf(&quot;%d\n&quot;, P);

return 0;
&#125;
&#x2F;&#x2F; 你的代码将被嵌在这里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输入样例1"><a class="markdownIt-Anchor" href="#输入样例1"></a> 输入样例1</h2>
<pre class="line-numbers language-none"><code class="language-none">5
12 31 55 89 101
31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例1"><a class="markdownIt-Anchor" href="#输出样例1"></a> 输出样例1</h2>
<pre class="line-numbers language-none"><code class="language-none">2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="输入样例2"><a class="markdownIt-Anchor" href="#输入样例2"></a> 输入样例2</h2>
<pre class="line-numbers language-none"><code class="language-none">3
26 78 233
31<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例2"><a class="markdownIt-Anchor" href="#输出样例2"></a> 输出样例2</h2>
<pre class="line-numbers language-none"><code class="language-none">0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">Position BinarySearch( List L, ElementType X )&#123;
    Position mid,start&#x3D;1,end&#x3D;L-&gt;Last;
    while(start&lt;&#x3D;end)&#123;
        mid&#x3D;(start+end)&#x2F;2;
        if(X&gt;L-&gt;Data[mid])start&#x3D;mid+1;
        if(X&lt;L-&gt;Data[mid])end&#x3D;mid-1;
        if(X&#x3D;&#x3D;L-&gt;Data[mid])return mid;
    &#125;
    return NotFound;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="两个有序链表序列的合并"><a class="markdownIt-Anchor" href="#两个有序链表序列的合并"></a> 两个有序链表序列的合并</h1>
<h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2>
<p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p>
<p>函数接口定义：</p>
<pre class="line-numbers language-none"><code class="language-none">List Merge( List L1, List L2 );
其中List结构定义如下：

typedef struct Node *PtrToNode;
struct Node &#123;
    ElementType Data; &#x2F;&#x2F; 存储结点数据 
    PtrToNode   Next; &#x2F;&#x2F; 指向下一个结点的指针 
&#125;;
typedef PtrToNode List; &#x2F;&#x2F; 定义单链表类型 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>L1和L2是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数Merge要将L1和L2合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。<br>
本题关键：直接使用原序列中的结点</p>
<p>裁判测试程序样例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node &#123;
    ElementType Data;
    PtrToNode   Next;
&#125;;
typedef PtrToNode List;

List Read(); &#x2F;&#x2F; 细节在此不表
void Print( List L ); &#x2F;&#x2F; 细节在此不表；空链表将输出NULL

List Merge( List L1, List L2 );

int main()
&#123;
    List L1, L2, L;
    L1 &#x3D; Read();
    L2 &#x3D; Read();
    L &#x3D; Merge(L1, L2);
    Print(L);
    Print(L1);
    Print(L2);
    return 0;
&#125;

&#x2F;&#x2F; 你的代码将被嵌在这里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">3
1 3 5
5
2 4 6 8 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">1 2 3 4 5 6 8 10
NULL        &#x2F;&#x2F;输出NULL是因为L1和L2的结点都指向了L中的结点
NULL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">List Merge(List L1, List L2)
&#123;
    List pa, pb, pc;
    List L &#x3D; (List)malloc(sizeof(struct Node));
    pa &#x3D; L1-&gt;Next;
    pb &#x3D; L2-&gt;Next;
    pc &#x3D; L;
    while (pa &amp;&amp; pb)
    &#123;
        if (pa-&gt;Data &lt;&#x3D; pb-&gt;Data)&#123;
            pc-&gt;Next &#x3D; pa;
            pc &#x3D; pa;
            pa &#x3D; pa-&gt;Next;
        &#125;else&#123;
            pc-&gt;Next &#x3D; pb;
            pc &#x3D; pb;
            pb &#x3D; pb-&gt;Next;
        &#125;
    &#125;
    pc-&gt;Next &#x3D; pa ? pa : pb;  &#x2F;&#x2F;如果pa不为空，pc-&gt;Next &#x3D; pa，否则pc-&gt;Next &#x3D; pb
    L1-&gt;Next &#x3D; NULL;
    L2-&gt;Next &#x3D; NULL;
    return L;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="maximum-subsequence-sum"><a class="markdownIt-Anchor" href="#maximum-subsequence-sum"></a> Maximum Subsequence Sum</h1>
<p>Given a sequence of K integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>N</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>N</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>K</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ N_1, N_2, ..., N_K\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>. A continuous subsequence is defined to be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>N</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>N</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>N</mi><mi>j</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ N_i, N_{i+1}, ..., N_j\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">1≤i≤j≤K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mo>−</mo><mn>2</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mo>−</mo><mn>4</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mo>−</mo><mn>5</mn><mo separator="true">,</mo><mo>−</mo><mn>2</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ -2, 11, -4, 13, -5, -2 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">−</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mclose">}</span></span></span></span>, its maximum subsequence is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mn>11</mn><mo separator="true">,</mo><mo>−</mo><mn>4</mn><mo separator="true">,</mo><mn>13</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{ 11, -4, 13 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mclose">}</span></span></span></span> with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>10000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤10000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>. The second line contains K numbers, separated by a space.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0,<br>
and you are supposed to output the first and the last numbers of the whole sequence.</p>
<h2 id="sample-input"><a class="markdownIt-Anchor" href="#sample-input"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">10
-10 1 2 3 4 -5 -23 3 7 -21<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="sample-output"><a class="markdownIt-Anchor" href="#sample-output"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">10 1 4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="ac代码-3"><a class="markdownIt-Anchor" href="#ac代码-3"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;
using namespace std;
int main()
&#123;
    int k,x,maxSum&#x3D;-1,sum&#x3D;0,s&#x3D;0,st&#x3D;0,e;
    cin&gt;&gt;k;
    for(int i&#x3D;0;i&lt;k;i++)
    &#123;
        cin&gt;&gt;x;
        if(!i)s&#x3D;x;
        if(sum&lt;0||!i)
        &#123;
            sum&#x3D;0;
            st&#x3D;x;
        &#125;
        sum+&#x3D;x;
        if(sum&gt;maxSum)
        &#123;
            maxSum&#x3D;sum;
            s&#x3D;st;
            e&#x3D;x;
        &#125;
    &#125;
    if(maxSum&lt;0)
    &#123;
        maxSum&#x3D;0;
        e&#x3D;x;
    &#125;
    cout&lt;&lt;maxSum&lt;&lt;&#39; &#39;&lt;&lt;s&lt;&lt;&#39; &#39;&lt;&lt;e;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="reversing-linked-list"><a class="markdownIt-Anchor" href="#reversing-linked-list"></a> Reversing Linked List</h1>
<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K=3, then you must output 3→2→1→6→5→4; if K=4, you must output 4→3→2→1→5→6.</p>
<h2 id="input-specification-2"><a class="markdownIt-Anchor" href="#input-specification-2"></a> Input Specification:</h2>
<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> which is the total number of nodes, and a positive <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo stretchy="false">(</mo><mo>≤</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K (≤N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. Then N lines follow, each describes a node in the format:<br>
Address Data Next<br>
where Address is the position of the node, Data is an integer, and Next is the position of the next node.</p>
<h2 id="output-specification-2"><a class="markdownIt-Anchor" href="#output-specification-2"></a> Output Specification:</h2>
<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">00100 6 4
00000 4 99999
00100 1 12309
68237 6 -1
33218 3 00000
99999 5 68237
12309 2 33218<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">00000 4 33218
33218 3 12309
12309 2 00100
00100 1 99999
99999 5 68237
68237 6 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-4"><a class="markdownIt-Anchor" href="#ac代码-4"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;自己构造一个memory数组来当做内存，然后基本操作就和链表的操作一样的。
&#x2F;&#x2F;注意“有多余结点不在链表上”(即该结点是孤立的，并没有被其他结点指向)
#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#define MAXSIZE 100000
using namespace std;
struct Lnode&#123;
    int next;
    int data;
&#125;node[MAXSIZE];
struct Snode&#123;
    int add;
    int next;
    int data;
&#125;snode[MAXSIZE];
void reverselink()&#123;
    int i,j,a,n,k,Addr,Data,Next,nodeaddr;
    struct Snode tmp[MAXSIZE];
    cin&gt;&gt;a&gt;&gt;n&gt;&gt;k;
    for(i&#x3D;0;i&lt;n;i++)&#123;
        cin &gt;&gt; Addr &gt;&gt; Data &gt;&gt; Next;
        node[Addr].data&#x3D;Data;
        node[Addr].next&#x3D;Next;
    &#125;
    nodeaddr&#x3D;a;
    for(i&#x3D;0,j&#x3D;0;nodeaddr!&#x3D;-1;i++,j++)&#123;
        tmp[i].data&#x3D;node[nodeaddr].data;
        tmp[i].add&#x3D;nodeaddr;
        nodeaddr&#x3D;node[nodeaddr].next;
    &#125;
    int tmpn&#x3D;j;
    for(i&#x3D;0;tmpn&#x2F;k&gt;0;tmpn-&#x3D;k,i++)reverse(tmp+i*k,tmp+k*(i+1));
    for(i&#x3D;0;i&lt;j-1;i++)tmp[i].next&#x3D;tmp[i+1].add;
    tmp[i].next&#x3D;-1;
    for(i&#x3D;0;i&lt;j;i++)&#123;
        printf(&quot;%05d %d &quot;,tmp[i].add,tmp[i].data);
        if(tmp[i].next!&#x3D;-1)printf(&quot;%05d\n&quot;,tmp[i].next);
        else printf(&quot;-1&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="pop-sequence"><a class="markdownIt-Anchor" href="#pop-sequence"></a> Pop Sequence</h1>
<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>
<h2 id="input-specification-3"><a class="markdownIt-Anchor" href="#input-specification-3"></a> Input Specification</h2>
<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>
<h2 id="output-specification-3"><a class="markdownIt-Anchor" href="#output-specification-3"></a> Output Specification</h2>
<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>
<h2 id="sample-input-3"><a class="markdownIt-Anchor" href="#sample-input-3"></a> Sample Input</h2>
<pre class="line-numbers language-none"><code class="language-none">5 7 5
1 2 3 4 5 6 7
3 2 1 7 5 6 4
7 6 5 4 3 2 1
5 6 4 3 7 2 1
1 7 6 5 4 3 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-3"><a class="markdownIt-Anchor" href="#sample-output-3"></a> Sample Output</h2>
<pre class="line-numbers language-none"><code class="language-none">YES
NO
NO
YES
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-5"><a class="markdownIt-Anchor" href="#ac代码-5"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
void popsequence()&#123;
    enum answer&#123;NO,YES&#125;;
    int i,j,l,c,m,n,k,pos,count;
    cin&gt;&gt;m&gt;&gt;n&gt;&gt;k;
    int inputseq[k][n],countseq[n];
    for(i&#x3D;0;i&lt;k;i++)for(j&#x3D;0;j&lt;n;j++)cin&gt;&gt;inputseq[i][j];
    for(i&#x3D;0;i&lt;k;i++)&#123;
        pos&#x3D;YES;
        for(j&#x3D;0;j&lt;n;j++)&#123;
            for(l&#x3D;0;l&lt;n;l++)countseq[l]&#x3D;0;
            count&#x3D;0;
            for(l&#x3D;j+1;l&lt;n;l++) &#123;
                if (inputseq[i][j] &gt; inputseq[i][l])countseq[count++]&#x3D;inputseq[i][l];
                if (count &gt;&#x3D; m)pos &#x3D; NO;
                for(c&#x3D;0;c&lt;count;c++)if(countseq[c+1]&gt;countseq[c])pos &#x3D; NO;
            &#125;
        &#125;
        if(pos&#x3D;&#x3D;YES)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;
        if(pos&#x3D;&#x3D;NO)cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt开发环境和编译工具介绍及相关基本概念</title>
    <url>/posts/d0ab9fa78862</url>
    <content><![CDATA[<h1 id="qt介绍"><a class="markdownIt-Anchor" href="#qt介绍"></a> Qt介绍</h1>
<p>Qt是跨平台的开发库，主要是开发图形用户界面(Graphical User Interface，GUI)应用程序，当然也可以开发非图形的命令行(Command User Interface，CUI)应用程序。 Qt支持众多的操作系统平台，如通用操作系统Windows、Linux、Unix，智能手机系统Android、iOS、WinPhone，嵌入式系统QNX、VxWorks等等，应用广泛。当然Qt库本身包含的功能模块也日益丰富，一直有新模块和第三方模块扩充。除了与操作系统底层结合特别紧密的，如驱动开发，需要利用操作系统本身的函数库实现之外，其他大部分的应用程序开发都可以用Qt实现的。Qt本身是纯c++开发的，此外Qt还存在Python、Ruby、Perl等脚本语言的绑定，也可以使用脚本语言开发基于Qt的程序。<br>
在Qt4以前的时代主流的是传统部件(或叫控件)编程，所用的语言一般是c++。Qt5诞生之时，正是手机移动设备蓬勃发展的时候，而传统的c++部件编写的界面对手机应用程序不是很方便，比如手机屏幕显示需要满足随意翻转功能，而这在传统桌面程序里基本遇不到。为了适应手机移动应用开发，Qt5将QML 脚本编程提到与传统c++部件编程相同的高度，力推QML界面编程，当然QML主要用于手机移动应用程序。QML包含大量使用手机移动设备的功能模块，比如基本部件(QtQuick模块)、GPS定位、渲染特效、蓝牙、NFC、WebkKit等等。<br>
简单地说，如果是传统桌面应用程序，使用c++部件开发就足够，如果是手机移动应用开发，QML是更好的选择。</p>
<p>关于Qt的下载，可以参考<a href="https://wiki.qt.io/Main">Qt维基网站</a>，其中会显示最新的正式版、LTS版、正在开发中的版本等详尽的版本信息。</p>
<h2 id="qt开发环境的目录结构"><a class="markdownIt-Anchor" href="#qt开发环境的目录结构"></a> Qt开发环境的目录结构</h2>
<p>下面以Linux环境下Qt5.4版本为例介绍Qt开发环境的目录结构，其他版本也可以此作为参考(涉及windows的内容默认是minGW环境)。<br>
因为Linux系统自带编译生成工具，因此Qt开发环境在Linux系统里所需安装的工具和依赖的库文件比在Windows里少一些。在Linux系统里Qt安装的开发环境大致分为两部分：</p>
<ul>
<li><strong>Qt类库</strong>的路径为</li>
</ul>
<blockquote>
<p>~/Qt5.4.0/5.4/gcc_64</p>
</blockquote>
<ul>
<li><strong>QtCreator集成开发环境</strong>的路径为</li>
</ul>
<blockquote>
<p>~/Qt5.4.0/Tools/QtCreator</p>
</blockquote>
<p>如果安装了Qt类库的源代码，则位于~/Qt5.4.0/5.4/Src目录里面(波浪号~是指当前用户主文件夹，如用户ABCDE的主文件夹为/home/ABCDE，如果是其他用户想用该用户目录下的Qt则应该指明该用户家目录的路径，在Windows或是MS-DOS下用户没有宿主目录，那么波浪号所指的目录则根据环境变量HOME而定)。如果是windows系统还要额外安装编译工具集，路径为C:\Qt\Qt5.4.0\Tools\mingw491_32，这个是MinGW工具集本身，拥有g++、ld、ar、mingw32-make等等编译链接生成工具。(如果是Visual Studio版本的Qt开发环境，可以参考<a href="http://pan.baidu.com/s/1nuyQHzb">vs版本安装教程</a>)</p>
<p>Linux系统里Qt开发环境整体的目录树绘制如下:</p>
<img src="https://s2.loli.net/2022/05/11/asSXeQl9vAF6PMt.png">
<p>Docs里的是帮助文档，需要Qt Assistant来查阅，Examples是例子代码，最后的MaintenanceTool是管理工具，如果是用离线包安装的，那只能用它删除Qt开发环境，如果是在线安装方式，还可以用它管理Qt开发环境的组件和升级组件。<br>
进一步再细分查看Qt类库的目录QTDIR，得到下图Qt类库目录树：</p>
<img src="https://s2.loli.net/2022/05/11/PBQwNuh69DoF8aR.png">
<h2 id="qt工具集介绍"><a class="markdownIt-Anchor" href="#qt工具集介绍"></a> Qt工具集介绍</h2>
<p>Qt官方的开发环境安装包里有自己专门的开发工具。其中qmake是Qt开发最核心的工具，可以生成Qt项目.pro文件，也可以自动生成项目的Makefile文件。项目(或者叫工程)是指为实现某个相对独立功能的程序代码合集，这些代码不单单是放在一块，而是有相互之间的关联性，并且有专门负责管理该项目的项目文件，比如Qt使用.pro文件管理项目，VC++则使用.vcproj作为项目文件。集成开发环境通常都是依据项目文件(.pro/.vcproj)管理和构建项目。</p>
<p>常用的Qt开发工具列表如下：</p>
<ul>
<li>qmake：核心的<strong>项目构建工具</strong>。可以生成跨平台的.pro项目文件，并能依据不同操作系统和编译工具生成相应的Makefile，用于构建可执行程序或链接库。</li>
<li>qtcreator：<strong>集成开发环境</strong>。包含项目生成管理、代码编辑、图形界面可视化编辑、编译生成、程序调试、上下文帮助、版本控制系统集成等众多功能，还支持手机和嵌入式设备的程序生成部署。</li>
<li>designer：<strong>Qt设计师</strong>。专门用于可视化编辑图形用户界面(所见即所得)，生成.ui文件用于Qt项目。</li>
<li>uic：User Interface Compiler，<strong>用户界面编译器</strong>。Qt使用XML语法格式的.ui文件定义用户界面，uic根据.ui文件生成用于创建用户界面的c++代码头文件，比如ui_*****.h。</li>
<li>moc：Meta-Object Compiler，<strong>元对象编译器</strong>。moc处理c++头文件的类定义里面的Q_OBJECT宏，它会生成源代码文件，比如moc_*****.cpp，其中包含相应类的元对象代码，元对象代码主要用于实现Qt信号/槽机制、运行时类型定义、动态属性系统。</li>
<li>rcc：Resource Compiler，<strong>资源文件编译器</strong>。负责在项目构建过程中编译.qrc资源文件，将资源嵌入到最终的Qt程序里。</li>
<li>assistant：<strong>Qt助手</strong>。帮助文档浏览查询工具，Qt库所有模块和开发工具的帮助文档、示例代码等都可以检索到，在Qt开发中非常实用。</li>
<li>linguist：<strong>Qt语言家</strong>。代码里用tr()宏包裹的就是可翻译的字符串，开发人员可用lupdate命令生成项目的待翻译字符串文件.ts，用linguist翻译多国语言.ts，翻译完成后用lrelease命令生成.qm文件，然后就可用于多国语言界面显示。</li>
<li>qmlscene：在Qt4.x里是用qmlviewer进行<strong>QML程序的原型设计和测试</strong>，Qt5用qmlscene取代了旧的qmlviewer。新的qmlscene另外还支持Qt5中的新特性scenegraph。</li>
</ul>
<h1 id="qt项目的编译"><a class="markdownIt-Anchor" href="#qt项目的编译"></a> Qt项目的编译</h1>
<h2 id="使用g手动编译并执行qt程序"><a class="markdownIt-Anchor" href="#使用g手动编译并执行qt程序"></a> 使用g++手动编译并执行Qt程序</h2>
<p>一般使用集成开发环境Qt Creator开发程序，用户是不需要关心环境变量之类的设置的，该工具自己会去寻找编译器g++、调试器gdb、生成器make以及系统里的开发库。如果需要手动编译的话，如果系统之前就自带Qt编译工具，那么进入终端直接输入命令进行编译即可。但是如果是新下载的Qt环境，还没有添加环境变量的话，就可以编制脚本来进行环境变量的配置。假设在用户主文件夹新建一个shell脚本qt5env.sh并编辑其中的内容：</p>
<ul>
<li>设置环境变量QTDIR指示Qt库的位置</li>
<li>添加Qt库的bin目录到PATH变量里</li>
<li>添加Qt库的lib目录到LD_LIBRARY_PATH变量里。</li>
</ul>
<p>由于这里把QTDIR/bin目录放在了旧的$PATH变量的前面，所以进入shell后会优先使用新安装的Qt库工具集。LD_LIBRARY_PATH变量是类似地设置，LD_LIBRARY_PATH是指定动态链接库的路径，也是优先使用新安装的Qt动态链接库。然后切换到家目录(qt5env.sh所在目录)，使用终端工具gnome-terminal(GNOME 桌面环境)或konsole(KDE 桌面环境)启动一个新的终端以便进行编译。<br>
脚本的实际编写大概是这样的：</p>
<pre class="line-numbers language-none"><code class="language-none">export QTDIR&#x3D;~&#x2F;Qt5.4.0&#x2F;5.4&#x2F;gcc_64
export PATH&#x3D;~&#x2F;Qt5.4.0&#x2F;5.4&#x2F;gcc_64&#x2F;bin:$PATH
export LD_LIBRARY_PATH&#x3D;~&#x2F;Qt5.4.0&#x2F;5.4&#x2F;gcc_64&#x2F;lib:$LD_LIBRARY_PATH
cd ~
konsole  #如果是GNOME桌面环境则用gnome-terminal<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就是执行脚本</p>
<pre class="line-numbers language-none"><code class="language-none">chmod +x .&#x2F;qt5env.sh  #使脚本具有执行权限
.&#x2F;qt5env.sh  #执行脚本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>下面就可以进行Qt程序的编译了，这里现以一个最简单的helloworld程序为例：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; ~&#x2F;helloworld.cpp
#include &lt;iostream&gt;
using namespace std;

int main(int argc, char **argv)
&#123;
    cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意项目和代码文件的全路径里不要包含任何中文字符、特殊字符和空格，这些字符对程序编译不方便，并且会导致开发工具找不到文件。<br>
使用g++手动进行编译：</p>
<pre class="line-numbers language-none"><code class="language-none">g++ helloworld.cpp -o helloworld
.&#x2F;helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果在windows系统中可能还存在另外一些问题：直接在MinGW命令行环境可以执行helloworld.exe程序，但是直接在系统点击该helloworld.exe程序无法执行。这是由于helloworld.exe所依赖的一些动态库.dll文件只有在minGW环境里有，系统环境变量是没有的。此时要么是添加环境变量，要么干脆把依赖的.dll文件复制到当前目录(大概是GCC异常处理库libgcc_s_dw2-1.dll和c<ins>标准库libstdc</ins>-6.dll)。或者可以采用静态链接的方法编译(静态链接库是直接塞入exe中的，删除.lib文件后exe照常能运行，而动态链接是.exe在运行时才链接的)：</p>
<pre class="line-numbers language-none"><code class="language-none">g++ helloworld.cpp -static -o helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样生成的.exe要比动态链接方式生成的大非常多，点击该.exe文件可以直接在系统环境中运行。<br>
此外，编译生成的可执行程序通常有两种版本，DeBug和Release版本，即调试和发行版本。</p>
<ul>
<li>Debug版本：代码编写之后，生成的目标程序或库文件通常不会绝对正确，或多或少有些毛病(bug)，因此需要进行纠错调试(Debug)。调试过程中需要源代码和二进制目标程序之间一一对应的关系，这样才能定位到错误代码，所以Debug版本的程序是不进行优化的。</li>
<li>Release版本：在纠正了发觉到的错误后，需要发布程序用于实际用途，实际应用时强调运行效率高，减少冗余代码，因此会对二进制程序进行大量优化，提升性能。</li>
<li>Debug和Release版本程序通常链接的也是各自版本的库文件。</li>
</ul>
<p>g++默认情况下生成的都是Release版可执行程序，如果希望在可执行程序里加入Debug调试信息以供gdb调试，需要编译时加一个-g选项：</p>
<pre class="line-numbers language-none"><code class="language-none">g++ helloworld.cpp -g -o helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
]]></content>
      <categories>
        <category>应用程序开发</category>
        <category>Qt学习</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>Qt学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU工具集术语介绍</title>
    <url>/posts/de15e3343b28</url>
    <content><![CDATA[<h1 id="gnu工具集"><a class="markdownIt-Anchor" href="#gnu工具集"></a> GNU工具集</h1>
<p>在上个世纪八十年代，计算机都是奢侈品，操作系统里最著名的是Unix家族，当时还没有Windows、Linux之类的，Unix系统都是商业软件，里面的应用软件也是商业软件，全是封闭的环境。<br>
系统程序员Richard M.Stallman(RMS)在此环境下创立了与众不同的GNU项目(GNU’s Not Unix)，以及推进自由软件发展的Free Software Foundation(FSF)自由软件基金会。GNU项目是为了创建自由的类Unix系统，也因此开发出来很多开源的系统工具，其中非常著名的就是GCC（GNU Compiler Collection，GNU编译器套件）。在GNU工具集里面，开发时常见到的几个罗列如下（这些工具通常位于Linux或Unix系统里的/usr/bin/目录）：</p>
<ul>
<li>gcc	  GNU c语言编译器。</li>
<li>g++	  GNU c++语言编译器。</li>
<li>ld	  GNU 链接器，将目标文件和库文件链接起来，创建可执行程序和动态链接库</li>
<li>ar	  生成静态库.a，可以编辑和管理静态链接库(在Linux中.a可由.o可重定向目标文件打包生成)</li>
<li>make	生成器，可以根据makefile文件自动编译链接生成可执行程序或库文件。</li>
<li>gdb	  调试器，用于调试可执行程序。</li>
<li>ldd	  查看可执行文件依赖的共享库（也叫动态链接库）。</li>
</ul>
<p>GNU ：<a href="http://www.gnu.org/">项目主页</a><br>
FSF ：<a href="http://www.fsf.org">基金会主页</a></p>
<h2 id="mingw"><a class="markdownIt-Anchor" href="#mingw"></a> MinGW</h2>
<p>原本GNU工具只在Linux/Unix系统里才有，随着Windows系统的广泛使用，为了在Windows系统里可以使用GNU工具，诞生了MinGW（Minimalist GNU for Windows）项目，利用MinGW就可以生成Windows里面的exe程序和dll链接库。需要注意的是，MinGW与Linux/Unix系统里GNU工具集的有些区别：</p>
<ul>
<li>MinGW里面工具带有扩展名.exe，Linux/Unix 系统里工具通常都是没有扩展名的。</li>
<li>MinGW里面的生成器文件名为mingw32-make.exe，Linux/Unix系统里就叫make。</li>
<li>MinGW在链接时是链接到*.a库引用文件，生成的可执行程序运行时依赖*.dll，而Linux/Unix系统里链接时和运行时都是使用*.so 。</li>
<li>MinGW里也没有ldd工具，因为Windows不使用.so共享库文件。如果要查看Windows里可执行文件的依赖库，需要使用微软自家的Dependency Walker工具。
<ul>
<li>Windows里面动态库扩展名为.dll，MinGW可以通过dlltool来生成用于创建和使用动态链接库需要的文件，如.def和.lib。</li>
</ul>
</li>
</ul>
<p>MinGW原本是用于生成32位程序的，随着64位系统流行起来，从MinGW分离出来了MinGW-w64项目，该项目同时支持生成64位和32位程序。</p>
<p>另外提一下，由于MinGW本身主要就是编译链接等工具和头文件、库文件，并不包含系统管理、文件操作之类的Shell环境，这对希望用类Unix命令的开发者来说还是不够用的。所以MinGW官方又推出了MSYS（Minimal SYStem），相当于是一个部署在Windows系统里面的小型Unix系统环境，移植了很多Unix/Linux命令行工具和配置文件等等，是对MinGW的扩展。<br>
MSYS对于熟悉Unix/Linux系统环境或者要尝试学习Unix/Linux系统的人都是一种便利。MSYS和MinGW的安装升级都是通过其官方的mingw-get工具实现，二者是统一下载安装管理的。对于MinGW-w64项目，它对应的小型系统环境叫MSYS2（Minimal SYStem 2），MSYS2是MSYS的衍生版，不仅支持64位系统和32位系统，还有自己的独特的软件包管理工具，它从Arch Linux系统里移植了pacman软件管理工具，所以装了MSYS2之后，可以直接通过pacman来下载安装软件，而且可以自动解决依赖关系、方便系统升级等。装了MSYS2之后，不需要自己去下载MinGW-w64，可以直接用pacman命令安装编译链接工具和git工具等。</p>
<p>MinGW ：<a href="http://www.mingw.org/">项目主页（含 MSYS）</a><br>
MinGW-w64 ： <a href="http://sourceforge.net/projects/mingw-w64/">项目主页</a><br>
MSYS2 ： <a href="http://sourceforge.net/projects/msys2/">项目主页</a></p>
<h2 id="动态链接和静态链接"><a class="markdownIt-Anchor" href="#动态链接和静态链接"></a> 动态链接和静态链接</h2>
<p>通常目标程序都不是独立个体，生成程序时都需要链接其他的库，要用到其他库的代码。对于多个程序同时运行而言，内存中就可能有同一个库的多个副本，占用了太多内存而实际调用的代码相同。为了优化内存运用效率，引入了动态链接库（Dynamic Link Library），或叫共享库（Shared Object）。<br>
使用动态链接库时，内存中只需要一份该库文件，其他程序要使用该库文件时，只要链接过来就行了。由于动态库文件外置，链接到动态库的目标程序相对比较小，因为剥离了大量库代码，而只需要一些链接指针。使用动态库，也意味着程序需要链接到如*.dll或*.so文件，得提前装好动态库文件，然后目标程序才能正常运行。<br>
静态库就是将链接库的代码和自己编写的代码都编译链接到一块，链接到静态库的程序通常比较大，但好处是运行时依赖的库文件很少，因为目标程序自己内部集成了很多库代码。</p>
<p>Linux/Unix系统里静态库和动态库扩展名一般分别是是.a和.so。Windows系统里VC编译器用的静态库扩展名一般是.lib，动态库扩展名一般是.dll。MinGW比较特殊，是将GNU工具集和链接库从Linux/Unix系统移植到Windows里，有意思的情况就出现了，MinGW使用的静态库扩展名为.a，而其动态库扩展名则为.dll，.a仅在生成目标程序过程中使用，.dll则是在目标程序运行时使用。</p>
<h3 id="显式链接和隐式链接"><a class="markdownIt-Anchor" href="#显式链接和隐式链接"></a> 显式链接和隐式链接</h3>
<p>这两种都是动态链接库的使用方式。动态链接库通常都有其导出函数列表，告知其他可执行程序可以使用它的哪些函数。可执行程序使用这些导出函数有两种方式：</p>
<ul>
<li>一是在运行时使用，也就是<strong>应用程序主动加载</strong>动态库的函数，Linux里比如用dlopen函数打开并加载动态库，Windows里一般用LoadLibrary打开并加载动态库，只有当程序代码执行到这些函数时，其参数里的动态库才会被加载，这就是显式链接。显式链接方式是在运行时加载动态库，其程序<strong>启动时并不检查这些动态库是否存在</strong>。</li>
<li>隐式链接是最为常见的，所有的编译环境<strong>默认都是采用隐式链接</strong>的方式使用动态库。隐式链接会在<strong>链接生成可执行程序</strong>时就确立依赖关系，在该程序<strong>启动时操作系统自动会检查</strong>它依赖的动态库，并一一加载到该程序的内存空间，程序员就不需要操心什么时候加载动态库了。</li>
</ul>
<p>比如VC编译环境，链接某个qt程序时使用动态库对应的.lib文件（包含动态库的导出函数声明，但没有实际功能代码），在.exe程序运行前系统会检查依赖的.dll，如果找不到某个动态库就会出现类似下图对话框：</p>
<img src="https://s2.loli.net/2022/05/10/EkP2ynMjwXCaz98.png">
<p>请注意VC链接器使用的.lib文件分两类，一种是完整的静态库，体积比较大，另一种是动态库的导出声明，体积比较小。 MinGW链接器使用的.a文件也是类似的。MinGW是将动态库的导出函数声明放在了.a文件里，程序运行依赖的动态库也是.dll。</p>
]]></content>
      <categories>
        <category>应用程序开发</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>编译原理实例</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile介绍</title>
    <url>/posts/2ea9a24cd534</url>
    <content><![CDATA[<h1 id="makefile"><a class="markdownIt-Anchor" href="#makefile"></a> makefile</h1>
<p>本系列参考 <a href="https://blog.csdn.net/haoel/category_9198_2.html">一起跟我写makefile</a>，在此向原作者致谢。文章经过了我个人的整理、补充、修正、再次排版而完成，记录在此以供大家学习分享。<br>
另附<a href="https://www.comsince.cn/download/gun_make.pdf">GNU make中文手册</a>以供参考(两者内容高度重合，也许这就是中文社区特色吧，还是推荐看中文手册，表述更清晰准确)。</p>
<p><strong>注：本系列内容大部分是基于GNU make的标准，其中cc命令默认调用Linux自带的c编译器程序</strong></p>
<ol>
<li>
<a href="/2022/05/09/makefile/" title="makefile介绍">makefile介绍</a>
</li>
<li>
<a href="/2022/05/14/makefile%E8%BF%9B%E9%98%B6/" title="makefile编写(1)：规则">makefile编写(1)：规则</a>
</li>
<li>
<a href="/2022/05/16/makefile%E7%BC%96%E5%86%99/" title="makefile编写(2)：变量">makefile编写(2)：变量</a>
</li>
<li>
<a href="/2022/05/18/makefile%E8%BF%9B%E9%98%B62/" title="makefile编写(3)：条件执行和函数">makefile编写(3)：条件执行和函数</a>
</li>
</ol>
<h2 id="为什么使用makefile"><a class="markdownIt-Anchor" href="#为什么使用makefile"></a> 为什么使用makefile</h2>
<p>虽然可以直接调用编译器如g++编译程序，但是如果项目里的代码文件变多了，哪些代码文件更新了需要重新编译，哪些代码没有改不需要重新编译等等，靠程序员自己记忆去处理是比较麻烦的事，还有哪些代码需要预处理或是链接哪些库文件，这些都是繁杂的过程。为了规范程序的编译生成过程，产生了<strong>规范化的生成脚本</strong>，就是makefile，生成器make可以依据规范的makefile自动生成目标程序或库文件。makefile也是一个研究项目的利器，很多项目可能文档不完整，而makefile就是项目的地图，从Makefile入手可以快速窥探整个项目的框架和概貌，深入代码而不至于迷路。<br>
简单的说，就是定义好makefile，可以让程序员只需要去关注如何编写代码，而生成程序过程中的脏活累活都交给make程序。而且现在makefile通常都有工具自动生成，如cmake、qmake工具，这样就大量减轻了程序员的负担。</p>
<blockquote>
<p>简单提一下CMake工具：CMake(Cross platform Make)是一个开源的跨平台自动化构建工具，可以跨平台地生成各式各样的makefile或者project文件，支持利用各种编译工具生成可执行程序或链接库。CMake自己不编译程序，它相当于用自己的构建脚本CMakeLists.txt，让各种编译工具集去生成可执行程序或链接库。一般用于编译程序的makefile文件比较复杂，自己去编写比较麻烦，而利用CMake，就可以编写相对简单的CMakeLists.txt，由CMake根据CMakeLists.txt自动生成makefile，然后就可以用make生成可执行程序或链接库。著名的Linux KDE桌面环境的茫茫多程序都是用CMake脚本构建的(用qt开发的)，另外跨平台的程序/库如Boost C++ Libraries、OpenCV、LLVM、Clang等也都是用CMake脚本构建的。以后如果接触到这些东西，是需要了解CMake的。<br>
CMake ：<a href="http://www.cmake.org/">项目主页</a><br>
KDE ：<a href="https://www.kde.org/">项目主页</a></p>
</blockquote>
<p>了解makefile并具备手动编写的能力是很重要的。makefile关系到了整个工程的编译规则，一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，文件编译的先后顺序，是否需要重新编译，并且在makefile中可以调用Shell脚本与操作系统进行交互，进而执行更加复杂的功能操作。</p>
<ul>
<li>虽然创建makefile的意义一般是作为生成脚本，但其可拓展性空间非常大。在其中的命令不一定只是使用编译器，完全加入其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、ftp等等，来完成诸如“打包”、“备份”、“制作安装包”、“提交代码”、“使用模板”、“合并文件”等等五花八门的功能，涉及文件操作，文件管理，开发设计，或是其它一些异想天开的功能</li>
<li>比如在编写银行交易程序时，由于交易程序基本一样，于是有人编写了一些通用程序模板，在该模板中把一些网络通讯、数据库操作、业务操作共性的东西写在一个文件中，在这些文件中用些诸如&quot;@@@N&quot;&quot;###N&quot;奇怪字串标注一些位置，然后编写交易业务时只需按照一种特定规则处理，最后在make时使用awk和sed把模板中的&quot;@@@N&quot;&quot;###N&quot;等字串替代成特定的程序形成c语言文件。</li>
</ul>
<h2 id="一个简单的实例"><a class="markdownIt-Anchor" href="#一个简单的实例"></a> 一个简单的实例</h2>
<p>简单程序可以自己一句句敲g++命令，如果项目复杂起来，代码太多了，自己敲命令编译就很麻烦，而且一个.cpp文件修改后就得重新生成目标文件*.o，因此实际开发项目时都是借助make工具(MinGW的是mingw32-make)，编写好makefile之后，只需要在项目文件夹执行一句make命令，其他生成目标文件、链接目标文件和库以及自动根据源代码改动重新生成等，这些事情全交给make，而程序员就不用操心构建程序的具体过程。<br>
makefile 文件可以自己编写，其实绝大多数的集成开发环境都可以根据项目文件自动生成相应的makefile，所以实际中很多都是集成开发环境自动完成的。<br>
这里示范一个简单的makefile，体会一下生成器make是如何工作的。<br>
在上面hellorect文件夹里新建一个文件，命名为makefile，不要带扩展名。使用Notepad2工具或记事本打开该makefile文件，里面输入如下脚本：</p>
<pre class="line-numbers language-none"><code class="language-none"># makefile for building: hellorect
CC &#x3D; gcc
CXX &#x3D; g++
LINKER &#x3D; g++
LFLAGS &#x3D; -lm -static

OBJECTS &#x3D; rect.o hellorect.o
DSTTARGET &#x3D; hellorect
# Default rule
all: $(DSTTARGET)

$(DSTTARGET): $(OBJECTS)
	$(LINKER)  $(LFLAGS)  -o $@  $(OBJECTS)

hellorect.o: hellorect.cpp
	$(CXX) -c  -o  $@  $&lt;  

rect.o: rect.cpp
	$(CXX) -c  -o  $@  $&lt;  

clean:
	rm  $(OBJECTS)  hellorect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里解释一下上面脚本的意思</p>
<ul>
<li># 打头的是注释，忽略掉</li>
<li>中间带有等于号的都是定义变量，引用变量的方式就是</li>
</ul>
<blockquote>
<p>$(变量名)</p>
</blockquote>
<ul>
<li>CC是c语言编译器，CXX是c++编译器，LINKER是链接器，LFLAGS是链接器的参数。OBJECT是编译得到的目标文件，DSTTARGET是链接后的可执行的目标程序。
<ul>
<li>makefile只是一个生成脚本，因此其解释执行的过程并不涉及复杂的符号存储链接的问题，makefile的变量基本上很类似于将宏展开为字符串的过程</li>
</ul>
</li>
</ul>
<h3 id="makefile基本生成规则"><a class="markdownIt-Anchor" href="#makefile基本生成规则"></a> makefile基本生成规则</h3>
<p>接下来是makefile的生成规则，makefile的基本规则是：</p>
<blockquote>
<p>生成目标: 依赖文件<br>
[tab字符] 系统命令</p>
</blockquote>
<p>上例的makefile中</p>
<blockquote>
<p>all: $(DSTTARGET)</p>
</blockquote>
<p>是默认生成规则，依赖文件$(DSTTARGET)，它的下一行没有命令。<br>
而如何生成$(DSTTARGET)呢，继续往下找</p>
<blockquote>
<p>$(DSTTARGET): $(OBJECTS)</p>
</blockquote>
<p>生成 $(DSTTARGET) 需要 $(OBJECTS)，有了目标文件之后执行命令</p>
<blockquote>
<p>$(LINKER)  $(LFLAGS)  -o $@  $(OBJECTS)</p>
</blockquote>
<p>即调用链接器$(LINKER)，根据链接器参数$(LFLAGS)和$(OBJECTS)，生成$@。$@就是上一行冒号左边的要生成的目标。注意系统命令$(LINKER)之前一定要有制表符tab字符，不能用4个空格代替，否则make时会出现没有分隔符(separator)的错误。</p>
<p>接下来的四句：</p>
<pre class="line-numbers language-none"><code class="language-none">hellorect.o: hellorect.cpp  
	$(CXX) -c  -o  $@  $&lt;  

rect.o: rect.cpp
	$(CXX) -c  -o  $@  $&lt; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是使用编译器生成目标文件hellorect.o和rect.o，$@是上一行冒号左边的目标，$&lt;是上一行冒号右边第一个依赖文件。hellorect.o和rect.o就是链接器需要的$(OBJECTS) 。</p>
<p>最后的两句是清除规则：</p>
<pre class="line-numbers language-none"><code class="language-none">clean:
	rm  $(OBJECTS)  hellorect<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>rm是删除命令，如果Windows系统里没有rm命令，请安装一个msysgit工具(<a href="http://msysgit.github.io/">下载地址</a>)， 然后系统环境变量里面会有msysgit工具路径，里面有rm工具。<br>
这里clean做的事情就是删除项目生成的.o和可执行文件。(注：Windows系统里可执行程序有.exe后缀，需要加上.exe后缀。）每个makefile中都应该写一个清空目标文件(.o和执行文件)的规则，这不仅便于重编译，也很利于保持文件的清洁。clean的规则不要放在文件的开头，不然这就会变成make的默认目标，相信谁也不愿意这样，不成文的规矩是——“clean从来都是放在文件的最后”。</p>
<h3 id="make自动管理编译文件"><a class="markdownIt-Anchor" href="#make自动管理编译文件"></a> make自动管理编译文件</h3>
<p>编辑好makefile文件之后，那么如何使用make工具呢？如果要生成项目，就在项目文件夹hellorect里执行：</p>
<blockquote>
<p>make</p>
</blockquote>
<p>如果要清理项目就执行：</p>
<blockquote>
<p>make clean</p>
</blockquote>
<p>Linux 系统里直接用make，MinGW里面是用mingw32-make生成程序，Windows系统里用mingw32-make。</p>
<p>在默认的方式下，也就是我们只输入make命令。那么，</p>
<ul>
<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件</li>
<li>如果找到，它会找文件中的第一个目标文件(target)，在上面的例子中，他会找到hellorec这个文件，并把这个文件作为最终的目标文件
<ul>
<li>如果edit文件不存在，或是edit所依赖的后面的.o文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成DSTTARGET这个文件</li>
</ul>
</li>
<li>如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件
<ul>
<li>这有点像一个堆栈的过程，把实际编译的顺序倒过来压栈，当到已经存在的依赖文件后再依次编译生成栈中的目标</li>
</ul>
</li>
<li>当然，一般源文件和头文件肯定是存在，于是make会生成.o文件，然后再用.o文件完成make的终极任务的编译，也就是执行文件DSTTARGET了</li>
<li>考虑到头文件的用途，一般源文件也是要依赖于头文件的，因此头文件改掉的话基本上整个工程都要重新编译了</li>
</ul>
<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系(而且是每完成一步编译任务应该就生成下一个任务的输入)，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。<strong>make只管文件的依赖性</strong>，即如果找了依赖关系之后，冒号后面的文件还是不在，那么对不起，make就不工作啦。<br>
通过上述分析，可以知道像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过可以显式让make执行，即命令make clean，以此来清除所有的目标文件，以便重编译。因此在实际中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如hellorecpp.c，那么根据依赖性hellorec.o会被重编译(也就是在这个依赖关系后面所定义的命令)，这时hellorec.o的文件也是最新的啦。hellorec.o的文件修改时间要比edit要新，所以hellorec也会被重新链接。</p>
<h2 id="make的基本工作原理以gnu-make为例"><a class="markdownIt-Anchor" href="#make的基本工作原理以gnu-make为例"></a> make的基本工作原理(以GNU make为例)</h2>
<p>makefile本质上只是一个文本文件，其中定义的规则是否可以实现要由具体平台的make工具而定(就跟c语言与c编译器的关系一样)。makefile一旦写好，只需要Shell中的一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个解释makefile指令的命令行程序，大多数集成开发环境都支持了这一命令工具，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make，不同厂商的make工具之间略有差异，不过这其中使用最多、应用最为广泛的还是GNU的make，相对来说也最遵循于IEEE 1003.2-1992标准(POSIX.2)，因此一般不作特殊说明的make都是指GNU的make。<br>
实际上针对这个问题进一步来说，make本身是考虑到跨平台的问题的，但是这里面存在着很重要的一点是make要调用Shell来解释命令，而不同平台不同版本的Shell的区别是非常大的。另外不同平台在文件系统、设备系统等方面的设计都有所不同(最明显的比方说UNIX和Windows的文件路径格式就不一样)，所以一般的软件其实都很难做到完全的跨平台。</p>
<h3 id="makefile文件名"><a class="markdownIt-Anchor" href="#makefile文件名"></a> makefile文件名</h3>
<p>注意：makefile文件通常没有扩展名。</p>
<ul>
<li>主要是linux原本就没有后缀名一说，xxx.xxx就是一个文件名，文件名和linux文件类型没有关系</li>
<li>有时需要编写一组复杂的包含彼此的makefile时，一般会定义一系列的makefile文件，但这些通常也是保留给主文件包含的makefile片段</li>
</ul>
<p><strong>默认</strong>的情况下，make工具会在当前目录下按顺序找寻<strong>文件名</strong>为GNUmakefile、makefile、Makefile的文件。在这三个文件名中，最好使用<strong>makefile</strong>这个文件名，因为总感觉这个比较符合变量命名规则，并且重要的是一些其他的make工具只对全小写的makefile文件名敏感。基本上来说，大多数的make工具都支持makefile和Makefile这两种默认文件名，因此最好不要用GNUmakefile，这个文件是GNU的make识别的。</p>
<ul>
<li>需要注意的是如果你同时定义了GNUmakefile、makefile、Makefile这三个文件名，那么make搜索的优先级为GNUmakefile&gt;makefile&gt;Makefile</li>
</ul>
<p>当然也可以使用别的文件名来命名makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等。如果要指定这些自定义命名的makefile并且作为make的生成脚本，可以使用make的“-f”和“--file”参数，如：</p>
<blockquote>
<p>make -f Make.Linux或make --file Make.AIX 等</p>
</blockquote>
<h3 id="makefile的构成"><a class="markdownIt-Anchor" href="#makefile的构成"></a> makefile的构成</h3>
<p>绝大多数的makefile里主要包含了五个东西：显式规则、隐式规则、变量定义、文件指示和注释。</p>
<ul>
<li>显式规则，显式规则说明了，如何生成一个或多的的目标文件，这是由makefile的编写者显式指定的，如要生成的文件，生成文件的依赖文件，生成的shell命令等。makefile中的命令必须要以[Tab]键开始
<ul>
<li>实际上makefile由两种语言的语法构成，一种是makefile原生语法，另一个是Shell脚本语法，这两者间就看开始是否使用[Tab]键缩进来区分</li>
</ul>
</li>
<li>隐晦规则，主要是由make工具具体支持的自动推导的功能，方便脚本编写</li>
<li>变量的定义，在makefile中可以定义一系列的变量，变量一般都是字符串</li>
<li>文件指示，其中主要包括三个部分
<ul>
<li>在一个makefile中引用另一个makefile，就像用include包含头文件一样</li>
<li>根据某些情况指定makefile中的有效部分，就像预编译指令#if一样</li>
<li>定义一个多行的命令</li>
</ul>
</li>
<li>注释，makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用#字符。如果要在makefile中使用#字符，可以用反斜框进行转义，如：\#</li>
</ul>
<h3 id="makefile文件包含"><a class="markdownIt-Anchor" href="#makefile文件包含"></a> makefile文件包含</h3>
<p>在makefile中使用include关键字可以把别的makefile包含进来，这很像c语言的#include，被包含的文件会完全一致地扩展在当前文件的包含位置。<br>
include的语法是：</p>
<blockquote>
<p>include&lt;filename&gt;</p>
</blockquote>
<p>其中filename可以是当前操作系统Shell的文件模式(也就是说可以包含通配符)。在include前面可以有一些空字符，但是<strong>绝不能以[Tab]键开始</strong>。include和filename间可以用一个或多个空格隔开，假设在目录中有几个以.mk结尾的makefile，那么可以这样包含：</p>
<blockquote>
<p>include foo.make *.mk</p>
</blockquote>
<p>或者也可以用文件名定义变量，假设用上面这些以.mk结尾的makefile定义变量$(bar)，也可以这样包含：</p>
<blockquote>
<p>include foo.make $(bar)</p>
</blockquote>
<p>make命令开始时，会搜索include所指出的其它makefile，并把其内容安置在当前的位置。如果文件都没有指定绝对路径的话，make会在当前目录下首先搜索，如果当前目录下没有找到那么make还会在下面的几个目录下找：</p>
<ul>
<li>如果make执行时，有&quot;-I&quot;或&quot;--include-dir&quot;参数，那么make就会在这个参数所指定的目录下去找</li>
<li>如果目录/include(一般是：/usr/local/bin/include或/usr/include)存在的话，make也会去这里找</li>
<li>如果当前环境中定义了环境变量<strong>MAKEFILES</strong>，那么make会把这个变量中的值做一个类似于include的操作。这个变量中的值是其它的makefile路径，用空格分隔。只是它和include不同的是从这个环境变量中引入的makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理
<ul>
<li>makefile会自动读取系统中的环境变量，并复制一份一模一样的，如果用户在makefile中定义的同名的变量，那么原来的环境变量就会被覆盖</li>
<li>最好慎重使用MAKEFILES这个环境变量，因为只要这个默认保留的变量一被定义，那么使用make时所有makefile都会受其影响。(也就是说所有mskefile都自动包含MAKEFILES中的文件，显然这是个很有问题的做法)</li>
</ul>
</li>
</ul>
<p>如果有文件没有找到或无法读的话，make会生成一条警告信息，但不会马上出现错误。它会继续载入其它的文件，一旦完成整个makefile的读取，make会再重试这些没有找到或不能读取的文件，如果还是不行，make才会出现一条错误信息。如果想让make忽略那些无法读取的文件继续执行，可以在include前加一个减号，其表示无论include过程中出现什么错误都不要报错继续执行，如：</p>
<blockquote>
<p>-include&lt;filename&gt;</p>
</blockquote>
<p>还有一个相关命令是sinclude，其作用和include是一样的，sinclude的意义在于和其它版本的make工具兼容。</p>
<h3 id="make的主要执行流程"><a class="markdownIt-Anchor" href="#make的主要执行流程"></a> make的主要执行流程</h3>
<ol>
<li>读入环境变量MAKEFILES定义的makefile文件列表</li>
<li>读入当前目录下的makefile文件
<ul>
<li>根据命名查找顺序GNUmakefile，makefile，Makefile，首先找到哪个就读取哪个</li>
</ul>
</li>
<li>读入被include的其它makefile</li>
<li>查找并重建所有已读取的makefile文件的规则
<ul>
<li>如果存在一个目标是当前读取的某一个makefile文件，则执行此规则重建此makefile文件，完成以后从第一步开始重新执行(也就是说一个makefile可能牵扯到另一个makefile的内容，并且这个makefile还包含了对方，因此要在重建包含的makefile之后重新执行这个makefile，总之这种情况很复杂且难以控制，最好避免)</li>
</ul>
</li>
<li>初始化文件中的变量，推导隐式规则，并分析所有规则，展开那些需要立即展开的变量和函数并根据预设条件确定执行分支</li>
<li>根据最终目标以及其他目标的依赖关系建立依赖关系链表</li>
<li>执行除最终目标以外的所有的目标的规则
<ul>
<li>规则中如果依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件</li>
</ul>
</li>
<li>执行最终目标所在的规则</li>
</ol>
<p>1-6步为读取和分析阶段，7-8为执行阶段。第一个阶段中，如果定义的变量被使用了，那么make会把其展开在使用的位置。但此时make一般并不会完全马上展开，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开(makefile毕竟是脚本按行执行，不需要编译，所以运行时再展开很正常)。</p>
]]></content>
      <categories>
        <category>应用程序开发</category>
      </categories>
      <tags>
        <tag>工具使用</tag>
        <tag>makefile</tag>
        <tag>编译原理实例</tag>
      </tags>
  </entry>
  <entry>
    <title>7.简单排序算法、统计工龄</title>
    <url>/posts/544c1950bf09</url>
    <content><![CDATA[<h1 id="各种排序"><a class="markdownIt-Anchor" href="#各种排序"></a> 各种排序</h1>
<p>给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下：<br>
数据1：只有1个元素；<br>
数据2：11个不相同的整数，测试基本正确性；<br>
数据3：103个随机整数；<br>
数据4：104个随机整数；<br>
数据5：105个随机整数；<br>
数据6：105个顺序整数；<br>
数据7：105个逆序整数；<br>
数据8：105个基本有序的整数；<br>
数据9：105个随机正整数，每个数字不超过1000。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入第一行给出正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">（</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">N（≤10^5）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">（</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>，随后一行给出N个（长整型范围内的）整数，其间以空格分隔。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">11
4 981 10 -17 0 -20 29 50 8 43 -5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">-20 -17 -5 0 4 8 10 29 43 50 981<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define maxnum 10050
using namespace std;
int n;
long a[maxnum];
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;a[i];
    mysort(0,n-1);
    for(int i&#x3D;0;i&lt;n-1;i++)cout&lt;&lt;a[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;a[n-1];
&#125;
&#x2F;&#x2F;冒泡排序
void mysort(int start,int end)&#123;                 
    for(int i&#x3D;end-start;i&gt;0;i--)&#123;
        int flag&#x3D;0;
        for(int j&#x3D;0;j&lt;i;j++)&#123;
            long tmp&#x3D;a[j];
            if(a[j]&gt;a[j+1])&#123;
                a[j]&#x3D;a[j+1],a[j+1]&#x3D;tmp;
                flag&#x3D;1;
            &#125;
        &#125;
        if(!flag)break;
    &#125;
&#125;
&#x2F;&#x2F;插入排序
void mysort(int start,int end)&#123;
    for(int i&#x3D;1;i&lt;&#x3D;end-start;i++)&#123;
        int j;
        long tmp&#x3D;a[i];
        for(j&#x3D;i;j&gt;0&amp;&amp;a[j-1]&gt;tmp;j--)a[j]&#x3D;a[j-1];
        a[j]&#x3D;tmp;
    &#125;
&#125;
&#x2F;&#x2F;希尔排序
void mysort(int start,int end)&#123;      &#x2F;&#x2F;希尔排序：基于原始增量序列版本
    for(int length&#x3D;(end+start)&#x2F;2;length&gt;0;length&#x2F;&#x3D;2)&#123;
        for(int i&#x3D;1;i&lt;n;i++)&#123;
            int j;
            long tmp&#x3D;a[i];
            for(j&#x3D;i;j&gt;&#x3D;length&amp;&amp;a[j-length]&gt;tmp;j-&#x3D;length)a[j]&#x3D;a[j-length];
            a[j]&#x3D;tmp;
        &#125;
    &#125;
&#125;
void mysort(int start,int end)&#123;      &#x2F;&#x2F;希尔排序：基于Sedgewick增量序列版本
    int Sedgewick[]&#x3D;&#123;929,505,209,109,41,19,5,1,0&#125;;
    for(int l&#x3D;0;Sedgewick[l]&gt;end-start;length&#x3D;Sedgewick[l++]);
    for(int length&#x3D;Sedgewick[l];length&gt;0;l++)&#123;
        for(int i&#x3D;1;i&lt;n;i++)&#123;
            int j;
            long tmp&#x3D;a[i];
            for(j&#x3D;i;j&gt;&#x3D;length&amp;&amp;a[j-length]&gt;tmp;j-&#x3D;length)a[j]&#x3D;a[j-length];
            a[j]&#x3D;tmp;
        &#125;
    &#125;
&#125;
&#x2F;&#x2F;堆排序
void percdown(int root,int size)&#123;
    long tmp&#x3D;a[root];
    int parent,child;
    for(parent&#x3D;root;parent*2+1&lt;size;parent&#x3D;child)&#123;
        child&#x3D;parent*2+1;
        if(child&lt;size-1&amp;&amp;a[child]&lt;a[child+1])child++;
        if(tmp&gt;&#x3D;a[child])break;
        else a[parent]&#x3D;a[child];
    &#125;
    a[parent]&#x3D;tmp;
&#125;
void mysort(int start,int end)&#123;
    for(int i&#x3D;(end-start+1)&#x2F;2;i&gt;&#x3D;0;i--)percdown(i,end-start+1);
    for(int i&#x3D;end-start;i&gt;0;i--)&#123;
        long tmp&#x3D;a[0];
        a[0]&#x3D;a[i],a[i]&#x3D;tmp;
        percdown(0,i);
    &#125;
&#125;
&#x2F;&#x2F;归并排序
long tmpa[maxnum];
void merge(long*a,long*tmpa,int start,int end,int center)&#123; &#x2F;&#x2F;归并子列
    int start1&#x3D;start,end1&#x3D;center,start2&#x3D;center+1,end2&#x3D;end,tmp&#x3D;start;
    while(start1&lt;&#x3D;end1&amp;&amp;start2&lt;&#x3D;end2)&#123;
        if(a[start1]&lt;&#x3D;a[start2])tmpa[tmp++]&#x3D;a[start1++];
        else tmpa[tmp++]&#x3D;a[start2++];
    &#125;
    while(start1&lt;&#x3D;end1)tmpa[tmp++]&#x3D;a[start1++];
    while(start2&lt;&#x3D;end2)tmpa[tmp++]&#x3D;a[start2++];
    for(int i&#x3D;start;i&lt;&#x3D;end;i++)a[i]&#x3D;tmpa[i];
&#125;
void mysort(int start,int end)&#123;     &#x2F;&#x2F;归并排序：递归版本
    if(start&gt;&#x3D;end)return;
    int center&#x3D;(start+end)&#x2F;2;
    mysort(start,center);
    mysort(center+1,end);
    merge(a,tmpa,start,end,center);
&#125;
void mysort(int start,int end)&#123;     &#x2F;&#x2F;归并排序：非递归版本
    int length&#x3D;1;
    while(length&lt;&#x3D;end-start)&#123;
        int i;
        for(i&#x3D;0;i&lt;&#x3D;n-length*2;i+&#x3D;length*2)merge(a,tmpa,i,i+length*2-1,i+length-1);
        if(i+length&lt;&#x3D;n)merge(a,tmpa,i,n-1,i+length-1);
        else for(int j&#x3D;i;j&lt;n;j++)tmpa[j]&#x3D;a[j];
        length*&#x3D;2;
        for(i&#x3D;0;i&lt;&#x3D;n-length*2;i+&#x3D;length*2)merge(tmpa,a,i,i+length*2-1,i+length-1);
        if(i+length&lt;&#x3D;n)merge(tmpa,a,i,n-1,i+length-1);
        else for(int j&#x3D;i;j&lt;n;j++)a[j]&#x3D;tmpa[j];
        length*&#x3D;2;
    &#125;
&#125; 
&#x2F;&#x2F;快速排序
int compare(const void*num1,const void*num2)&#123;
    return (*(int*)num1-*(int*)num2);
&#125;
void mysort(int start,int end)&#123;                 &#x2F;&#x2F;快速排序：库函数版本
    qsort(a,end-start+1,sizeof(long),compare);
&#125;
int cutoff;
void swap(long*element1,long*element2)&#123;
    long tmp&#x3D;*element1;
    *element1&#x3D;*element2,*element2&#x3D;tmp;
&#125;
long median(int start,int end)&#123;
    int center&#x3D;(start+end)&#x2F;2;
    if(a[start]&gt;a[center])swap(&amp;a[start],&amp;a[center]);
    if(a[start]&gt;a[end])swap(&amp;a[start],&amp;a[end]);
    if(a[center]&gt;a[end])swap(&amp;a[center],&amp;a[end]);
    swap(&amp;a[center],&amp;a[end-1]);
    return a[end-1];
&#125;
void mysort(int start,int end)&#123;                 &#x2F;&#x2F;快速排序：手写版本
    if(start&gt;&#x3D;end)return;
    if(cutoff&lt;&#x3D;end-start+1)&#123;
        long pivot&#x3D;median(start,end);
        int low&#x3D;start,high&#x3D;end-1;
        while(low&lt;high)&#123;
            while(a[++low]&lt;pivot);
            while(a[--high]&gt;pivot);
            swap(&amp;a[low],&amp;a[high]);
        &#125;
        swap(&amp;a[low],&amp;a[end-1]);
        mysort(start,low-1);
        mysort(low+1,end);
    &#125;else sort(a,a+end-start+1);
&#125;
&#x2F;&#x2F;基数排序
#define maxdigit 4
#define radix 10
typedef struct node*pnode;
struct node&#123;
    long key;pnode next;
&#125;;
struct headnode&#123;
    pnode head,tail;
&#125;;
typedef struct headnode bucket[radix];
long factor;
int getdigit(long num,int bits)&#123;
    int bitnum;
    for(int i&#x3D;0;i&lt;bits;i++)&#123;
        bitnum&#x3D;(int)num%radix;
        num&#x2F;&#x3D;radix;
    &#125;
    return bitnum;
&#125;
void mysort(int start,int end)&#123;                 &#x2F;&#x2F;基数排序：LSD(次位优先)版本
    for(int i&#x3D;0;i&lt;n;i++)if(factor+a[i]&lt;0)factor&#x3D;-a[i];
    for(int i&#x3D;0;i&lt;n;i++)a[i]+&#x3D;factor;
    bucket buk;
    pnode list&#x3D;nullptr,p,tmp;
    for(auto&amp;i:buk)i.head&#x3D;i.tail&#x3D;nullptr;
    for(int i&#x3D;end-start;i&gt;&#x3D;0;i--)&#123;
        tmp&#x3D;new struct node;
        tmp-&gt;key&#x3D;a[i];
        tmp-&gt;next&#x3D;list,list&#x3D;tmp;
    &#125;
    for(int i&#x3D;1;i&lt;&#x3D;maxdigit;i++)&#123;
        p&#x3D;list;
        while(p)&#123;
            int di&#x3D;getdigit(p-&gt;key,i);
            tmp&#x3D;p,p&#x3D;p-&gt;next,tmp-&gt;next&#x3D;nullptr;
            if(!buk[di].head)buk[di].head&#x3D;buk[di].tail&#x3D;tmp;
            else buk[di].tail-&gt;next&#x3D;tmp,buk[di].tail&#x3D;tmp;
        &#125;
        list&#x3D;nullptr;
        for(int j&#x3D;radix-1;j&gt;&#x3D;0;j++)&#123;
            if(buk[j].head)&#123;
                buk[j].tail-&gt;next&#x3D;list;
                list&#x3D;buk[j].head;
                buk[j].head&#x3D;buk[j].tail&#x3D;nullptr;
            &#125;
        &#125;
    &#125;
    for(int i&#x3D;0;i&lt;end-start+1;i++)&#123;
        tmp&#x3D;list;
        list&#x3D;list-&gt;next;
        a[i]&#x3D;tmp-&gt;key-factor;
        free(tmp);
    &#125;
&#125;
void mysort_pass(int start,int end,int bits)&#123;
    bucket buk;
    pnode list&#x3D;nullptr,p,tmp;
    if(bits&lt;&#x3D;0)return;
    for(auto&amp;i:buk)i.head&#x3D;i.tail&#x3D;nullptr;
    for(int i&#x3D;start;i&lt;&#x3D;end;i++)&#123;
        tmp&#x3D;new struct node;
        tmp-&gt;key&#x3D;a[i];
        tmp-&gt;next&#x3D;list,list&#x3D;tmp;
    &#125;
    p&#x3D;list;
    while(p)&#123;
        int di&#x3D;getdigit(p-&gt;key,bits);
        tmp&#x3D;p,p&#x3D;p-&gt;next;
        if(!buk[di].head)buk[di].tail&#x3D;tmp;
        tmp-&gt;next&#x3D;buk[di].head,buk[di].head&#x3D;tmp;
    &#125;
    int left&#x3D;start,right&#x3D;start;
    for(auto i:buk)&#123;
        if(i.head)&#123;
            p&#x3D;i.head;
            while(p)&#123;
                tmp&#x3D;p,p&#x3D;p-&gt;next;
                a[right++]&#x3D;tmp-&gt;key;
                free(tmp);
            &#125;
            mysort_pass(left,right-1,bits-1);
            left&#x3D;right;
        &#125;
    &#125;
&#125;
void mysort(int start,int end)&#123;                 &#x2F;&#x2F;基数排序：MSD(主位优先)版本
    for(int i&#x3D;0;i&lt;end-start+1;i++)if(factor+a[i]&lt;0)factor&#x3D;-a[i];
    for(int i&#x3D;0;i&lt;end-start+1;i++)a[i]+&#x3D;factor;
    mysort_pass(start,end,maxdigit);
    for(int i&#x3D;0;i&lt;end-start+1;i++)a[i]-&#x3D;factor;
&#125;    
int counts[radix];
long tmpa[maxcount];
void mysort(int start,int end)&#123;                 &#x2F;&#x2F;基数排序：无链表版本
    int bits&#x3D;1;
    for(int i&#x3D;0;i&lt;n;i++)if(a[i]+factor&lt;0)factor&#x3D;-a[i];
    for(int i&#x3D;0;i&lt;n;i++)a[i]+&#x3D;factor;
    for(int i&#x3D;0;i&lt;maxdigit;i++)&#123;
        for(int&amp;j:counts)j&#x3D;0;
        for(int j&#x3D;0;j&lt;end-start+1;j++)&#123;
            int k&#x3D;(int)(a[j]&#x2F;bits)%radix;
            counts[k]++;
        &#125;
        for(int j&#x3D;1;j&lt;radix;j++)counts[j]+&#x3D;counts[j-1];
        for(int j&#x3D;0;j&lt;end-start+1;j++)&#123;
            int k&#x3D;(int)(a[j]&#x2F;bits)%radix;
            tmpa[counts[k]-1]&#x3D;a[j];
            counts[k]--;
        &#125;
        for(int j&#x3D;0;j&lt;end-start+1;j++)a[j]&#x3D;tmpa[j];
        bits*&#x3D;10;
    &#125;
    for(int i&#x3D;0;i&lt;n;i++)a[i]-&#x3D;factor;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="统计工龄"><a class="markdownIt-Anchor" href="#统计工龄"></a> 统计工龄</h1>
<p>给定公司N名员工的工龄，要求按工龄增序输出每个工龄段有多少员工。</p>
<h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h2>
<p>输入首先给出正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">（</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mi mathvariant="normal">）</mi></mrow><annotation encoding="application/x-tex">N（≤10^5）</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">（</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">）</span></span></span></span>，即员工总人数；随后给出N个整数，即每个员工的工龄，范围在[0, 50]。</p>
<h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h2>
<p>按工龄的递增顺序输出每个工龄的员工个数，格式为：“工龄:人数”。每项占一行。如果人数为0则不输出该项。</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">8
10 2 0 5 7 2 5 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">0:1
2:3
5:2
7:1
10:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define maxages 55
using namespace std;
int n,age,ages[maxages];
void count();
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;age;
        ages[age]++;
    &#125;
    for(int i&#x3D;0;i&lt;maxages;i++)if(ages[i])cout&lt;&lt;i&lt;&lt;&#39;:&#39;&lt;&lt;ages[i]&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>6.词频统计、电话聊天狂人、QQ帐户的申请与登陆</title>
    <url>/posts/c26c4006a7b5</url>
    <content><![CDATA[<h1 id="词频统计"><a class="markdownIt-Anchor" href="#词频统计"></a> 词频统计</h1>
<p>散列表应用：文件中单词词频统计<br>
例：给定一个英文文本文件，统计文件中所有单词出现的频率，并输出词频最大的前10%的单词及其词频，假设单词字符定义为大小写字母、数字和下划线，其他字符均认为是单词分隔符，不予考虑</p>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<ul>
<li>关键：对新读入的单词在已有的单词表中查找，如果已经存在，则将该单词的词频加1；如果不存在，则插入该单词并记词频为1</li>
<li>如何设计该单词表的数据结构才可以进行快速的查找和插入：应用散列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    int TableSize&#x3D;10000;                    &#x2F;&#x2F;散列表估计大小
    int wordcount&#x3D;0,length;
    HashTable H;
    ElementType word;
    FILE*fp;
    char document[30]&#x3D;&quot;HarryPotter.txt&quot;;    &#x2F;&#x2F;要被统计词频的文件名
    H&#x3D;InitializeTable(TableSize);           &#x2F;&#x2F;建立散列表
    if((fp&#x3D;fopen(document,&#39;r&#39;))&#x3D;&#x3D;NULL)FatalError(&quot;无法打开文件！\n&quot;);
    while(!feof(fp))&#123;
        length&#x3D;GetAWord(fp,word);           &#x2F;&#x2F;从文件中读取一个单词
        if(length&gt;3)&#123;                       &#x2F;&#x2F;只考虑适当长度的单词
            wordcount++;                    &#x2F;&#x2F;统计文件中单词总数
            InsertAndCount(word,H);          
        &#125;
    &#125;
    fclose(fp);
    printf(&quot;该文档总共出现%d个有效单词，&quot;,wordcount);
    Show(H,10.0&#x2F;100);                       &#x2F;&#x2F;显示词频前10%的所有单词
    &#x2F;&#x2F;统计最大词频：
    &#x2F;&#x2F;用一组数统计从1到最大词频的单词数
    &#x2F;&#x2F;计算前10%的词频应该是多少
    &#x2F;&#x2F;输出前10%的单词
    DestroyTable(H);                        &#x2F;&#x2F;销毁散列表
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="电话聊天狂人"><a class="markdownIt-Anchor" href="#电话聊天狂人"></a> 电话聊天狂人</h1>
<p>给定大量手机用户通话记录，找出其中通话次数最多的聊天狂人。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入首先给出正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，为通话记录条数。随后N行，每行给出一条通话记录。简单起见，这里只列出拨出方和接收方的11位数字构成的手机号码，其中以空格分隔。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>在一行中给出聊天狂人的手机号码及其通话次数，其间以空格分隔。如果这样的人不唯一，则输出狂人中最小的号码及其通话次数，并且附加给出并列狂人的人数。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">4                        
13005711862 13588625832
13505711862 13088625832
13588625832 18087925832
15005713862 13588625832<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">13588625832 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h2>
<p>解法1-排序</p>
<ul>
<li>第1步：读入最多<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2*10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>个电话号码，每个号码存为长度为11的字符串</li>
<li>第2步：按字符串非递减顺序排序</li>
<li>第3步：扫描有序数组，累计同号码出现的次数，并且更新最大次数</li>
<li>此方法编程快捷简单，但无法扩展解决动态插入的问题</li>
</ul>
<p>解法2-直接映射</p>
<ul>
<li>第1步：创建有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2\times10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个单元的整数数组，保证每个电话号码对应唯一的单元下标：数组初始化为0</li>
<li>第2步：对读入的每个电话号码，找到以之为下标的单元，数值累计1次</li>
<li>第3步：顺序扫描数组，找出累计次数最多的单元</li>
<li>此方法编程简单快捷，动态插入快</li>
<li>但下标范围已经超过了unsigned long，需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup><mo>×</mo><mn>2</mn><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo>≈</mo><mn>37</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">2\times10^{10}\times2bytes≈37GB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">7</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>，为了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">2\times10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>个号码扫描<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2\times10^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>个单元</li>
</ul>
<p>解法3-带“智商“的散列</p>
<ul>
<li>分离链接法</li>
<li>将最后5位用于散列</li>
</ul>
<h3 id="程序框架"><a class="markdownIt-Anchor" href="#程序框架"></a> 程序框架</h3>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    创建散列表;
    读入号码插入表中;
    扫描表输出狂人;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>HashTable的定义 ——&gt; NextPrime ——&gt; CreateTable<br>
Hash,Find ——&gt; Insert</p>
<p>扫描整个散列表：更新最大通话次数、更新最小号码+统计人数</p>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    int N,i;
    ElementType key;
    HashTable H;
    scanf(&quot;%d&quot;,&amp;N);
    H&#x3D;CreateTable(N*2);     &#x2F;&#x2F;创建一个散列表
    for(i&#x3D;0;i&lt;N;i++)&#123;
        scanf(&quot;%s&quot;,key);Insert(H,Key);
        scanf(&quot;%s&quot;,key);Insert(H,Key);
    &#125;
    ScanAndOutput(H);
    DestroyTable(H);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出狂人</p>
<pre class="line-numbers language-none"><code class="language-none">void ScanAndOutput(HashTable H)&#123;
    int i,MaxCnt&#x3D;PCnt&#x3D;0;
    ElementType MinPhone;
    List Ptr;
    MinPhone[0]&#x3D;&#39;\0&#39;;
    for(i&#x3D;0;i&lt;H-&gt;TableSizel;i++)&#123;                &#x2F;&#x2F;扫描链表
        Ptr&#x3D;H-&gt;Heads[i].Next;
        while(Ptr)&#123;
            if(Ptr-&gt;Count&gt;MaxCnt)&#123;               &#x2F;&#x2F;更新最大通话次数
                MaxCnt&#x3D;Ptr-&gt;Count;
                strcpy(MinPhone,Ptr-&gt;Data);
                PCnt&#x3D;1;
            &#125;
            else if(Ptr-&gt;Count&#x3D;&#x3D;MaxCnt)&#123;
                PCnt++;                          &#x2F;&#x2F;狂人计数
                if(strcmp(MinPhone,Ptr-&gt;Data)&gt;0)
                    strcpy(MinPhone,Ptr-&gt;Data);  &#x2F;&#x2F;更新狂人的最小手机号码
            &#125;
            Ptr&#x3D;Ptr-&gt;Next;
        &#125;
    &#125;
    printf(&quot;%s %d&quot;,MinPhone,MaxCnt);
    if(PCnt&gt;1)printf(&quot; %d&quot;,PCnt);
    printf(&quot;\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>HashTable的定义</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct LNode *PtrToLNode;
struct LNode &#123;
    ElementType Data;
    PtrToLNode Next;
    int Count;(新增)
&#125;;
typedef PtrToLNode Position;
typedef PtrToLNode List;

#define MAXTABLESIZE 1000000
int Hash(int Key,int P)&#123;            &#x2F;&#x2F;除留余数法散列函数
    return Key%P;
&#125;
int NextPrime( int N )
&#123; &#x2F;&#x2F; 返回大于N且不超过MAXTABLESIZE的最小素数 
    int i, p &#x3D; (N%2)? N+2 : N+1; &#x2F;&#x2F;从大于N的下一个奇数开始 

    while( p &lt;&#x3D; MAXTABLESIZE ) &#123;
        for( i&#x3D;(int)sqrt(p); i&gt;2; i-- )
            if ( !(p%i) ) break; &#x2F;&#x2F; p不是素数 
        if ( i&#x3D;&#x3D;2 ) break; &#x2F;&#x2F; for正常结束，说明p是素数 
        else  p +&#x3D; 2; &#x2F;&#x2F; 否则试探下一个奇数 
    &#125;
    return p;
&#125;
HashTable CreateTable( int TableSize )
&#123;
    HashTable H;
    int i;
    H &#x3D; (HashTable)malloc(sizeof(struct TblNode));
    H-&gt;TableSize &#x3D; NextPrime(TableSize);
    H-&gt;Heads &#x3D; (List)malloc(H-&gt;TableSize*sizeof(struct LNode));
    for( i&#x3D;0; i&lt;H-&gt;TableSize; i++ ) &#123;
        H-&gt;Heads[i].Data[0] &#x3D; &#39;\0&#39;;
        H-&gt;Heads[i].Next &#x3D; NULL;
        H-&gt;Heads[i].Count&#x3D;0;(新增)
    &#125;
    return H;
&#125;
Position Find( HashTable H, ElementType Key )
&#123;
    Position P;
    Index Pos;
  
    Pos &#x3D; Hash( atoi(Key+KEYLENGTH-MAXD), H-&gt;TableSize );(修改)
    P &#x3D; H-&gt;Heads[Pos].Next; &#x2F;&#x2F; 从该链表的第1个结点开始 
    &#x2F;&#x2F; 当未到表尾，并且Key未找到时 
    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )
        P &#x3D; P-&gt;Next;

    return P; &#x2F;&#x2F; 此时P或者指向找到的结点，或者为NULL 
&#125;
bool Insert( HashTable H, ElementType Key )
&#123;
    Position P, NewCell;
    Index Pos;
  
    P &#x3D; Find( H, Key );
    if ( !P ) &#123; &#x2F;&#x2F; 关键词未找到，可以插入 
        NewCell &#x3D; (Position)malloc(sizeof(struct LNode));
        strcpy(NewCell-&gt;Data, Key);
        NewCell-&gt;Count&#x3D;1;(新增)
        Pos&#x3D;Hash(atoi(Key+KEYLENGTH-MAXD),H-&gt;TableSize);(修改)
        &#x2F;&#x2F; 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 
        NewCell-&gt;Next &#x3D; H-&gt;Heads[Pos].Next;
        H-&gt;Heads[Pos].Next &#x3D; NewCell; 
        return true;
    &#125;
    else &#123; &#x2F;&#x2F; 关键词已存在 
        printf(&quot;键值已存在&quot;);
        return false;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;map的应用！
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
using namespace std;
map&lt;string,int&gt;id;
string num1,num2,minphn;
int n,maxc,countc;
void crazyman();
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;num1&gt;&gt;num2;
        id[num1]++,id[num2]++;
    &#125;
    crazyman();
&#125;
void crazyman()&#123;
    for(auto i:id)&#123;
        if(i.second&gt;maxc)maxc&#x3D;i.second,minphn&#x3D;i.first,countc&#x3D;1;
        else if(i.second&#x3D;&#x3D;maxc)countc++;
    &#125;
    cout&lt;&lt;minphn&lt;&lt;&#39; &#39;&lt;&lt;maxc;
    if(countc&gt;1)cout&lt;&lt;&#39; &#39;&lt;&lt;countc;
    cout&lt;&lt;endl;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="qq帐户的申请与登陆"><a class="markdownIt-Anchor" href="#qq帐户的申请与登陆"></a> QQ帐户的申请与登陆</h1>
<p>实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。</p>
<h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h2>
<p>输入首先给出一个正整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(≤10^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，随后给出N行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。</p>
<h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h2>
<p>针对每条指令，给出相应的信息：<br>
1）若新申请帐户成功，则输出“New: OK”；<br>
2）若新申请的号码已经存在，则输出“ERROR: Exist”；<br>
3）若老帐户登陆成功，则输出“Login: OK”；<br>
4）若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；<br>
5）若老帐户密码错误，则输出“ERROR: Wrong PW”。</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">5
L 1234567890 myQQ@qq.com
N 1234567890 myQQ@qq.com
N 1234567890 myQQ@qq.com
L 1234567890 myQQ@qq
L 1234567890 myQQ@qq.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">ERROR: Not Exist
New: OK
ERROR: Exist
ERROR: Wrong PW
Login: OK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 还是map
#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#define digitn 100500
using namespace std;
int n;
char command;
string id,pw;
map&lt;string,string&gt;qq;
void judgeqq(char,const string&amp;,const string&amp;),insert(string,string);
int main()&#123;
    cin&gt;&gt;n;
    for(int i&#x3D;0;i&lt;n;i++)&#123;
        cin&gt;&gt;command&gt;&gt;id&gt;&gt;pw;
        judgeqq(command,id,pw);
    &#125;
&#125;
void judgeqq(char cd,const string&amp;idstr,const string&amp;pwstr)&#123;
    if(cd&#x3D;&#x3D;&#39;N&#39;)&#123;
        if(qq.find(idstr)!&#x3D;qq.end())cout&lt;&lt;&quot;ERROR: Exist&quot;&lt;&lt;endl;
        else&#123;
            qq[idstr]&#x3D;pwstr;
            cout&lt;&lt;&quot;New: OK&quot;&lt;&lt;endl;
        &#125;
    &#125;else if(cd&#x3D;&#x3D;&#39;L&#39;)&#123;
        if(qq.find(idstr)&#x3D;&#x3D;qq.end())cout&lt;&lt;&quot;ERROR: Not Exist&quot;&lt;&lt;endl;
        else if(qq[idstr]!&#x3D;pwstr)cout&lt;&lt;&quot;ERROR: Wrong PW&quot;&lt;&lt;endl;
        else cout&lt;&lt;&quot;Login: OK&quot;&lt;&lt;endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】一位计算机系研究生的心路历程</title>
    <url>/posts/6926d3c72e6d</url>
    <content><![CDATA[<p>时光荏苒，回眸一看，不觉在安大计算机已经过了一学期的研究生生活了.大多数作为计算机学院的研究生，一个很大的误区就是计算机专业毕业出来的研究生都得找编程、写算法方面的工作，于是读研的大部分时间就耗在如何通过增加项目实践经验来充实自己的研究生阶段生活。而以这种作为读研模式的研究生注定了出来找工作很可能还是和一些比较优秀的本科毕业生竞争抢饭碗，most importantly，这不是正确的读研模式。读研究生出来必须能具备本科生所不具备的能力素质和科研修养，要不然研究生学费就白交了，钱是小事，关键是读研所耗费的青春就白白浪费了…多宝贵的3年！很可惜，安大计算机学院大多数实验中心效仿的是这种读研机制…😦<br>
但关键是看个人，如果自己对某个研究方向感兴趣的话可以自己独立钻研，把计算机专业看做一门科学而不是纯粹的工程实践诚然是一个重大的观念性的转折。<br>
下面我引用一篇牛人对攻读计算机专业研究生的一些看法：<br>
如果你有实际开发工作经验，感觉自己的水平和实力进入了一个高原期，迫切需要从理论上提高，那么计算机学院是唯一选择。因为计算机学院才能让你在理论上更上一层楼。软件学院从教学计划上就没有把你往这方面带。当然能不能更上一层楼最终还是完全取决于你自己。需要特别说明的是，工作经验并不一定等于开发经验，我见过很多工作2-3年的人，但是没有一点开发经验。<br>
你说：“他们都有很强的开发能力,只是不太喜欢读书,也只是希望混个学历对今后在岗位上晋升有好处”，我可以向你保证，你所说的人绝对不是开发能力很强的人。因为：<br>
1）高手不可能不喜欢读书；<br>
2）高手不可能想去混一个学历；<br>
3）高手不可能认为晋升是因为学历的原因。<br>
还需要说明的是，考计算机的人未必个个都是高手，严格来说，大部分都不会编程序。也就是说，庸庸碌碌之辈仍然占绝大多数。研究生毕业的师兄只拿2500元左右的比比皆是，所以不要寄希望于拿一张研究生文凭出去赚高薪。但是，对于有实际开发工作经验的人，要想自己在3年之中有一个真正的提高的话，计算机学院提供了广阔的平台。就我所知，每一个月拿2万以上的也有（上海育碧，图形特效算法设计）。所以，同为研究生毕业，能力的差距是极大的。所以，不要去问“研究生毕业能拿多少钱？”，要问“像我这种水平的人，研究生毕业能拿多少钱？”这样人家才能够准确地回答你。<br>
所谓“有实际开发工作经验”是指你目前已经具备下列能力：<br>
1）你已经认为C<ins>和汇编语言都是很简单的语言，并能够自如地运用；<br>
2）你能够在30分钟之内想到正确的五子棋AI算法设计思路和方向；<br>
3）你完全理解STL为什么这么重要；<br>
4）你能够独立地解决所有的编译与链接问题，哪怕你从来没有遇到的问题，你也不需要询问任何人；<br>
5）英文网站是你的首要信息来源；<br>
6）能够读懂英语写成的国际标准，比如NTFS磁盘格式标准。<br>
7）你经常站在集合论的角度思考算法问题；<br>
8）能够理解一个简单的驱动程序，能够理解一个简单3D交互程序；<br>
9）你能够认识到线性代数和概率论在实际编程工作中的极端重要性；<br>
10）你完全理解COM的设计思想，尤其能够理解COM为什么要设计成这样；<br>
11）当我说到虚函数的重要作用时，你不会急着去找书来翻；<br>
12）你能够说出C</ins>为什么比其他语言优秀的理由，记住这种理由应该来自于你的开发体会，而不是因为其他人都这么说。<br>
此外还有很多判断标准，但如果你同时具备5条以上，可以认为你已经具备相应的开发经验了。在这种状态下读研，你将取得读研效益的最大值。<br>
读研重要的是要明白你自己要干什么，不能等导师来告诉你你应该干什么。研究生的优势在于理论功底深厚，思维具有穿透力，当然编程能力首先要过关，不要读完研究生还不知道MFC程序的WinMain函数在哪里。所以，研究生期间，你一定要做有理论深度的算法设计，比如大规模数据的搜索算法，性能是首要考虑因素，不要奢望SQL函数能够帮你解决问题，所有的问题你都必须自己解决，你必须解决内外存交换的性能瓶颈。再比如极品飞车的3D场景生成，图形变换，碰撞检测，物性模拟，纹理映射，灯光模型等等，这些都是可以保证你能拿到2万以上月薪的技术。如果你认为这些东西太难，不可能做得出来的话，那么你就不适合读研。真的，要是你认为读研之后还是要去搞一般的程序设计，如信息管理系统之类的软件，那么你读研的价值就完全不会得到体现，因为这些工作根本就不需要读研。<br>
软件学院宣称培养软件开发人才，恕我直言，我从来没有看见那个高手是培训成功的。成为软件开发高手的路只有一条：自学！软件开发中需要大量的编程实践和独立思考，只有在此过程中，你才能够逐步成长起来。软件学院宣称培养软件项目经理，这更是搞笑，在某种意义上这是欺骗行为。学院里面能够培养出软件开发经理更是十足的谎言，软件项目经理必须，或者说更强调从战争中学会战争。没有实践经验的项目经理就是绣花枕头一个。<br>
实话实说，软件学院就是一个蒙钱的机构，公关工作做得很好，善于打广告，而且都是打着高薪的幌子，就如同外面的什么北大青鸟培训班一样。两个字：蒙钱！四个字：还是蒙钱！<br>
总之一句话，如果你只想成为软件开发高手（比如认为会编驱动程序或杀毒软件就是高手的那种），建议工作，不要考研；完全没有工作经验的，也不建议考研，你进来了只有瞎混一通。如果你有上述工作经验且想成为高级软件工程师（能够独立理解并设计出快速傅立叶变换算法的那种软件工程师）的话，那么强烈建议考研。考研让你有3年放松思考的机会，也有3年让你思想和技术积累沉淀的机会。非常难得的机会。不考研的话，这种机会就是一种奢侈，可望而不可即的那么一种奢侈。<br>
所以，不管你是哪一种情况，都不建议考软件学院。除非你是女生，把能够成为一个研究生当着一生最大满足的那种女生。<br>
1、关于读书的机会成本问题。读研的机会成本的确是很高。任何人都可以简单地计算出来。所以，我也不赞成所有的人都去读研。读研只适合那些痛感数学在编程中的极端重要性的人。如果对理论工具和理论思维的极端重要性没有切肤的认识，那么读研的价值几乎为0；读研的好处在于：<br>
1）把你自己放在一个学术和工程的交叉点上；<br>
2）让你具备了进入微软等世界顶级软件研发机构的可能性；记住只是可能性。但是不读研这种可能性为0。<br>
3）如前所述，如果没有读研的机会，你也就没有静下心来好好钻研几年理论的机会；一边工作拿高薪，一边深入地学习各种理论，诸位认为这可能吗？我反正认为不可能，我觉得学习钻研理论最需要的就是一个长期安静独处的环境，一边工作一边读书是不可能有这样的环境的，你会觉得每天都在疲于奔命。而读研正好可以提供这样一个环境。我同时还反对整天跟着导师的屁股后面跑，这样会浪费很多时间。读计算机的研究生，主要依靠自己去查阅最新文献，自己去研读文献，和导师的口头交流一个月一次就足够了，前提还需要导师的水平足够牛。如果导师的水平不牛，这也没关系，不理他就是了，自己做好自己的事情即可。<br>
2、关于研究生教学质量问题。坦白地说，全国都是“洪桐县中无好人”，尤其在计算科学领域，大牛极少。那为什么还要去读研？大哉问！把读研的收获寄托在名校或名师的名气上，我认为是注定要失败的。读研全靠自学，研究生之间的差距全部体现在自学能力上面。又有人问，既然是自学，为什么非要读研？回答是：因为读研就是为你买一份保险，就是买一份你自学三年之后不会失业的保险。这份保险主要是一种心理上的后盾，让你在自学过程中经得起诱惑，能够从容镇定地去追寻计算机理论发展的坚实足迹，从欧拉，费马，高斯，康托，图灵等巨匠那里寻找方法论的珠宝。倘若没有这份保证，你在家里面自学3个月，保证你会被失业的压力压得喘不过气来，何谈安心学习？<br>
3、关于实战经验与理论学习的优劣问题。这没有定论，如前所述，管理信息系统，设备驱动开发，工具软件开发，软件病毒剖析等等这些工作不太需要创造性，需要的是耐心和经验，需要的是对既有规范的准确理解，这类开发工作最适合在实战中提高，理论学习没什么作用。但是在人工智能，模式识别，图像压缩，虚拟现实，巨量数据检索，自然语言理解，计算机图形学等等领域，理论学习就占据着绝对的统治地位！这些领域的突破对人类的生活的影响是极其巨大而深刻的。某些领域处于一个极其快速发展的态势之中，比如计算机图形学，相信诸君能够从众多3D游戏的灿烂辉煌中体认到我的这种说法。在这些领域，如果没有扎实的理论功底，一切都是那么遥远，不管你花了多少时间在编程上面。<br>
4、关于高级研发人员的知识结构问题。首先声明，我不是一个纯粹理论激进分子，即认为除了理论之外，一切都不重要。我认为，纯熟的编程技能是最基本但也是最必不可少的技能。没有这个基础，一切计算机理论就是空谈（研究图灵可计算性理论的研究者除外）。有了这个基础之后，下列理论学习方向必须重点突破：<br>
1）科学哲学。这是核心中的核心！可惜国内不开这门课。不但不开课，而且还作为批判对象来引用，实在是遗憾至极！这是一门教你如何“钓鱼”的学科，在一切科学研究中居于最核心的地位。它是古今科研方法和思维方法的集大成者，很难想象一个成熟的研究者没有一套自己的方法论体系。科学哲学最需要的是领会与总结，它的思想与启示会伴随我们的一生。<br>
2）康托集合论，矩阵方法，离散结构，图论方法，群论方法之间的紧密关系。最重要的认识这些理论对实践的重要启示和方法引导。我始终认为，如果你学了一门理论之后，却不知道这门理论有什么作用，那么你的理论就白学了，你什么东西都没有捞着。所以，学习任何理论之前，先问自己：它有什么用？在哪里用？如何用？带着这些问题去学习理论，你才会真正地学到东西。用这三个问题去问你的理论课老师，他的回答就是判断其实际水平的最佳标准.<br>
3）思维要有极强的穿透力，学会看透文献作者没有写出来的动机。绝大部分大师都有隐瞒自己最具有方法论启示意义的思考环节的习惯。牛顿和华罗庚先生都有这个坏习惯。这让大家认为他们是天才，因为很多问题他想到了，我们想不到。但是为什么他们能想到，我们想不到？他们是怎样想到的？没有人告诉我们牛顿发现万有引力定律时的思考过程，当然，牛顿可以慷慨地把他的思考结果告诉我们，但是，他那可以点石成金的“金手指”却没有教给我们。我们的任务就是要培养透过文章看穿作者背后意图和动机的能力，在这方面，台湾的侯捷和美国的Donbox是绝佳典范。这两只老狐（呵呵，是爱称）凭着其猎犬一般的嗅觉，抽丝剥茧，一个把COM背后的幕后设计动机揭开并暴露到了光天化日之下，另一个把MFC的宏观架构做了一次完美的外科手术。其非凡的思维穿透力令人惊叹。<br>
4）英语。英语本身不重要，但是用英语写成的文献就极其重要了。所以，专门把英语作为一个重头戏列出来。大家不要相信英语无用论的鬼话。对于搞计算机的而言，英语就是你的母语！<br>
5）其它的具体理论还有很多，但是都不如这三个方面重要，因为我觉得这三个方面是最具有根本性，全局性的能力培养环节。需要指出的是，很多高深理论对你的工作是无意义的，当心时间陷进去。一定要把效率最高的时间段用在最具有决定性意义的理论学习上。<br>
5、关于读研之后的出路是否光明的问题。我们应该承认，读研之后，你的工作机会不是变多了，而是变少了。而且越是高手，他的工作机会和工作范围就越少。这是因为，越是搞前沿研发的公司，其数量越少，在这个圈子的人也就越少。你找工作的范围就越小，试问：如果微软的OS设计专家出来找工作，能够让他选择的公司能有几家？但是，这种公司数量的减少是以工资待遇的急剧上升为补偿的，同时，你在工作中所受到的充分尊重也是在一般公司中体会不到的。所以不要担心学了高科技用不上，呵呵，你只会越来越感觉自己学的不够用。相信接到过猎头公司电话的人会体会得到。真正的高手从来就不会担心工作的问题，也从来不会到人才市场上去找工作。既然选择了理论深入，那么就应该把眼光放得更远。</p>
]]></content>
      <categories>
        <category>杂记</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>到了哈佛，你就知道</title>
    <url>/posts/03e64e662cf9</url>
    <content><![CDATA[<p><em><strong>到了哈佛，你才知道真正的精英并不是天才，都是要付出更多努力的人。<br>
日前，两张美国哈佛大学图书馆凌晨4点多学生仍在学习的照片，在网上迅速传播。照片显示：凌晨4点的哈佛大学图书馆里，灯火通明，座无虚席……图片配文这样写道：哈佛是一种象征。人到底有怎样的发挥潜力？人的意志，人的才情，人的理想，为什么在哈佛能兑现？哈佛的学生餐厅，很难听到说话的声音，每个学生端着比萨可乐坐下后，往往边吃边看书或是边做笔记。我就没见过哪个学生光吃不读的，更没见过哪个学生边吃边闲聊的。感觉哈佛，餐厅不过是一个可以吃东西的图书馆，是哈佛正宗100个图书馆之外的另类图书馆。哈佛的医院，同样的宁静，同样的不管有多少在候诊的人也无一人说话，无一人不在阅读或记录。医院仍是图书馆的延伸。于是，哈佛产生的诺贝尔奖得主有33位。哈佛产生的美国总统有7位。<br>
哈佛校园里，不见华丽服饰，不见浓妆异彩，更不见晃里晃荡，只有匆匆的脚步，坚实地写下人生的篇章。哈佛不是神话，哈佛只是一个证明，人的意志，精神，抱负，理想的证明。<br>
央视《世界著名大学》制片人谢娟曾带摄制组到哈佛大学采访。她告诉人们：我们到哈佛大学时，是半夜2点，可让我们惊讶的是，整个校园当时是灯火通明的，那是一个不夜城。餐厅里，图书馆里，教室里还有很多学生在看书。那种强烈的学习气氛一下子就感染了我们。<br>
在哈佛，学生的学习是不分白天和黑夜的。那时，我才知道，在美国，在哈佛这样的名校，学生的压力是很大的。在哈佛，到处可以看到睡觉的人，甚至在食堂的长椅上也有人在呼呼大睡。而旁边来来往往就餐的人并不觉得稀奇。因为他们知道这些倒头就睡的人实在是太累了。在哈佛，我们见到最多的就是学生一边啃着面包一边忘我地在看书。你到了哈佛，你就知道中国高校的差距在哪里了。<br>
在哈佛采访，感受最深的是，哈佛学生学的太苦了，但是他们明显也是乐在其中。是什么让哈佛的学生能以苦为乐呢？我的感觉到，他们对所学领域的强烈兴趣。还有就是哈佛学生心中燃烧的要在未来承担重要责任的使命感。从这些学生身上，你能感到他们生命的能量在这里被迸发了出来。<br>
在哈佛学习的一个北大女孩说，哈佛的本科生，每学期至少要选修4门主要课程，一年是8门课，4年之内修满32门课并通过考试才可以毕业。一般而言，学校都要求本科生在入校后的头两年内完成核心课程的学习，第三年开始进入主修专业课程的学习。只有最聪明的天才学生可以在两三年内读完这32门课，一般的学生光应付4门课就已经忙得头晕脑涨了，因为在课堂上教授们讲的飞快，不管你听得懂听不懂，课下又留下一大堆阅读材料，读不完你根本就完成不了作业。<br>
那个北大女孩说，我在这里一个星期的阅读量是我在北大一年的阅读量，而且，在哈佛的作业量要求很大，她说，我们课后要花很多时间看书，预习案例。每堂课都需要提前做大量的准备，课前准备充分了，上课时才能在课堂上和别人交流，贡献您的个人思想，才能和大家一起学习，否则，你是无法融入到课堂的教学中的，当每个学生都投入了时间认真准备了，才可以快速推进课堂讨论的进程，而之前如果不读那么多的书，你就无法参加到课堂讨论之中。哈佛学生的学习压力也来自学校的淘汰机制。<br>
哈佛平均每年有大约20%的学生会因为考试不及格或者修不满学分而休学或退学，而且淘汰的20%的学生的考评并不是学期末才完成，每堂课都要记录发言成绩，平均占到总成绩的50%，这就要求学生均匀用力、不能放松。在哈佛不仅学生有压力，老师一样有压力。在哈佛的课堂，要求老师讲的东西都是新的。老师每年讲课的内容都要跟住前沿科学的发展变化。因此，哈佛的老师必须处在最前沿科学的研究阵地。哈佛认为，教授首先应当是个学者，能够享受挑战和创新的乐趣，而且能与他人进行有说服力的交流。<br>
哈佛大学终身教授丘成桐教授说：中国大学生的大学生活相比之下太轻松了，我们总是说，中国的孩子为了高考受了多少苦，其实，在美国一些著名的中学里，高中的学习同样是很苦的。我的孩子上中学的时候，也经常学到半夜。在美国，随着年龄的增长，一点点加大学习的任务。到了大学时是最苦的，所有的精英教育全都必须是吃苦的。<br>
而中国的孩子到了大学，却一下子放松下来了。他们放松的4年，恰好是美国大学生最勤奋的4年，积蓄人生能量的黄金4年。所以，美国的高科技人才一直是世界最多的。我们国内的一些重点大学很难让人感受到哈佛那样的学习气氛和探究氛围，到了哈佛，你才知道真正的精英并不是天才，都是要付出更多努力的人。<br>
说到中美大学生的比较，有两点值得一提，一是，我们的学生缺少吃苦精神。我们的家长和学生认为高考前是最苦的。我们讲的寒窗苦读，很多时候是被动的苦，带着功利的苦。而不是在其中有过浓厚的兴趣。不少大学生经过高考的“独木桥”后，开始在大学校园里舒舒服服地等着毕业：上课想逃就逃；考试临时抱佛脚。二是，有些家长也是从小灌输给孩子这种思想，让孩子认为，所有的学习都是为了高考。于是，高考结束，学习变得不再重要。<br>
而在美国大学，尤其是精英云集的大学所要付出的苦是我们想象不到的。在哈佛，征服学习是每个人的口号。要想变得强大就需要学习得更多，为此哈佛的课程安排多而且紧张。其目的是帮助学生提高批判性思维能力和想象力，学会发现和鉴别事实真相，坚持对事物进行严谨的分析，能够理性、历史地认识现实问题和道德问题。另外，练就长时间超负荷学习的毅力。<br>
当美国大学生带着浓厚的兴趣，积聚能量的时候，步入社会工作做准备的时候。身为中国的大学生却长长地舒了口气，觉得我终于可以好好休息休息了。中国式的教育让学生在高考前“用力”过猛，在该储备能力的阶段不仅没有积蓄能量，而是大量消耗了这种能量。<br>
一位中国旅美教师说，中国学生在大学阶段被美国学生远远地甩在了后面。其根源还在于我们的基础教育。美国小学是知识的吝啬鬼，严格限制孩子得到知识的数量，一个月只允许孩子得到一个知识，孩子每得到一个知识都需要付出很多的汗水和辛苦；在这个过程中，动手、思考和感悟比知识本身更重要；孩子对知识总是有渴望的感觉。而中国的小学教育是一个贪婪鬼，把知识当成了免费的黄金珠宝。<br>
中国教育者不知道知识与智慧的关系，总是让孩子直接得到越来越多的知识。美国教育的聪明就在于：先让孩子去感悟，去思考，然后得到知识，这个时候知识就变成了智慧；由于开始的时候，知识都特别简单，比较容易得到感悟，知识也就容易变成智慧。智慧其实就是我们常说的创造力。学习有三个阶段：感性认识——感悟——知识，知识是学习的最高阶段。美国教育让孩子走完三个阶段，才能得到知识；中国教育是让孩子通过感性认识得到知识，或者直接得到知识。<br>
美国教育一个月的知识量只相当于中国教育一天的知识量。相差29天，这29天就是感悟的时间。美国教育通过让孩子感悟比中国教育多产生了一个东西：智慧。美国学生比中国学生多产生了一个东西：创新能力。在高中时期，美国学校培养的是自主学习的习惯。而比较中国，中国的高中是老师填鸭式学习，让学生习惯了依赖。能力、习惯上的差距，让中国学生与美国学生在大学选择了不同的生活方式和态度。<br>
哈佛的学生说，在哈佛学习强度大，睡眠很少，有在炼狱的感觉，对意志是一个很大的挑战。但是如果挺过去，以后再大的困难也就能够克服了。而中国大学生认为，终于摆脱束缚，可以想干什么，就干什么了。于是，把大多时间用在了学习以外的事情上。我们在最该学习的时候断档了。这就注定了，我们的大学生被甩得越来越远。<br>
很多学者用金字塔来形容中美学生的学习能力。差别在于，中国孩子的学习能力是正金字塔，年纪越大学习的空间越小。而美国学生的学习是倒金字塔，他们学会的是持续学习的能力。中国学生的学习动力，还有大学的严进宽出的教育体制，都让他们觉得上大学是无比轻松的一件事情。<br>
从自身到外在都没有敦促他们学习的力量，于是，放松成为一种普遍的状态，都在讨回他们前12年被克扣的休闲时间，尽情地休闲。中国学生是刻苦学习12年，到大学休闲。美国学生是“休闲”12年，大学开始刻苦学习，玩命的学。这是走向社会前，最有价值的黄金学习阶段，这4年，他们在本领与情商的提高上会有质的飞跃。在哈佛，教授们会时常提醒学生们要做好时间管理。在人生的道路上，你停步不前，但有人却在拼命赶路。<br>
也许当你站立的时候，他还在你的后面向前追赶，但当你再一回望时，已看不到他的身影了，因为，他已经跑到你的前面了，需要你来追赶他了。所以，你不能停步，你要不断向前，不断超越。成功与安逸是不可兼得的，选择了其一，就必定放弃另一个结局。今天不努力，明天必定遭罪。哈佛告诉它的学生：“学习时的痛苦是暂时的，未学到的痛苦是终生的。”而我们的大学生，正在品尝这种痛苦，我们民族也在为此付出代价。<br>
哈佛的毕业生有一个传统：捐助哈佛。哈佛的资金三分之一来自捐助。很多学生的家长，也都是哈佛校友哈佛人。一代一代的哈佛人，进入社会上层又把财富反馈给母校哈佛。每年的捐款，是哈佛收入的重要部分。给予往往是相互的。是先有哈佛的给予还是先有给予哈佛，这个问题或如鸡生蛋还是蛋生鸡那样说不清。或者只有让哈佛告诉你。哈佛没有高楼大厦，只有新英格兰的红砖墙。即使诺贝尔奖获得者也不过在校园有一个决不起眼的停车位。<br>
毕竟哈佛最起眼的是100座图书馆，尤其是一个个像图书馆那样的人，或者说，一个人就是一座图书馆。哈佛或哈佛人是不需要任何包装的。有人称史华慈是哈佛的一位类似东方的大儒，在他动过癌症手术的82岁高龄的时候，依然天天早上按时去办公室工作，即使有时要倒下。而他办公室里挂大衣的两个衣架，竟是用铁丝胡乱缠绕而成的。<br>
某教授对学生说，你学我这门课，你就一天只能睡两小时。学生想，那么，我学四门课，我就没有睡眠时间了，我就得倒贴睡眠时间了。哈佛的博士生，可能每3天要啃下一本大书，每本几百页，还要交上阅读报告。哈佛过桥便是波士顿，前人类学系主任张光直在哈佛读博士那几年，没有上过桥没有去过波士顿。<br>
哈佛学生或是哈佛教授，首先不是一份荣誉，而是一种证明。人到底可以有怎样的意志力，人到底可能有怎样的发挥潜力?哈佛告诉你。哈佛是一种象征，最高智慧的象征，最高学府的象征。人的意志，人的才情，人的理想，为什么在哈佛能兑现?哈佛告诉你。<br>
作为闻名于世的学府，哈佛大学培养了许多名人，他们中有33位诺贝尔奖获得者、7位美国总统以及各行各业的职业精英。究竟是什么使哈佛成为精英的摇篮？哈佛学子接受了什么样的精神和理念？这些问题吸引着成千上万的人去探知其中的答案。</strong></em></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/posts/b809d98fd460</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 6%;
;
}
table th:nth-of-type(3){
width: 6%;
}
table th:nth-of-type(4){
width: 6%;
}
table th:nth-of-type(5){
width: 6%;
}
table th:nth-of-type(6){
width: 5%;
}
table th:nth-of-type(7){
width: 5%;
}
table th:nth-of-type(8){
width: 5%;
}
table th:nth-of-type(9){
width: 5%;
}
table th:nth-of-type(10){
width: 5%;
}
table th:nth-of-type(11){
width: 5%;
}
table th:nth-of-type(12){
width: 5%;
}
table th:nth-of-type(13){
width: 5%;
}
table th:nth-of-type(14){
width: 5%;
}
table th:nth-of-type(16){
width: 5%;
}
table th:nth-of-type(17){
width: 5%;
}
table th:nth-of-type(18){
width: 5%;
}
table th:nth-of-type(19){
width: 5%;
}
</style>
<h1 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h1>
<ul>
<li>实例：编译器处理源代码中的变量，涉及变量及属性(如：变量类型)的管理
<ul>
<li>插入：新变量定义</li>
<li>查找：变量的引用</li>
<li>变量处理的本质：动态查找问题</li>
<li>已知的几种查找方法：
<ul>
<li>顺序查找   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>二分查找   <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>二叉搜索树  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h为二叉查找树的高度
<ul>
<li>平衡二叉树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>使用查找树、AVL进行变量管理
<ul>
<li>两个变量名(字符串)比较效率不高(要一个个字符进行比较)
<ul>
<li>考虑将字符串转化为整数的比较</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>实例：登陆qq时，qq服务器如何核对身份，面对庞大用户群如何快速找到用户信息？
<ul>
<li>如果使用二分法查找：
<ul>
<li>假设十亿(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>≈</mo><msup><mn>2</mn><mn>30</mn></msup></mrow><annotation encoding="application/x-tex">10^9\approx2^{30}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>)有效用户，用二分查找30次</li>
<li>假设用户信息大小为1KB，则需要1TB(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup></mrow><annotation encoding="application/x-tex">1\times10^9</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span></span></span></span>KB)连续空间</li>
<li>需要按有效qq号大小有序存储：在连续存储空间中，插入和删除一个新qq号码需要移动大量数据
<ul>
<li>二分查找不适合动态查找</li>
</ul>
</li>
</ul>
</li>
<li>问题：如何快速搜索到需要的关键词，如果关键词不方便比较怎么办
<ul>
<li>查找的本质：已知对象找位置
<ul>
<li>有序安排对象：全序、半序</li>
<li>典型：二分查找(全序)、查找树(半序)</li>
<li>直接算出对象位置：散列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/W7UhVqiy5OYwnFj.png" width="50%" height="50%">
<h2 id="散列"><a class="markdownIt-Anchor" href="#散列"></a> 散列</h2>
<p>散列(Hashing)的基本思想：</p>
<ul>
<li>以关键字key为自变量，通过一个确定的函数h(散列函数)，计算出对应的函数值h(key)，作为数据对象的存储地址</li>
<li>不同的关键字坑会映射到同一个散列地址上，即h(key(i))=h(key(j))，当key(i)!=key(j)，称为“冲突(Collision)”</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/xZ45hDn3w9yfA6Y.png" width="50%" height="50%">
<ul>
<li>散列查找法的两项基本工作：
<ul>
<li>计算位置：构造散列函数确定关键词存储位置
<ul>
<li>将对象映射成一个整型</li>
</ul>
</li>
<li>解决冲突：应用某种策略解决多个关键词位置相同的问题</li>
</ul>
</li>
<li>时间复杂度：几乎为常量复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即查找时间与问题规模无关
<ul>
<li>如果没有溢出，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">T(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span></span></span></span>查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">)=T(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span></span></span></span>插入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">)=T(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span></span></span></span>删除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">)=O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/gzkQUSHWNBduR1o.png" width="50%" height="50%">
<ul>
<li>装填因子(Loading Factor)：设散列空间大小为m，填入表中元素的个数是n，则称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mi>n</mi><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">α=\frac{n}{m}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>为散列表的装填因子</li>
<li>散列表查找性能评价
<ul>
<li>成功平均查找长度(ASLs) ——&gt; 查找成功的情况
<ul>
<li>查找表中包含的关键词的平均查找比较次数(查找过程中的冲突次数+1)</li>
</ul>
</li>
<li>不成功平均查找长度(ASLu) ——&gt; 插入或查找失败的情况
<ul>
<li>不在散列表中的关键词的平均查找次数(假设查找不到情况下的比较次数：h(key)与最近一个空闲位置的距离)</li>
<li>一般方法：将不在散列表中的关键词分若干类</li>
<li>如：根据h(key)值分类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实例1：有n=11个数据对象的集合{18,23,11,20,2,7,27,30,42,15,34}，符号表的大小用TableSize=17，选取散列函数h如下：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">TableSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span></li>
<li>数据存放：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>18</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">(</mo><mn>23</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">(</mo><mn>11</mn><mo stretchy="false">)</mo><mo>=</mo><mn>11</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">(</mo><mn>20</mn><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">h(18)=1,h(23)=6,h(11)=11,h(20)=3,h(2)=2,……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">8</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">2</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">地址h(key)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">关键词key</td>
<td style="text-align:center">34</td>
<td style="text-align:center">18</td>
<td style="text-align:center">2</td>
<td style="text-align:center">20</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">23</td>
<td style="text-align:center">7</td>
<td style="text-align:center">42</td>
<td style="text-align:center"></td>
<td style="text-align:center">27</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center">30</td>
<td style="text-align:center"></td>
<td style="text-align:center">15</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>此时如果插入新整型数据35，h(35)=1，由于该位置已有对象——“冲突”
<ul>
<li>此时如果进行查找，如：
<ul>
<li>key=22，h(22)=5，地址(5)为空，22不在表中</li>
<li>key=30，h(30)=13，地址(13)存放是30，查找成功</li>
</ul>
</li>
</ul>
</li>
<li>装填因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mn>11</mn><mi mathvariant="normal">/</mi><mn>17</mn><mo>≈</mo><mn>0.65</mn></mrow><annotation encoding="application/x-tex">α=11/17≈0.65</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">/</span><span class="mord">1</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">5</span></span></span></span></li>
<li>成功平均查找长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><mn>11</mn></mfrac><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASLs=\frac{1+1+1+1+1+1+1+1+1+1+1}{11}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>不成功平均查找长度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mfrac><mrow><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>6</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn></mrow><mn>17</mn></mfrac><mo>=</mo><mn>2.53</mn></mrow><annotation encoding="application/x-tex">ASLu=\frac{5+4+3+2+1+1+6+5+4+3+2+1+2+1+2+1}{17}=2.53</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">7</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">3</span></span></span></span>  (假设冲突处理为线性探测)</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/X8a5LwySsclnprd.png" width="50%" height="50%">
<p>实例2：将acos、define、float、exp、char、atan、ceil、floor、clock、ctime顺次放入一张散列表中</p>
<ul>
<li>散列表设计为一个二维数组Table[26][2]，2列分别代表两个槽</li>
<li>散列函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">h(key)=key[0]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>’</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/Fj3cnkGb9ClJURT.png" width="50%" height="50%">
<h2 id="散列表的抽象数据类型描述"><a class="markdownIt-Anchor" href="#散列表的抽象数据类型描述"></a> 散列表的抽象数据类型描述</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：符号表(SymbolTable)
数据对象集：符号表是“名字(Name)-属性(Attribute)”对的集合
操作集：Table ∈ SymbolTable，Name ∈ NameType，Attr ∈ AttributeType
SymbolTable initializeTable(int TableSize):创建一个长度为TableSize的符号表;
Boolean IsIn(SymbolTable Table,NameType Name):查找特定的名字Name是否在符号表Table中;
AttributeType Find(SymbolTable Table,NameType Name):获取Table中指定名字Name对应的属性;
SymbolTable Modefy(SymbolTable Table,NameType Name,AttributeType Attr):将Table中指定名字Name的属性改为Attr;
SymbolTable Insert(SymbolTable Table,NameType Name,AttributeType Attr):向Table中插入一个新名字Name及其属性Attr;
SymbolTable Delete(SymbolTable Table,NameType Name):从Table中闪出一个名字Name及其属性.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h2>
<ul>
<li>一个“好”的散列函数一般应考虑下列两个因素：
<ul>
<li>计算简单，一边提高转换速度</li>
<li>关键词对应的地址空间分布均匀，以尽量减少冲突</li>
</ul>
</li>
</ul>
<h3 id="数字关键词的散列函数构造"><a class="markdownIt-Anchor" href="#数字关键词的散列函数构造"></a> 数字关键词的散列函数构造</h3>
<h4 id="直接定址法"><a class="markdownIt-Anchor" href="#直接定址法"></a> 直接定址法</h4>
<ul>
<li>取关键词的某个线性函数值为散列地址，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">h(key)=a\times key+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> (a、b为常数)</li>
<li>数据格式如：(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>−</mo><mn>1990</mn></mrow><annotation encoding="application/x-tex">h(key)=key-1990</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mord">0</span></span></span></span>)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">地址h(key)</th>
<th style="text-align:center">出生年份(key)</th>
<th style="text-align:center">人数(attribute)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1990</td>
<td style="text-align:center">1285万</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1991</td>
<td style="text-align:center">1281万</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1992</td>
<td style="text-align:center">1280万</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">1250万</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">2011</td>
<td style="text-align:center">1180万</td>
</tr>
</tbody>
</table>
<ul>
<li>散列地址转换例：h(1990)=0，h(2000)=10</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/Fz2q7Q5agmtGnf9.png" width="50%" height="50%">
<h4 id="数字分析法"><a class="markdownIt-Anchor" href="#数字分析法"></a> 数字分析法</h4>
<ul>
<li>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址
<ul>
<li>比如取11位手机号码key的后4位作为地址进行手机号存储：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>t</mi><mi>o</mi><mi>i</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo>+</mo><mn>7</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(key)=atoi(key+7)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">7</span><span class="mclose">)</span></span></span></span>
<ul>
<li>atoi(char* key)将字符串转换为整型</li>
<li>散列地址转换如：h(15079054887)=4887</li>
</ul>
</li>
<li>再如关键字key是18位的身份证号码的存储：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>6</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">h(key)=(key[6]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">6</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>‘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>10</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">)\times10^4+(key[10]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>14</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">)\times10^3+(key[14]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">4</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>16</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">)\times10^2+(key[16]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>×</mo><mn>10</mn><mo>+</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>17</mn><mo stretchy="false">]</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">)\times10+(key[17]-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mord">7</span><span class="mclose">]</span><span class="mord">−</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>散列地址转换例：h(330106199010080419)=1109</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/oxQKkgFUCuJfOrp.png" width="50%" height="50%">
<h4 id="除留余数法"><a class="markdownIt-Anchor" href="#除留余数法"></a> 除留余数法</h4>
<ul>
<li>散列函数为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span></li>
<li>散列表例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi><mi mathvariant="normal">%</mi><mn>17</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(h(key)=key\%17)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">%</span><span class="mord">1</span><span class="mord">7</span><span class="mclose">)</span></span></span></span></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">地址h(key)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">13</th>
<th style="text-align:center">14</th>
<th style="text-align:center">15</th>
<th style="text-align:center">16</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">关键词key</td>
<td style="text-align:center">34</td>
<td style="text-align:center">18</td>
<td style="text-align:center">2</td>
<td style="text-align:center">20</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">23</td>
<td style="text-align:center">7</td>
<td style="text-align:center">42</td>
<td style="text-align:center"></td>
<td style="text-align:center">27</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center">30</td>
<td style="text-align:center"></td>
<td style="text-align:center">15</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li>此例中P=Tablesize=17
<ul>
<li>一般情况下P取素数
<ul>
<li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>=</mo><mi>N</mi><mo>=</mo><mi>k</mi><mi>n</mi><mi mathvariant="normal">，</mi><mi>P</mi><mo>=</mo><mi>k</mi><mi>p</mi><mi mathvariant="normal">，</mi><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">key=N=kn，P=kp，h(key)=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi mathvariant="normal">，</mi><mi>p</mi><mi mathvariant="normal">，</mi><mi>r</mi><mi mathvariant="normal">，</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">n，p，r，k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>均为整数</li>
<li>由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N%p=r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>得，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>=</mo><mi>P</mi><mi>q</mi><mo>+</mo><mi>r</mi><mi mathvariant="normal">，</mi><mi>k</mi><mi>n</mi><mo>=</mo><mi>k</mi><mi>p</mi><mi>q</mi><mo>+</mo><mi>r</mi><mi mathvariant="normal">，</mi><mi>n</mi><mo>=</mo><mi>p</mi><mi>q</mi><mo>+</mo><mfrac><mi>r</mi><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">N=Pq+r，kn=kpq+r，n=pq+\frac{r}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">n,p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span></span></span></span>均为整数，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mi>r</mi><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{r}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.040392em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>也是整数，因此r的取值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>2</mn><mi>k</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>k</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,k,2k,…,(p-1)k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span></li>
<li>另一方面，由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>代表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，其取值需要覆盖地址空间范围内所有连续的整数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>P</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1,2,…,P-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
<li>此时只有一种情况即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，说明<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>互质，由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>的取值是任意的，因此令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>为素数</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/iUy7baoLGTmI6Eg.png" width="50%" height="50%">
<h4 id="折叠法-平方取中法"><a class="markdownIt-Anchor" href="#折叠法-平方取中法"></a> 折叠法、平方取中法</h4>
<ul>
<li>折叠法
<ul>
<li>将关键字分割成位数相同的几个部分，然后叠加</li>
</ul>
</li>
<li>平方取中法
<ul>
<li>将关键字平方后取其中间几位的码值</li>
</ul>
</li>
<li>如：56793542</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/kKu7BMleNwL58QT.png" width="50%" height="50%">
<h3 id="字符关键词的散列函数构造"><a class="markdownIt-Anchor" href="#字符关键词的散列函数构造"></a> 字符关键词的散列函数构造</h3>
<h4 id="基本构造方法ascii码加和法"><a class="markdownIt-Anchor" href="#基本构造方法ascii码加和法"></a> 基本构造方法————ASCII码加和法</h4>
<ul>
<li>
<p>对字符型关键词key定义散列函数如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(key)=(Σkey[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">TableSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span></li>
<li>这种构造方法过于简单，冲突可能性较大，如：
<ul>
<li>a3、b2、c1，eat、tea(关键字和相等的情况)</li>
<li>实际上ASCII码取值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">～</mi><mn>127</mn></mrow><annotation encoding="application/x-tex">0～127</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord cjk_fallback">～</span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span></span></span></span>，长度为n的字符串的字符ASCII值和仅有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>127</mn><mi>n</mi></mrow><annotation encoding="application/x-tex">127n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mord mathdefault">n</span></span></span></span>中取值，而实际上字符串有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><msup><mn>7</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">127^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>种组合</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对基本方法的改进————前三个字符移位法</p>
<ul>
<li>把字符串的前三个字符取出来，看成27进制种的个位数，十位数，百位数，
<ul>
<li>使用27的原因：26个字母加空格，即27</li>
</ul>
</li>
<li>如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>×</mo><mn>2</mn><msup><mn>7</mn><mn>2</mn></msup><mo>+</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>27</mn><mo>+</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(key)=(key[0]\times27^2+key[1]\times27+key[2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord"><span class="mord">7</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">TableSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span>
<ul>
<li>这种构造方法较较基本方法冲突相对少，但仍然存在一定的冲突问题，如：
<ul>
<li>string、street、strong、structure等(前三个关键字相同)</li>
<li>存在空间浪费的问题</li>
<li>在本例的散列函数，以前三位作为关键码则所有可能的取值为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><msup><mn>6</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">26^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>(26个字母)
<ul>
<li>而前三个字符的不同组合在实际使用中大概有3000种可能</li>
<li>空间浪费<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≈</mo><mfrac><mn>3000</mn><mrow><mn>2</mn><msup><mn>6</mn><mn>3</mn></msup></mrow></mfrac><mo>≈</mo><mn>30</mn></mrow><annotation encoding="application/x-tex">≈\frac{3000}{26^3}≈30%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mtight">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/OBvAQ2ryGYJpRdw.png" width="50%" height="50%">
<h4 id="位移法"><a class="markdownIt-Anchor" href="#位移法"></a> 位移法</h4>
<ul>
<li>涉及关键词的所有n个字符，并且合理分布</li>
<li>考虑字符串的所有位，将其看作32进制数的每一位
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>×</mo><mn>3</mn><msup><mn>2</mn><mi>i</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h(key)=(Σkey[n-i-1]\times32^i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0746639999999998em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">TableSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span></li>
<li>散列地址转换例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo></mrow><annotation encoding="application/x-tex">h(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span></span></span></span>&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>b</mi><mi>c</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">abcde</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">)</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">)=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mn>3</mn><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo></mrow><annotation encoding="application/x-tex">\times32^4+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mord">+</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mn>3</mn><msup><mn>2</mn><mn>3</mn></msup><mo>+</mo></mrow><annotation encoding="application/x-tex">\times32^3+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mord">+</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mn>3</mn><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo></mrow><annotation encoding="application/x-tex">\times32^2+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord">+</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo><mn>32</mn><mo>+</mo></mrow><annotation encoding="application/x-tex">\times32+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">×</span><span class="mord">3</span><span class="mord">2</span><span class="mord">+</span></span></span></span>’<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span>’$</li>
</ul>
</li>
</ul>
<p>位移散列函数伪代码</p>
<pre class="line-numbers language-none"><code class="language-none">Index Hash(const char*Key,int TableSize)&#123;
    unsigned int h&#x3D;0;                   &#x2F;&#x2F;散列函数值，初始化为0
    while(*Key)h&#x3D;(h&lt;&lt;5)+*Key++;         &#x2F;&#x2F;位移映射，h&lt;&lt;5相当于h*32，*Key++是先取*Key再Key++
    return h%TableSize;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="冲突处理方法"><a class="markdownIt-Anchor" href="#冲突处理方法"></a> 冲突处理方法</h2>
<ul>
<li>常用处理冲突的思路：
<ul>
<li>换个位置：开放地址法</li>
<li>同一位置的冲突对象组织在一起：链地址法</li>
</ul>
</li>
</ul>
<h3 id="开放定址法open-addressing"><a class="markdownIt-Anchor" href="#开放定址法open-addressing"></a> 开放定址法(Open Addressing)</h3>
<img src="https://s2.loli.net/2022/05/04/bZEYRMjshe9iB4A.png" width="50%" height="50%">
<ul>
<li>一旦产生了冲突(该地址已有其他元素)，就按某种规则去寻找另一空地址
<ul>
<li>若发生了第i次冲突，试探的下一个地址将增加d(i)，基本公式为：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_i(key)=(h(key)+d(i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">(</mo><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TableSize  (1&lt;=i&lt;TableSize)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></li>
<li>不同的解决冲突方案决定了不同的d(i)，不同方案如：
<ul>
<li>线性探测：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">d(i)=i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></li>
<li>平方探测：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">d(i)=i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></li>
<li>双散列：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi><mo>×</mo><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(i)=i\times h(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></li>
<li>其他如伪随机方法等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在开放地址散列表中，删除操作通常只能“懒惰删除”
<ul>
<li>由于开放定址的每次冲突解决操作互相是相关的，因此如果删除一个会导致“断链”</li>
<li>因此，需要增加一个“删除标记(Deleted)”，表示所在位置元素已删除，其空间可以在下次插入时重用</li>
</ul>
</li>
</ul>
<h4 id="线性探测法linear-probing"><a class="markdownIt-Anchor" href="#线性探测法linear-probing"></a> 线性探测法(Linear Probing)</h4>
<ul>
<li>以增量序列1，2，……，(TableSize-1)循环试探下一个存储地址</li>
<li>例1：设关键词序列为{47,7,29,11,9,84,54,20,30}
<ul>
<li>设散列表表长TableSize=13(装填因子<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mn>9</mn><mi mathvariant="normal">/</mi><mn>13</mn><mo>≈</mo><mn>0.69</mn></mrow><annotation encoding="application/x-tex">α=9/13≈0.69</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mord">/</span><span class="mord">1</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">9</span></span></span></span>)</li>
<li>散列函数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span></li>
<li>采用线性探测法处理冲突并计算散列表和查找性能</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">关键词key</th>
<th style="text-align:center">47</th>
<th style="text-align:center">7</th>
<th style="text-align:center">29</th>
<th style="text-align:center">11</th>
<th style="text-align:center">9</th>
<th style="text-align:center">84</th>
<th style="text-align:center">54</th>
<th style="text-align:center">20</th>
<th style="text-align:center">30</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">散列值h(key)</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7</td>
<td style="text-align:center">10</td>
<td style="text-align:center">9</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">冲突次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<ul>
<li>“聚集”现象：由于冲突的元素会依次向下试探并存储，导致冲突元素将本不属于自身的地址占据，进而在冲突发生的相邻区域产生更多冲突从而形成“聚集”现象</li>
<li>将序列插入散列表的操作过程：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">操作\地址</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入7</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">d(1)=1</td>
</tr>
<tr>
<td style="text-align:center">插入11</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入9</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入84</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">84</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">d(3)=3</td>
</tr>
<tr>
<td style="text-align:center">插入54</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">84</td>
<td style="text-align:center">54</td>
<td style="text-align:center"></td>
<td style="text-align:center">d(1)=1</td>
</tr>
<tr>
<td style="text-align:center">插入20</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">84</td>
<td style="text-align:center">54</td>
<td style="text-align:center">20</td>
<td style="text-align:center">d(3)=3</td>
</tr>
<tr>
<td style="text-align:center">插入30</td>
<td style="text-align:center">11</td>
<td style="text-align:center">30</td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">84</td>
<td style="text-align:center">54</td>
<td style="text-align:center">20</td>
<td style="text-align:center">d(6)=6</td>
</tr>
</tbody>
</table>
<ul>
<li>ASLs=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn></mrow><mn>9</mn></mfrac><mo>=</mo><mfrac><mn>23</mn><mn>9</mn></mfrac><mo>≈</mo><mn>2.56</mn></mrow><annotation encoding="application/x-tex">\frac{1+7+1+1+2+1+4+2+4}{9}=\frac{23}{9}≈2.56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span><span class="mord">6</span></span></span></span></li>
<li>ASLu=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>6</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>4</mn></mrow><mn>13</mn></mfrac><mo>=</mo><mfrac><mn>50</mn><mn>13</mn></mfrac><mo>≈</mo><mn>3.85</mn></mrow><annotation encoding="application/x-tex">\frac{3+2+1+2+1+1+1+9+8+7+6+5+4}{13}=\frac{50}{13}≈3.85</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">9</span><span class="mbin mtight">+</span><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">5</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">8</span><span class="mord">5</span></span></span></span></li>
</ul>
<img src="https://s2.loli.net/2022/05/04/njY3lS1bZaMVxs4.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/04/r7yYu83RbJzoKWI.png" width="50%" height="50%">
<ul>
<li>例2：将acos、define、float、exp、char、atan、ceil、floor顺序存入一张大小为26的散列表中
<ul>
<li>散列函数：h(key)=key[0]-‘a’，采用线性探测d(i)=i</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">acos</th>
<th style="text-align:center">atan</th>
<th style="text-align:center">char</th>
<th style="text-align:center">define</th>
<th style="text-align:center">exp</th>
<th style="text-align:center">float</th>
<th style="text-align:center">ceil</th>
<th style="text-align:center">floor</th>
<th style="text-align:center">……</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<ul>
<li>ASLs=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>3</mn></mrow><mn>8</mn></mfrac><mo>=</mo><mfrac><mn>15</mn><mn>8</mn></mfrac><mo>≈</mo><mn>1.87</mn></mrow><annotation encoding="application/x-tex">\frac{1+2+1+1+1+1+5+3}{8}=\frac{15}{8}≈1.87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">8</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">8</span><span class="mord">7</span></span></span></span></li>
<li>ASLu=<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>9</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>6</mn><mo>+</mo><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>∗</mo><mn>18</mn></mrow><mn>26</mn></mfrac><mo>=</mo><mfrac><mn>62</mn><mn>26</mn></mfrac><mo>≈</mo><mn>2.38</mn></mrow><annotation encoding="application/x-tex">\frac{9+8+7+6+5+4+3+2+1*18}{26}=\frac{62}{26}≈2.38</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mbin mtight">+</span><span class="mord mtight">8</span><span class="mbin mtight">+</span><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">6</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">+</span><span class="mord mtight">4</span><span class="mbin mtight">+</span><span class="mord mtight">3</span><span class="mbin mtight">+</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mbin mtight">∗</span><span class="mord mtight">1</span><span class="mord mtight">8</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">3</span><span class="mord">8</span></span></span></span></li>
</ul>
<h4 id="平方探测法quadratic-probing又称二次探测"><a class="markdownIt-Anchor" href="#平方探测法quadratic-probing又称二次探测"></a> 平方探测法(Quadratic Probing)，又称二次探测</h4>
<ul>
<li>以增量序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>…</mo><mo>…</mo><mo separator="true">,</mo><msup><mi>q</mi><mn>2</mn></msup><mo separator="true">,</mo><mo>−</mo><msup><mi>q</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^2,-1^2,2^2,-2^2,……,q^2,-q^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>且<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mfrac><mrow><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><mn>2</mn></mfrac><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">q\leq⌊\frac{TableSize}{2}⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span></span></span></span>循环试探下一个存储地址</li>
<li>例：以线性探测法例1为例
<ul>
<li>散列表表长TableSize=11</li>
<li>散列函数为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span></li>
<li>采用平方探测法处理冲突并计算散列表和查找性能</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">关键词key</th>
<th style="text-align:center">47</th>
<th style="text-align:center">7</th>
<th style="text-align:center">29</th>
<th style="text-align:center">11</th>
<th style="text-align:center">9</th>
<th style="text-align:center">84</th>
<th style="text-align:center">54</th>
<th style="text-align:center">20</th>
<th style="text-align:center">30</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">散列值h(key)</td>
<td style="text-align:center">3</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">9</td>
<td style="text-align:center">7</td>
<td style="text-align:center">10</td>
<td style="text-align:center">9</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">冲突次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<ul>
<li>将序列插入散列表的操作过程</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">操作\地址</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入7</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">d(1)=1</td>
</tr>
<tr>
<td style="text-align:center">插入11</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入9</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center"></td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入84</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">84</td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center"></td>
<td style="text-align:center">d(2)=-1</td>
</tr>
<tr>
<td style="text-align:center">插入54</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">84</td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">54</td>
<td style="text-align:center">无冲突</td>
</tr>
<tr>
<td style="text-align:center">插入20</td>
<td style="text-align:center">11</td>
<td style="text-align:center"></td>
<td style="text-align:center">20</td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">84</td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">54</td>
<td style="text-align:center">d(3)=4</td>
</tr>
<tr>
<td style="text-align:center">插入30</td>
<td style="text-align:center">11</td>
<td style="text-align:center">30</td>
<td style="text-align:center">20</td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">84</td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">54</td>
<td style="text-align:center">d(3)=4</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>4</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>9</mn><mo>=</mo><mn>18</mn><mi mathvariant="normal">/</mi><mn>9</mn><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ASLs=(1+1+2+1+1+3+1+4+4)/9=18/9=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord">/</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mo stretchy="false">(</mo><mn>5</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>10</mn><mo>+</mo><mn>9</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>7</mn><mo>+</mo><mn>6</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>11</mn><mo>=</mo><mn>56</mn><mi mathvariant="normal">/</mi><mn>11</mn><mo>≈</mo><mn>5.09</mn></mrow><annotation encoding="application/x-tex">ASLu=(5+4+3+2+1+1+10+9+8+7+6)/11=56/11≈5.09</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mord">6</span><span class="mord">/</span><span class="mord">1</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">0</span><span class="mord">9</span></span></span></span></li>
<li>某些情况下平方探测法可能无法探查到所有空间
<ul>
<li>例：向下方列表中中插入11(TableSize=5)</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">操作\地址</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入11</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mn>11</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mn>5</mn><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>2</mn><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mn>5</mn><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><msup><mn>3</mn><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mn>5</mn><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mn>3</mn><mn>2</mn></msup><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mn>5</mn><mo>=</mo><mn>2</mn><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">h(11)=1,1+1=2,1-1=0,(1+2^2)\%5=0,(1-2^2)\%5=2,(1+3^2)\%5=0,(1-3^2)\%5=2……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">%</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span></li>
<li>不过有定理显示：如果散列表长度TableSize是某个4k+3(k是正整数)形式的素数时，平方探测可以探查到整个散列表空间
<ul>
<li>设TableSize=S(S为大于5的素数)</li>
<li>向表中插入一个冲突元素x，并从剩余位置中任选两个，设探测次数分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mi mathvariant="normal">，</mi><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">i,j，0&lt;i,j\leq⌊S/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></li>
<li>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>S</mi><mo>=</mo><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">(h(x)+d(i))\%S=(h(x)+d(j))\%S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></li>
<li>由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mi>d</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>j</mi><mn>2</mn></msup><mi mathvariant="normal">，</mi><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>S</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">d(i)=i^2=d(j)=j^2，0&lt;i,j\leq⌊S/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span>知，当且仅当i=j时两次不同的探测之间才会发生冲突，即剩余位置是互异的</li>
<li>由于剩余位置互异，每次探测都找到一个新位置，因此总存在一个i使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">(h(x)+d(i))\%S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>能探测到空闲单元</li>
</ul>
</li>
<li>探测次数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi><mo>≤</mo><mo stretchy="false">⌊</mo><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">q\leq⌊TableSize/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span>
<ul>
<li>由于每次探测的位置是互异的，因而对每个探测q而言都会减少2个未探测过的单元<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mi>q</mi><mn>2</mn></msup><mi mathvariant="normal">，</mi><mo>−</mo><msup><mi>q</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(q^2，-q^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>q最多只需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊TableSize/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span>次就可以探测整个空间</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/JBIS9TAxOk5N84X.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/04/S6WrPYhuwjUHBCR.png" width="50%" height="50%">
<h4 id="双散列探测法double-hashing"><a class="markdownIt-Anchor" href="#双散列探测法double-hashing"></a> 双散列探测法(Double Hashing)</h4>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>×</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">i\times h_2(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h_2(key)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>是另一个散列函数</li>
<li>探测序列为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>2</mn><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>3</mn><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo>…</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">h_2(key),2h_2(key),3h_2(key),……</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span></span></span></span>
<ul>
<li>对任意的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">≠</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">ke,h_2(key)\neq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
<li>探测序列还应该保证所有的散列存储单元都应该能够被探测到，选择一下形式效果较好：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>p</mi><mo>−</mo><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h_2(key)=p-(key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></li>
<li>其中：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>&lt;</mo><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi mathvariant="normal">，</mi><mi>p</mi><mi mathvariant="normal">、</mi><mi>T</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">p&lt;TableSize，p、TableSize</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">、</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span>都是素数</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/MPt4DoEZyw5k7dL.png" width="50%" height="50%">
<h4 id="再散列rehashing"><a class="markdownIt-Anchor" href="#再散列rehashing"></a> 再散列(Rehashing)</h4>
<ul>
<li>当散列表元素太多(即装填因子α太大)时，查找效率会下降
<ul>
<li>实用最大装填因子一般取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.5</mn><mo>≤</mo><mi>α</mi><mo>≤</mo><mn>0.85</mn></mrow><annotation encoding="application/x-tex">0.5\leq α\leq 0.85</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">5</span></span></span></span>
<ul>
<li>当装填因子过大时，解决的方案时加倍扩大散列表，这个过程叫做“再散裂(Rehashing)”</li>
<li>注意：当散列表规模扩大以后，必须把所有元素重新计算后放入到散列表相应位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/U59dF7cDkjVqQnx.png" width="50%" height="50%">
<h3 id="分离链接法separate-chaining"><a class="markdownIt-Anchor" href="#分离链接法separate-chaining"></a> 分离链接法(Separate chaining)</h3>
<ul>
<li>将相应位置上冲突的所有关键词存储在同一个单链表中</li>
<li>例：设关键字序列为47,7,29,11,16,92,22,8,3,50,37,89,94,21；
<ul>
<li>散列函数为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>k</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">h(key)=key</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">mod</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>11</mn></mrow><annotation encoding="application/x-tex">11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span></span></span></span></li>
<li>用分离链接法处理冲突
<ul>
<li>表中有9个结点只需一次查找，5个结点需要2次查找</li>
<li>查找成功的平均查找次数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mfrac><mrow><mn>9</mn><mo>+</mo><mn>5</mn><mo>∗</mo><mn>2</mn></mrow><mn>14</mn></mfrac><mo>≈</mo><mn>1.36</mn></mrow><annotation encoding="application/x-tex">ASLs=\frac{9+5*2}{14}≈1.36</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span><span class="mbin mtight">+</span><span class="mord mtight">5</span><span class="mbin mtight">∗</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span><span class="mord">6</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/v8tBSji91Uk6o43.png" width="50%" height="50%">
<h3 id="冲突处理方法的伪代码描述"><a class="markdownIt-Anchor" href="#冲突处理方法的伪代码描述"></a> 冲突处理方法的伪代码描述</h3>
<p>开放定址法散列表结构、查找操作、插入操作的伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct HashTbl*HashTable;
struct HashTbl&#123;
    int TableSize;Cell*TheCells;
&#125;H;
HashTable InitializeTable(int TableSize)&#123;
    HashTable H;
    int i;
    if(TableSize&lt;MinTableSize)&#123;
        Error(&quot;散列表太小&quot;);
        return NULL;
    &#125;
    &#x2F;&#x2F;分配散列表
    H&#x3D;(HashTable)malloc(sizeof(struct HashTbl));
    if(H&#x3D;&#x3D;NULL)
        FatalError(&quot;空间溢出！！！&quot;);
    H-&gt;TableSize&#x3D;NextPrime(TableSize);
    &#x2F;&#x2F;分配散列表Cells
    H-&gt;TheCells&#x3D;(Cells*)malloc(sizeof(Cell)*H-&gt;TableSize);
    if(H-&gt;TheCells&#x3D;&#x3D;NULL)
        FatalError(&quot;空间溢出！！！&quot;);
    for(i&#x3D;0;i&lt;H-&gt;TblaeSize;i++)
        H-&gt;TheCells[i].Info&#x3D;Empty;
    return H;
&#125;
Position Find(ElementType Key,HashTable H)&#123;                     &#x2F;&#x2F;平方探测
    Position CurrentPos,NewPos;
    int CNum&#x3D;0;                                                 &#x2F;&#x2F;记录冲突次数
    NewPos&#x3D;CurrentPos&#x3D;Hash(Key,H-&gt;TableSize);
    while(H-&gt;TheCells[NewPos].Info!&#x3D;Empty&amp;&amp;
        H-&gt;TheCells[NewPos].Element!&#x3D;Key)&#123;                      &#x2F;&#x2F;字符串类型的关键词需要strcmp函数！！
        if(++CNum%2)&#123;                                           &#x2F;&#x2F;判断冲突的奇偶次
            NewPos&#x3D;CurrentPos+(CNum+1)&#x2F;2*(CNum+1)&#x2F;2  
            &#x2F;&#x2F;如：
            &#x2F;&#x2F;d(i)    +1^2  -1^2  +2^2  -2^2  +3^2  -3^2  ……
            &#x2F;&#x2F;Cnum      1     2     3     4     5     6   ……
            while(NewPos&gt;&#x3D;H-&gt;TableSize)
                NewPos-&#x3D;H-&gt;TableSize;
        &#125;else&#123;
            NewPos&#x3D;CurrentPos-(CNum+1)&#x2F;2*(CNum+1)&#x2F;2  
            while(NewPos&lt;0)
                NewPos+&#x3D;H-&gt;TableSize;
        &#125;
    &#125;
    return NewPos;
&#125;
void Insert(ElementType Key,HashTable H)&#123;
    &#x2F;&#x2F;插入操作
    Position Pos;
    Pos&#x3D;Find(Key,H);
    if(H-&gt;TheCells[Pos].Info!&#x3D;Legitimate)&#123;
        &#x2F;&#x2F;确认在此插入
        H-&gt;TheCells[Pos].Info&#x3D;Legitimate;
        H-&gt;TheCells[Pos].Info&#x3D;Key;
            &#x2F;&#x2F;字符串类型的关键词需要strcpy函数
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>分离链接法散列表结构，查找操作的伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct ListNode*Position,*List;
struct ListNode&#123;
    ElementType Element;
    Position Next;
&#125;;
typedef struct HashTbl*HashTable;
struct HashTbl&#123;
    int TableSize;
    List TheList;
&#125;;
Position Find(ElementType Key,HashTable H)&#123;
    Position P;
    int Pos&#x3D;Hash(Key,H-&gt;TableSize);             &#x2F;&#x2F;初始散列位置
    P&#x3D;H-&gt;TheLists[Pos].Next;                    &#x2F;&#x2F;获得链表头
    while(P!&#x3D;NULL&amp;&amp;strcmp(P-&gt;Element,Key))
        P&#x3D;P-&gt;Next;
    return P;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="散列表实现演示"><a class="markdownIt-Anchor" href="#散列表实现演示"></a> 散列表实现演示</h2>
<h3 id="使用开放定制法解决冲突"><a class="markdownIt-Anchor" href="#使用开放定制法解决冲突"></a> 使用开放定制法解决冲突</h3>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdio&gt;
#include&lt;cmath&gt;
#define MAXTABLESIZE 100000 &#x2F;* 允许开辟的最大散列表长度 *&#x2F;
typedef int ElementType;    &#x2F;* 关键词类型用整型 *&#x2F;
typedef int Index;          &#x2F;* 散列地址类型 *&#x2F;
typedef Index Position;     &#x2F;* 数据所在位置与散列地址是同一类型 *&#x2F;
&#x2F;* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 *&#x2F;
typedef enum &#123; Legitimate, Empty, Deleted &#125; EntryType;

typedef struct HashEntry Cell; &#x2F;* 散列表单元类型 *&#x2F;
struct HashEntry&#123;
    ElementType Data; &#x2F;* 存放元素 *&#x2F;
    EntryType Info;   &#x2F;* 单元状态 *&#x2F;
&#125;;

typedef struct TblNode *HashTable; &#x2F;* 散列表类型 *&#x2F;
struct TblNode &#123;   &#x2F;* 散列表结点定义 *&#x2F;
    int TableSize; &#x2F;* 表的最大长度 *&#x2F;
    Cell *Cells;   &#x2F;* 存放散列单元数据的数组 *&#x2F;
&#125;;

int Hash( int , int );
int NextPrime( int N )
&#123; &#x2F;* 返回大于N且不超过MAXTABLESIZE的最小素数 *&#x2F;
    int i, p &#x3D; (N%2)? N+2 : N+1; &#x2F;*从大于N的下一个奇数开始 *&#x2F;

    while( p &lt;&#x3D; MAXTABLESIZE ) &#123;
        for( i&#x3D;(int)sqrt(p); i&gt;2; i-- )
            if ( !(p%i) ) break; &#x2F;* p不是素数 *&#x2F;
        if ( i&#x3D;&#x3D;2 ) break; &#x2F;* for正常结束，说明p是素数 *&#x2F;
        else  p +&#x3D; 2; &#x2F;* 否则试探下一个奇数 *&#x2F;
    &#125;
    return p;
&#125;

HashTable CreateTable( int TableSize )
&#123;
    HashTable H;
    int i;

    H &#x3D; (HashTable)malloc(sizeof(struct TblNode));
    &#x2F;* 保证散列表最大长度是素数 *&#x2F;
    H-&gt;TableSize &#x3D; NextPrime(TableSize);
    &#x2F;* 声明单元数组 *&#x2F;
    H-&gt;Cells &#x3D; (Cell *)malloc(H-&gt;TableSize*sizeof(Cell));
    &#x2F;* 初始化单元状态为“空单元” *&#x2F;
    for( i&#x3D;0; i&lt;H-&gt;TableSize; i++ )
        H-&gt;Cells[i].Info &#x3D; Empty;

    return H;
&#125;
Position Find( HashTable H, ElementType Key )
&#123;
    Position CurrentPos, NewPos;
    int CNum &#x3D; 0; &#x2F;* 记录冲突次数 *&#x2F;

    NewPos &#x3D; CurrentPos &#x3D; Hash( Key, H-&gt;TableSize ); &#x2F;* 初始散列位置 *&#x2F;
    &#x2F;* 当该位置的单元非空，并且不是要找的元素时，发生冲突 *&#x2F;
    while( H-&gt;Cells[NewPos].Info!&#x3D;Empty &amp;&amp; H-&gt;Cells[NewPos].Data!&#x3D;Key ) &#123;
                                           &#x2F;* 字符串类型的关键词需要 strcmp 函数!! *&#x2F;
        &#x2F;* 统计1次冲突，并判断奇偶次 *&#x2F;
        if( ++CNum%2 )&#123; &#x2F;* 奇数次冲突 *&#x2F;
            NewPos &#x3D; CurrentPos + (CNum+1)*(CNum+1)&#x2F;4; &#x2F;* 增量为+[(CNum+1)&#x2F;2]^2 *&#x2F;
            if ( NewPos &gt;&#x3D; H-&gt;TableSize )
                NewPos &#x3D; NewPos % H-&gt;TableSize; &#x2F;* 调整为合法地址 *&#x2F;
        &#125;
        else &#123; &#x2F;* 偶数次冲突 *&#x2F;
            NewPos &#x3D; CurrentPos - CNum*CNum&#x2F;4; &#x2F;* 增量为-(CNum&#x2F;2)^2 *&#x2F;
            while( NewPos &lt; 0 )
                NewPos +&#x3D; H-&gt;TableSize; &#x2F;* 调整为合法地址 *&#x2F;
        &#125;
    &#125;
    return NewPos; &#x2F;* 此时NewPos或者是Key的位置，或者是一个空单元的位置（表示找不到）*&#x2F;
&#125;

bool Insert( HashTable H, ElementType Key )
&#123;
    Position Pos &#x3D; Find( H, Key ); &#x2F;* 先检查Key是否已经存在 *&#x2F;

    if( H-&gt;Cells[Pos].Info !&#x3D; Legitimate ) &#123; &#x2F;* 如果这个单元没有被占，说明Key可以插入在此 *&#x2F;
        H-&gt;Cells[Pos].Info &#x3D; Legitimate;
        H-&gt;Cells[Pos].Data &#x3D; Key;
        &#x2F;*字符串类型的关键词需要 strcpy 函数!! *&#x2F;
        return true;
    &#125;
    else &#123;
        printf(&quot;键值已存在&quot;);
        return false;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用分离链接法解决冲突"><a class="markdownIt-Anchor" href="#使用分离链接法解决冲突"></a> 使用分离链接法解决冲突</h3>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#define KEYLENGTH 15                   &#x2F;* 关键词字符串的最大长度 *&#x2F;
#define MAXTABLESIZE 100000            &#x2F;* 允许开辟的最大散列表长度 *&#x2F;
typedef char ElementType[KEYLENGTH+1]; &#x2F;* 关键词类型用字符串 *&#x2F;
typedef int Index;                     &#x2F;* 散列地址类型 *&#x2F;
&#x2F;******** 以下是单链表的定义 ********&#x2F;
typedef struct LNode *PtrToLNode;
struct LNode &#123;
    ElementType Data;
    PtrToLNode Next;
&#125;;
typedef PtrToLNode Position;
typedef PtrToLNode List;
&#x2F;******** 以上是单链表的定义 ********&#x2F;

typedef struct TblNode *HashTable; &#x2F;* 散列表类型 *&#x2F;
struct TblNode &#123;   &#x2F;* 散列表结点定义 *&#x2F;
    int TableSize; &#x2F;* 表的最大长度 *&#x2F;
    List Heads;    &#x2F;* 指向链表头结点的数组 *&#x2F;
&#125;;

int Hash( ElementType , int );
int NextPrime( int N )
&#123; &#x2F;* 返回大于N且不超过MAXTABLESIZE的最小素数 *&#x2F;
    int i, p &#x3D; (N%2)? N+2 : N+1; &#x2F;*从大于N的下一个奇数开始 *&#x2F;

    while( p &lt;&#x3D; MAXTABLESIZE ) &#123;
        for( i&#x3D;(int)sqrt(p); i&gt;2; i-- )
            if ( !(p%i) ) break; &#x2F;* p不是素数 *&#x2F;
        if ( i&#x3D;&#x3D;2 ) break; &#x2F;* for正常结束，说明p是素数 *&#x2F;
        else  p +&#x3D; 2; &#x2F;* 否则试探下一个奇数 *&#x2F;
    &#125;
    return p;
&#125;
HashTable CreateTable( int TableSize )
&#123;
    HashTable H;
    int i;

    H &#x3D; (HashTable)malloc(sizeof(struct TblNode));
    &#x2F;* 保证散列表最大长度是素数，具体见代码6.3.1 *&#x2F;
    H-&gt;TableSize &#x3D; NextPrime(TableSize);

    &#x2F;* 以下分配链表头结点数组 *&#x2F;
    H-&gt;Heads &#x3D; (List)malloc(H-&gt;TableSize*sizeof(struct LNode));
    &#x2F;* 初始化表头结点 *&#x2F;
    for( i&#x3D;0; i&lt;H-&gt;TableSize; i++ ) &#123;
         H-&gt;Heads[i].Data[0] &#x3D; &#39;\0&#39;;
         H-&gt;Heads[i].Next &#x3D; NULL;
    &#125;

    return H;
&#125;

Position Find( HashTable H, ElementType Key )
&#123;
    Position P;
    Index Pos;
  
    Pos &#x3D; Hash( Key, H-&gt;TableSize ); &#x2F;* 初始散列位置 *&#x2F;
    P &#x3D; H-&gt;Heads[Pos].Next; &#x2F;* 从该链表的第1个结点开始 *&#x2F;
    &#x2F;* 当未到表尾，并且Key未找到时 *&#x2F; 
    while( P &amp;&amp; strcmp(P-&gt;Data, Key) )
        P &#x3D; P-&gt;Next;

    return P; &#x2F;* 此时P或者指向找到的结点，或者为NULL *&#x2F;
&#125;

bool Insert( HashTable H, ElementType Key )
&#123;
    Position P, NewCell;
    Index Pos;
  
    P &#x3D; Find( H, Key );
    if ( !P ) &#123; &#x2F;* 关键词未找到，可以插入 *&#x2F;
        NewCell &#x3D; (Position)malloc(sizeof(struct LNode));
        strcpy(NewCell-&gt;Data, Key);
        Pos &#x3D; Hash( Key, H-&gt;TableSize ); &#x2F;* 初始散列位置 *&#x2F;
        &#x2F;* 将NewCell插入为H-&gt;Heads[Pos]链表的第1个结点 *&#x2F;
        NewCell-&gt;Next &#x3D; H-&gt;Heads[Pos].Next;
        H-&gt;Heads[Pos].Next &#x3D; NewCell; 
        return true;
    &#125;
    else &#123; &#x2F;* 关键词已存在 *&#x2F;
        printf(&quot;键值已存在&quot;);
        return false;
    &#125;
&#125;

void DestroyTable( HashTable H )
&#123;
    int i;
    Position P, Tmp;
  
    &#x2F;* 释放每个链表的结点 *&#x2F;
    for( i&#x3D;0; i&lt;H-&gt;TableSize; i++ ) &#123;
        P &#x3D; H-&gt;Heads[i].Next;
        while( P ) &#123;
            Tmp &#x3D; P-&gt;Next;
            free( P );
            P &#x3D; Tmp;
        &#125;
    &#125;
    free( H-&gt;Heads ); &#x2F;* 释放头结点数组 *&#x2F;
    free( H );        &#x2F;* 释放散列表结点 *&#x2F;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="散列表性能分析"><a class="markdownIt-Anchor" href="#散列表性能分析"></a> 散列表性能分析</h2>
<ul>
<li>平均查找长度(ASL)用来度量散列表查找效率：成功或不成功</li>
<li>关键词的比较次数，取决于产生冲突的多少
<ul>
<li>影响产生冲突多少有以下三个因素：</li>
<li>散列函数是否均匀</li>
<li>处理冲突的办法</li>
<li>散列表的装填因子α</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/dkb5fO48IqKXhNn.png" width="50%" height="50%">
<h3 id="开放定址法的查找性能"><a class="markdownIt-Anchor" href="#开放定址法的查找性能"></a> 开放定址法的查找性能</h3>
<h4 id="线性探测法"><a class="markdownIt-Anchor" href="#线性探测法"></a> 线性探测法</h4>
<ul>
<li>可以证明，线性探测法的期望查找次数，满足以下公式：
<ul>
<li>对插入成功和不成功查找而言：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><msup><mi>α</mi><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p=\frac{1}{2}[1+\frac{1}{1-α^2}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li>
<li>对成功查找而言：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">[</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow></mfrac><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">p=\frac{1}{2}[1+\frac{1}{1-α}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">[</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">]</span></span></span></span></li>
<li>比如，当α=0.5，此时有一半的位置被填满(假设每个散列值发生的可能性相同，则插入或查询有一半的可能会发生冲突)
<ul>
<li>插入操作和不成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mn>0.5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.5</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mo stretchy="false">)</mo><mo>=</mo><mn>2.5</mn></mrow><annotation encoding="application/x-tex">ASLu=0.5\times(1+\frac{1}{(1-0.5)^2})=2.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span>次</li>
<li>成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mn>0.5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mn>0.5</mn></mrow></mfrac><mo stretchy="false">)</mo><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">ASLs=0.5\times(1+\frac{1}{1-0.5})=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span></span></span></span>次</li>
</ul>
</li>
</ul>
</li>
<li>例：插入序列{11,47,7,29,9,84,54,20,30}</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">H(key)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
<th style="text-align:center">11</th>
<th style="text-align:center">12</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">11</td>
<td style="text-align:center">30</td>
<td style="text-align:center"></td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">84</td>
<td style="text-align:center">54</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">冲突次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mn>9</mn><mn>13</mn></mfrac><mo>≈</mo><mn>0.69</mn></mrow><annotation encoding="application/x-tex">α=\frac{9}{13}≈0.69</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord">9</span></span></span></span>，于是
<ul>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mn>0.5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.69</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mfrac><mo>≈</mo><mn>5.70</mn></mrow><annotation encoding="application/x-tex">ASLu=0.5\times(1+\frac{1}{(1-0.69)^2}≈5.70</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.365108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">6</span><span class="mord mtight">9</span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">7</span><span class="mord">0</span></span></span></span>次</li>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mn>0.5</mn><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mn>0.69</mn></mrow></mfrac><mo>≈</mo><mn>2.11</mn></mrow><annotation encoding="application/x-tex">ASLs=0.5\times(1+\frac{1}{1-0.69}≈2.11</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">6</span><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">1</span><span class="mord">1</span></span></span></span>次</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/xhF42nPzjLg9ROM.png" width="50%" height="50%">
<h3 id="平方探测法和双散列探测法"><a class="markdownIt-Anchor" href="#平方探测法和双散列探测法"></a> 平方探测法和双散列探测法</h3>
<ul>
<li>可以证明，平方探测法和双散列探测法探测次数满足以下公式：
<ul>
<li>对插入和查找不成功而言：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>α</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">p=\frac{1}{1-α}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>对成功查找而言：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><mo>−</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><mi>α</mi></mfrac></mrow><annotation encoding="application/x-tex">p=-\frac{ln(1-α)}{α}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li>
<li>比如，当α=0.5时
<ul>
<li>插入操作和不成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mfrac><mn>1</mn><mn>0.5</mn></mfrac><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">ASLu=\frac{1}{0.5}=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li>成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>×</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>0.5</mn><mo stretchy="false">)</mo></mrow><mn>0.5</mn></mfrac><mo>≈</mo><mn>1.39</mn></mrow><annotation encoding="application/x-tex">ASLs=-1\times \frac{ln(0.5)}{0.5}≈1.39</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">5</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span><span class="mord">9</span></span></span></span>次</li>
</ul>
</li>
<li>例：插入序列{11,47,7,29,9,84,54,20,30}</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">H(key)</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">10</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">11</td>
<td style="text-align:center">30</td>
<td style="text-align:center">20</td>
<td style="text-align:center">47</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">84</td>
<td style="text-align:center">7</td>
<td style="text-align:center">29</td>
<td style="text-align:center">9</td>
<td style="text-align:center">54</td>
</tr>
<tr>
<td style="text-align:center">冲突次数</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mn>9</mn><mn>11</mn></mfrac><mo>≈</mo><mn>0.82</mn></mrow><annotation encoding="application/x-tex">α=\frac{9}{11}≈0.82</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span><span class="mord">2</span></span></span></span>，于是
<ul>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mn>0.82</mn></mrow></mfrac><mo>≈</mo><mn>5.56</mn></mrow><annotation encoding="application/x-tex">ASLu=\frac{1}{1-0.82}≈5.56</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">8</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">.</span><span class="mord">5</span><span class="mord">6</span></span></span></span>次</li>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mo>−</mo><mn>1</mn><mo>×</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mn>0.82</mn><mo stretchy="false">)</mo></mrow><mn>0.82</mn></mfrac><mo>≈</mo><mn>2.09</mn></mrow><annotation encoding="application/x-tex">ASLs=-1\times \frac{ln(1-0.82)}{0.82}≈2.09</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">8</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight">0</span><span class="mord mtight">.</span><span class="mord mtight">8</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">0</span><span class="mord">9</span></span></span></span>次</li>
</ul>
</li>
</ul>
<h3 id="期望探测次数与装填因子α的关系"><a class="markdownIt-Anchor" href="#期望探测次数与装填因子α的关系"></a> 期望探测次数与装填因子α的关系</h3>
<ul>
<li>当装填因子α&lt;0.5的时候，各种探测法的期望探测次数都不大，也比较接近</li>
<li>随着α的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数比成功查找的期望探测次数要大</li>
<li>合理的最大装填因子α应该不超过0.85</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/2gLtuvDfZOd6w8j.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/04/5qrTGflHxgEepSb.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/04/9T2KENPCfXmzhsS.png" width="50%" height="50%">
<h2 id="分离链接法性能分析"><a class="markdownIt-Anchor" href="#分离链接法性能分析"></a> 分离链接法性能分析</h2>
<p>所有地址链表长度的和(装入的元素个数)相对于表长的比例定义为装填因子α，因此α有可能超过1</p>
<ul>
<li>不难证明：其期望探测次数p为
<ul>
<li>对插入和不成功查找而言：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup></mrow><annotation encoding="application/x-tex">α+e^{-α}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.771331em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.771331em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>对成功查找而言：$1+\frac{α}{2}$</li>
<li>比如，当α=1时
<ul>
<li>插入操作和不成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>≈</mo><mn>1.37</mn></mrow><annotation encoding="application/x-tex">ASLu=1+e^{-1}≈1.37</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">3</span><span class="mord">7</span></span></span></span>次
<ul>
<li>成功查找的期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>=</mo><mn>1.5</mn></mrow><annotation encoding="application/x-tex">ASLs=1+\frac{1}{2}=1.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span></span></span></span>次</li>
</ul>
</li>
</ul>
</li>
<li>例：插入序列{11,47,7,29,9,84,54,20,30}
<ul>
<li>14个元素分配在11个单链表中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo>=</mo><mfrac><mn>14</mn><mn>11</mn></mfrac><mo>≈</mo><mn>1.27</mn></mrow><annotation encoding="application/x-tex">α=\frac{14}{11}≈1.27</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">7</span></span></span></span></li>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>s</mi><mo>=</mo><mn>1.27</mn><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mn>1.27</mn></mrow></msup><mo>≈</mo><mn>1.55</mn></mrow><annotation encoding="application/x-tex">ASLs=1.27+e^{-1.27}≈1.55</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">2</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mord">5</span></span></span></span>次</li>
<li>期望<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><mi>L</mi><mi>u</mi><mo>=</mo><mn>1</mn><mo>+</mo><mfrac><mn>1.27</mn><mn>2</mn></mfrac><mo>=</mo><mn>1.635</mn></mrow><annotation encoding="application/x-tex">ASLu=1+\frac{1.27}{2}=1.635</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">L</span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">6</span><span class="mord">3</span><span class="mord">5</span></span></span></span>次</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/i6ZNwqp4DCkTgdK.png" width="50%" height="50%">
<h2 id="散列表性能总结"><a class="markdownIt-Anchor" href="#散列表性能总结"></a> 散列表性能总结</h2>
<ul>
<li>选择合适的h(key)，散列表的查找效率期望是常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，几乎与关键字的空间大小n无关，也适合于关键字直接比较计算量大的问题</li>
<li>散列表是以较小的α为前提，因此散列方法是一个以空间换时间的策略</li>
<li>散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找</li>
</ul>
<h3 id="开放定址法"><a class="markdownIt-Anchor" href="#开放定址法"></a> 开放定址法</h3>
<ul>
<li>散列表是一个数组，存储效率高，随机查找</li>
<li>散列表有“聚集”现象</li>
</ul>
<h3 id="分离链接法"><a class="markdownIt-Anchor" href="#分离链接法"></a> 分离链接法</h3>
<ul>
<li>散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低</li>
<li>关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”</li>
<li>太小的α可能导致空间浪费，大的α又将付出更多的时间代价，不均匀的链表长度导致时间效率的严重下降</li>
</ul>
<h2 id="应用实例"><a class="markdownIt-Anchor" href="#应用实例"></a> 应用实例</h2>
<p>散列表应用：文件中单词词频统计<br>
例：给定一个英文文本文件，统计文件中所有单词出现的频率，并输出词频最大的前10%的单词及其词频，假设单词字符定义为大小写字母、数字和下划线，其他字符均认为是单词分隔符，不予考虑</p>
<p>分析：</p>
<ul>
<li>关键：对新读入的单词在已有的单词表中查找
<ul>
<li>如果已经存在，则将该单词的词频加1</li>
<li>如果不存在，则插入该单词并记词频为1</li>
</ul>
</li>
<li>如何设计该单词表的数据结构才可以进行快速的查找和插入：应用散列表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    int TableSize&#x3D;10000;                    &#x2F;&#x2F;散列表估计大小
    int wordcount&#x3D;0,length;
    HashTable H;
    ElementType word;
    FILE*fp;
    char document[30]&#x3D;&quot;HarryPotter.txt&quot;;    &#x2F;&#x2F;要被统计词频的文件名
    H&#x3D;InitializeTable(TableSize);           &#x2F;&#x2F;建立散列表
    if((fp&#x3D;fopen(document,&#39;r&#39;))&#x3D;&#x3D;NULL)FatalError(&quot;无法打开文件！\n&quot;);
    while(!feof(fp))&#123;
        length&#x3D;GetAWord(fp,word);           &#x2F;&#x2F;从文件中读取一个单词
        if(length&gt;3)&#123;                       &#x2F;&#x2F;只考虑适当长度的单词
            wordcount++;                    &#x2F;&#x2F;统计文件中单词总数
            InsertAndCount(word,H);              
        &#125;
    &#125;
    fclose(fp);
    printf(&quot;该文档总共出现%d个有效单词，&quot;,wordcount);
    Show(H,10.0&#x2F;100);                       &#x2F;&#x2F;显示词频前10%的所有单词
    &#x2F;&#x2F;统计最大词频：
    &#x2F;&#x2F;用一组数统计从1到最大词频的单词数
    &#x2F;&#x2F;计算前10%的词频应该是多少
    &#x2F;&#x2F;输出前10%的单词
    DestroyTable(H);                        &#x2F;&#x2F;销毁散列表
    return 0;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>继续</title>
    <url>/posts/a5da8771259e</url>
    <content><![CDATA[<p><em><strong>一位音乐系的学生走进练习室。在钢琴上，摆着一份全新的乐谱。<br>
“超高难度 …… ”他翻动着乐谱，喃喃自语，感觉自己对弹奏钢琴的信心似乎跌到了谷底，消靡殆尽。<br>
已经三个月了！自从跟了这位新的指导教授后，不知道，为什么教授要以这种方式整人。<br>
勉强打起精神。他开始用十指奋战、奋战、奋战 …… 琴音盖住了练习室外教授走来的脚步声。<br>
指导教授是个极有名的钢琴大师。授课第一天，他给自己的新学生一份乐谱。“试试看吧！”他说。乐谱难度颇高，学生弹得生涩僵滞，错误百出。“还不熟，回去好好练习！”教授在下课时，如此叮嘱学生。<br>
学生练了一个星期，第二周上课时正准备让教授验收，没想到教授又给了他一份难度更高的乐谱，“试试看吧！”上星期的课，教授提也没提。学生再次挣扎于更高难度的技巧挑战。<br>
第三周。更难的乐谱又出现了。同样的情形持续着，学生每次在课堂上都被一份新的乐谱所困扰，然后把它带回去练习，接着再回到课堂上，重新面临两倍难度的乐谱，却怎么样都追不上进度，一点也没有因为上周的练习而驾轻就熟的感觉，学生感到越来越不安，沮丧和气馁。<br>
教授走进练习室。学生再也忍不住了。它必须向钢琴大师提出这三个月来何以不断折磨自己的质疑。<br>
教授没开口，他抽出了最早的那份乐谱，教给学生。“弹奏吧！”他以坚定的目光望着学生。<br>
不可思议的结果发生了，连学生自己都惊讶万分，他居然可以将这首曲子弹奏得如此美妙、如此精湛！教授又让学生试了第二堂课的乐谱，学生依然呈现超高水准的表现 …… 演奏结束，学生怔怔地看着老师，说不出话来。<br>
“如果，我任由你表现最擅长的部分，可能你还在练习最早的那份乐谱，就不会有现在这样的程度 …… ”钢琴大师缓缓地说。</strong></em></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>表排序、桶排序、基数排序</title>
    <url>/posts/71c24891d81c</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 10%;
;
}
table th:nth-of-type(3){
width: 10%;
}
table th:nth-of-type(4){
width: 10%;
}
table th:nth-of-type(5){
width: 10%;
}
table th:nth-of-type(6){
width: 10%;
}
table th:nth-of-type(7){
width: 10%;
}
table th:nth-of-type(8){
width: 10%;
}
table th:nth-of-type(9){
width: 10%;
}
</style>
<h1 id="表排序"><a class="markdownIt-Anchor" href="#表排序"></a> 表排序</h1>
<img src="https://s2.loli.net/2022/05/04/ZoBqF7CGbk8VfPH.png" width="50%" height="50%">
<span id="more"></span>
<p>表排序(间接排序)</p>
<ul>
<li>当每一个待排序的元素都非常大，一本书，一部电影等，移动元素的代价比较大
<ul>
<li>选择不移动元素而移动指向他们的下标</li>
</ul>
</li>
<li>定义一个数组作为“表”(table)</li>
<li>例：table(以插入排序为例)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">f</td>
<td style="text-align:center">d</td>
<td style="text-align:center">c</td>
<td style="text-align:center">a</td>
<td style="text-align:center">g</td>
<td style="text-align:center">b</td>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">f(d)</td>
<td style="text-align:center">d(f)</td>
<td style="text-align:center">c</td>
<td style="text-align:center">a</td>
<td style="text-align:center">g</td>
<td style="text-align:center">b</td>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">f©</td>
<td style="text-align:center">d(d)</td>
<td style="text-align:center">c(f)</td>
<td style="text-align:center">a</td>
<td style="text-align:center">g</td>
<td style="text-align:center">b</td>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<center> ...... </center>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">f(a)</td>
<td style="text-align:center">d(b)</td>
<td style="text-align:center">c©</td>
<td style="text-align:center">a(d)</td>
<td style="text-align:center">g(e)</td>
<td style="text-align:center">b(f)</td>
<td style="text-align:center">h(g)</td>
<td style="text-align:center">e(h)</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<h2 id="物理排序"><a class="markdownIt-Anchor" href="#物理排序"></a> 物理排序</h2>
<p>如果一定要按照实际的物理地址进行排序，下面的方法可在线性时间复杂度下完成</p>
<ul>
<li>N个数字的排列由若干个独立的环组成
<ul>
<li>A[0]对应table[3]，A[3]对应table[1]，A[1]对应table[5]，A[5]对应table[0]，形成一个环</li>
<li>独立的环对每个环进行移动操作可减少移动次数(避免无效的移动)</li>
</ul>
</li>
<li>如：在表中分出三个环，分别对每个环里面的元素按照物理排序</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">f</td>
<td style="text-align:center">d</td>
<td style="text-align:center">c</td>
<td style="text-align:center">a</td>
<td style="text-align:center">g</td>
<td style="text-align:center">b</td>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">3(1)</td>
<td style="text-align:center">5(1)</td>
<td style="text-align:center">2(2)</td>
<td style="text-align:center">1(1)</td>
<td style="text-align:center">7(3)</td>
<td style="text-align:center">0(1)</td>
<td style="text-align:center">6(3)</td>
<td style="text-align:center">4(3)</td>
</tr>
</tbody>
</table>
<ul>
<li>令temp=table[0]=f，此时table[0]的位置空出
<ul>
<li>将该位置上本来应该放置的元素移动过来，即table[0]=a，此时原来放置a的位置table[3]空出</li>
<li>同理，将table[3]应该放置的元素d移动到table[3]，同样的table[1]空出</li>
<li>以此类推，直到table[5]空出，此时table[5]应该放置的元素为f=temp，将临时变量放入最后的空位</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">[0]</th>
<th style="text-align:center">[1]</th>
<th style="text-align:center">[2]</th>
<th style="text-align:center">[3]</th>
<th style="text-align:center">[4]</th>
<th style="text-align:center">[5]</th>
<th style="text-align:center">[6]</th>
<th style="text-align:center">[7]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center">g</td>
<td style="text-align:center">f</td>
<td style="text-align:center">h</td>
<td style="text-align:center">e</td>
</tr>
<tr>
<td style="text-align:center">table</td>
<td style="text-align:center">3(1)</td>
<td style="text-align:center">5(1)</td>
<td style="text-align:center">2(2)</td>
<td style="text-align:center">1(1)</td>
<td style="text-align:center">7(3)</td>
<td style="text-align:center">0(1)</td>
<td style="text-align:center">6(3)</td>
<td style="text-align:center">4(3)</td>
</tr>
</tbody>
</table>
<ul>
<li>如何判断一个环的结束
<ul>
<li>每访问一个空位i后，令table[i]=i</li>
<li>当发现table[i]==i时，环结束</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/H7QfkVDxac85SKi.png" width="50%" height="50%">
<p>复杂度分析</p>
<ul>
<li>最好情况：初始即有序</li>
<li>最坏情况：
<ul>
<li>有⌊\freq{N}{2}⌋个环，每个环包含2个元素(多元环最多的情况)
<ul>
<li>需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌊</mo><mn>3</mn><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">⌊3N/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord">3</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span>次元素移动</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(mN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，m是每个A元素的复制时间(每个元素都比较大，故复制元素的时间不可忽略)</li>
</ul>
</li>
</ul>
<h1 id="桶排序"><a class="markdownIt-Anchor" href="#桶排序"></a> 桶排序</h1>
<p>定理：任何基于比较的排序算法，其最坏情况平均时间复杂度下界为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ω(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>桶排序：打破<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">NlogN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>的界限(并不直接进行比较)</p>
<ul>
<li>例：假设有N个学生，成绩是0到100之间的整数(于是有M=101个不同的成绩值)
<ul>
<li>如何在线性时间内将学生按成绩排序
<ul>
<li>此问题中数据的特殊性：学生可以有很多，但是成绩的种类就只有101种</li>
</ul>
</li>
<li>建立101个“桶”，每个桶代表一个成绩值，相同成绩的学生在对应的桶中构成链表</li>
<li>扫描每个学生的成绩，依次将其插入到对应的桶中</li>
<li>每个桶被初始化为一个空链表的头指针</li>
</ul>
</li>
</ul>
<p>桶排序伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void BUcket_Sort(ElementType A[],int N)&#123;
    初始化count[];
    while(读入1个学生的成绩grade)
        将该生插入count[grade]链表;
    for(i&#x3D;0;i&lt;M;i++)&#123;
        if(count[i])
            输出整个count[i]链表;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N,M)=O(M+N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>每个学生结点和成绩结点都要扫描一遍</li>
<li>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>&gt;</mo><mo>&gt;</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M&gt;&gt;N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(M)=O(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span>，可看做线性算法</li>
</ul>
<h1 id="基数排序"><a class="markdownIt-Anchor" href="#基数排序"></a> 基数排序</h1>
<h2 id="单关键字排序"><a class="markdownIt-Anchor" href="#单关键字排序"></a> 单关键字排序</h2>
<p>基数排序：根据位次建桶</p>
<ul>
<li>例：假设有N=10个整数，每个整数的值在0到999之间(于是有M=1000个不同的可能值)
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>64</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>216</mn><mo separator="true">,</mo><mn>512</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>729</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>343</mn><mo separator="true">,</mo><mn>125</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[64,8,216,512,27,729,0,1,343,125]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">6</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">2</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">4</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
</ul>
</li>
<li>如何在线性时间内将所有整数排序
<ul>
<li>在排序的时候，次关键字对应低位，主关键字对应高位
<ul>
<li>如整数的高位相对于低位而言是主关键字，低位是次关键字</li>
</ul>
</li>
<li>“次位优先”(Least Significant Digit,LSD)
<ul>
<li>将整数按位排序，先从低位开始排序，然后对高位进行排序(递增)</li>
</ul>
</li>
<li>将整数的进制称为“基数”
<ul>
<li>建立基数个桶</li>
<li>先按低位对元素进行排序，然后在前面的基础上对高位进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/jvUze1mtbQ7Xf5D.png" width="50%" height="50%">
<p>时间复杂度：设元素个数为N，基数为B，LSD的趟数(最高位数)为P=\frac{log(最大元素)}{logB}</p>
<ul>
<li>一共排序P趟</li>
<li>在每一趟排序中要对B个桶、N个元素扫描一遍</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>P</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(P(N+B))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> (一般而言P和B可忽略不计，因此该算法是线性复杂度)</li>
<li>额外空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="多关键字的排序"><a class="markdownIt-Anchor" href="#多关键字的排序"></a> 多关键字的排序</h2>
<ul>
<li>例：一副扑克牌是按两种关键字排序的
<ul>
<li>K0[花色]：♣️ &lt; ♦️ &lt; ♥️ &lt; ♠️</li>
<li>K1[面值]：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&lt;</mo><mn>3</mn><mo>&lt;</mo><mn>4</mn><mo>&lt;</mo><mn>5</mn><mo>&lt;</mo><mn>6</mn><mo>&lt;</mo><mn>7</mn><mo>&lt;</mo><mn>8</mn><mo>&lt;</mo><mn>9</mn><mo>&lt;</mo><mn>10</mn><mo>&lt;</mo><mi>J</mi><mo>&lt;</mo><mi>Q</mi><mo>&lt;</mo><mi>K</mi><mo>&lt;</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">2&lt;3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">7</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></li>
<li>有序结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>♣️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.10556em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span>A♣️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>♦️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">...A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">A</span></span></span></span>♦️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>♥️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">...A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">A</span></span></span></span>♥️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>♠️<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">...A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault">A</span></span></span></span>♠️</li>
</ul>
</li>
<li>此问题中主关键字为花色，此关键字为面值
<ul>
<li>“主位优先”(Most Significant Digit,MSD)</li>
</ul>
</li>
<li>为花色建4个桶
<ul>
<li>在每个桶内排序，最后合并结果</li>
<li>比较，用“次位优先”排序：</li>
</ul>
</li>
<li>为面值建13个桶
<ul>
<li>将结果合并，然后再为花色建4个桶，再次排序</li>
</ul>
</li>
<li>LSD并不是在任何情况下都比MSD快，二者各有各自的适用场合</li>
</ul>
<h2 id="基数排序演示"><a class="markdownIt-Anchor" href="#基数排序演示"></a> 基数排序演示</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdlib&gt;
typedef int ElementType;

&#x2F;* 基数排序 - 次位优先 *&#x2F;

&#x2F;* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix *&#x2F;
#define MaxDigit 4
#define Radix 10

&#x2F;* 桶元素结点 *&#x2F;
typedef struct Node *PtrToNode;
struct Node &#123;
    int key;
    PtrToNode next;
&#125;;

&#x2F;* 桶头结点 *&#x2F;
struct HeadNode &#123;
    PtrToNode head, tail; 
&#125;;
typedef struct HeadNode Bucket[Radix];  &#x2F;&#x2F;桶是一个头结点链表，在最后排序的时候可以通过头尾结点指针来整个插入
 
int GetDigit ( int X, int D )
&#123; &#x2F;* 默认次位D&#x3D;1, 主位D&lt;&#x3D;MaxDigit *&#x2F;
    int d, i;
  
    for (i&#x3D;1; i&lt;&#x3D;D; i++) &#123;
        d &#x3D; X % Radix;
        X &#x2F;&#x3D; Radix;
    &#125;
    return d;
&#125;

void LSDRadixSort( ElementType A[], int N )
&#123; &#x2F;* 基数排序 - 次位优先 *&#x2F;
    int D, Di, i;
    Bucket B;
    PtrToNode tmp, p, List &#x3D; NULL; 
  
    for (i&#x3D;0; i&lt;Radix; i++) &#x2F;* 初始化每个桶为空链表 *&#x2F;
        B[i].head &#x3D; B[i].tail &#x3D; NULL;
    for (i&#x3D;0; i&lt;N; i++) &#123; &#x2F;* 将原始序列逆序存入初始链表List *&#x2F;
        tmp &#x3D; (PtrToNode)malloc(sizeof(struct Node));
        tmp-&gt;key &#x3D; A[i];
        tmp-&gt;next &#x3D; List;            
        List &#x3D; tmp;
    &#125;
    &#x2F;* 下面开始排序 *&#x2F; 
    for (D&#x3D;1; D&lt;&#x3D;MaxDigit; D++) &#123; &#x2F;* 对数据的每一位循环处理 *&#x2F;
        &#x2F;* 下面是分配的过程 *&#x2F;
        p &#x3D; List;
        while (p) &#123;                    &#x2F;&#x2F;直到List为空，分配结束
            Di &#x3D; GetDigit(p-&gt;key, D); &#x2F;* 获得当前元素的当前位数字 *&#x2F;
            &#x2F;* 从List中摘除 *&#x2F;
            tmp &#x3D; p; p &#x3D; p-&gt;next;      &#x2F;&#x2F;tmp指向被摘除的元素，p指向List下一个元素
            &#x2F;* 插入B[Di]号桶尾 *&#x2F;      
            tmp-&gt;next &#x3D; NULL;
            if (B[Di].head &#x3D;&#x3D; NULL)    &#x2F;&#x2F;桶空时的情况
                B[Di].head &#x3D; B[Di].tail &#x3D; tmp;
            else &#123;
                B[Di].tail-&gt;next &#x3D; tmp;
                B[Di].tail &#x3D; tmp;
            &#125;
        &#125;
        &#x2F;* 下面是收集的过程 *&#x2F;
        List &#x3D; NULL; 
        for (Di&#x3D;Radix-1; Di&gt;&#x3D;0; Di--) &#123; &#x2F;* 将每个桶的元素顺序收集入List *&#x2F; &#x2F;&#x2F;注意：这一过程是从radix-1即最大基数开始的
            if (B[Di].head) &#123; &#x2F;* 如果桶不为空 *&#x2F;
                &#x2F;* 整桶插入List表头 *&#x2F;
                B[Di].tail-&gt;next &#x3D; List;
                List &#x3D; B[Di].head;
                B[Di].head &#x3D; B[Di].tail &#x3D; NULL; &#x2F;* 清空桶 *&#x2F;
            &#125;
        &#125;
    &#125;
    &#x2F;* 将List倒入A[]并释放空间 *&#x2F;
    for (i&#x3D;0; i&lt;N; i++) &#123;
        tmp &#x3D; List;
        List &#x3D; List-&gt;next;
        A[i] &#x3D; tmp-&gt;key;
        free(tmp);
    &#125; 
&#125;

&#x2F;* 基数排序 - 主位优先 *&#x2F;

void MSD( ElementType A[], int L, int R, int D )
&#123; &#x2F;* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 *&#x2F;
    int Di, i, j;
    Bucket B;
    PtrToNode tmp, p, List &#x3D; NULL; 
    if (D&#x3D;&#x3D;0) return; &#x2F;* 递归终止条件 *&#x2F;
  
    for (i&#x3D;0; i&lt;Radix; i++) &#x2F;* 初始化每个桶为空链表 *&#x2F;
        B[i].head &#x3D; B[i].tail &#x3D; NULL;
    for (i&#x3D;L; i&lt;&#x3D;R; i++) &#123; &#x2F;* 将原始序列逆序存入初始链表List *&#x2F;
        tmp &#x3D; (PtrToNode)malloc(sizeof(struct Node));
        tmp-&gt;key &#x3D; A[i];
        tmp-&gt;next &#x3D; List;
        List &#x3D; tmp;
    &#125;
    &#x2F;* 下面是分配的过程 *&#x2F;
    p &#x3D; List;
    while (p) &#123;
        Di &#x3D; GetDigit(p-&gt;key, D); &#x2F;* 获得当前元素的当前位数字 *&#x2F;
        &#x2F;* 从List中摘除 *&#x2F;
        tmp &#x3D; p; p &#x3D; p-&gt;next;
        &#x2F;* 插入B[Di]号桶 *&#x2F;
        if (B[Di].head &#x3D;&#x3D; NULL) B[Di].tail &#x3D; tmp; 
        tmp-&gt;next &#x3D; B[Di].head;         &#x2F;&#x2F;注意MSD中不是插在桶尾，而是插在桶头
        B[Di].head &#x3D; tmp;
    &#125;
    &#x2F;* 下面是收集的过程 *&#x2F;
    i &#x3D; j &#x3D; L; &#x2F;* i, j记录当前要处理的A[]的左右端下标 *&#x2F;
    for (Di&#x3D;0; Di&lt;Radix; Di++) &#123; &#x2F;* 对于每个桶 *&#x2F;       &#x2F;&#x2F;MSD对每一个桶递归地进行排序
        if (B[Di].head) &#123; &#x2F;* 将非空的桶整桶倒入A[], 递归排序 *&#x2F;
            p &#x3D; B[Di].head;
            while (p) &#123;
                tmp &#x3D; p;
                p &#x3D; p-&gt;next;
                A[j++] &#x3D; tmp-&gt;key;   &#x2F;&#x2F;j最终为桶中的元素个数
                free(tmp);
            &#125;
            &#x2F;* 递归对该桶数据排序, 位数减1 *&#x2F;
            MSD(A, i, j-1, D-1);
            i &#x3D; j; &#x2F;* 为下一个桶对应的A[]左端 *&#x2F;
        &#125; 
    &#125; 
&#125;

void MSDRadixSort( ElementType A[], int N )
&#123; &#x2F;* 统一接口 *&#x2F;
    MSD(A, 0, N-1, MaxDigit); 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="各种排序方法的比较"><a class="markdownIt-Anchor" href="#各种排序方法的比较"></a> 各种排序方法的比较</h1>
<img src="https://s2.loli.net/2022/05/04/k6SDgwiVGat318X.png" width="50%" height="50%">
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序、归并排序</title>
    <url>/posts/8f1ffe4cb905</url>
    <content><![CDATA[<h1 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h1>
<p>堆排序伪代码描述：(自底向上建堆)</p>
<ul>
<li>建立最大堆，将最大的元素存在数组末尾)</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void Heap_Sort(ElementType A[],int N)
&#123;
    for(i&#x3D;N&#x2F;2-1;i&gt;&#x3D;0;i--)                   &#x2F;&#x2F;BuildHeap
        PercDown(A,i,N);
    for(i&#x3D;N-1;i&gt;0;i--)                      &#x2F;&#x2F;DeleteMax(取出最大元素并在0-i之间构建最大堆)
        Swap(&amp;A[0],&amp;A[i])
        PercDown(A,0,i);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<img src="https://s2.loli.net/2022/05/04/O2MaUf3CFqJEsSw.png" width="50%" height="50%">
<p>将较大的元素放到最后，然后将前面的元素重新建立最小堆<br>
注意，在常规的堆中第0个元素应该存放哨兵，但是对某个数组进行排序时数组可能并没有存放哨兵，此时</p>
<ul>
<li>对于下标为i的元素，其左、右孩子的下标分别为：2i+1, 2i+2</li>
</ul>
<p>定理：堆排序处理N个不同元素的随机排列的平均比较次数是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo>−</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2NlogN-O(Nlog(logN))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序</li>
</ul>
<span id="more"></span>
<h2 id="堆排序演示"><a class="markdownIt-Anchor" href="#堆排序演示"></a> 堆排序演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 浙江大学示例程序 *&#x2F;
typedef int ElementType;
void Swap( ElementType *a, ElementType *b )
&#123;
     ElementType t &#x3D; *a; *a &#x3D; *b; *b &#x3D; t;
&#125;
 
void PercDown( ElementType A[], int p, int N )
&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;
  &#x2F;* 将N个元素的数组中以A[p]为根的子堆调整为最大堆 *&#x2F;
    int Parent, Child;
    ElementType X;

    X &#x3D; A[p]; &#x2F;* 取出根结点存放的值 *&#x2F;
    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;
        Child &#x3D; Parent * 2 + 1;
        if( (Child!&#x3D;N-1) &amp;&amp; (A[Child]&lt;A[Child+1]) )
            Child++;  &#x2F;* Child指向左右子结点的较大者 *&#x2F;
        if( X &gt;&#x3D; A[Child] ) break; &#x2F;* 找到了合适位置 *&#x2F;
        else  &#x2F;* 下滤X *&#x2F;
            A[Parent] &#x3D; A[Child];
    &#125;
    A[Parent] &#x3D; X;
&#125;

void HeapSort( ElementType A[], int N ) 
&#123; &#x2F;* 堆排序 *&#x2F;
     int i;
      
     for ( i&#x3D;N&#x2F;2-1; i&gt;&#x3D;0; i-- )&#x2F;* 建立最大堆 *&#x2F;
         PercDown( A, i, N );
     
     for ( i&#x3D;N-1; i&gt;0; i-- ) &#123;
         &#x2F;* 删除最大堆顶 *&#x2F;
         Swap( &amp;A[0], &amp;A[i] ); &#x2F;* 见代码7.1 *&#x2F;
         PercDown( A, 0, i );
     &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h1>
<p>核心：有序子列的归并<br>
例：序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>38</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,13,24,26,2,15,27,38]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mclose">]</span></span></span></span></p>
<ul>
<li>分为有序子列1：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>24</mn><mo separator="true">,</mo><mn>26</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,13,24,26]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，有序子列2：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>27</mn><mo separator="true">,</mo><mn>38</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,15,27,38]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mclose">]</span></span></span></span>
<ul>
<li>分别在两个子列中进行归并
<ul>
<li>1和2比较，1是较小的元素，因此将1作为合并后序列的第一个元素</li>
<li>2和13比较，2较小，将2作为第二个元素</li>
<li>以此类推，分别将子列1和子列2中的元素依次比较，选择两个没加入合并序列元素中较小的一个加入合并序列</li>
</ul>
</li>
</ul>
</li>
<li>如果两个子列一共有N个元素，则归并的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>和选择排序一样，归并排序的性能不受输入数据的影响，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<img src="https://s2.loli.net/2022/05/04/qR8e3nTwM5UcOzH.png" width="50%" height="50%">
<h2 id="有序子列归并"><a class="markdownIt-Anchor" href="#有序子列归并"></a> 有序子列归并</h2>
<p>归并排序：有序子列归并的伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void Merge(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)
&#x2F;&#x2F;L&#x3D;左边起始位置，R&#x3D;右边起始位置，RightEnd&#x3D;右边终点位置
&#123;
    LeftEnd&#x3D;R-1;                            &#x2F;&#x2F;左边终点位置是右边子列起始位置前一个下标
    Tmp&#x3D;L;                                  &#x2F;&#x2F;存放结果数组的初始位置(左边子列的初始下标)
    NumElements&#x3D;RightEnd-L+1;
    while(L&lt;&#x3D;LeftEnd&amp;&amp;R&lt;&#x3D;RightEnd)&#123;         &#x2F;&#x2F;进行归并
        if(A[L]&lt;&#x3D;A[R])TmpA[TMp++]&#x3D;A[L++];
        else TmpA[Tmp++]&#x3D;A[R++];
    &#125;
    while(L&lt;&#x3D;LeftEnd)                       &#x2F;&#x2F;直接复制左边子列剩下的元素
        TmpA[Tmp++]&#x3D;A[L++];
    while(R&lt;&#x3D;RightEnd)                      &#x2F;&#x2F;直接复制右边子列剩下的元素
        TmpA[Tmp++]&#x3D;A[R++];
    for(i&#x3D;0;i&lt;NumElements;i++,RightEnd--)   &#x2F;&#x2F;将归并范围内的结果复制到A中
        A[RightEnd]&#x3D;TmpA[RightEnd];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="递归实现"><a class="markdownIt-Anchor" href="#递归实现"></a> 递归实现</h2>
<p>归并排序递归算法伪代码描述：分而治之</p>
<pre class="line-numbers language-none"><code class="language-none">void MSort(ElementType A[],ElementType TmpA[],int L,int R,int RightEnd)
&#123;
    int Center;
    if(L&lt;RightEnd)&#123;
        Center&#x3D;(L+RightEnd)&#x2F;2;
        MSort(A,TmpA,L,Center);
        MSort(A,TmpA,Center+1,RightEnd);
        Merge(A,TmpA,L,Center+1,RightEnd);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由递推式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=T(N/2)+T(N/2)+O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>——&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span><br>
稳定性：稳定<br>
递归算法额外空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<p>统一函数接口：</p>
<pre class="line-numbers language-none"><code class="language-none">void Merge_sort(ElementType A[],int N)
&#123;
    ElementType*TmpA;
    TmpA&#x3D;malloc(N*sizeof(ElementType));
    if(TmpA!&#x3D;NULL)&#123;
        MSort(A,TmpA,0,N-1);
        free(TmpA);
    &#125;
    else Error(&quot;空间不足&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果只在Merge中声明临时数组:<br>
void Merge(ElementType A[],int L,int R,int RightEnd);<br>
void MSort(ElementType A[],int L,int RightEnd);</p>
<ul>
<li>此时需要不断地在merge中malloc/free这个临时数组TmpA，虽然参数少了，但实际上增加了很多不必要的开销</li>
</ul>
<h2 id="非递归实现"><a class="markdownIt-Anchor" href="#非递归实现"></a> 非递归实现</h2>
<p>归并排序非递归算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void MSort(ElementType A[],ElementType TmpA[],int N,int length)
&#x2F;&#x2F;length&#x3D;当前有序子列的长度
&#123;
    for(i&#x3D;0;i&lt;&#x3D;N-2*length;i+&#x3D;2*length)
        Merge(A,TmpA,i,i+length,i+2*length-1);      &#x2F;&#x2F;将A中元素归并到TmpA
    if(i+length&lt;N)                                  &#x2F;&#x2F;归并最后两个子列(还剩两个子列但最后一个子列不满的情况)
        Merge(A,TmpA,i,i+length,N-1);
    else                                            &#x2F;&#x2F;最后只剩一个子列(只剩一个子列的情况)
        for(j&#x3D;i;j&lt;N;j++)TmpA[j]&#x3D;A[j];
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>统一函数接口：</p>
<pre class="line-numbers language-none"><code class="language-none">void Merge_sort(ElementType A[],int N)
&#123;
    ElementType*TmpA;
    TmpA&#x3D;malloc(N*sizeof(ElementType));
    if(TmpA!&#x3D;NULL)&#123;
        while(length&lt;N)&#123;                            &#x2F;&#x2F;每个while循环里做两次merge，保证跳出循环后最终结果一定存在A中
            MSort(A,TmpA,N,length);
            length*&#x3D;2;
            MSort(TmpA,A,N,length);
            length*&#x3D;2;                              &#x2F;&#x2F;一次循环后length实际变成4*length
        &#125;
        free(TmpA);
    &#125;
    else Error(&quot;空间不足&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>稳定性：稳定</li>
<li>额外空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>
<ul>
<li>此算法以length开始进行分组一对一对进行归并A并复制到TmpA中，再以同样过程归并TmpA并复制回A中，直到length等于N
<ul>
<li>即一个元素与相邻元素构成有序数组，再与旁边数组构成有序数组，直至整个数组有序</li>
</ul>
</li>
</ul>
</li>
<li>归并排序由于需要额外空间，并且要在临时数组中来来回回地反复导数据，因此在实际应用中较少用在内排序中</li>
<li>在外排序中，归并排序是一个比较有用的工具</li>
</ul>
<h2 id="归并排序演示"><a class="markdownIt-Anchor" href="#归并排序演示"></a> 归并排序演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 归并排序 - 递归实现 *&#x2F;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
typedef int ElementType;
&#x2F;* L &#x3D; 左边起始位置, R &#x3D; 右边起始位置, RightEnd &#x3D; 右边终点位置*&#x2F;
void Merge( ElementType A[], ElementType TmpA[], int L, int R, int RightEnd )
&#123; &#x2F;* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 *&#x2F;
     int LeftEnd, NumElements, Tmp;
     int i;
     
     LeftEnd &#x3D; R - 1; &#x2F;* 左边终点位置 *&#x2F;
     Tmp &#x3D; L;         &#x2F;* 有序序列的起始位置 *&#x2F;
     NumElements &#x3D; RightEnd - L + 1;
     
     while( L &lt;&#x3D; LeftEnd &amp;&amp; R &lt;&#x3D; RightEnd ) &#123;
         if ( A[L] &lt;&#x3D; A[R] )
             TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 将左边元素复制到TmpA *&#x2F;
         else
             TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 将右边元素复制到TmpA *&#x2F;
     &#125;

     while( L &lt;&#x3D; LeftEnd )
         TmpA[Tmp++] &#x3D; A[L++]; &#x2F;* 直接复制左边剩下的 *&#x2F;
     while( R &lt;&#x3D; RightEnd )
         TmpA[Tmp++] &#x3D; A[R++]; &#x2F;* 直接复制右边剩下的 *&#x2F;
         
     for( i &#x3D; 0; i &lt; NumElements; i++, RightEnd -- )
         A[RightEnd] &#x3D; TmpA[RightEnd]; &#x2F;* 将有序的TmpA[]复制回A[] *&#x2F;
&#125;

void Msort( ElementType A[], ElementType TmpA[], int L, int RightEnd )
&#123; &#x2F;* 核心递归排序函数 *&#x2F; 
     int Center;
     
     if ( L &lt; RightEnd ) &#123;
          Center &#x3D; (L+RightEnd) &#x2F; 2;
          Msort( A, TmpA, L, Center );              &#x2F;* 递归解决左边 *&#x2F; 
          Msort( A, TmpA, Center+1, RightEnd );     &#x2F;* 递归解决右边 *&#x2F;  
          Merge( A, TmpA, L, Center+1, RightEnd );  &#x2F;* 合并两段有序序列 *&#x2F; 
     &#125;
&#125;

void MergeSort( ElementType A[], int N )
&#123; &#x2F;* 归并排序 *&#x2F;
     ElementType *TmpA;
     TmpA &#x3D; (ElementType *)malloc(N*sizeof(ElementType));
     
     if ( TmpA !&#x3D; NULL ) &#123;
          Msort( A, TmpA, 0, N-1 );
          free( TmpA );
     &#125;
     else printf( &quot;空间不足&quot; );
&#125;

&#x2F;* 归并排序 - 循环实现 *&#x2F;
&#x2F;* 这里Merge函数在递归版本中给出 *&#x2F;

&#x2F;* length &#x3D; 当前有序子列的长度*&#x2F;
void Merge_pass( ElementType A[], ElementType TmpA[], int N, int length )
&#123; &#x2F;* 两两归并相邻有序子列 *&#x2F;
     int i, j;
      
     for ( i&#x3D;0; i &lt;&#x3D; N-2*length; i +&#x3D; 2*length )
         Merge( A, TmpA, i, i+length, i+2*length-1 );
     if ( i+length &lt; N ) &#x2F;* 归并最后2个子列*&#x2F;
         Merge( A, TmpA, i, i+length, N-1);
     else &#x2F;* 最后只剩1个子列*&#x2F;
         for ( j &#x3D; i; j &lt; N; j++ ) TmpA[j] &#x3D; A[j];
&#125;

void Merge_Sort( ElementType A[], int N )
&#123; 
     int length; 
     ElementType *TmpA;
     
     length &#x3D; 1; &#x2F;* 初始化子序列长度*&#x2F;
     TmpA &#x3D; (ElementType*)malloc( N * sizeof( ElementType ) );
     if ( TmpA !&#x3D; NULL ) &#123;
          while( length &lt; N ) &#123;
              Merge_pass( A, TmpA, N, length );
              length *&#x3D; 2;
              Merge_pass( TmpA, A, N, length );
              length *&#x3D; 2;
          &#125;
          free( TmpA );
     &#125;
     else printf( &quot;空间不足&quot; );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>希尔排序、快速排序</title>
    <url>/posts/b4e0d940ef9c</url>
    <content><![CDATA[<h1 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h1>
<p>希尔排序(by Donald Shell)：基于插入排序，利用插入排序的简单，同时每次交换相隔较远的元素，使得每次消去不止一个逆序对</p>
<ul>
<li>定义增量序列元素 D(M)&gt;D(M-1)&gt;…&gt;D(1)=1</li>
<li>对每个D(k)进行“D(k)-间隔”排序(k=M,M-1,…,1)
<ul>
<li>“D(k)-间隔”有序的序列，在执行“D(k-1)-间隔”排序后，仍然是“D(k)-间隔”有序的</li>
</ul>
</li>
</ul>
<p>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>81</mn><mo separator="true">,</mo><mn>94</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>96</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>35</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>95</mn><mo separator="true">,</mo><mn>28</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[81,94,11,96,12,35,17,95,28,58,41,75,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></p>
<p>5-间隔–分为5组</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>81</mn><mo separator="true">,</mo><mn>35</mn><mo separator="true">,</mo><mn>41</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[81,35,41]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>94</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>75</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[94,17,75]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>95</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,95,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>96</mn><mo separator="true">,</mo><mn>28</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[96,28]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>12</mn><mo separator="true">,</mo><mn>58</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[12,58]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>35</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>81</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[35,41,81]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>17</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>94</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[17,75,94]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>95</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,15,95]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>28</mn><mo separator="true">,</mo><mn>96</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[28,96]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>12</mn><mo separator="true">,</mo><mn>58</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[12,58]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>35</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>28</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>96</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>81</mn><mo separator="true">,</mo><mn>94</mn><mo separator="true">,</mo><mn>95</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[35,17,11,28,12,41,75,15,96,58,81,94,95]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>3-间隔–分为3组</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>35</mn><mo separator="true">,</mo><mn>28</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>95</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[35,28,75,58,95]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>17</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>81</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[17,12,15,81]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>96</mn><mo separator="true">,</mo><mn>94</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,41,96,94]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>28</mn><mo separator="true">,</mo><mn>35</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>95</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[28,35,58,75,95]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>81</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[12,15,17,81]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>94</mn><mo separator="true">,</mo><mn>96</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,41,94,96]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>28</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>35</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>94</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>81</mn><mo separator="true">,</mo><mn>96</mn><mo separator="true">,</mo><mn>95</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[28,12,11,35,15,41,58,17,94,75,81,96,95]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>1-间隔–<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>17</mn><mo separator="true">,</mo><mn>28</mn><mo separator="true">,</mo><mn>35</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>58</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>81</mn><mo separator="true">,</mo><mn>94</mn><mo separator="true">,</mo><mn>95</mn><mo separator="true">,</mo><mn>96</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,12,15,17,28,35,41,58,75,81,94,95,96]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<span id="more"></span>
<img src="https://s2.loli.net/2022/05/04/6TiDuLUCW2mrsbd.png" width="50%" height="50%">
<h2 id="希尔增量序列"><a class="markdownIt-Anchor" href="#希尔增量序列"></a> 希尔增量序列</h2>
<p>原始希尔排序(按待排序序列的长度)</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">⌊</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">⌊</mo><mi>D</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">D(M)=⌊N/2⌋,D(k)=⌊D(k+1)/2⌋</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">⌋</span></span></span></span></li>
</ul>
<p>希尔排序(原始增量序列)伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void Shell_sort(ElementType A[],int N)
&#123;
    for(D&#x3D;N&#x2F;2;D&gt;0;D&#x2F;&#x3D;2)&#123;        &#x2F;&#x2F;希尔增量序列
        for(P&#x3D;D;P&lt;N;P++)&#123;       &#x2F;&#x2F;插入排序，每一个增量内连续的元素可看作是一组，每组序号相同的元素相互比较
            Tmp&#x3D;A[P];
            for(i&#x3D;P;i&gt;&#x3D;D&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)&#x2F;&#x2F;注意i至少要大于增量才能比较，因此实际上是从后往前比较的
                A[i]&#x3D;A[i-D];
            A[i]&#x3D;Tmp;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>稳定性：不稳定(相等的元素可能由于其各自所处的位置不同而与之前或之后的元素交换，使其相对位置发生改变)</li>
<li>最坏情况：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=Θ(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>较坏情况例子：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<p>8-间隔–<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>9</mn><mo separator="true">,</mo><mn>13</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[9,13]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>14</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[10,14]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,7]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>11</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[11,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>12</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[12,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>4-间隔–<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,3,5,7]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>9</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>15</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[9,11,13,15]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,4,6,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>10</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[10,12,14,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>2-间隔–<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,3,4,5,6,7,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[9,10,11,12,13,14,15,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,9,2,10,3,11,4,12,5,13,6,14,7,15,8,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>1-间隔–<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn><mo separator="true">,</mo><mn>11</mn><mo separator="true">,</mo><mn>12</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>14</mn><mo separator="true">,</mo><mn>15</mn><mo separator="true">,</mo><mn>16</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mclose">]</span></span></span></span></p>
<p>原因：增量元素D(k)之间不互质，则小增量可能不起作用</p>
<img src="https://s2.loli.net/2022/05/04/tBJLl3siQvIAdpz.png" width="50%" height="50%">
<h2 id="其他增量序列"><a class="markdownIt-Anchor" href="#其他增量序列"></a> 其他增量序列</h2>
<ul>
<li>Hibbard增量序列
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">D(k)=2^{k-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> ——保证了相邻元素互质</li>
<li>最坏情况：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>3</mn><mn>2</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=Θ(N^{\frac{3}{2}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>猜想：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>5</mn><mn>4</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(avg)=O(N^{\frac{5}{4}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">5</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>    (目前还未能得到证明)</li>
</ul>
</li>
</ul>
</li>
<li>Sedgewick增量序列
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>19</mn><mo separator="true">,</mo><mn>41</mn><mo separator="true">,</mo><mn>109</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,5,19,41,109,...]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mclose">]</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mo>×</mo><msup><mn>4</mn><mi>i</mi></msup><mo>−</mo><mn>9</mn><mo>×</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">9\times 4^i-9\times 2^i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mi>i</mi></msup><mo>−</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mi>i</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">4^i-3\times 2^i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.907994em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>=</mo><mn>9</mn><mo>×</mo><mn>1</mn><mo>−</mo><mn>9</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo>=</mo><mn>16</mn><mo>−</mo><mn>3</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>19</mn><mo>=</mo><mn>9</mn><mo>×</mo><mn>4</mn><mo>−</mo><mn>9</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>41</mn><mo>=</mo><mn>64</mn><mo>−</mo><mn>3</mn><mo>×</mo><mn>8</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mn>109</mn><mo>=</mo><mn>9</mn><mo>×</mo><mn>16</mn><mo>−</mo><mn>9</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">1=9\times 1-9\times 1+1,5=16-3\times 4+1,19=9\times 4-9\times 2+1,41=64-3\times 8+1,109=9\times 16-9\times 4+1,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li>
</ul>
</li>
<li>猜想：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>7</mn><mn>6</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(avg)=O(N^{\frac{7}{6}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，最坏情况<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mfrac><mn>4</mn><mn>3</mn></mfrac></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(N^{\frac{4}{3}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20402em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9540200000000001em;"><span style="top:-3.363em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>       (目前未能得到证明)</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/6HGPyaSKozC9EeA.png" width="50%" height="50%">
<p>例：希尔排序-用Sedgewick增量序列</p>
<pre class="line-numbers language-none"><code class="language-none">void ShellSort(ElementType A[],int N)
&#123;
    int Si,D,P,i;
    ElementType Tmp;                               &#x2F;&#x2F;这里只列出一小部分增量 
    int Sedgewick[]&#x3D;&#123;929,505,209,109,41,19,5,1,0&#125;;
    for(Si&#x3D;0;Sedgewick[Si]&gt;&#x3D;N;Si++);               &#x2F;&#x2F;初始的增量Sedgewick[Si]不能超过待排序列长度 
    for(D&#x3D;Sedgewick[Si];D&gt;0;D&#x3D;Sedgewick[++Si])
        for(P&#x3D;D;P&lt;N;P++)&#123;                          &#x2F;&#x2F;插入排序
            Tmp&#x3D;A[P];
            for(i&#x3D;P;i&gt;&#x3D;D&amp;&amp;A[i-D]&gt;Tmp;i-&#x3D;D)
                A[i]&#x3D;A[i-D];
            A[i]&#x3D;Tmp;
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h1>
<img src="https://s2.loli.net/2022/05/04/3AgIXxlVFbdTtih.png" width="50%" height="50%">
<p>快速排序：实际应用中在大规模的随机数据下<strong>通常表现最好</strong>的排序算法<br>
算法概述：分而治之策略的典型应用<br>
例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>13</mn><mo separator="true">,</mo><mn>81</mn><mo separator="true">,</mo><mn>92</mn><mo separator="true">,</mo><mn>43</mn><mo separator="true">,</mo><mn>65</mn><mo separator="true">,</mo><mn>31</mn><mo separator="true">,</mo><mn>57</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[13,81,92,43,65,31,57,26,75,0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span></span></span></span></p>
<ul>
<li>找到主元(枢纽、枢轴)65</li>
<li>将各元素依次与65进行比较，大的分为一组，小的分为一组——&gt;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>13</mn><mo separator="true">,</mo><mn>43</mn><mo separator="true">,</mo><mn>31</mn><mo separator="true">,</mo><mn>57</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mo stretchy="false">[</mo><mn>81</mn><mo separator="true">,</mo><mn>92</mn><mo separator="true">,</mo><mn>75</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[13,43,31,57,26,0],[81,92,75]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mclose">]</span></span></span></span></li>
<li>在两组中重复这一过程，最后排序为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>13</mn><mo separator="true">,</mo><mn>26</mn><mo separator="true">,</mo><mn>31</mn><mo separator="true">,</mo><mn>43</mn><mo separator="true">,</mo><mn>57</mn><mo separator="true">,</mo><mn>65</mn><mo separator="true">,</mo><mn>75</mn><mo separator="true">,</mo><mn>81</mn><mo separator="true">,</mo><mn>92</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,13,26,31,43,57,65,75,81,92]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mord">2</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>快速排序基本思路：</p>
<pre class="line-numbers language-none"><code class="language-none">void QuickSort(ElementType A[],int N)&#123;
    pivot&#x3D;从A[]中选一个主元;
    将S&#x3D;&#123;A[]\pivot&#125;分成两个独立子集:
        A1&#x3D;&#123;a∈S | a&lt;&#x3D;pivot&#125;和
        A2&#x3D;&#123;a∈S | a&lt;&#x3D;pivot&#125;;
    A[]&#x3D;Quicksort(A1,N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2,N2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>快速排序的最好情况：与主元的选取方法有关<br>
如果选取的主元每次都处于序列的中间，并且正好将序列中分：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>此时不需要交换，每次将序列等分，属于分治算法的标准复杂度)</li>
</ul>
<h2 id="选取主元"><a class="markdownIt-Anchor" href="#选取主元"></a> 选取主元</h2>
<img src="https://s2.loli.net/2022/05/04/MoXFire8hZ3KTzs.png" width="50%" height="50%">
<p>假设令pivot=A[0]</p>
<ul>
<li>若序列完全有序，则序列每次被划分为0和n-1个元素的两个连续子列，实际相当于没有划分
<ul>
<li>相当于退化为没有提前判断结束的冒泡排序</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(N)+T(N-1)=O(N)+O(N-1)+T(N-2)=O(N)+O(N-1)+...+O(1)=O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/NP8HEMmakj49KCT.png" width="50%" height="50%">
<ul>
<li>随机选取主元
<ul>
<li>rand()函数也是有开销的，不可取</li>
</ul>
</li>
<li>取头、中、尾的中位数
<ul>
<li>例：使用中位数取pivot</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">ElementType Median(ElementType A[],int Left,int Right)&#123;
    int Center&#x3D;(Left+Right)&#x2F;2;
    if(A[Left]&gt;A[Center])Swap(&amp;A[Left],&amp;A[Center]);
    if(A[Left]&gt;A[Right])Swap(&amp;A[Left],&amp;A[Right]);
    if(A[Center]&gt;A[Right])Swap(&amp;A[Center],&amp;A[Right]);     &#x2F;&#x2F;保证A[Left]&lt;&#x3D;A[Center]&lt;&#x3D;A[Right]
    Swap(&amp;A[Center],&amp;A[Right-1]);         &#x2F;&#x2F;将pivot藏到右边，只需考虑A[Left+1]...A[Right-2]即可
    return A[Right-1];                                    &#x2F;&#x2F;返回pivot
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="子集划分"><a class="markdownIt-Anchor" href="#子集划分"></a> 子集划分</h2>
<p>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>8</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[8,1,4,9,0,3,5,2,7,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>以6为主元进行一趟快速排序</p>
<img src="https://s2.loli.net/2022/05/04/N1U8kyCxqDMIi29.png" width="75%" height="75%">
<p>快速排序快的核心原因：</p>
<ul>
<li>每一轮快速排序中以主元为界做完子集划分之后，最后枢轴都会被换到正确的位置上且之后不会再移动
<ul>
<li>因为每一轮快速排序都是以上一个主元为界对两边的子序列做递归，</li>
<li>主元左右序列的元素在上一轮快速排序中已经按照与枢轴的大小关系排好序</li>
</ul>
</li>
<li>如果有元素正好等于pivot
<ul>
<li>停下来交换而不是继续向下遍历
<ul>
<li>假设一种极端情况，序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,1,1,1,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>
<ul>
<li>此时主元必然为1，则左右两侧开始扫描后最终都会遍历到最后，甚至可能发生越界</li>
<li>即使对越界进行处理，最终子列分别为0和n-1个元素，出现快速排序的最坏情况(序列基本有序)</li>
<li>反之，如果停下来交换的话，就会每轮确定一个元素位置，达到快速排序的最好情况(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="小规模数据的处理"><a class="markdownIt-Anchor" href="#小规模数据的处理"></a> 小规模数据的处理</h2>
<ul>
<li>快速排序的问题
<ul>
<li>算法往往需要使用递归
<ul>
<li>对小规模数据(例如N不到100)可能还不如插入排序快</li>
</ul>
</li>
</ul>
</li>
<li>解决方案
<ul>
<li>当递归的数据规模充分小，则停止递归，直接调用简单排序(如插入排序)
<ul>
<li>在程序中定义一个Cutoff的阈值</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/S4EkBOlc68bWXFu.png" width="50%" height="50%">
<p>快速排序最终算法实现伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void Ouick_Sort(ElementType A[],int Left,int Right)&#123;
    if(Cutoff&lt;&#x3D;Right-Left)&#123;
        Pivot&#x3D;Median(A,Left,Right);
        i&#x3D;Left,j&#x3D;Right-1;
        while(true)&#123;
            while(A[++i]&lt;Pivot);  
            &#x2F;&#x2F;注意先自增很重要，因为i和j初值分别是Left和Right-1，通过Median()已经确定了和主元的关系，因此直接跳过即可
            &#x2F;&#x2F;这样的话i和j终止时都是刚好停在使循环结束的那个元素上面
            &#x2F;&#x2F;A[i]和pivot不取等，即遇到与pivot相等的元素也停下来做交换
            while(A[--j]&gt;Pivot);
            if(i&lt;j)Swap(&amp;A[i],&amp;A[j]);   &#x2F;&#x2F;比主元小的放在左边，大的放在右边
            else break;                 &#x2F;&#x2F;此时i&#x3D;&#x3D;j，整个子列已经扫描完，i的位置就是主元所在的位置
        &#125;
        Swap(&amp;A[i],&amp;A[Right-1]);        &#x2F;&#x2F;把主元交换到第i的位置
        Quicksort(A,Left,i-1);
        Quicksort(A,i+1,Right);
    &#125;else Insertion_Sort(A+Left,Right-Left+1);
&#125;
void Quick_Sort(ElementType A[],int N)&#123;
    Quicksort(A,0,N-1);
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h2>
<ul>
<li>平均：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>最坏：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>额外空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>
<ul>
<li>需要递归调用，最好情况是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，最坏是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>稳定性：不稳定</li>
</ul>
<h2 id="快速排序演示"><a class="markdownIt-Anchor" href="#快速排序演示"></a> 快速排序演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 快速排序 - 直接调用库函数 *&#x2F;

#include &lt;cstdlib&gt;
#define MAXN 100
using namespace std;
typedef int ElementType;

void qsort (void *base, size_t nitems, size_t size, int (*compar) (const void *, const void*)) ;
&#x2F;*---------------简单整数排序--------------------*&#x2F;
int N,A[MAXN];

int compare(const void *a, const void *b)
&#123; &#x2F;* 比较两整数。非降序排列 *&#x2F;
    return (*(int*)a - *(int*)b);
&#125;
&#x2F;*---------------------------------------------*&#x2F;


&#x2F;*--------------- 一般情况下，对结构体Node中的某键值key排序 ---------------*&#x2F;
struct Node &#123;
    int key1, key2;
&#125; S[MAXN];
 
int compare2keys(const void *a, const void *b)
&#123; &#x2F;* 比较两种键值：按key1非升序排列；如果key1相等，则按key2非降序排列 *&#x2F;
    int k;
    if ( ((const struct Node*)a)-&gt;key1 &lt; ((const struct Node*)b)-&gt;key1 )
        k &#x3D; 1;
    else if ( ((const struct Node*)a)-&gt;key1 &gt; ((const struct Node*)b)-&gt;key1 )
        k &#x3D; -1;
    else &#123; &#x2F;* 如果key1相等 *&#x2F;
        if ( ((const struct Node*)a)-&gt;key2 &lt; ((const struct Node*)b)-&gt;key2 )
            k &#x3D; -1;
        else
            k &#x3D; 1;
    &#125;
    return k;
&#125;
&#x2F;*-------------------------------------------------------------------*&#x2F;

&#x2F;* 调用接口 *&#x2F; 
int main()&#123;
    qsort(A,N,sizeof(int),compare);
    qsort(S, N, sizeof(struct Node), compare2keys);
&#125;
&#x2F;*--------*&#x2F;

&#x2F;* 快速排序 *&#x2F;
void InsertionSort( ElementType A[], int N );
void Swap(ElementType*,ElementType*);

ElementType Median3( ElementType A[], int Left, int Right )
&#123; 
    int Center &#x3D; (Left+Right) &#x2F; 2;
    if ( A[Left] &gt; A[Center] )
        Swap( &amp;A[Left], &amp;A[Center] );
    if ( A[Left] &gt; A[Right] )
        Swap( &amp;A[Left], &amp;A[Right] );
    if ( A[Center] &gt; A[Right] )
        Swap( &amp;A[Center], &amp;A[Right] );
    &#x2F;* 此时A[Left] &lt;&#x3D; A[Center] &lt;&#x3D; A[Right] *&#x2F;
    Swap( &amp;A[Center], &amp;A[Right-1] ); &#x2F;* 将基准Pivot藏到右边*&#x2F;
    &#x2F;* 只需要考虑A[Left+1] … A[Right-2] *&#x2F;
    return  A[Right-1];  &#x2F;* 返回基准Pivot *&#x2F;
&#125;

void Qsort( ElementType A[], int Left, int Right )&#x2F;&#x2F;有问题，这个函数应该是没写递归出口
&#123; &#x2F;* 核心递归函数 *&#x2F; 
     int Pivot, Cutoff, Low, High;
    
     if ( Cutoff &lt;&#x3D; Right-Left ) &#123; &#x2F;* 如果序列元素充分多，进入快排 *&#x2F;
          Pivot &#x3D; Median3( A, Left, Right ); &#x2F;* 选基准 *&#x2F; 
          Low &#x3D; Left; High &#x3D; Right-1;
          while (1) &#123; &#x2F;*将序列中比基准小的移到基准左边，大的移到右边*&#x2F;
               while ( A[++Low] &lt; Pivot ) ;
               while ( A[--High] &gt; Pivot ) ;
               if ( Low &lt; High ) Swap( &amp;A[Low], &amp;A[High] );
               else break;
          &#125;
          Swap( &amp;A[Low], &amp;A[Right-1] );   &#x2F;* 将基准换到正确的位置 *&#x2F; 
          Qsort( A, Left, Low-1 );    &#x2F;* 递归解决左边 *&#x2F; 
          Qsort( A, Low+1, Right );   &#x2F;* 递归解决右边 *&#x2F;  
     &#125;
     else InsertionSort( A+Left, Right-Left+1 ); &#x2F;* 元素太少，用简单排序 *&#x2F; 
&#125;

void QuickSort( ElementType A[], int N )
&#123; &#x2F;* 统一接口 *&#x2F;
     Qsort( A, 0, N-1 );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序</title>
    <url>/posts/c38bdd921611</url>
    <content><![CDATA[<h1 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h1>
<ul>
<li>前提：void X_Sort(ElementType A[],int N)
<ul>
<li>本文及后续章节<a href="/2022/05/05/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" title="希尔排序、快速排序">希尔排序、快速排序</a>、<a href="/2022/05/06/%E5%A0%86%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" title="堆排序、归并排序">堆排序、归并排序</a>、<a href="/2022/05/06/%E8%A1%A8%E6%8E%92%E5%BA%8F%E3%80%81%E6%A1%B6%E6%8E%92%E5%BA%8F%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/" title="表排序、桶排序、基数排序">表排序、桶排序、基数排序</a>中在介绍排序算法时，函数头都有统一的范式为X_Sort</li>
</ul>
</li>
<li>大多数情况下，为简单期间，讨论排序的情况默认是从小到大的整数排序(任何一种数据结构，只要可以比较都可以采用排序算法)</li>
<li>N是正整数</li>
<li>只讨论基于比较的排序(&gt;,=,&lt;的情况均有定义)</li>
<li>只讨论内部排序(内存空间足够大，所有数据都可以一次性导入内存中，排序在内存中一次性完成)</li>
<li>稳定性：任意两个相等的数据，排序前后的相对位置不发生改变</li>
<li>没有一种排序是在任何情况下都表现最好的</li>
</ul>
<span id="more"></span>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<p>冒泡排序伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void Bubble_Sort(ElementType A[],int N)
&#123;
    for(P&#x3D;N-1;P&gt;&#x3D;0;P--)&#123;
        flag&#x3D;0;
        for(i&#x3D;0;i&lt;P;i++)&#123;               &#x2F;&#x2F;一趟冒泡
            if(A[i]&gt;A[i+1])&#123;  
                Swap(A[i],A[i+1]);
                flag&#x3D;1;                 &#x2F;&#x2F;标识发生了交换
            &#125;
        &#125;
        if(flag&#x3D;&#x3D;0)break;               &#x2F;&#x2F;冒泡全程无交换，表示排序已结束
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>冒泡排序：</p>
<ul>
<li>好比比较相邻的两个泡泡，因为大的泡泡总是飞在小泡泡的上面，所以排序时就按照这种方法将相邻的两数据之间进行交换排序</li>
<li>每一趟冒泡确定序列中最大/最小的元素位置</li>
<li>稳定性：稳定</li>
<li>最好情况：顺序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span> (将数据扫描一遍即可)</li>
<li>最坏情况：逆序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
此外，冒泡排序有一个好处是这种算法的比较和交换都是单向且相邻的，因此对于单向链表的存储结构而言这种方法比较合适</li>
</ul>
<h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2>
<p>插入排序伪代码描述</p>
<pre class="line-numbers language-none"><code class="language-none">void Insertion_Sort(lementType A[],int N)
&#123;
    for(P&#x3D;1;P&lt;N;P++)&#123;
        Tmp&#x3D;A[P];                       &#x2F;&#x2F;摸下一张牌(取出未排序序列中的第一个元素)
        for(i&#x3D;P;i&gt;0&amp;&amp;A[i-1]&gt;Tmp;i--)
            A[i]&#x3D;A[i-1];                &#x2F;&#x2F;移出空位(依次与已排序序列中元素比较并右移)
        A[i]&#x3D;Tmp;                       &#x2F;&#x2F;新增牌位(放进合适的位置)
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>插入排序：</p>
<ul>
<li>可以类比打牌的时候一张张摸牌的同时进行排序，将新摸到的牌放到合适的位置</li>
<li>稳定性：稳定</li>
<li>最好情况：顺序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
<li>最坏情况：逆序<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>插入排序相对于冒泡排序(交换)的优点在于每次比较后不需要直接移动元素到空位，而是继续往前找直到找到位置后再一次性插入</li>
</ul>
<p>例：给定初始序列{34,8,64,51,32,21}，冒泡排序和插入排序分别需要多少次元素交换才能完成？</p>
<ul>
<li>冒泡排序需9次交换
<ul>
<li>第一趟冒泡：34,8,64,51,32,21——&gt;8,34,51,32,21,64
<ul>
<li>4次交换</li>
</ul>
</li>
<li>第二趟冒泡：8,34,51,32,21,64——&gt;8,34,32,21,51,64
<ul>
<li>2次交换</li>
</ul>
</li>
<li>第三趟冒泡：8,34,32,21,51,64——&gt;8,32,21,34,51,64
<ul>
<li>2次交换</li>
</ul>
</li>
<li>第四趟冒泡：8,32,21,34,51,64——&gt;8,21,32,34,51,64
<ul>
<li>1次交换</li>
</ul>
</li>
</ul>
</li>
<li>插入排序需9次交换
<ul>
<li>第一张牌：34,8——&gt;8,34
<ul>
<li>1次交换</li>
</ul>
</li>
<li>第二张牌：8,34,64——&gt;8,34,64
<ul>
<li>无交换</li>
</ul>
</li>
<li>第三张牌：8,34,64,51——&gt;8,34,51,64
<ul>
<li>1次交换</li>
</ul>
</li>
<li>第四张牌：8,34,64,51,32——&gt;8,32,34,51,64
<ul>
<li>3次交换</li>
</ul>
</li>
<li>第五张牌：8,34,64,51,32,21——&gt;8,21,32,34,51,64
<ul>
<li>4次交换</li>
</ul>
</li>
</ul>
</li>
<li>交换次数的实质：逆序对个数</li>
</ul>
<h2 id="冒泡排序和插入排序的时间复杂度分析"><a class="markdownIt-Anchor" href="#冒泡排序和插入排序的时间复杂度分析"></a> 冒泡排序和插入排序的时间复杂度分析</h2>
<ul>
<li>对于下标i&lt;j，如果A[i]&gt;A[j]，则称(i,j)是一对逆序对(inversion)</li>
<li>问题：序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>34</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>64</mn><mo separator="true">,</mo><mn>51</mn><mo separator="true">,</mo><mn>32</mn><mo separator="true">,</mo><mn>21</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[34,8,64,51,32,21]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>中有多少逆序对？
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>34</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>34</mn><mo separator="true">,</mo><mn>32</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>34</mn><mo separator="true">,</mo><mn>21</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>64</mn><mo separator="true">,</mo><mn>51</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>64</mn><mo separator="true">,</mo><mn>32</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>64</mn><mo separator="true">,</mo><mn>21</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>51</mn><mo separator="true">,</mo><mn>32</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>51</mn><mo separator="true">,</mo><mn>21</mn><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mn>32</mn><mo separator="true">,</mo><mn>21</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(34,8),(34,32),(34,21),(64,51),(64,32),(64,21),(51,32),(51,21),(32,21)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">6</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>交换相邻的两个元素：最多只能消去一个逆序对</li>
<li>插入排序：插入排序的时间复杂度不仅跟序列的元素个数有关，还跟逆序对有关
<ul>
<li>设逆序对个数为I，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>I</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>I</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N,I)=O(N+I)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mclose">)</span></span></span></span></li>
<li>如果序列基本有序，则插入排序简单且高效(如果I和N是同一数量级，则插入排序的复杂度是线性的)</li>
</ul>
</li>
<li>定理：任意N个不同元素组成的序列平均具有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn></mrow><mn>4</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N-1}{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个逆序对(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N-1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个对子)</li>
<li>定理：任何仅以交换相邻两元素来排序的算法，其最坏情况平均时间复杂度下界为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ω(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>
<ul>
<li>这意味着：要提高算法效率，必须
<ul>
<li>每次消去不止一个逆序对</li>
<li>每次交换相隔较远的2个元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
<p>选择排序：依次找到序列中剩余的最小元<br>
选择排序伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void Selection_Sort(ElementType A[],int N)
&#123;
    for(i&#x3D;0;i&lt;N;i++)&#123;
        MinPosition&#x3D;ScanForMin(A,i,N-1);    &#x2F;&#x2F;从A[i]到A[N-1]中找最小元，并将其位置赋给MinPosition
        Swap(A[i],A[MinPosition]);          &#x2F;&#x2F;将未排序部分的最小元换到有序部分的最后位置
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无论如何：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=Θ(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
算法优化的关键：对于交换元素来说稳定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，关键在于怎样找到最小元</p>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>AOV、AOE网络与拓扑排序</title>
    <url>/posts/6f97992c1725</url>
    <content><![CDATA[<img src="https://s2.loli.net/2022/05/04/qUHtbcnLdO4zxV7.png" width="50%" height="50%">
<span id="more"></span>
<h1 id="aovactivity-on-vertex网络"><a class="markdownIt-Anchor" href="#aovactivity-on-vertex网络"></a> AOV(Activity On Vertex)网络</h1>
<ul>
<li>顶点表示活动，边表示活动之间的优先关系</li>
</ul>
<h1 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h1>
<p>拓扑序：如果图中从v到w有一条有向路径，则v一定排在W之前，满足此条件的顶点序列成为一个拓扑序</p>
<ul>
<li>获得一个拓扑序的过程就是拓扑排序</li>
<li>AOV如果有合理的拓扑序，则必定是有向无环图(Directed Acyclic Graph, DAG)
<ul>
<li>v必须在w开始之前结束</li>
</ul>
</li>
</ul>
<p>拓扑排序算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void TopSort()
&#123;
    for(cnt&#x3D;0;cnt&lt;nv;cnt++)
    &#123;
        v&#x3D;为输出的入度为0的顶点; &#x2F;&#x2F;O(v)
        if(这样的v不存在)  &#x2F;&#x2F;如果外循环还没结束就已经找不到入度为0的顶点，则说明剩下的顶点中没有入度为0的顶点，存在回路
        &#123;
            ERROR(&quot;图中有回路&quot;);
            break;
        &#125;
        输出v，或者记录v的输出序号; 
        for(v的每个邻接点w)
            Indegree[w]--;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>
再此基础上可以进行改进，随时将入度为0的顶点放到一个容器里<br>
改进后算法的伪代码描述(BFS方法)：</p>
<pre class="line-numbers language-none"><code class="language-none">void TopSort()
&#123;
    for(图中每个顶点v)
        if(Indegree[v]&#x3D;&#x3D;0)
            Enqueue(v,Q);
    while(!Empty(Q))
    &#123;
        v&#x3D;Dequeue(Q);
        输出v，或者记录v的输出序号;cnt++:
        for(v的每个邻接点w)
            if(--Indegree[w]&#x3D;&#x3D;0)
                Enqueue(w,Q);
    &#125;
    if(cnt!&#x3D;v)
        ERROR(&quot;图中有回路&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改进后的算法可以用来检测有向图是否DAG<br>
时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></p>
<h2 id="拓扑排序演示"><a class="markdownIt-Anchor" href="#拓扑排序演示"></a> 拓扑排序演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 浙江大学mooc数据结构课程
#define MaxVertexNum 100
typedef int Vertex;
typedef int WeightType;
typedef int ElementType;
typedef char DataType;
typedef struct LGNode *PtrToLGNode;
typedef struct AdjVNode *PtrToAdjVNode; 
typedef struct QNode *Queue;
typedef PtrToLGNode LGraph;
struct AdjVNode&#123;
    Vertex AdjV;      
    WeightType Weight;  
    PtrToAdjVNode Next;   
&#125;;
typedef struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
    DataType Data;           
&#125; AdjList[MaxVertexNum];
struct LGNode&#123;  
    int Nv;  
    int Ne;    
    AdjList G;  
&#125;;
struct QNode
&#123;
    struct Node *rear;
    struct Node *front;
&#125;;
Queue CreateQueue( int );
void AddQ(Queue, ElementType);
bool IsEmpty(Queue);
ElementType DeleteQ(Queue);
&#x2F;* 邻接表存储 - 拓扑排序算法 *&#x2F;

bool TopSort( LGraph Graph, Vertex TopOrder[] )
&#123; &#x2F;* 对Graph进行拓扑排序,  TopOrder[]顺序存储排序后的顶点下标 *&#x2F;
    int Indegree[MaxVertexNum], cnt;
    Vertex V;
    PtrToAdjVNode W;
    Queue Q &#x3D; CreateQueue( Graph-&gt;Nv );
 
    &#x2F;* 初始化Indegree[] *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        Indegree[V] &#x3D; 0;
        
    &#x2F;* 遍历图，得到Indegree[] *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        for (W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next)
            Indegree[W-&gt;AdjV]++; &#x2F;* 对有向边&lt;V, W-&gt;AdjV&gt;累计终点的入度 *&#x2F;
            
    &#x2F;* 将所有入度为0的顶点入列 *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        if ( Indegree[V]&#x3D;&#x3D;0 )
            AddQ(Q, V);
            
    &#x2F;* 下面进入拓扑排序 *&#x2F; 
    cnt &#x3D; 0; 
    while( !IsEmpty(Q) )&#123;
        V &#x3D; DeleteQ(Q); &#x2F;* 弹出一个入度为0的顶点 *&#x2F;
        TopOrder[cnt++] &#x3D; V; &#x2F;* 将之存为结果序列的下一个元素 *&#x2F;
        &#x2F;* 对V的每个邻接点W-&gt;AdjV *&#x2F;
        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )
            if ( --Indegree[W-&gt;AdjV] &#x3D;&#x3D; 0 )&#x2F;* 若删除V使得W-&gt;AdjV入度为0 *&#x2F;
                AddQ(Q, W-&gt;AdjV); &#x2F;* 则该顶点入列 *&#x2F; 
    &#125; &#x2F;* while结束*&#x2F;
    
    if ( cnt !&#x3D; Graph-&gt;Nv )
        return false; &#x2F;* 说明图中有回路, 返回不成功标志 *&#x2F; 
    else
        return true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="关键路径问题"><a class="markdownIt-Anchor" href="#关键路径问题"></a> 关键路径问题</h1>
<img src="https://s2.loli.net/2022/05/04/s8rKBCf3TlNHEa1.png" width="50%" height="50%">
<h2 id="aoeactivity-on-edge网络"><a class="markdownIt-Anchor" href="#aoeactivity-on-edge网络"></a> AOE(Activity On Edge)网络</h2>
<img src="https://s2.loli.net/2022/05/04/uazYVqS6NTGCibe.png" width="50%" height="50%">
<ul>
<li>一般用于安排项目的工序</li>
<li>边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">a_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(活动)指向顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(事件)表示活动到此结束
<ul>
<li>顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(事件)中通常包含三种信息
<ul>
<li>事件编号<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></li>
<li>最早完成时间(Earliest)
<ul>
<li>对于AOE网中的任意一个事件来说，从源点到该点的最长路径代表着该事件的最早发生时间</li>
</ul>
</li>
<li>最晚完成时间(Latest)
<ul>
<li>表示在不推迟整个工期的前提下，事件允许的最晚发生时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>有向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">i_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>(活动)通常包括两种信息
<ul>
<li>活动持续时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">C&lt;i,j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></li>
<li>活动机动时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mi mathvariant="normal">：</mi><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">D&lt;i,j&gt;：Latest(j)-Earliest(j)-C&lt;i,j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>
<ul>
<li>事件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最晚开始时间-事件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>的最早开始时间-活动<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">i_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>持续时间，取其中最早的那一个</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="关键路径"><a class="markdownIt-Anchor" href="#关键路径"></a> 关键路径</h2>
<p>由绝对不允许延误(机动时间为0)的活动(共n个)组成的路径</p>
<ul>
<li>整个项目(活动n)的工期：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">Earliest[n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span></li>
<li>设最开始的活动0工期为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">Earliest[0]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>
<ul>
<li>事件j的工期：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo>∈</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Earliest[j]=max\{Earliest[i]+C&lt;i,j&gt;\},(&lt;i,j&gt;∈E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>机动时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo>=</mo><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">D&lt;i,j&gt;=Latest[j]-Earliest[i]-C&lt;i,j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>
<ul>
<li>事件<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>i</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">i_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的机动时间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Latest[i]=min(Latest[j]-C&lt;i,j&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<p>关键路径求解步骤</p>
<ul>
<li>首先求出正向拓扑排序求出顶点的最早开始时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">ve</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">{</mo><mi>E</mi><mi>a</mi><mi>r</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Earliest[j]=Max\{Earliest[i]+C&lt;i,j&gt;\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span></li>
</ul>
</li>
<li>然后逆向拓扑排序求出顶点的最迟开始时间：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">vl</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>L</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Latest[i]=min(Latest[j]-C&lt;i,j&gt;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">L</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>利用ve，vl求出边的最早开始时间ee，最迟开始时间el
<ul>
<li>ee=el表示此边为关键路径中的边</li>
<li>ee,el计算公式：假设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>k</mi><mo>=</mo><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">ak=&lt;i,j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>e</mi><mo>=</mo><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ee=ve(i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>l</mi><mo>=</mo><mi>v</mi><mi>l</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo><mo>−</mo><mi>C</mi><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">el=vl(j)-C&lt;i,j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树问题</title>
    <url>/posts/ab6b4967c58c</url>
    <content><![CDATA[<h1 id="最小生成树问题"><a class="markdownIt-Anchor" href="#最小生成树问题"></a> 最小生成树问题</h1>
<p>什么是最小生成树(Minimum Spanning Tree, MST)？</p>
<ul>
<li>是一棵树
<ul>
<li>连通，无回路</li>
<li>|V|个顶点一定有|V|-1条边
<ul>
<li>向生成树中任加一条边都一定构成回路</li>
</ul>
</li>
</ul>
</li>
<li>是生成树
<ul>
<li>包含图的全部顶点</li>
<li>它的|V|-1条边都包含在图中</li>
</ul>
</li>
<li>边的权重和最小</li>
<li>推论：最小生成树存在&lt;-&gt;图连通</li>
</ul>
<span id="more"></span>
<h2 id="最小生成树问题中的贪心算法策略"><a class="markdownIt-Anchor" href="#最小生成树问题中的贪心算法策略"></a> 最小生成树问题中的贪心算法策略</h2>
<ul>
<li>什么是&quot;贪&quot;
<ul>
<li>每一步都要最好的</li>
<li>什么是&quot;好&quot;
<ul>
<li>选择权重最小的边</li>
</ul>
</li>
</ul>
</li>
<li>需要的约束
<ul>
<li>只能用图里有的边</li>
<li>只能正好用掉|v|-1条边</li>
<li>不能有回路</li>
</ul>
</li>
</ul>
<h2 id="prim算法让一棵小树长大归并点"><a class="markdownIt-Anchor" href="#prim算法让一棵小树长大归并点"></a> Prim算法——让一棵小树长大(归并点)</h2>
<ul>
<li>类似于Dijkstra算法，只需将访问的结点按顺序收录进入最小生成树MST即可</li>
</ul>
<p>Prim算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void Prim()
&#123;
    MST&#x3D;&#123;S&#125;;
    while(1)
    &#123;
        V&#x3D;未收录顶点中dist最小者;
        if(这样的v不存在)break;
        将v收录进MST:dist[v]&#x3D;0;  &#x2F;&#x2F;注意prim中是将收录后的顶点集合作为一个整体
        for(v的每个邻接点w)       
            if(dist[w]!&#x3D;0)      &#x2F;&#x2F;如果w没有被收录
            if(E(v,w)&lt;dist[w])  &#x2F;&#x2F;v是生成树中的顶点，E[v,w]表示w与生成树中的顶点v的距离
            &#123;
                dist[w]&#x3D;E(v,w); 
                parent[w]&#x3D;v;
            &#125;
    &#125;
    if(MST中收的顶点不到v个)      &#x2F;&#x2F;prim算法收录的是点
        ERROR(&quot;生成树不存在&quot;);   &#x2F;&#x2F;prim算法如果生成树不存在，说明剩下顶点的dist均为无穷大，图不连通
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>其中初始化dist[v]=E(s,v)或正无穷，parent[s]=-1</li>
<li>dist定义为一个顶点到最小生成树的距离(与生成树已收录的所有顶点之间距离最小的那个)</li>
<li>prim算法相当于是依次在树中某个顶点与新增顶点之间加入一条边，已经在树中的顶点之间不会再新增边，因此不会产生回路</li>
<li>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 适合稠密图</li>
</ul>
<h2 id="kruskal算法将森林合并为树归并边"><a class="markdownIt-Anchor" href="#kruskal算法将森林合并为树归并边"></a> Kruskal算法——将森林合并为树(归并边)</h2>
<p>将图看成一个森林，每个顶点为一棵独立的树，更为直截了当的贪心算法</p>
<p>Kruskal算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void Kruskal(Graph G)
&#123;
    MST&#x3D;();                          &#x2F;&#x2F;MST初始为空
    While(MST中不到v-1条边&amp;&amp;E中还有边)
    &#123;
        从E中取一条权重最小的边E(v,w);  &#x2F;&#x2F;可借助最小堆
        将E(v,w)从E中删除;
        if(E(v,w)不在MST中构成回路)    &#x2F;&#x2F;可借助并查集
            将E(v,w)加入MST;
        else
            彻底无视E(v,w);
    &#125;
    if(MST中不到v-1条边)     &#x2F;&#x2F;kruskal算法收录的是边
        ERROR(&quot;生成树不存在&quot;);  &#x2F;&#x2F;同理，当E中的边全部删完并去掉后构成回路的边后，剩余的不到v-1条边，说明图是不连通的
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mi>l</mi><mi>g</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(elge)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span> 适合稀疏图</li>
</ul>
<h2 id="最小生成树问题演示"><a class="markdownIt-Anchor" href="#最小生成树问题演示"></a> 最小生成树问题演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 浙江大学mooc数据结构课程
#include&lt;cstdlib&gt;
#define INFINITY 65535
#define MaxVertexNum 100
#define ERROR -1
typedef int Vertex;
typedef int WeightType;
typedef char DataType;
typedef struct MGNode *PtrToMGNode;
typedef struct LGNode *PtrToLGNode;
typedef struct ENode *PtrToENode;
typedef struct AdjVNode *PtrToAdjVNode; 
typedef PtrToMGNode MGraph;
typedef PtrToLGNode LGraph;
typedef PtrToENode Edge;
struct MGNode&#123;
    int Nv; 
    int Ne;  
    WeightType G[MaxVertexNum][MaxVertexNum]; 
    DataType Data[MaxVertexNum];   
&#125;;
struct ENode&#123;
    Vertex V1, V2;   
    WeightType Weight; 
&#125;;
struct AdjVNode&#123;
    Vertex AdjV;    
    WeightType Weight;  
    PtrToAdjVNode Next;   
&#125;;
typedef struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
    DataType Data;         
&#125; AdjList[MaxVertexNum];
struct LGNode&#123;  
    int Nv;  
    int Ne;  
    AdjList G;  
&#125;;
LGraph CreateGraph(int);
void InsertEdge(LGraph,Edge);
void Swap(Edge,Edge);


&#x2F;* 邻接矩阵存储 - Prim最小生成树算法 *&#x2F;

Vertex FindMinDist( MGraph Graph, WeightType dist[] )
&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;
    Vertex MinV, V;
    WeightType MinDist &#x3D; INFINITY;

    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;
        if ( dist[V]!&#x3D;0 &amp;&amp; dist[V]&lt;MinDist) &#123;
            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;
            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;
            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;
        &#125;
    &#125;
    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;
        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;
    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回-1作为标记 *&#x2F;
&#125;

int Prim( MGraph Graph, LGraph MST )
&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;
    WeightType dist[MaxVertexNum], TotalWeight;
    Vertex parent[MaxVertexNum], V, W;
    int VCount;
    Edge E;
  
    &#x2F;* 初始化。默认初始点下标是0 *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;
        &#x2F;* 这里假设若V到W没有直接的边，则Graph-&gt;G[V][W]定义为INFINITY *&#x2F;
           dist[V] &#x3D; Graph-&gt;G[0][V];
           parent[V] &#x3D; 0; &#x2F;* 暂且定义所有顶点的父结点都是初始点0 *&#x2F; 
    &#125;
    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;
    VCount &#x3D; 0;      &#x2F;* 初始化收录的顶点数 *&#x2F;
    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;
    MST &#x3D; CreateGraph(Graph-&gt;Nv);
    E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立空的边结点 *&#x2F;
         
    &#x2F;* 将初始点0收录进MST *&#x2F;
    dist[0] &#x3D; 0;
    VCount ++;
    parent[0] &#x3D; -1; &#x2F;* 当前树根是0 *&#x2F;

    while (1) &#123;
        V &#x3D; FindMinDist( Graph, dist );
        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;
        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;
            break;   &#x2F;* 算法结束 *&#x2F;
          
        &#x2F;* 将V及相应的边&lt;parent[V], V&gt;收录进MST *&#x2F;
        E-&gt;V1 &#x3D; parent[V];
        E-&gt;V2 &#x3D; V;
        E-&gt;Weight &#x3D; dist[V];
        InsertEdge( MST, E );
        TotalWeight +&#x3D; dist[V];
        dist[V] &#x3D; 0;&#x2F;&#x2F;dist[V]&#x3D;0代表已经访问过该顶点
        VCount++;
      
        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;
            if ( dist[W]!&#x3D;0 &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;
            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;
                if ( Graph-&gt;G[V][W] &lt; dist[W] ) &#123;&#x2F;&#x2F;与Dijkstra同理，只不过这里dist[V]&#x3D;0
                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;
                    dist[W] &#x3D; Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;
                    parent[W] &#x3D; V; &#x2F;* 更新树 *&#x2F;
                &#125;
            &#125;
    &#125; &#x2F;* while结束*&#x2F;
    if ( VCount &lt; Graph-&gt;Nv ) &#x2F;* MST中收的顶点不到|V|个 *&#x2F;
       TotalWeight &#x3D; ERROR;
    return TotalWeight;   &#x2F;* 算法执行完毕，返回最小权重和或错误标记 *&#x2F;
&#125;

&#x2F;* 邻接表存储 - Kruskal最小生成树算法 *&#x2F;

&#x2F;*-------------------- 顶点并查集定义 --------------------*&#x2F;
typedef Vertex ElementType; &#x2F;* 默认元素可以用非负整数表示 *&#x2F;
typedef Vertex SetName;     &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;
typedef ElementType SetType[MaxVertexNum]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;

void InitializeVSet( SetType S, int N )
&#123; &#x2F;* 初始化并查集 *&#x2F;
    ElementType X;

    for ( X&#x3D;0; X&lt;N; X++ ) S[X] &#x3D; -1;
&#125;

void Union( SetType S, SetName Root1, SetName Root2 )
&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;
    &#x2F;* 保证小集合并入大集合 *&#x2F;
    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;
        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;
        S[Root1] &#x3D; Root2;
    &#125;
    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;
        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1  *&#x2F;
        S[Root2] &#x3D; Root1;
    &#125;
&#125;

SetName Find( SetType S, ElementType X )
&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;
    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;
        return X;
    else
        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;
&#125;

bool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )
&#123; &#x2F;* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 *&#x2F;
    Vertex Root1, Root2;

    Root1 &#x3D; Find( VSet, V1 ); &#x2F;* 得到V1所属的连通集名称 *&#x2F;
    Root2 &#x3D; Find( VSet, V2 ); &#x2F;* 得到V2所属的连通集名称 *&#x2F;

    if( Root1&#x3D;&#x3D;Root2 ) &#x2F;* 若V1和V2已经连通，则该边不能要 *&#x2F;
        return false;
    else &#123; &#x2F;* 否则该边可以被收集，同时将V1和V2并入同一连通集 *&#x2F;
        Union( VSet, Root1, Root2 );
        return true;
    &#125;
&#125;
&#x2F;*-------------------- 并查集定义结束 --------------------*&#x2F;

&#x2F;*-------------------- 边的最小堆定义 --------------------*&#x2F;
void PercDown( Edge ESet, int p, int N )
&#123; &#x2F;* 改编代码4.24的PercDown( MaxHeap H, int p )    *&#x2F;
  &#x2F;* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 *&#x2F;
    int Parent, Child;
    struct ENode X;

    X &#x3D; ESet[p]; &#x2F;* 取出根结点存放的值 *&#x2F;
    for( Parent&#x3D;p; (Parent*2+1)&lt;N; Parent&#x3D;Child ) &#123;
        Child &#x3D; Parent * 2 + 1;
        if( (Child!&#x3D;N-1) &amp;&amp; (ESet[Child].Weight&gt;ESet[Child+1].Weight) )
            Child++;  &#x2F;* Child指向左右子结点的较小者 *&#x2F;
        if( X.Weight &lt;&#x3D; ESet[Child].Weight ) break; &#x2F;* 找到了合适位置 *&#x2F;
        else  &#x2F;* 下滤X *&#x2F;
            ESet[Parent] &#x3D; ESet[Child];
    &#125;
    ESet[Parent] &#x3D; X;
&#125;

void InitializeESet( LGraph Graph, Edge ESet )
&#123; &#x2F;* 将图的边存入边数组ESet，并且初始化为最小堆 *&#x2F;
    Vertex V;
    PtrToAdjVNode W;
    int ECount;

    &#x2F;* 将图的边存入数组ESet *&#x2F;
    ECount &#x3D; 0;
    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ )
        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next )
            if ( V &lt; W-&gt;AdjV ) &#123; &#x2F;* 避免重复录入无向图的边，只收V1&lt;V2的边 *&#x2F;
                ESet[ECount].V1 &#x3D; V;
                ESet[ECount].V2 &#x3D; W-&gt;AdjV;
                ESet[ECount++].Weight &#x3D; W-&gt;Weight;
            &#125;
    &#x2F;* 初始化为最小堆 *&#x2F;
    for ( ECount&#x3D;Graph-&gt;Ne&#x2F;2; ECount&gt;&#x3D;0; ECount-- )
        PercDown( ESet, ECount, Graph-&gt;Ne );
&#125;

int GetEdge( Edge ESet, int CurrentSize )
&#123; &#x2F;* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 *&#x2F;

    &#x2F;* 将最小边与当前堆的最后一个位置的边交换 *&#x2F;
    Swap( &amp;ESet[0], &amp;ESet[CurrentSize-1]);
    &#x2F;* 将剩下的边继续调整成最小堆 *&#x2F;
    PercDown( ESet, 0, CurrentSize-1 );&#x2F;&#x2F;注意只调整前CurrentSize-1个边，交换后的最小边不做处理

    return CurrentSize-1; &#x2F;* 返回最小边所在位置 *&#x2F;
&#125;
&#x2F;*-------------------- 最小堆定义结束 --------------------*&#x2F;


int Kruskal( LGraph Graph, LGraph MST )
&#123; &#x2F;* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 *&#x2F;
    WeightType TotalWeight;
    int ECount, NextEdge;
    SetType VSet; &#x2F;* 顶点数组 *&#x2F;
    Edge ESet;    &#x2F;* 边数组 *&#x2F;

    InitializeVSet( VSet, Graph-&gt;Nv ); &#x2F;* 初始化顶点并查集 *&#x2F;
    ESet &#x3D; (Edge)malloc( sizeof(struct ENode)*Graph-&gt;Ne );
    InitializeESet( Graph, ESet ); &#x2F;* 初始化边的最小堆 *&#x2F;
    &#x2F;* 创建包含所有顶点但没有边的图。注意用邻接表版本 *&#x2F;
    MST &#x3D; CreateGraph(Graph-&gt;Nv);
    TotalWeight &#x3D; 0; &#x2F;* 初始化权重和     *&#x2F;
    ECount &#x3D; 0;      &#x2F;* 初始化收录的边数 *&#x2F;

    NextEdge &#x3D; Graph-&gt;Ne; &#x2F;* 原始边集的规模 *&#x2F;
    while ( ECount &lt; Graph-&gt;Nv-1 ) &#123;  &#x2F;* 当收集的边不足以构成树时 *&#x2F;
        NextEdge &#x3D; GetEdge( ESet, NextEdge ); &#x2F;* 从边集中得到最小边的位置 *&#x2F;
        if (NextEdge &lt; 0) &#x2F;* 边集已空 *&#x2F;
            break;
        &#x2F;* 如果该边的加入不构成回路，即两端结点不属于同一连通集 *&#x2F;
        if ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )&#x3D;&#x3D;true ) &#123;
            &#x2F;* 将该边插入MST *&#x2F;
            InsertEdge( MST, ESet+NextEdge );&#x2F;&#x2F;ESet+NextEdge表示ESet[NextEdge]
            TotalWeight +&#x3D; ESet[NextEdge].Weight; &#x2F;* 累计权重 *&#x2F;
            ECount++; &#x2F;* 生成树中边数加1 *&#x2F;
        &#125;
    &#125;
    if ( ECount &lt; Graph-&gt;Nv-1 )
        TotalWeight &#x3D; -1; &#x2F;* 设置错误标记，表示生成树不存在 *&#x2F;

    return TotalWeight;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5.六度空间、哈利波特的考试</title>
    <url>/posts/39942f11e23b</url>
    <content><![CDATA[<h1 id="六度空间"><a class="markdownIt-Anchor" href="#六度空间"></a> 六度空间</h1>
<p>“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入第1行给出两个正整数，分别表示社交网络图的结点数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>&lt;</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">1&lt;N≤10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>，表示人数）、边数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mn>33</mn><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">≤33×N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。<br>
每个结节点输出一行，格式为“结点编号:（空格）百分比%”。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">10 9
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">1: 70.00%
2: 80.00%
3: 90.00%
4: 100.00%
5: 100.00%
6: 100.00%
7: 100.00%
8: 90.00%
9: 80.00%
10: 70.00%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="算法思路"><a class="markdownIt-Anchor" href="#算法思路"></a> 算法思路</h2>
<ul>
<li>对每个结点，进行广度优先搜索</li>
<li>搜索过程中累计访问的结点数</li>
<li>需要记录层数，仅计算6层以内的结点数</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void SDS()
&#123;
    for(each V in G)
    &#123;
        count&#x3D;BFS(V);
        Output(count&#x2F;N);
    &#125;
&#125;
int BFS(Vertex V)
&#123;
    visited[V]&#x3D;true;
    count&#x3D;1,level&#x3D;0,last&#x3D;V;
    Enqueue(V,Q);
    while(!IsEmpty(Q))
    &#123;
        V&#x3D;Dequeue(Q);
        for(V的每个邻接点W)
            if(!visited[W])
            &#123;
                visited[W]&#x3D;true;
                Enqueue(W,Q);
                count++;
                tail&#x3D;W;
            &#125;
        if(V&#x3D;&#x3D;last)
        &#123;
            level++;
            last&#x3D;tail;
        &#125;
        if(level&#x3D;&#x3D;6)break;
    &#125;
    return count;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;queue&gt;
#define MaxPeople 1000
#define MaxSocial 33
using namespace std;
typedef int Vertex;
typedef struct ENode *PtrToENode;
typedef struct AdjVNode *PtrToAdjVNode;
typedef struct LGNode *PtrToLGNode;
typedef struct Vnode AdjList[MaxPeople];
typedef PtrToENode Edge;
typedef PtrToLGNode LGraph;
struct ENode&#123;
    Vertex V1, V2;
&#125;;
struct AdjVNode&#123;
    Vertex AdjV;
    PtrToAdjVNode Next;
&#125;;
struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
&#125;;
struct LGNode&#123;
    int Nv,Ne;
    AdjList G;
&#125;;
LGraph CreateLGraph(int);
void InsertLGraph(Edge,LGraph);
void BuildLGraph(LGraph,int);
void SDS(LGraph,bool*);
int BFS(LGraph,Vertex,bool*);
int main(int argc,char*argv[]) &#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    bool visited[n+1];
    LGraph L&#x3D; CreateLGraph(n);
    BuildLGraph(L,m);
    SDS(L,visited);
&#125;
LGraph CreateLGraph(int VertexNum)&#123;
    auto L&#x3D;new struct LGNode;
    L-&gt;Nv&#x3D;VertexNum,L-&gt;Ne&#x3D;0;
    for(int i&#x3D;0;i &#96;&lt;L-&gt;&#96;Nv;i++)L-&gt;G[i].FirstEdge&#x3D; nullptr;
    return L;
&#125;
void InsertLGraph(Edge E,LGraph L)&#123;
    PtrToAdjVNode  newnode1,newnode2;
    newnode1&#x3D;new struct AdjVNode;
    newnode2&#x3D;new struct AdjVNode;
    newnode1-&gt;AdjV&#x3D;E-&gt;V2;
    newnode2-&gt;AdjV&#x3D;E-&gt;V1;
    newnode1-&gt;Next&#x3D;L-&gt;G[E-&gt;V1-1].FirstEdge;
    newnode2-&gt;Next&#x3D;L-&gt;G[E-&gt;V2-1].FirstEdge;
    L-&gt;G[E-&gt;V1-1].FirstEdge&#x3D;newnode1;
    L-&gt;G[E-&gt;V2-1].FirstEdge&#x3D;newnode2;
    L-&gt;Ne++;
&#125;
void BuildLGraph(LGraph L,int m)&#123;
    for(int i&#x3D;0;i&lt;m;i++)&#123;
        auto E&#x3D;new struct ENode;
        cin&gt;&gt;E-&gt;V1&gt;&gt;E-&gt;V2;
        InsertLGraph(E,L);
    &#125;
&#125;
void SDS(LGraph L,bool* visited)&#123;
    float count;
    for(int i &#x3D;1;i&lt;&#x3D;L-&gt;Nv;i++)&#123;
        for(int j&#x3D;1;j&lt;&#x3D;L-&gt;Nv;j++)visited[j]&#x3D; false;
        count&#x3D;(float)BFS(L,i,visited);
        printf(&quot;%d: %.2f%%\n&quot;,i,100*count&#x2F;(float)L-&gt;Nv);
    &#125;
&#125;
int BFS(LGraph L,Vertex V,bool* visited)&#123;
    queue &#96;&lt;Vertex&gt;&#96; q;
    int count&#x3D;1,level&#x3D;0;
    Vertex last&#x3D;V,tail;
    PtrToAdjVNode W;
    visited[V]&#x3D;true;
    q.push(V);
    while(!q.empty())&#123;
        V&#x3D;q.front(),q.pop();
        W &#x3D; L-&gt;G[V-1].FirstEdge;
        while(W)&#123;
           if(!visited[W-&gt;AdjV])&#123;
               q.push(W-&gt;AdjV);
               visited[W-&gt;AdjV]&#x3D; true,tail&#x3D;W-&gt;AdjV,count++;
           &#125;
            W&#x3D;W-&gt;Next;
        &#125;
        if(V&#x3D;&#x3D;last)last&#x3D;tail,level++;
        if(level&#x3D;&#x3D;6)break;
    &#125;
    return count;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="哈利波特的考试"><a class="markdownIt-Anchor" href="#哈利波特的考试"></a> 哈利·波特的考试</h1>
<p>哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；<br>
而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。</p>
<h2 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h2>
<p>输入说明：输入第1行给出两个正整数N(≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。</p>
<h2 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h2>
<p>输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。<br>
如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">6 11
3 4 70
1 2 1
5 4 50
2 6 50
5 6 60
1 3 70
4 6 60
3 6 80
5 1 100
2 4 60
5 2 80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例-2"><a class="markdownIt-Anchor" href="#输出样例-2"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">4 70<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="程序框架搭建"><a class="markdownIt-Anchor" href="#程序框架搭建"></a> 程序框架搭建</h2>
<p>题意理解：任意两顶点间的最短路径-Floyd算法</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    MGraph G&#x3D;BuildGraph();
    FindAnimal(G);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>MGraph的定义：CreateGraph,InsertEdge——&gt;BuildGraph<br>
Floyd算法：FindMaxDist(i)——&gt;FindMin——&gt;FindAnimal</p>
<p>选择动物</p>
<pre class="line-numbers language-none"><code class="language-none">void FindAnimal(MGraph Graph)
&#123;
    WeightType D[MaxVertex][MaxVertex],MaxDist,MinDist;
    Vertex Animal,i;
    Floyd(Graph,D);
    MinDist&#x3D;INFINITY;
    for(i&#x3D;0;i&lt;Graph-&gt;Nv;i++)
    &#123;
        MaxDist&#x3D;FindMaxDist(D,i,Graph-&gt;Nv);
        if(MaxDist&#x3D;&#x3D;INFINITY)
        &#123;
            cout&lt;&lt;0&lt;&lt;endl;
            return;
        &#125;
        if(MinDist&gt;MaxDist)
        &#123;
            MinDist&#x3D;MaxDist;
            Animal&#x3D;i+1;
        &#125;
    &#125;
    cout&lt;&lt;Animal&lt;&lt;&#39; &#39;&lt;&lt;MinDist&lt;&lt;endl;
&#125;
WeightType FindMaxDist(WeightType D[][MaxVertexNum],Vertex i,int N)
&#123;
    WeightType MaxDist;
    Vertex j;
    MaxDist&#x3D;0;
    for(j&#x3D;0;j&lt;N;j++)
        if(i!&#x3D;j&amp;&amp;D[i][j]&gt;MaxDist)MaxDist&#x3D;D[i][j];
    return MaxDist;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码-2"><a class="markdownIt-Anchor" href="#ac代码-2"></a> ac代码</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#define MaxAnimal 101
#define INFINITY 65535
using namespace std;
void BuildGragh(int,int);
void Floyd(int);
int MGraph[MaxAnimal][MaxAnimal],D[MaxAnimal][MaxAnimal];
int main()&#123;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    BuildGragh(n,m);
    Floyd(n);
&#125;
void BuildGragh(int n,int m)&#123;
    int v,w,weight;
    for(int i&#x3D;0;i&lt;MaxAnimal;i++)for(int j&#x3D;0;j&lt;MaxAnimal;j++)
        if(i!&#x3D;j)MGraph[i][j]&#x3D;INFINITY;
    for(int i&#x3D;0;i&lt;m;i++)&#123;
        cin&gt;&gt;v&gt;&gt;w&gt;&gt;weight;
        MGraph[v][w]&#x3D;MGraph[w][v]&#x3D;weight;
    &#125;
&#125;
void Floyd(int n)&#123;
    int dist[MaxAnimal+1]&#x3D;&#123;0&#125;,minp&#x3D;INFINITY,mini;
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)for(int j&#x3D;1;j&lt;&#x3D;n;j++)
        D[i][j]&#x3D;MGraph[i][j];
    for(int k&#x3D;1;k&lt;&#x3D;n;k++)for(int i&#x3D;1;i&lt;&#x3D;n;i++)for(int j&#x3D;1;j&lt;&#x3D;n;j++)
        if(D[i][j]&gt;D[i][k]+D[k][j])D[i][j]&#x3D;D[i][k]+D[k][j];
    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
        for(int j&#x3D;1;j&lt;&#x3D;n;j++)if(D[i][j]&gt;dist[i])dist[i]&#x3D;D[i][j];
        if(minp&gt;dist[i])minp&#x3D;dist[i],mini&#x3D;i;
    &#125;
    if(minp&lt;INFINITY)cout&lt;&lt;mini&lt;&lt;&#39; &#39;&lt;&lt;minp&lt;&lt;endl;
    else cout&lt;&lt;0&lt;&lt;endl;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式的表示和运算</title>
    <url>/posts/482560d0b6e6</url>
    <content><![CDATA[<h1 id="最短路径问题图的wpl"><a class="markdownIt-Anchor" href="#最短路径问题图的wpl"></a> 最短路径问题(图的WPL)</h1>
<p>最短路径问题的抽象</p>
<ul>
<li>在网络中，求两个不同顶点之间所有路径中，边的权值之和最小的那一条路径
<ul>
<li>这条路径就是两点之间的最短路径(Shortest Path)</li>
<li>第一个顶点为源点(Source)</li>
<li>最后一个顶点为终点(Destination)</li>
</ul>
</li>
</ul>
<p>问题分类</p>
<ul>
<li>单源点最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径
<ul>
<li>(有向)无权图</li>
<li>(有向)有权图</li>
<li>无向图是一种特殊的有向图，与有向图的原理相同</li>
</ul>
</li>
<li>多源点最短路径问题：求任意两顶点间的最短路径
<ul>
<li>从某任意源点出发，求所有源点所有其他顶点的最短路径</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="无权图的单源点最短路径算法"><a class="markdownIt-Anchor" href="#无权图的单源点最短路径算法"></a> 无权图的单源点最短路径算法</h2>
<ul>
<li>按照递增(非递减)的顺序找出各个顶点的最短路径
<ul>
<li>这种情况的最短路径的本质：顶点与源点之间的顶点最少
<ul>
<li>间隔的顶点最少——高度/深度/层数最少</li>
<li>由BFS逐层搜索找到符合条件的最短路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/OAzCmKWZ1FeT7cV.png" width="50%" height="50%">
<pre class="line-numbers language-none"><code class="language-none">void BFS(Vertex S)
&#123;
    Enqueue(S,Q);
    while(!Isempty(Q))
    &#123;
        V&#x3D;Dequeue(Q);
        for(V的每个邻接点W)
            if(!visited[W])
            &#123;
                visited[W]&#x3D;true;
                Enqueue(W,Q);
            &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>无权图的单源点最短路径BFS算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void UnweightedMinPath(Vertex S)
&#123;
    Enqueue(S,Q);
    while(!Isempty(Q))
    &#123;
        V&#x3D;Dequeue(Q);
        for(V的每个邻接点W)
            if(dist[W]&#x3D;&#x3D;-1) &#x2F;&#x2F;这种情况dist数组初始化为正无穷、负无穷、-1等都可以，只要是权值不可能取到的值即可
            &#123;               &#x2F;&#x2F;注意不能初始化为0，因为dist[S]&#x3D;0
                dist[W]&#x3D;dist[V]+1;      &#x2F;&#x2F;V的每个邻接点V的距离是1，与源点的距离是dist[V]+1
                path[W]&#x3D;V;
                Enqueue(W,Q);
            &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>dist[W]=S到W的最短距离</li>
<li>dist[S]=0
<ul>
<li>源点S与自身的距离被初始化为0，与其他顶点的距离初始化为-1</li>
</ul>
</li>
<li>path[W]=S到W的路上经过的某顶点(W前面经过那一个顶点)</li>
<li>输出S到W的路径上顶点的方法：借助堆栈，从路径末端顶点开始开始向前搜索path[i]，直到源点S，然后将顶点全部弹出</li>
<li>BFS时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>v</mi><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h2 id="有权图的单源点最短路径算法"><a class="markdownIt-Anchor" href="#有权图的单源点最短路径算法"></a> 有权图的单源点最短路径算法</h2>
<ul>
<li>按照递增的顺序找出各个顶点的最短路径
<ul>
<li>仍然按照BFS的方式——每层寻找最短路径时要考虑权值——Dijkstra算法(<strong>BFS的扩展、贪心策略</strong>)</li>
</ul>
</li>
</ul>
<h3 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法</h3>
<ul>
<li>令S={源点s+已经确定了最短路径的顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>}</li>
<li>对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过s中的顶点
<ul>
<li>即路径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>−</mo><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo>∈</mo><mi>S</mi><mo stretchy="false">)</mo><mo>−</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">s-(v_i ∈ S)-v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的最小长度</li>
</ul>
</li>
<li>路径仅经过s中的顶点：若路径是按照递增(非递减)的顺序生成的，则
<ul>
<li>真正的最短路径必须只经过S中的顶点</li>
<li>该问题存在最优子结构特征
<ul>
<li>假设从源点到终点的最短路径中去掉终点，那么倒数第二个顶点到源点之间仍然应该是这两点之间的最短路径
<ul>
<li>因为最后两点之间的距离已确定，所以终点的最短路径需要此路径上倒数第二个顶点也满足其最短路径</li>
<li>依此类推，最短路径中的每个点都应该是另一条最短路径上的顶点</li>
<li>并且由于收录顶点是按距离递增的顺序，所以如果顶点v的最短路径中包含未收录的顶点，则一定不是按照距离递增顺序收录的</li>
</ul>
</li>
<li>Dijkstra算法不能解决有负边的情况，因为如果存在负边则意味着两点之间再加上一条边后路径可以变小
<ul>
<li>此时去掉一条负边后剩下的路径不一定最短，不满足最优子结构</li>
<li>某些情况下可能存在负值圈negative-cost-cycle，即在一个回路中走一圈后反而距离和为负，此时最短距离为负无穷</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>每次从未收录的顶点中选一个dist最小的收录(贪心算法)</li>
<li>增加一个v进入S，可能影响另外一个w的dist值
<ul>
<li>如果新增收录v后导致w的dist值变短
<ul>
<li>v一定在w的最短路径上</li>
<li>v和w之间必定存在一条直接相连的边
<ul>
<li>因为w只经过已经收录过的顶点，如果v和w不存在边的话则说明v和w之间存在其他顶点且未被收录(因为其dist值比v的长))</li>
<li>*实际上，收录v只能影响到其邻接点的dist值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">dist[w]=min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span></span></span></span>{<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>v</mi><mo stretchy="false">]</mo><mo>+</mo><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">dist[w],dist[v]+&lt;v,w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>的权重}</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/SphXsFmwbHjP6qG.png" width="50%" height="50%">
<p>Dijkstra算法伪代码描述：</p>
<pre class="line-numbers language-none"><code class="language-none">void Dijkstra(Vertex S)
&#123;
    while(1)
    &#123;
        V&#x3D;未收录顶点中dist最小者;                  &#x2F;&#x2F;有权图这种情况dist应该初始化为INFINITY
        if(这样的V不存在)break;
        collected[V]&#x3D;true;
        for(V的每个邻接点W)
            if(collected[W]&#x3D;&#x3D;false)
                if(dist[V]+E&lt;V,W&gt; &lt; dist[W])
                &#123;                               &#x2F;&#x2F;存在这种情况：源点到W的路径过长，使源点到V再到W的路径相对更短
                    dist[W]&#x3D;dist[V]+E&lt;V,W&gt;;
                    path[W]&#x3D;V;
                &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Dijkstra算法的时间复杂度取决于对dist的处理方法<br>
算法1：直接扫描所有未收录顶点——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li>查找dist最小值(v次)——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(v^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>遍历所有邻接点——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>2</mn></msup><mo>+</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v^2+e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span> ——对稠密图效果好</li>
</ul>
<p>算法2：将dist存在最小堆中</p>
<ul>
<li>查找dist最小值(v次)——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>v</mi><mi>l</mi><mi>g</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(vlgv)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span></li>
<li>遍历所有邻接点，同时要把新的dist插入堆——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>e</mi><mi>l</mi><mi>g</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(elge)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>v</mi><mi>l</mi><mi>g</mi><mi>v</mi><mo>+</mo><mi>e</mi><mi>l</mi><mi>g</mi><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(vlgv+elge)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mclose">)</span></span></span></span> ——对稀疏图效果好</li>
</ul>
<h2 id="多源点最短路径算法"><a class="markdownIt-Anchor" href="#多源点最短路径算法"></a> 多源点最短路径算法</h2>
<p>算法1：直接将Dijkstra算法调用v遍</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>3</mn></msup><mo>+</mo><mi>e</mi><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v^3+ev)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span> ——对稀疏图效果好(整体上可视作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(v^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>)</li>
</ul>
<p>算法2：Floyd算法</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>v</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(v^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ——对稠密图效果好</li>
</ul>
<h3 id="floyd算法"><a class="markdownIt-Anchor" href="#floyd算法"></a> Floyd算法</h3>
<ul>
<li>D(k)[i][j]=路径{$i\rightarrow {l\leq k}\rightarrow j$}的最小长度</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mrow><mo>−</mo><mn>1</mn></mrow></msub><mo>→</mo><msub><mi>D</mi><mn>0</mn></msub><mo>→</mo><msub><mi>D</mi><mn>1</mn></msub><mo>→</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mo>→</mo><msub><mi>D</mi><mrow><mi>v</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">D_{-1}\rightarrow D_0\rightarrow D_1\rightarrow ,..., \rightarrow D_{v-1}[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span></span><span class="base"><span class="strut" style="height:0.56131em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>最后给出了i到j的真正最短距离
<ul>
<li>D(-1)是什么？
<ul>
<li>直接以图的邻接矩阵形式进行初始化即可(对角元为0，没有边的元素为正无穷)</li>
</ul>
</li>
</ul>
</li>
<li>当D(k-1)已经完成，递推到D(k)时：
<ul>
<li>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">∉</mi></mrow><annotation encoding="application/x-tex">k ∉</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.75em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.25em;"><span></span></span></span></span></span></span></span></span></span> 最短路径{$i\rightarrow {l\leq k}\rightarrow j}，则D_k=D_{k-1}$</li>
<li>或者<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∈</mo></mrow><annotation encoding="application/x-tex">k ∈</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span></span></span></span> 最短路径{$i\rightarrow {l\leq k}\rightarrow j$}，则该路径必定由两段最短路径组成
<ul>
<li>D(k)[i][j]=D(k-1)[i][k]+D(k-1)[k][j]</li>
</ul>
</li>
</ul>
</li>
<li>Floyd算法的核心为：
<ul>
<li>对于从顶点i到顶点j的最短路径，拿出网中所有的顶点进行如下判断：
<ul>
<li>如果i到k的路径长度加k到j的路径长度小于i到j的路径长度，则说明存在一条更短的路径，此时更新路径即可</li>
<li>任意的两个顶点全部做以上的判断，最终遍历完成后记录的最终的权值即为对应顶点之间的最短路径</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void Floyd()&#123;
    for(i&#x3D;0;i&lt;N;i++)
        for(j&#x3D;0;j&lt;N;j++)
        &#123;
            D[i][j]&#x3D;G[i][j];
            path[i][j]&#x3D;-1;
        &#125;
    for(k&#x3D;0;k&lt;N;k++)
        for(i&#x3D;0;i&lt;N;i++)
            for(j&#x3D;0;j&lt;N;j++)
                if(D[i][k]+D[k][j]&lt;D[i][j])
                &#123;
                    D[i][j]&#x3D;D[i][k]+D[k][j];
                    path[i][j]&#x3D;k;
                &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最短路径算法演示"><a class="markdownIt-Anchor" href="#最短路径算法演示"></a> 最短路径算法演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 浙江大学mooc数据结构
#define MaxVertexNum 100
#define INFINITY 65535
#define ERROR -1
typedef struct AdjVNode *PtrToAdjVNode; 
typedef struct MGNode *PtrToMGNode;
typedef struct LGNode *PtrToLGNode;
typedef struct QNode *Queue;
typedef int ElementType;
typedef int Vertex;
typedef int WeightType;
typedef char DataType;
typedef PtrToLGNode LGraph;
typedef PtrToMGNode MGraph;
struct AdjVNode&#123;
    Vertex AdjV;       
    WeightType Weight; 
    PtrToAdjVNode Next;   
&#125;;
typedef struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
    DataType Data;        
&#125; AdjList[MaxVertexNum];
struct MGNode&#123;
    int Nv; 
    int Ne;  
    WeightType G[MaxVertexNum][MaxVertexNum]; 
    DataType Data[MaxVertexNum];     
&#125;;
struct LGNode&#123;  
    int Nv;     
    int Ne;     
    AdjList G; 
&#125;;
Queue CreateQueue( int );
void AddQ(Queue, ElementType);
bool IsEmpty(Queue);
ElementType DeleteQ(Queue);
&#x2F;* 邻接表存储 - 无权图的单源最短路算法 *&#x2F;

&#x2F;* dist[]和path[]全部初始化为-1 *&#x2F;
void Unweighted ( LGraph Graph, int dist[], int path[], Vertex S )
&#123;
    Queue Q;
    Vertex V;
    PtrToAdjVNode W;
    
    Q &#x3D; CreateQueue( Graph-&gt;Nv ); &#x2F;* 创建空队列, MaxSize为外部定义的常数 *&#x2F;
    dist[S] &#x3D; 0; &#x2F;* 初始化源点 *&#x2F;
    AddQ (Q, S);

    while( !IsEmpty(Q) )&#123;
        V &#x3D; DeleteQ(Q);
        for ( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next ) &#x2F;* 对V的每个邻接点W-&gt;AdjV *&#x2F;
            if ( dist[W-&gt;AdjV]&#x3D;&#x3D;-1 ) &#123; &#x2F;* 若W-&gt;AdjV未被访问过 *&#x2F;
                dist[W-&gt;AdjV] &#x3D; dist[V]+1; &#x2F;* W-&gt;AdjV到S的距离更新 *&#x2F;
                path[W-&gt;AdjV] &#x3D; V; &#x2F;* 将V记录在S到W-&gt;AdjV的路径上 *&#x2F;
                AddQ(Q, W-&gt;AdjV);
            &#125;
    &#125; &#x2F;* while结束*&#x2F;
&#125;

&#x2F;* 邻接矩阵存储 - 有权图的单源最短路算法 *&#x2F;

Vertex FindMinDist( MGraph Graph, int dist[], int collected[] )
&#123; &#x2F;* 返回未被收录顶点中dist最小者 *&#x2F;
    Vertex MinV, V;
    int MinDist &#x3D; INFINITY;

    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) &#123;
        if ( collected[V]&#x3D;&#x3D;false &amp;&amp; dist[V]&lt;MinDist) &#123;
            &#x2F;* 若V未被收录，且dist[V]更小 *&#x2F;
            MinDist &#x3D; dist[V]; &#x2F;* 更新最小距离 *&#x2F;
            MinV &#x3D; V; &#x2F;* 更新对应顶点 *&#x2F;
        &#125;
    &#125;
    if (MinDist &lt; INFINITY) &#x2F;* 若找到最小dist *&#x2F;
        return MinV; &#x2F;* 返回对应的顶点下标 *&#x2F;
    else return ERROR;  &#x2F;* 若这样的顶点不存在，返回错误标记 *&#x2F;
&#125;

bool Dijkstra( MGraph Graph, int dist[], int path[], Vertex S )
&#123;
    int collected[MaxVertexNum];
    Vertex V, W;

    &#x2F;* 初始化：此处默认邻接矩阵中不存在的边用INFINITY表示 *&#x2F;
    for ( V&#x3D;0; V&lt;Graph-&gt;Nv; V++ ) &#123;
        dist[V] &#x3D; Graph-&gt;G[S][V];
        if ( dist[V]&lt;INFINITY )
            path[V] &#x3D; S;
        else
            path[V] &#x3D; -1;
        collected[V] &#x3D; false;
    &#125;
    &#x2F;* 先将起点收入集合 *&#x2F;
    dist[S] &#x3D; 0;
    collected[S] &#x3D; true;

    while (1) &#123;
        &#x2F;* V &#x3D; 未被收录顶点中dist最小者 *&#x2F;
        V &#x3D; FindMinDist( Graph, dist, collected );
        if ( V&#x3D;&#x3D;ERROR ) &#x2F;* 若这样的V不存在 *&#x2F;
            break;      &#x2F;* 算法结束 *&#x2F;
        collected[V] &#x3D; true;  &#x2F;* 收录V *&#x2F;
        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;
            &#x2F;* 若W是V的邻接点并且未被收录 *&#x2F;
            if ( collected[W]&#x3D;&#x3D;false &amp;&amp; Graph-&gt;G[V][W]&lt;INFINITY ) &#123;
                if ( Graph-&gt;G[V][W]&lt;0 ) &#x2F;* 若有负边 *&#x2F;
                    return false; &#x2F;* 不能正确解决，返回错误标记 *&#x2F;
                &#x2F;* 若收录V使得dist[W]变小 *&#x2F;
                if ( dist[V]+Graph-&gt;G[V][W] &lt; dist[W] ) &#123;&#x2F;* 因为初始化为INFINITY，所以此句包含源点和第一个顶点的情况 *&#x2F;
                    dist[W] &#x3D; dist[V]+Graph-&gt;G[V][W]; &#x2F;* 更新dist[W] *&#x2F;
                    path[W] &#x3D; V; &#x2F;* 更新S到W的路径 *&#x2F;
                &#125;
            &#125;
    &#125; &#x2F;* while结束*&#x2F;
    return true; &#x2F;* 算法执行完毕，返回正确标记 *&#x2F;
&#125;

&#x2F;* 邻接矩阵存储 - 多源最短路算法 *&#x2F;

bool Floyd( MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum] )
&#123;
    Vertex i, j, k;

    &#x2F;* 初始化 *&#x2F;
    for ( i&#x3D;0; i&lt;Graph-&gt;Nv; i++ )
        for( j&#x3D;0; j&lt;Graph-&gt;Nv; j++ ) &#123;
            D[i][j] &#x3D; Graph-&gt;G[i][j];  &#x2F;* D[i][j]初始化为i,j之间的直接路径长度 *&#x2F;
            path[i][j] &#x3D; -1;
        &#125;

    for( k&#x3D;0; k&lt;Graph-&gt;Nv; k++ )
        for( i&#x3D;0; i&lt;Graph-&gt;Nv; i++ )
            for( j&#x3D;0; j&lt;Graph-&gt;Nv; j++ )
                if( D[i][k] + D[k][j] &lt; D[i][j] ) &#123;
                    D[i][j] &#x3D; D[i][k] + D[k][j];
                    if ( i&#x3D;&#x3D;j &amp;&amp; D[i][j]&lt;0 ) &#x2F;* 若发现负值圈 *&#x2F;
                        return false; &#x2F;* 不能正确解决，返回错误标记 *&#x2F;
                    path[i][j] &#x3D; k;
                &#125;
    return true; &#x2F;* 算法执行完毕，返回正确标记 *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>4.救邦德-简单版</title>
    <url>/posts/5c4fa5568562</url>
    <content><![CDATA[<h1 id="saving-james-bond-easy-version"><a class="markdownIt-Anchor" href="#saving-james-bond-easy-version"></a> Saving James Bond - Easy Version</h1>
<p>This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape.</p>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification:</h2>
<p>Each input file contains one test case. Each case starts with a line containing two positive integers <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mo>≤</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (≤100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>, the number of crocodiles, and D, the maximum distance that James could jump. Then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> lines follow, each containing the (x,y) location of a crocodile. Note that no two crocodiles are staying at the same position.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification:</h2>
<p>For each test case, print in a line “Yes” if James can escape, or “No” if not.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">14 20
25 -15
-25 28
8 49
29 15
-35 -2
5 28
27 -29
-8 -28
-20 -35
-25 -20
-13 29
-30 15
-35 40
12 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">Yes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">4 13
-12 12
12 12
-12 -12
12 -12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">No<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2>
<p>总体算法:DFS</p>
<pre class="line-numbers language-none"><code class="language-none">void ListComponents(Graph G)
&#123;
    for(each V in G)
    if(!visited[V])
    DFS(V);
&#125;
void DFS(Vertex V)
&#123;
    visited[V]&#x3D;true;
    for(V的每个邻接点W)
    if(!visited[W])DFS(W);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由DFS算法写出本道题的基本算法框架(伪代码)</p>
<pre class="line-numbers language-none"><code class="language-none">void Save007(Graph G)
&#123;
    for(each in G)
    &#123;
        if(!visited[V]&amp;&amp;FirstJump(V))
        &#123;
            answer&#x3D;DFS(V);
            if(answer&#x3D;&#x3D;YES)break;
        &#125;
    &#125;
    if(answewr&#x3D;&#x3D;YES) output(&quot;Yes&quot;);
    else output(&quot;No&quot;);
&#125;
int DFS(Vertex V)
&#123;
    visited[V]&#x3D;true;
    if(IsSafe(V))answer&#x3D;YES;
    else&#123;
        for(each W in G)
            if(!visited[W]&amp;&amp;Jump(V,W))&#123;
                answer&#x3D;DFS(W);
                if(answer&#x3D;&#x3D;YES)break;
            &#125;
    &#125;
    return answer;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ac代码"><a class="markdownIt-Anchor" href="#ac代码"></a> ac代码</h2>
<p>(别嫌弃，毕竟初学者)</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cmath&gt;
#define MaxCorcodiles 101
#define Diameter 15
using namespace std;
typedef struct Point&#123;
    int x,y;
&#125;point;
double isEdge(point,point,int);
bool canescape(point,int);
void BuildMGraph(int,int,point*,double[][MaxCorcodiles]);
bool DST(int,int,int,bool*,point*,double[][MaxCorcodiles]);
int main(int argc,char*argv[]) &#123;
    int n,jump;
    bool answer&#x3D; false,Vistied[MaxCorcodiles];
    double MGraph[MaxCorcodiles][MaxCorcodiles];
    point Datapoint[MaxCorcodiles];
    cin&gt;&gt;n&gt;&gt;jump;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;0;j&lt;n;j++)MGraph[i][j]&#x3D;-1;
    BuildMGraph(n,jump,Datapoint,MGraph);
    for(int i&#x3D;0;i&lt;n;i++)Vistied[i]&#x3D;false;
    for(int i&#x3D;0;i&lt;n;i++)if(sqrt(pow(Datapoint[i].x,2)+pow(Datapoint[i].y,2))&lt;&#x3D;jump+Diameter) &#123;
    answer &#x3D; DST(i, n, jump, Vistied, Datapoint, MGraph);
    if(answer)break;
    &#125;
    if(answer)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
&#125;
bool canescape(point p,int jump)&#123;
    return (p.x-jump&lt;&#x3D;-50||p.x+jump&gt;&#x3D;50||p.y+jump&gt;&#x3D;50||p.y-jump&lt;&#x3D;-50);
&#125;
double isEdge(point p1,point p2,int jump)&#123;
    double weight &#x3D;sqrt(pow(p1.x - p2.x,2) + pow(p1.y - p2.y,2));
    if(weight&lt;&#x3D;jump)return weight;
    else return -1;
&#125;
void BuildMGraph(int n,int jump,point* Datapoint,double MGraph[][MaxCorcodiles])&#123;
    double w;
    for(int i&#x3D;0;i&lt;n;i++)cin&gt;&gt;Datapoint[i].x&gt;&gt;Datapoint[i].y;
    for(int i&#x3D;0;i&lt;n;i++)for(int j&#x3D;0;j&lt;n;j++)
    if(i!&#x3D;j&amp;&amp;(w&#x3D;isEdge(Datapoint[i],Datapoint[j],jump))&gt;&#x3D;0)MGraph[i][j]&#x3D;w;
&#125;
bool DST(int v,int n,int jump,bool*Vistied,point*Datapoint,double MGraph[][MaxCorcodiles])&#123;
    bool answer &#x3D; false;
    Vistied[v]&#x3D; true;
    if(canescape(Datapoint[v],jump))answer&#x3D;true;
    for(int i&#x3D;0;i&lt;n;i++)if(MGraph[v][i]&gt;0&amp;&amp;!Vistied[i])&#123;
        answer&#x3D;DST(i,n,jump,Vistied,Datapoint,MGraph);
        if(answer)break;
    &#125;
    return answer;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/posts/0d79969cf7e2</url>
    <content><![CDATA[<h1 id="什么是图graph"><a class="markdownIt-Anchor" href="#什么是图graph"></a> 什么是“图”(Graph)？</h1>
<img src="https://s2.loli.net/2022/05/04/LMlXENzmHRoJ1j5.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/04/zM6GO9N71ArDoHn.png" width="50%" height="50%">
<span id="more"></span>
<ul>
<li>表示“多对多”的关系
<ul>
<li>线性表：“一对一”关系，树：“一对多”关系</li>
<li>实际上，线性表和树都可以认为是图的一种特例</li>
</ul>
</li>
<li>图中包含(两种结构共同建立起图的结构)
<ul>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合</li>
<li>边是顶点对的组合：
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(v,w)∈E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v,w∈V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>，表示无向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>−</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v-w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v,w&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>表示从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>指向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span>的边(单行线)，表示有向边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo>→</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">v\rightarrow w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>不考虑重边和自回路
<ul>
<li>无重边：对无向边，两个结点之间的边只有一条</li>
<li>无自回路：对有向边，从一个顶点出发的边不能指向该顶点自身</li>
</ul>
</li>
<li>权重：如果图的边上带有权重，则称为“网络”</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/cpkFRPxv4jXlySd.png" width="50%" height="50%">
<h2 id="图的抽象数据类型定义"><a class="markdownIt-Anchor" href="#图的抽象数据类型定义"></a> 图的抽象数据类型定义</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：图(Graph)
数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
操作集：对于任意图G ∈ Graph，以及v ∈ V，e ∈ E
Graph Create():建立并返回空图;
Graph InsertVertex(Graph G,Vertex v):将v插入G;
Graph InsertEdge(Graph G,Edge e):将e插入G;
void DFS(Graph G,Vertex v):从顶点v出发深度优先遍历图G;
void BFS(Graph G,Vertex v):从顶点v出发宽度(广度)优先遍历图G;
void ShortestPath(Graph G,Vertex v,int Dist[]):计算图G中顶点v到任意其他顶点的最短距离;
void MST(Graph G):计算图G的最小生成树;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="如何在程序中表示一个图"><a class="markdownIt-Anchor" href="#如何在程序中表示一个图"></a> 如何在程序中表示一个图</h2>
<p>常用的两种方法：邻接矩阵、邻接表<br>
(除此外还有各种五花八门的方法，使用哪种取决于研究问题的特点)</p>
<h3 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h3>
<ul>
<li>使用邻接矩阵G[N][N]
<ul>
<li>N个顶点从0到N-1编号</li>
<li>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>是G中的边则G[i][j]=1，否则G[i][j]=0</li>
</ul>
</li>
<li>问题：对于无向图的存储，怎样可以省一半的空间
<ul>
<li>用一个长度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{N(N+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的一维数组A存储半个矩阵(上三角或下三角)的元素</li>
<li>则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">G_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>在A中对应的下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>i</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>+</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">\frac{i(i+1)}{2}+j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></li>
<li>在一维数组压缩后，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mi>i</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">Gij</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>之前的元素包括前i行(从0开始)i列构成的三角形内的元素，再加上第i+1行的前j个元素</li>
</ul>
</li>
<li>对于网络，只需要把G[i][j]的值由1改为定义为边<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;v_i,v_j&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>的权重即可
<ul>
<li>问题：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">v_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>之间若没有边该怎么表示？
<ul>
<li>不一定，取决于权重的取值范围</li>
<li>如使用16位带符号位的int的所能表示的最大数65535是一个比较通用的表示方法</li>
</ul>
</li>
</ul>
</li>
<li>邻接矩阵的优点
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”(有边直接相连的顶点)</li>
<li>方便计算任一顶点的“度”(从该顶点出发的总边数为“出度”，指向该顶点的边数为“入度”)
<ul>
<li>无向图：对应行(或列)非0元素的个数</li>
<li>有向图：对应行非0元素的个数是“出度”；对应列非0元素的个数是“入度”</li>
</ul>
</li>
</ul>
</li>
<li>邻接矩阵的缺点
<ul>
<li>浪费空间——存稀疏图(点很多但边很少)有大量的无效空间</li>
<li>对稠密图(特别是完全图-任意两顶点之间均有一条边，共<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>N</mi></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{(N-1)N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>条)还是很合算的</li>
<li>浪费时间——如统计稀疏图中有几条边时需要遍历大量无效空间</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/sPpoleMjQbJ14Yg.png" width="50%" height="50%">
<h3 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h3>
<ul>
<li>使用邻接表：G[N]为指针数组，对应矩阵每行一个链表，只存非0元素
<ul>
<li>对于网络，在非头结点中要增加一个记录权重的域</li>
<li>一定要够稀疏才合算啊~~~</li>
</ul>
</li>
<li>需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>个头指针<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>2</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">+2E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>个结点空间(无向图)
<ul>
<li>每条边对应存储一个结点信息，每个结点至少两个域，一个储存边中结点的信息另一个是结点指针)</li>
<li>如果指针和结点信息所占的空间相同的话，则使用邻接表存储无向图消耗的空间可以简单看作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>+</mo><mn>4</mn><mi>E</mi></mrow><annotation encoding="application/x-tex">N+4E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span>(而邻接矩阵则是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</li>
</ul>
</li>
<li>邻接表的特点
<ul>
<li>方便找任一顶点的所有“邻接点”</li>
<li>节约稀疏图的空间</li>
<li>当边数特别多时，不适合邻接表存储
<ul>
<li>对无向图：方便计算任一顶点的“度”(无向图的入度出度相等，因此只需对头结点连接的链进行遍历即可)</li>
<li>对有向图：只能计算“出度”；需要构造“逆邻接表”(存指向自己的边)来方便计算“入度”</li>
<li>并且不方便检查任意一对顶点之间是否存在边以及其邻接点</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/nsqLce1T9Mrtpl5.png" width="50%" height="50%">
<h2 id="图的实现演示"><a class="markdownIt-Anchor" href="#图的实现演示"></a> 图的实现演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;浙江大学mooc数据结构课程
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
&#x2F;* 图的邻接矩阵表示法 *&#x2F;

#define MaxVertexNum 100    &#x2F;* 最大顶点数设为100 *&#x2F;
#define INFINITY 65535        &#x2F;* ∞设为双字节无符号整数的最大值65535*&#x2F;
typedef int WeightType;        &#x2F;* 边的权值设为整型 *&#x2F;
typedef char DataType;        &#x2F;* 顶点存储的数据类型设为字符型 *&#x2F;

&#x2F;* 顶点的定义 *&#x2F;
typedef int Vertex;         &#x2F;* 用顶点下标表示顶点,为整型 *&#x2F;
&#x2F;* 边的定义 *&#x2F;
typedef struct ENode *PtrToENode;
struct ENode&#123;
    Vertex V1, V2;      &#x2F;* 有向边&lt;V1, V2&gt; V1-&gt;V2 *&#x2F;
    WeightType Weight;  &#x2F;* 权重 *&#x2F;
&#125;;
typedef PtrToENode Edge;

&#x2F;* 图结点的定义 *&#x2F;
typedef struct MGNode *PtrToMGNode;
struct MGNode&#123;
    int Nv;  &#x2F;* 顶点数 *&#x2F;
    int Ne;  &#x2F;* 边数   *&#x2F;
    WeightType G[MaxVertexNum][MaxVertexNum]; &#x2F;* 邻接矩阵，因为其中有可能要存储边的权值，所以类型为WeightType *&#x2F;
    DataType Data[MaxVertexNum];      &#x2F;* 存顶点的数据 *&#x2F;
    &#x2F;* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 *&#x2F;
&#125;;
typedef PtrToMGNode MGraph; &#x2F;* 以邻接矩阵存储的图类型 *&#x2F;

&#x2F;* 图的邻接表表示法 *&#x2F;

&#x2F;* 边的定义：同邻接矩阵 *&#x2F;
&#x2F;* 邻接点的定义 *&#x2F;
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode&#123;
    Vertex AdjV;        &#x2F;* 邻接点下标 *&#x2F;
    WeightType Weight;  &#x2F;* 边权重 *&#x2F;
    PtrToAdjVNode Next;    &#x2F;* 指向下一个邻接点的指针 *&#x2F;
&#125;;

&#x2F;* 顶点表头结点的定义 *&#x2F;
typedef struct Vnode&#123;
    PtrToAdjVNode FirstEdge;&#x2F;* 边表头指针 *&#x2F;
    DataType Data;            &#x2F;* 存顶点的数据 *&#x2F;
    &#x2F;* 注意：很多情况下，顶点无数据，此时Data可以不用出现 *&#x2F;
&#125; AdjList[MaxVertexNum];    &#x2F;* 定义一个表头结点数组，下标对应图中的所有结点，再加上图的一些其他信息就可以构成图的结构*&#x2F;

&#x2F;* 图结点的定义 *&#x2F;
typedef struct LGNode *PtrToLGNode;
struct LGNode&#123;  
    int Nv;     &#x2F;* 顶点数 *&#x2F;
    int Ne;     &#x2F;* 边数   *&#x2F;
    AdjList G;  &#x2F;* 邻接表 *&#x2F;
&#125;;
typedef PtrToLGNode LGraph; &#x2F;* 以邻接表方式存储的图类型 *&#x2F;

&#x2F;* MGraph初始化 *&#x2F;
MGraph CreateMGraph( int VertexNum )
&#123; &#x2F;* 初始化一个有VertexNum个顶点但没有边的图，顶点数必须要指定，不然无法分配邻接表的空间 *&#x2F;
    Vertex V, W;
    MGraph Graph;

    Graph &#x3D; (MGraph)malloc( sizeof(struct MGNode) );
    Graph-&gt;Nv &#x3D; VertexNum;
    Graph-&gt;Ne &#x3D; 0;
     
    &#x2F;* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) *&#x2F;
    for(V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        for(W&#x3D;0; W&lt;Graph-&gt;Nv; W++)
            Graph-&gt;G[V][W] &#x3D; 0; &#x2F;* 或INFINITY *&#x2F;
    
    return Graph;
&#125;

&#x2F;* 向MGraph中插入边 *&#x2F;
void InsertEdge( MGraph Graph, Edge E)
&#123;
    &#x2F;* 插入边 &lt;V1, V2&gt; *&#x2F;
    Graph-&gt;G[E-&gt;V1][E-&gt;V2] &#x3D; E-&gt;Weight;
    
    &#x2F;* 若是无向图，还要插入边&lt;V2, V1&gt; *&#x2F;
    Graph-&gt;G[E-&gt;V2][E-&gt;V1] &#x3D; E-&gt;Weight;
&#125;

&#x2F;* 完整地建立一个MGraph *&#x2F;
MGraph BuildMGraph()
&#123;
    MGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;

    scanf(&quot;%d&quot;, &amp;Nv);
    Graph &#x3D; CreateMGraph(Nv);
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));
    if( Graph-&gt;Ne !&#x3D; 0) &#123;
        E &#x3D; (Edge)malloc(sizeof(struct ENode));
        for(i&#x3D;0; i&lt;Graph-&gt;Ne; i++) &#123;
            scanf(&quot;%d %d %d&quot;,
                    &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);
            InsertEdge( Graph, E);
        &#125;
    &#125;
    &#x2F;* 如果顶点有数据的话，读入数据 *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        scanf(&quot; %c&quot;, &amp;(Graph-&gt;Data[V]));
    return Graph;
&#125;

&#x2F;* 简化的图的邻接矩阵实现 *&#x2F;
int G[MaxVertexNum][MaxVertexNum],Nv,Ne;
void BuildGraph_sim()
&#123;
    int i, j, v1, v2, w;

    scanf(&quot;%d&quot;, &amp;Nv);
    &#x2F;* CreateGraph *&#x2F;
    for(i&#x3D;0; i&lt;Nv; i++)
        for(j&#x3D;0;j&lt;Nv;j++)
            G[i][j] &#x3D; 0;&#x2F;* 或INFINITY *&#x2F;
    scanf(&quot;%d&quot;, &amp;Ne);
    for(i&#x3D;0; i&lt;Ne; i++) &#123;
        scanf(&quot;%d %d %d&quot;, &amp;v1, &amp;v2, &amp;w);
        &#x2F;* InsertEdge *&#x2F;
        G[v1][v2] &#x3D; w;
        G[v2][v1] &#x3D; w;
    &#125;
&#125;


LGraph CreateLGraph( int VertexNum )
&#123; 
    Vertex V;
    LGraph Graph;
    
    Graph &#x3D; (LGraph)malloc( sizeof(struct LGNode) ); &#x2F;* 建立图 *&#x2F;
    Graph-&gt;Nv &#x3D; VertexNum;
    Graph-&gt;Ne &#x3D; 0;
    &#x2F;* 初始化邻接表头指针 *&#x2F;
    &#x2F;* 注意：这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1) *&#x2F;
       for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++)
        Graph-&gt;G[V].FirstEdge &#x3D; NULL;
            
    return Graph; 
&#125;

void InsertEdge( LGraph Graph, Edge E )
&#123;
    PtrToAdjVNode NewNode;
    
    &#x2F;* 插入边 &lt;V1, V2&gt; ，&lt;V1, V2&gt;代表V1-&gt;V2，所以要将V2插入到V1作为表头的链表中*&#x2F;
    &#x2F;* 为V2建立新的邻接点 *&#x2F;
    NewNode &#x3D; (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV &#x3D; E-&gt;V2;
    NewNode-&gt;Weight &#x3D; E-&gt;Weight;
    &#x2F;* 将V2插入V1的表头 *&#x2F;
    NewNode-&gt;Next &#x3D; Graph-&gt;G[E-&gt;V1].FirstEdge; 
    &#x2F;* 注意：表头存的是之前最后一次插入的表结点，而再向表中插入边实际上是将上一次插入的表结点与这次插入的结点之间相连 *&#x2F;
    Graph-&gt;G[E-&gt;V1].FirstEdge &#x3D; NewNode;
    &#x2F;* 更新FirstEdge *&#x2F;
        
    &#x2F;* 若是无向图，还要插入边 &lt;V2, V1&gt; *&#x2F;
    &#x2F;* 为V1建立新的邻接点 *&#x2F;
    NewNode &#x3D; (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
    NewNode-&gt;AdjV &#x3D; E-&gt;V1;
    NewNode-&gt;Weight &#x3D; E-&gt;Weight;
    &#x2F;* 将V1插入V2的表头 *&#x2F;
    NewNode-&gt;Next &#x3D; Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V2].FirstEdge &#x3D; NewNode;
&#125;

LGraph BuildLGraph()
&#123;
    LGraph Graph;
    Edge E;
    Vertex V;
    int Nv, i;
    
    scanf(&quot;%d&quot;, &amp;Nv);   &#x2F;* 读入顶点个数 *&#x2F;
    Graph &#x3D; CreateLGraph(Nv); &#x2F;* 初始化有Nv个顶点但没有边的图 *&#x2F; 
    
    scanf(&quot;%d&quot;, &amp;(Graph-&gt;Ne));   &#x2F;* 读入边数 *&#x2F;
    if ( Graph-&gt;Ne !&#x3D; 0 ) &#123; &#x2F;* 如果有边 *&#x2F; 
        E &#x3D; (Edge)malloc( sizeof(struct ENode) ); &#x2F;* 建立边结点 *&#x2F; 
        &#x2F;* 读入边，格式为&quot;起点 终点 权重&quot;，插入邻接表 *&#x2F;
        for (i&#x3D;0; i&lt;Graph-&gt;Ne; i++) &#123;
            scanf(&quot;%d %d %d&quot;, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight); 
            &#x2F;* 注意：如果权重不是整型，Weight的读入格式要改 *&#x2F;
            InsertEdge( Graph, E );
        &#125;
    &#125; 

    &#x2F;* 如果顶点有数据的话，读入数据 *&#x2F;
    for (V&#x3D;0; V&lt;Graph-&gt;Nv; V++) 
        scanf(&quot; %c&quot;, &amp;(Graph-&gt;G[V].Data)); &#x2F;* 只在表头存储即可 *&#x2F;

    return Graph;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h2>
<h3 id="深度优先搜索depth-first-searchdfs"><a class="markdownIt-Anchor" href="#深度优先搜索depth-first-searchdfs"></a> 深度优先搜索(Depth First Search,DFS)</h3>
<ul>
<li>类似于树的先序遍历</li>
<li>访问一个结点后继续顺着一个当前结点连接的结点往下访问，直到没有结点可以访问，然后原路返回上一层，直到回到起点位置</li>
<li>原路返回——堆栈</li>
<li>伪代码：(递归算法为例，非递归用堆栈)</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void DFS(Vertex V)          &#x2F;&#x2F;实际上是每调用一次DFS(V)是将V所在连通分量遍历一遍，BFS同理，不连通的结点并没有遍历到
&#123;
    visited[V]&#x3D;true;        &#x2F;&#x2F;使用visited数组记录已经访问过的结点，并在每次调用函数(访问)时将当前结点状态改为已访问过
    for(V的每个邻接点W)       &#x2F;&#x2F;考察当前结点的每个邻接顶点
        if(!visited[W])     &#x2F;&#x2F;如果邻接结点没有访问过
            DFS(W);         &#x2F;&#x2F;访问该结点
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对有N个顶点、E条边的图：</p>
<ul>
<li>用邻接表存储图：时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span>
<ul>
<li>一共有n个表，表中的边各访问一次)</li>
</ul>
</li>
<li>用邻接矩阵存储图：时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="广度优先搜索breadth-first-searchbfs"><a class="markdownIt-Anchor" href="#广度优先搜索breadth-first-searchbfs"></a> 广度优先搜索(Breadth First Search,BFS)</h3>
<ul>
<li>类似于树的层序遍历</li>
<li>伪代码：(非递归算法为例)</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void BFS(Vertex V)
&#123;
    visited[V]&#x3D;true;        
    Enqueue(V,Q);          &#x2F;&#x2F;将访问的结点入队列
    while(!IsEmpty(Q))     &#x2F;&#x2F;如果队列不为空
    &#123;
        V&#x3D;Dequeue(Q);      &#x2F;&#x2F;队首元素出队列
        for(V的每个邻接点W)
            if(!visited[W]) &#x2F;&#x2F;对没有访问过的邻接点
            &#123;
                visited[W]&#x3D;true;
                Enqueue(W,Q);   &#x2F;&#x2F;将邻接点入队列
            &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对有N个顶点、E条边的图：</p>
<ul>
<li>用邻接表存储图，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N+E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li>
<li>用邻接矩阵存储图，时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>由此可见，图遍历的时间复杂度与存储方式无关</li>
</ul>
<h3 id="图的连通性"><a class="markdownIt-Anchor" href="#图的连通性"></a> 图的连通性</h3>
<ul>
<li>连通(无向图的概念)：如果从v到w存在一条无向路径，则称v和w是连通的
<ul>
<li>连通图：图中任意两顶点间均连通</li>
<li>路径：v到w的路径是一系列顶点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>v</mi><mi>n</mi></msub><mo separator="true">,</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">v,v_1,v_2,…,v_n,W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>的集合，其中任一对相邻的顶点间都有图中的边相连接
<ul>
<li>路径的长度是路径中的边数(如果带权，则是所有边的权重和)</li>
<li>如果V到W之间所有顶点都不同，则称简单路径(没有回路)</li>
<li>回路：起点等于终点的路径</li>
</ul>
</li>
</ul>
</li>
<li>连通分量：无向图的极大连通子图
<ul>
<li>极大顶点数：再加哪怕一个顶点就不连通了</li>
<li>极大边数：包含子图中所有顶点相连的所有边</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/q3mChO6lYK87I1U.png" alt="4_2.1_连通分量.png" width="50%" height="50%">
<ul>
<li>强连通(有向图的概念)：有向图中顶点v和w之间存在双向路径，则称v和w是强连通的
<ul>
<li>强连通图：有向图中任一两顶点均强连通</li>
<li>强连通分量：有向图的极大强连通子图</li>
<li>弱连通：存在路径，但不存在双向路径
<ul>
<li>判断图是否连通可以借助并查集</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/Per6wHly2aS7W9M.png" width="50%" height="50%">
<p>因此对不连通的图进行DFS、BFS时，需要在外层对图中所有结点在进行一次遍历</p>
<ul>
<li>防止极端情况如图中所有结点都不连通，都是极大连通子图</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void ListComponents(Graph G)
&#123;
    for(each V in G)
        if(!visited[V])DFS(V);&#x2F;&#x2F;或者BFS(V);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="图的遍历操作演示"><a class="markdownIt-Anchor" href="#图的遍历操作演示"></a> 图的遍历操作演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 遍历操作实现 *&#x2F;
#include &lt;stdio.h&gt;
#include &lt;queue&gt;
#define MaxVertexNum 100
#define INFINITY 65535
#define MaxSize 100
typedef int ElementType;
typedef int Vertex;
typedef int WeightType;
typedef char DataType;
typedef struct AdjVNode *PtrToAdjVNode; 
typedef struct MGNode *PtrToMGNode;
typedef struct LGNode *PtrToLGNode;
typedef struct QNode *Queue;
typedef PtrToLGNode LGraph;
typedef PtrToMGNode MGraph;
bool Visited[MaxVertexNum];
struct AdjVNode&#123;
    Vertex AdjV;       
    WeightType Weight; 
    PtrToAdjVNode Next;   
&#125;;
typedef struct Vnode&#123;
    PtrToAdjVNode FirstEdge;
    DataType Data;        
&#125; AdjList[MaxVertexNum];
struct LGNode&#123;  
    int Nv;     
    int Ne;     
    AdjList G; 
&#125;;
struct MGNode&#123;
    int Nv; 
    int Ne;  
    WeightType G[MaxVertexNum][MaxVertexNum]; 
    DataType Data[MaxVertexNum];     
&#125;;
struct Node&#123;             
    ElementType Data;
    struct Node *Next;
&#125;;
struct QNode
&#123;
    struct Node *rear;
    struct Node *front;
&#125;;
Queue CreateQueue( int );
void AddQ(Queue, ElementType);
bool IsEmpty(Queue);
ElementType DeleteQ(Queue);
&#x2F;* 邻接表存储的图 - DFS *&#x2F;

void Visit( Vertex V )
&#123;
    printf(&quot;正在访问顶点%d\n&quot;, V);
&#125;

&#x2F;* Visited[]为全局变量，已经初始化为false *&#x2F;
void DFS( LGraph Graph, Vertex V, void (*Visit)(Vertex) )
&#123;   &#x2F;* 以V为出发点对邻接表存储的图Graph进行DFS搜索 *&#x2F;
    PtrToAdjVNode W;
    
    Visit( V ); &#x2F;* 访问第V个顶点 *&#x2F;
    Visited[V] &#x3D; true; &#x2F;* 标记V已访问 *&#x2F;

    for( W&#x3D;Graph-&gt;G[V].FirstEdge; W; W&#x3D;W-&gt;Next ) &#x2F;* 对V的每个邻接点W-&gt;AdjV *&#x2F;
        if ( !Visited[W-&gt;AdjV] )    &#x2F;* 若W-&gt;AdjV未被访问 *&#x2F;
            DFS( Graph, W-&gt;AdjV, Visit );    &#x2F;* 则递归访问之 *&#x2F;
&#125;

&#x2F;* 邻接矩阵存储的图 - BFS *&#x2F;

&#x2F;* IsEdge(Graph, V, W)检查&lt;V, W&gt;是否图Graph中的一条边，即W是否V的邻接点。  *&#x2F;
&#x2F;* 此函数根据图的不同类型要做不同的实现，关键取决于对不存在的边的表示方法。*&#x2F;
&#x2F;* 例如对有权图, 如果不存在的边被初始化为INFINITY, 则函数实现如下:         *&#x2F;
bool IsEdge( MGraph Graph, Vertex V, Vertex W )
&#123;
    return Graph-&gt;G[V][W]&lt;INFINITY ? true : false;
&#125;

&#x2F;* Visited[]为全局变量，已经初始化为false *&#x2F;
void BFS ( MGraph Graph, Vertex S, void (*Visit)(Vertex) )
&#123;   &#x2F;* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 *&#x2F;
    Queue Q;     
    Vertex V, W;

    Q &#x3D; CreateQueue( MaxSize ); &#x2F;* 创建空队列, MaxSize为外部定义的常数 *&#x2F;
    &#x2F;* 访问顶点S：此处可根据具体访问需要改写 *&#x2F;
    Visit( S );
    Visited[S] &#x3D; true; &#x2F;* 标记S已访问 *&#x2F;
    AddQ(Q, S); &#x2F;* S入队列 *&#x2F;
    
    while ( !IsEmpty(Q) ) &#123;
        V &#x3D; DeleteQ(Q);  &#x2F;* 弹出V *&#x2F;
        for( W&#x3D;0; W&lt;Graph-&gt;Nv; W++ ) &#x2F;* 对图中的每个顶点W *&#x2F;
            &#x2F;* 若W是V的邻接点并且未访问过 *&#x2F;
            if ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;
                &#x2F;* 访问顶点W *&#x2F;
                Visit( W );
                Visited[W] &#x3D; true; &#x2F;* 标记W已访问 *&#x2F;
                AddQ(Q, W); &#x2F;* W入队列 *&#x2F;
            &#125;
    &#125; &#x2F;* while结束*&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>继续</title>
    <url>/posts/4facf4eea635</url>
    <content><![CDATA[<p><em><strong>每个人都背负着一个沉重的十字架，在缓慢而艰难地向前行走，突然有个人就停了下来，“上帝，这实在太沉重了，请允许我砍掉一些吧！”，于是他把十字架砍去了一小节，背负着减负的十字架继续前行，虽稍微轻松，但前路漫漫，十字架的压力让人依然感觉行走艰难，哦，上帝，让我再砍去一点点吧。感谢上帝，这样我的旅途就轻松多了。</strong></em></p>
<p><em><strong>当别人都负重奋力艰难的前行时，他哼着欢快的歌谣，不费力走到了队伍的前头，并暗暗得意于自己的聪明举措。突然前方出现一个宽大的沟壑，眼看着无计可施。这时，后面赶上来的人用他们的十字架搭成了桥梁，顺利渡过。当他也尝试着效仿他们时，才发现他的十字架远远达不到对岸。当别人都已渐渐远行，他只能停在原地懊恼不已。“如果当初不偷懒，我本也可以和他们一样，跨过这道沟壑的”，可是人生很多事情事发后再去后悔已经晚了……</strong></em></p>
<p><em><strong>其实我们每个人都背负着各种各样的十字架，在艰难前行。它也许是我们的学习、工作中的压力，也许是我们必须承担的责任和义务。</strong></em></p>
<p><em><strong>也许放弃了一切，我们会暂时过得很轻松，但是当人生出现沟坎时，我们将很难跨越。生命中很多东西看似承受会很痛苦，但是如果你面对了、抗过去了，也许就云开日出了。我们的高度也将在这个过程中得到提升！</strong></em></p>
<p><em><strong>所以，请勇敢背负起属于自己的十字架，它将帮助我们跨过沟壑、穿过黑暗、走向成功的彼岸！</strong></em></p>
<p><em><strong>也许，每一个你讨厌的现在，都有一个不够努力的曾经。只要还没有到达终点，努力从现在开始就不晚。</strong></em></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列、堆、哈夫曼树</title>
    <url>/posts/b807a686acbe</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 15%;
}
table th:nth-of-type(2){
width: 15%;
;
}
table th:nth-of-type(3){
width: 15%;
}
table th:nth-of-type(4){
width: 15%;
}
table th:nth-of-type(5){
width: 15%;
}
table th:nth-of-type(6){
width: 15%;
}
</style>
<h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1>
<p>优先队列(Priority Queue)：特殊的“队列”，取出元素的顺序是依照元素的优先权(关键字)大小，而不是元素进入队列的先后顺序<br>
问题：如何组织优先队列？</p>
<ul>
<li>一般的数组、链表？</li>
<li>有序的数组或链表？</li>
<li>二叉搜索树、AVL树？</li>
</ul>
<h2 id="优先队列的实现"><a class="markdownIt-Anchor" href="#优先队列的实现"></a> 优先队列的实现</h2>
<p>若采用数组或链表实现优先队列</p>
<ul>
<li>数组：
<ul>
<li>插入——元素总是插入尾部——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>删除——查找最大(或最小)的关键字——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li>从数组中删去关键字需要移动其他元素——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>链表：
<ul>
<li>插入——元素总是插入链表的头部——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>删除——查找最大(或最小)关键字——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li>删去结点——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
<li>有序数组：
<ul>
<li>找到合适的位置——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>或<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li>移动元素并插入——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>删去最后一个元素(最大或最小)——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>有序链表：
<ul>
<li>插入——找到合适的位置——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>
<ul>
<li>插入元素——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>删除——删除首元素或尾元素——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Θ(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<p>问题：是否可以采用二叉树存储结构？</p>
<ul>
<li>
<p>使用二叉搜索树？</p>
<ul>
<li>可以采用二叉搜索树，但是二叉搜索树在删除结点后不会对树的高度进行调整(注意是不带平衡操作版本的)</li>
<li>所以在删除多个最大(最小)元素后树的形态就歪掉了</li>
</ul>
</li>
<li>
<p>如果采用二叉树结构，应更关注插入还是删除？</p>
<ul>
<li>树结点顺序如何安排？</li>
<li>树是怎样的结构？</li>
</ul>
</li>
</ul>
<p>优先队列的<strong>完全二叉树表示</strong>——堆</p>
<h1 id="堆的定义"><a class="markdownIt-Anchor" href="#堆的定义"></a> 堆的定义</h1>
<p>堆(Heap)：两个特性</p>
<ul>
<li>结构性：用数组表示的完全二叉树存储(此处特指二叉堆)</li>
<li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)
<ul>
<li>“最大堆(MaxHeap)”，也称“大顶堆”：根结点是最大值</li>
<li>“最小堆(MinHeap)”，也称“小顶堆”：根结点是最小值</li>
</ul>
</li>
<li>注意，从根结点到任一结点的路径上结点序列的有序性</li>
</ul>
<h2 id="堆的抽象数据类型描述"><a class="markdownIt-Anchor" href="#堆的抽象数据类型描述"></a> 堆的抽象数据类型描述</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：最大堆(MaxHeap)
数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值
操作集：最大堆H ∈ MaxHeap，元素item ∈ ElementType，主要操作有：
MaxHeap Create(int MaxSize):创建一个空的最大堆;
Boolean IsFull(MaxHeap H):判断最大堆H是否已满;
Insert(MaxHeap H,ElementType item):将元素item插入最大堆H;
Boolean IEmpty(MaxHeap H):判断最大堆H是否为空;
ElementType DeleteMax(MaxHeap H):返回H中最大元素(高优先级);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆的顺序存储实现以最大堆为例"><a class="markdownIt-Anchor" href="#堆的顺序存储实现以最大堆为例"></a> 堆的顺序存储实现(以最大堆为例)</h2>
<pre class="line-numbers language-none"><code class="language-none">typedef struct HeapStruct *MaxHeap;
struct HeapStruct
&#123; 
    ElementType Elements[MaxSize];       &#x2F;&#x2F;存储堆元素的数组
    int Size,Capacity;                   &#x2F;&#x2F;堆的当前元素个数和最大容量
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆的实现以最大堆为例"><a class="markdownIt-Anchor" href="#堆的实现以最大堆为例"></a> 堆的实现(以最大堆为例)</h2>
<h3 id="堆的创建空堆"><a class="markdownIt-Anchor" href="#堆的创建空堆"></a> 堆的创建(空堆)</h3>
<pre class="line-numbers language-none"><code class="language-none">MaxHeap Create(int MaxSize)                                 &#x2F;&#x2F;创建容量为MaxSize的空的最大堆
&#123;
    MaxHeap H&#x3D;(MaxHeap)malloc(sizeof(struct HeapStruct));
    H-&gt;Elements&#x3D;(ElementType*)malloc((MaxSize+1)*sizeof(ElementType));&#x2F;&#x2F;因为堆的元素从下标为1开始存放所以申请MaxSize+1
    H-&gt;Size&#x3D;0,H-&gt;Capacity&#x3D;MaxSize,H-&gt;Elements[0]&#x3D;MaxData;   &#x2F;&#x2F;定义“哨兵”为a大于堆中所有可能元素的值，便于以后更快操作
    &#x2F;&#x2F;哨兵元素在堆中的必要性：因为堆元素在插入时会一直向上比较，当比较到根结点的时候如果没有哨兵元素就会发生越界
    return H;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将其中的MaxData换成小于对中所有元素的MinData，同样适用于创建最小堆</p>
<h3 id="堆的插入"><a class="markdownIt-Anchor" href="#堆的插入"></a> 堆的插入</h3>
<p>最大堆的插入算法：将新增结点插入到从其父结点到根结点的有序序列中<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<pre class="line-numbers language-none"><code class="language-none">void Insert(MaxHeap H,ElementType item)
&#x2F;&#x2F;将元素item插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵
&#x2F;&#x2F;哨兵元素不小于堆中的最大元素，控制循环顺利结束
&#123;
    int i;
    if(IsFull(H))&#123;
        cout&lt;&lt;&quot;最大堆已满&quot;&lt;&lt;endl;
        return;
    &#125;
    i&#x3D;++H-&gt;Size;                                           &#x2F;&#x2F;i的初值为最大堆中当前最后一个元素的后一个位置
    for(;item&gt;H-&gt;Elements[i&#x2F;2];i&#x2F;&#x3D;2)  &#x2F;&#x2F;将item值与Elements[i]所在子树的根结点进行比较，如果大的话继续向上比较(将i移到i&#x2F;2)
        H-&gt;Elements[i]&#x3D;H-&gt;Elements[i&#x2F;2];&#x2F;&#x2F;同时如果item比根结点就将根结点移到i的位置(向下过滤结点)，比逐个交换数据效率高
    H-&gt;Elements[i]&#x3D;item;                                   &#x2F;&#x2F;循环跳出后，将item插入i当前位置
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>循环条件改为item&lt;H-&gt;Elements[i/2]就是最小堆插入</p>
<h3 id="堆的删除"><a class="markdownIt-Anchor" href="#堆的删除"></a> 堆的删除</h3>
<p>最大堆的删除算法：取出根结点(最大值)元素，同时取堆的最后一个结点(为了保持完全二叉树的结构特性)<br>
将其移动到根结点处，找出根结点最大的孩子与其进行比较，如果比根结点大就交换两个结点，直到根结点关键字比所有孩子都大<br>
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(N)=O(logN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<pre class="line-numbers language-none"><code class="language-none">ElementType DeleteMax(MaxHeap H)
&#123;
    int Parent,Child;
    ElementType MaxItem,temp;
    if(IsEmpty)
    &#123;
        cout&lt;&lt;&quot;最大堆已为空&quot;&lt;&lt;endl;
        return -1;
    &#125;
    MaxItem&#x3D;H-&gt;Elements[0];                               &#x2F;&#x2F;取出根结点最大值
    temp&#x3D;H-&gt;Elements[H-&gt;Size--];                          &#x2F;&#x2F;用最大堆中最后一个元素从根结点开始向上过滤下层结点
    for(Parent&#x3D;1;Parent*2&lt;&#x3D;H-&gt;Size;Parent&#x3D;Child)
    &#123;
        Child&#x3D;Parent*2;
        if(Child!&#x3D;H-&gt;Size&amp;&amp;(H-&gt;Elements[Child]&lt;H-&gt;Elements[Child+1]))Child++;&#x2F;&#x2F;Child&#x3D;&#x3D;H-&gt;Size说明左孩子是最后的元素
        if(temp&gt;&#x3D;H-&gt;Elements[Child])break;                &#x2F;&#x2F;当temp大于两个孩子时跳出循环
        else H-&gt;Elements[Parent]&#x3D;H-&gt;Elements[Child];      &#x2F;&#x2F;移动temp元素到下一层
    &#125;
    H-&gt;Elements[Parent]&#x3D;temp;&#x2F;&#x2F;将temp的值赋给当前位置(此时该位置的值一定是无效的，因为之前的结点要么被删除，要么移到了上层结点)
    return MaxItem;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="堆的建立"><a class="markdownIt-Anchor" href="#堆的建立"></a> 堆的建立</h3>
<p>最大堆的建立<br>
堆的一个很重要的应用——堆排序</p>
<ul>
<li>需要建立最大(最小)堆</li>
</ul>
<p>建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中</p>
<ul>
<li>算法1(自顶向下)：通过插入操作，将N个元素一一相继插入到一个初始为空的堆中去
<ul>
<li>其最大时间代价为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>算法2(自底向上)：在线性时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>下建立最大堆
<ul>
<li>核心思想：借鉴删除操作中调整堆的方法
<ul>
<li>在删除中是在左右子树都已经是堆的情况下调整根结点</li>
<li>因此，创建堆的过程可以反过来，从叶子结点往上开始调整根结点，保证下面的都是堆，然后再向上调整</li>
</ul>
</li>
<li>将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>调整结点位置(使用类似删除结点中的下滤调整算法，从根结点依次向下调整)，已满足最大堆的有序特性</li>
<li>建堆从Size/2开始，即第一个非叶结点开始建堆，倒数第二层需要比较1次，倒数第三层需要比较2次……直到根结点需要比较lgN次
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mn>2</mn><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">T(N)=N/4+2N/8+…+2(lgN-1)+lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>+</mo><mn>2</mn><mi>N</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo>+</mo><mo>…</mo><mo>+</mo><mn>2</mn><mo stretchy="false">(</mo><mi>h</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>h</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(N)=N/4+2N/8+…+2(h-2)+h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>由错位相减法
<ul>
<li>$2T(N)-T(N)=N/2+N/4+N/8+…+2-(h-1)&lt; N-lgN+1&lt; N $</li>
</ul>
</li>
<li>因此，该算法复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>此时在一棵调整好的堆上，不同层数h的结点对应的最多交换次数为</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">层数</th>
<th style="text-align:center">结点数</th>
<th style="text-align:center">最多交换次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">lgN-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">lgN</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>4</mn></mrow><annotation encoding="application/x-tex">N/4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">4</span></span></span></span></td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">lgN+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">N/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord">2</span></span></span></span></td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<img src="https://s2.loli.net/2022/05/04/aDNR7PdcOhYypAF.png" width="50%" height="50%">
<p>自底向上算法建立最大堆</p>
<pre class="line-numbers language-none"><code class="language-none">void PercDownBuild(MaxHeap H)
&#123;
    int Parent,Child;
    ElementType temp;
    for(int i&#x3D;H-&gt;Size&#x2F;2;i&gt;&#x3D;1;i--)
    &#123;
        temp&#x3D;H-&gt;Elements[i];                             
        for(Parent&#x3D;i;Parent*2&lt;&#x3D;H-&gt;Size;Parent&#x3D;Child)
        &#123;
            Child&#x3D;Parent*2;
            if（Child!&#x3D;H-&gt;Size&amp;&amp;(H-&gt;Elements[Child]&lt;H-&gt;Elements[Child+1])）Child++;
            if(temp&gt;&#x3D;H-&gt;Elements[Child])break;             
            else H-&gt;Elements[Parent]&#x3D;H-&gt;Elements[Child];     
        &#125;
        H-&gt;Elements[Parent]&#x3D;temp;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆的实现演示"><a class="markdownIt-Anchor" href="#堆的实现演示"></a> 堆的实现演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;浙江大学mooc数据结构
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
typedef int ElementType;
typedef struct HNode *Heap; &#x2F;* 堆的类型定义 *&#x2F;
struct HNode &#123;
    ElementType *Data; &#x2F;* 存储元素的数组 *&#x2F;
    int Size;          &#x2F;* 堆中当前元素个数 *&#x2F;
    int Capacity;      &#x2F;* 堆的最大容量 *&#x2F;
&#125;;
typedef Heap MaxHeap; &#x2F;* 最大堆 *&#x2F;
typedef Heap MinHeap; &#x2F;* 最小堆 *&#x2F;

#define MAXDATA 1000  &#x2F;* 该值应根据具体情况定义为大于堆中所有可能元素的值 *&#x2F;

MaxHeap CreateHeap( int MaxSize )
&#123; &#x2F;* 创建容量为MaxSize的空的最大堆 *&#x2F;

    MaxHeap H &#x3D; (MaxHeap)malloc(sizeof(struct HNode));
    H-&gt;Data &#x3D; (ElementType *)malloc((MaxSize+1)*sizeof(ElementType));
    H-&gt;Size &#x3D; 0;
    H-&gt;Capacity &#x3D; MaxSize;
    H-&gt;Data[0] &#x3D; MAXDATA; &#x2F;* 定义&quot;哨兵&quot;为大于堆中所有可能元素的值*&#x2F;

    return H;
&#125;

bool IsFull( MaxHeap H )
&#123;
    return (H-&gt;Size &#x3D;&#x3D; H-&gt;Capacity);
&#125;

bool Insert( MaxHeap H, ElementType X )
&#123; &#x2F;* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 *&#x2F;
    int i;
 
    if ( IsFull(H) ) &#123; 
        printf(&quot;最大堆已满&quot;);
        return false;
    &#125;
    i &#x3D; ++H-&gt;Size; &#x2F;* i指向插入后堆中的最后一个元素的位置 *&#x2F;
    for ( ; H-&gt;Data[i&#x2F;2] &lt; X; i&#x2F;&#x3D;2 )
        H-&gt;Data[i] &#x3D; H-&gt;Data[i&#x2F;2]; &#x2F;* 上滤X *&#x2F;
    H-&gt;Data[i] &#x3D; X; &#x2F;* 将X插入 *&#x2F;
    return true;
&#125;

#define ERROR -1 &#x2F;* 错误标识应根据具体情况定义为堆中不可能出现的元素值 *&#x2F;

bool IsEmpty( MaxHeap H )
&#123;
    return (H-&gt;Size &#x3D;&#x3D; 0);
&#125;

ElementType DeleteMax( MaxHeap H )
&#123; &#x2F;* 从最大堆H中取出键值为最大的元素，并删除一个结点 *&#x2F;
    int Parent, Child;
    ElementType MaxItem, X;

    if ( IsEmpty(H) ) &#123;
        printf(&quot;最大堆已为空&quot;);
        return ERROR;
    &#125;

    MaxItem &#x3D; H-&gt;Data[1]; &#x2F;* 取出根结点存放的最大值 *&#x2F;
    &#x2F;* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 *&#x2F;
    X &#x3D; H-&gt;Data[H-&gt;Size--]; &#x2F;* 注意当前堆的规模要减小 *&#x2F;
    for( Parent&#x3D;1; Parent*2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child ) &#123;
        Child &#x3D; Parent * 2;
        if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )
            Child++;  &#x2F;* Child指向左右子结点的较大者 *&#x2F;
        if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;* 找到了合适位置 *&#x2F;
        else  &#x2F;* 下滤X *&#x2F;
            H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];
    &#125;
    H-&gt;Data[Parent] &#x3D; X;

    return MaxItem;
&#125; 

&#x2F;*----------- 建造最大堆 -----------*&#x2F;
void PercDown( MaxHeap H, int p )
&#123; &#x2F;* 下滤：将H中以H-&gt;Data[p]为根的子堆调整为最大堆 *&#x2F;
    int Parent, Child;
    ElementType X;

    X &#x3D; H-&gt;Data[p]; &#x2F;* 取出根结点存放的值 *&#x2F;
    for( Parent&#x3D;p; Parent*2&lt;&#x3D;H-&gt;Size; Parent&#x3D;Child ) &#123;
        Child &#x3D; Parent * 2;
        if( (Child!&#x3D;H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+1]) )
            Child++;  &#x2F;* Child指向左右子结点的较大者 *&#x2F;
        if( X &gt;&#x3D; H-&gt;Data[Child] ) break; &#x2F;* 找到了合适位置 *&#x2F;
        else  &#x2F;* 下滤X *&#x2F;
            H-&gt;Data[Parent] &#x3D; H-&gt;Data[Child];
    &#125;
    H-&gt;Data[Parent] &#x3D; X;
&#125;

void BuildHeap( MaxHeap H )
&#123; &#x2F;* 调整H-&gt;Data[]中的元素，使满足最大堆的有序性  *&#x2F;
  &#x2F;* 这里假设所有H-&gt;Size个元素已经存在H-&gt;Data[]中 *&#x2F;

    int i;

    &#x2F;* 从最后一个结点的父节点开始，到根结点1 *&#x2F;
    for( i &#x3D; H-&gt;Size&#x2F;2; i&gt;0; i-- )
        PercDown( H, i );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="哈夫曼树"><a class="markdownIt-Anchor" href="#哈夫曼树"></a> 哈夫曼树</h1>
<p>什么是哈夫曼树?<br>
实例：将百分制的成绩换成五分制的成绩<br>
算法1:</p>
<pre class="line-numbers language-none"><code class="language-none">if(score&lt;60)grade&#x3D;1;
else if(score&lt;70)grade&#x3D;2;
else if(score&lt;80)grade&#x3D;3;
else if(score&lt;90)grade&#x3D;4;
else grade&#x3D;5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果考虑学生成绩的分布的概率：</p>
<table>
<thead>
<tr>
<th style="text-align:center">分数段</th>
<th style="text-align:center">0-59</th>
<th style="text-align:center">60-69</th>
<th style="text-align:center">70-79</th>
<th style="text-align:center">80-89</th>
<th style="text-align:center">90-100</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">比例</td>
<td style="text-align:center">0.05</td>
<td style="text-align:center">0.15</td>
<td style="text-align:center">0.40</td>
<td style="text-align:center">0.30</td>
<td style="text-align:center">0.10</td>
</tr>
</tbody>
</table>
<p>查找效率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.05</mn><mo>×</mo><mn>1</mn><mo>+</mo><mn>0.15</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>0.4</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>0.3</mn><mo>×</mo><mn>4</mn><mo>+</mo><mn>0.1</mn><mo>×</mo><mn>4</mn><mo>=</mo><mn>3.15</mn></mrow><annotation encoding="application/x-tex">0.05\times1+0.15\times2+0.4\times3+0.3\times4+0.1\times4=3.15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span></span></span></span></p>
<p>算法2:</p>
<pre class="line-numbers language-none"><code class="language-none">if(score&lt;80)&#123;
    if(score&lt;70)
    if(score&lt;60)grade&#x3D;1;
    else grade&#x3D;2;
    else grade&#x3D;3;
&#125;else if(score&lt;90)grade&#x3D;4;
else grade&#x3D;5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查找效率：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0.05</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>0.15</mn><mo>×</mo><mn>3</mn><mo>+</mo><mn>0.4</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>0.3</mn><mo>×</mo><mn>2</mn><mo>+</mo><mn>0.1</mn><mo>×</mo><mn>2</mn><mo>=</mo><mn>2.2</mn></mrow><annotation encoding="application/x-tex">0.05\times3+0.15\times3+0.4\times2+0.3\times2+0.1\times2=2.2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">0</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">.</span><span class="mord">2</span></span></span></span></p>
<p>启示：根据结点不同的查找效率构造更有效的搜索树</p>
<h2 id="哈夫曼树的定义"><a class="markdownIt-Anchor" href="#哈夫曼树的定义"></a> 哈夫曼树的定义</h2>
<p>带权路径长度(WPL)：设二叉树有n个叶子结点，每个叶子结点带有权值wk，从根结点到每个叶子结点的长度为lk，<br>
则每个叶子结点的带权路径长度之和就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi>P</mi><mi>L</mi><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>w</mi><mi>k</mi></msub><msub><mi>l</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">WPL=\sum_{k=1}^{n}w_kl_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>
最优二叉树或哈夫曼树(Huffman Tree)：WPL最小的二叉树</p>
<h2 id="哈夫曼树的特点"><a class="markdownIt-Anchor" href="#哈夫曼树的特点"></a> 哈夫曼树的特点</h2>
<ul>
<li>没有度为1的结点</li>
<li>n个叶子的哈夫曼树共有2n-1个结点(n个叶子结点，n-1个度为2的结点)</li>
<li>哈夫曼树的任意非叶子结点的左右子树交换后仍然是哈夫曼树</li>
<li>对同一组权值{w1,w2,…,wn}存在同构的多棵哈夫曼树</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/fN8Ml6vsmzBbt2X.png" width="50%" height="50%">
<h2 id="哈夫曼树的建立"><a class="markdownIt-Anchor" href="#哈夫曼树的建立"></a> 哈夫曼树的建立</h2>
<p>构造哈夫曼树的算法：每次将权值最小的两棵二叉树合并</p>
<ul>
<li>从结点序列中取出权值最小的和次小的两个节点分别作为树的左子树和右子树
<ul>
<li>构造存储哈夫曼树节点的最小堆(找到树中最小的结点)</li>
</ul>
</li>
<li>两个节点权值的和作为根节点的权值，将新构造的树插入到哈夫曼树中，并删除原来的两个节点
<ul>
<li>实现堆删除、插入操作</li>
</ul>
</li>
<li>从剩下n-1(每次删除两个结点，新增一个结点)个二叉树中取出最小的和次小的节点重复上述操作
<ul>
<li>构造哈夫曼树</li>
</ul>
</li>
</ul>
<h2 id="哈夫曼树链式存储实现"><a class="markdownIt-Anchor" href="#哈夫曼树链式存储实现"></a> 哈夫曼树链式存储实现：</h2>
<pre class="line-numbers language-none"><code class="language-none">typedef struct TreeNode *HuffmanTree;
struct TreeNode
&#123;
    int Weight;
    HuffmanTree Left,Right;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="哈夫曼编码"><a class="markdownIt-Anchor" href="#哈夫曼编码"></a> 哈夫曼编码</h2>
<p>实例：给定一个字符串，如何对字符进行编码，可以使得该字符串的编码存储空间最少？</p>
<ul>
<li>假设有一段文本，包含58个字符，并由以下7个字符构成：a,e,i,s,t,空格(sp),换行(nl);</li>
<li>这7个字符出现的次数不同，那么如何对这7个字符进行编码，使得总编码空间最少？</li>
</ul>
<p>分析：</p>
<ul>
<li>用等长ASCII编码(1字节)：58*8=464位</li>
<li>用等长3位编码：58*3=174位(一共7种字符，使用3位就可以完全表示所有字符了)</li>
<li>不等长编码：出现频率高的字符用的编码短些，出现频率低的字符则编码长一些</li>
<li>进行不等长编码如何避免二义性？
<ul>
<li>前缀码(prefix code)：任何字符的编码都不是另一字符编码的前缀
<ul>
<li>如：a(1)，s(101)，t(0)，此时a就是s的前缀，那么二进制字符序列101就有两种不同解释：ata和s</li>
<li>前缀码就消除了这种二义性，可以无二义地解码</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>使用二叉树进行编码</p>
<ul>
<li>机器码——&gt;二进制——&gt;二叉树
<ul>
<li>左右分支：0,1</li>
<li>字符只在叶子结点上，此时一个字符就不会是另一个字符的前缀
<ul>
<li>如果前面都相同则至少最后一位是不同的，反之如果用子树根结点表示字符，就会存在前缀的情况)</li>
</ul>
</li>
<li>假设有一个字符串aaaxuaxz，四个字符频率为：a:4,u:1,x:2,z:1
<ul>
<li>一种满足哈夫曼编码要求的编码：00010111010110</li>
<li>Cost=1 * 4 + 2 * 2 + 3 *(1+1)=14</li>
</ul>
</li>
<li>Cost(字符长度，编码存储空间)的实质：对应二叉树的WPL
<ul>
<li>存储空间最少——&gt;哈夫曼树</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/04/TWuLzVOoAqKwiGf.png" width="50%" height="50%">
<h2 id="哈夫曼树实现及演示"><a class="markdownIt-Anchor" href="#哈夫曼树实现及演示"></a> 哈夫曼树实现及演示</h2>
<p>哈夫曼树建立的关键：找到序列中最小和次小的两个元素——&gt;优先队列——&gt;堆</p>
<ul>
<li>借助最小堆实现</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">typedef struct HeapStruct *MinHeap;
typedef struct TreeNode *HuffmanTree;
typedef HuffmanTree ElementType;
struct TreeNode
&#123;
    int Weight;
    HuffmanTree Left,Right;
&#125;;
struct HeapStruct
&#123; 
    ElementType Elements*;   
    int Size,Capacity;        
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建用于建立哈夫曼树的最小堆</p>
<pre class="line-numbers language-none"><code class="language-none">MinHeap Create(int MaxSize)
&#123;
    MinHeap H&#x3D;(MinHeap)malloc(sizeof(struct HeapStruct));
    H-&gt;Elements*&#x3D;(ElementType*)malloc((MaxSize+1)sizeof(ElementType));
    H-&gt;Size&#x3D;0,H-&gt;Capacity&#x3D;MaxSize;
    H-&gt;Elements[0]-&gt;Weight&#x3D;MinData,H-&gt;Elements[0]-&gt;Left&#x3D;H-&gt;Elements[0]-&gt;Right&#x3D;NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最小堆插入</p>
<pre class="line-numbers language-none"><code class="language-none">void InsertMin(MaxHeap H,ElementType T)
&#123;
    if(isFull(H))
    &#123;
        cout&lt;&lt;&quot;最小堆已满&quot;&lt;&lt;endl;
        return;
    &#125;
    for(int i&#x3D;++H-&gt;Size;T-&gt;Weight&lt;H-&gt;Elements[i&#x2F;2];i&#x2F;&#x3D;2)
        H-&gt;Elements[i]&#x3D;H-&gt;Elements[i&#x2F;2];
    H-&gt;Elements[i]&#x3D;T;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最小堆删除</p>
<pre class="line-numbers language-none"><code class="language-none">MinHeap DeleteMin(MinHeap H)
&#123;
    int Parent,Child;
    ElementType tmp,minheap;
    if(isEmpty(H))
    &#123;
        cout&lt;&lt;&quot;最小堆已空&quot;&lt;&lt;endl;
        return NULL;
    &#125;
    minheap&#x3D;H-&gt;Elements[0],tmp&#x3D;H-&gt;Elements[H-&gt;Size--];
    for(Parent&#x3D;1;Parent*2&lt;&#x3D;H-&gt;Size;Parent&#x3D;child)
    &#123;
        Child&#x3D;Parent*2;
        if(H-&gt;Elements[Child]-&gt;Weight&gt;H-&gt;Elements[Child+1]-&gt;Weight)Child++;
        if(T-&gt;Weight&lt;&#x3D;H-&gt;Elements[Child]-&gt;Weight)break;
        else H-&gt;Elements[Parent]&#x3D;H-&gt;Elements[Child];
    &#125;
    H-&gt;Elements[Parent]&#x3D;T;
    return minheap;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最小堆建立</p>
<pre class="line-numbers language-none"><code class="language-none">BuildMinHeap(MinHeap H)
&#123;
    int Parent,Child;
    ElementType tmp;
    for(int i&#x3D;H-&gt;Size&#x2F;2;i&gt;&#x3D;1;i--)
    &#123;
        tmp&#x3D;H-&gt;Elements[i];
        for(Parent&#x3D;i;Parent*2&lt;&#x3D;H-&gt;Size;Parent&#x3D;child)
        &#123;
            Child&#x3D;Parent*2;
            if(H-&gt;Elements[Child]-&gt;Weight&gt;H-&gt;Elements[Child+1]-&gt;Weight)Child++;
            if(T-&gt;Weight&lt;&#x3D;H-&gt;Elements[Child]-&gt;Weight)break;
            else H-&gt;Elements[Parent]&#x3D;H-&gt;Elements[Child];
        &#125;
        H-&gt;Elements[Parent]&#x3D;T;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>建立哈夫曼树</p>
<ul>
<li>整体时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlgN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">HuffmanTree Huffman(MinHeap H)
&#x2F;&#x2F;假设H-&gt;Size个权值已经存在H-&gt;Elements[]-&gt;Weight中
&#123;
    HuffmanTree T;
    BuildMinHeap(H);              &#x2F;&#x2F;将权值调整为最小堆
    while(H-&gt;Size&gt;0)              &#x2F;&#x2F;共进行H-&gt;Size-1次的合并
    &#123;
        T&#x3D;(HuffmanTree)malloc(sizeof(struct TreeNode)); &#x2F;&#x2F;建立新结点
        T-&gt;Left&#x3D;DeleteMin(H);                           &#x2F;&#x2F;从堆中删除一个最小结点作为新哈夫曼树结点的左孩子
        T-&gt;Right&#x3D;DeleteMin(H);                          &#x2F;&#x2F;从堆中删除一个次小结点作为新哈夫曼树结点的右孩子
        T-&gt;Weight&#x3D;T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight;     &#x2F;&#x2F;计算新权值
        InsertMin(H,T-&gt;Weight);                         &#x2F;&#x2F;将新T插入堆
    &#125;
    T&#x3D;DeleteMin(H);                                     &#x2F;&#x2F;最后第n次剩的那个结点是哈夫曼树根结点
    return T;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树、平衡二叉树</title>
    <url>/posts/309cccadf437</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 12%;
}
table th:nth-of-type(2){
width: 8%;
;
}
table th:nth-of-type(3){
width: 8%;
}
table th:nth-of-type(4){
width: 8%;
}
table th:nth-of-type(5){
width: 8%;
}
table th:nth-of-type(6){
width: 8%;
}
table th:nth-of-type(7){
width: 8%;
}
table th:nth-of-type(8){
width: 8%;
}
table th:nth-of-type(9){
width: 8%;
}
table th:nth-of-type(10){
width: 8%;
}
table th:nth-of-type(11){
width: 8%;
}
</style>
<h1 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h1>
<p>由查找问题：针对静态查找和动态查找，数据应如何组织</p>
<ul>
<li>需要特定的数据读取、插入和删除方式</li>
</ul>
<span id="more"></span>
<h2 id="二叉搜索树的定义"><a class="markdownIt-Anchor" href="#二叉搜索树的定义"></a> 二叉搜索树的定义</h2>
<p>二叉搜索树(BST,Binary Search Tree)，也称二叉排序树或二叉查找树<br>
一棵二叉搜索树，可以为空；如果不为空，满足以下性质：</p>
<ul>
<li>非空左子树的所有键值小于其根结点的键值</li>
<li>非空右子树的所有键值大于其根结点的键值</li>
<li>左、右子树都是二叉搜索树</li>
</ul>
<h2 id="二叉搜索树操作集中的特殊函数"><a class="markdownIt-Anchor" href="#二叉搜索树操作集中的特殊函数"></a> 二叉搜索树操作集中的特殊函数</h2>
<pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType X,BinTree BST):从二叉搜索树BST中查找元素X，返回其所在结点的地址;
Position FindMin(BinTree BST):从二叉搜索树BST中查找返回最小元素所在结点的地址;
Position FindMax(BinTree BST):从二叉搜索树BST中查找返回最大元素所在结点的地址;
BinTree Insert(ElementType X,BinTree BST):向二叉搜索树BST中插入元素X;
BinTree Delete(ElementType X,BinTree BST):从二叉搜索树BST中删除元素X;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="二叉搜索树操作集"><a class="markdownIt-Anchor" href="#二叉搜索树操作集"></a> 二叉搜索树操作集</h1>
<h2 id="二叉搜索树的查找操作find"><a class="markdownIt-Anchor" href="#二叉搜索树的查找操作find"></a> 二叉搜索树的查找操作：Find</h2>
<ul>
<li>查找从根结点开始，如果树为空，返回NULL</li>
<li>若搜索树非空，则根结点关键字和X进行比较，并进行不同的操作
<ul>
<li>若X小于根结点的键值，只需在左子树中继续搜索</li>
<li>若X大于根结点的键值，在右子树中继续搜索</li>
<li>若两者比较结果相等，搜索完成，返回指向此结点的指针</li>
<li>查找的效率取决于树的深度</li>
</ul>
</li>
</ul>
<p>Find操作的递归算法</p>
<pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType X,BinTree BST)             &#x2F;&#x2F;尾递归：在程序要返回的时候递归，从遍历的角度上讲都可以用循环实现
&#123;
    if(!BST)return NULL;
    if(X&lt;BST-&gt;Data)return Find(X,BST-&gt;Left);         &#x2F;&#x2F;在左子树中继续查找
    else if(X&gt;BST-&gt;Data)return Find(X,BST-&gt;Right);   &#x2F;&#x2F;在右子树中继续查找
    else return BST;                                 &#x2F;&#x2F;查找成功，返回找到结点的地址  
&#125;   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Find操作的非递归算法</p>
<pre class="line-numbers language-none"><code class="language-none">Position Find(ElementType X,BinTree BST)
&#123;
    if(!BST)return NULL;
    while(BST)
    &#123;
        if(X&lt;BST-&gt;Data)BST&#x3D;BST-&gt;Left;
        else if(X&gt;BST-&gt;Data)BST&#x3D;BST-&gt;Right;
        else return BST;
    &#125;
    return NULL;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树查找最大和最小元素操作findminfindmax"><a class="markdownIt-Anchor" href="#二叉搜索树查找最大和最小元素操作findminfindmax"></a> 二叉搜索树查找最大和最小元素操作：FindMin，FindMax</h2>
<ul>
<li>最大元素一定是在数的最右分支的端结点上</li>
<li>最小元素一定是在数的最左分支的端结点上</li>
</ul>
<p>FindMin操作的递归算法/FindMax操作的非递归算法(二者原理完全相同，可互相转化)</p>
<pre class="line-numbers language-none"><code class="language-none">Position FindMin(BinTree BST)
&#123;
    if(!BST)return NULL;                           &#x2F;&#x2F;空二叉搜索树，返回NULL
    else if(!BST-&gt;Left)return BST;                 &#x2F;&#x2F;找到最左叶结点并返回
    else return FindMin(BST-&gt;Left);                &#x2F;&#x2F;沿左分支继续查找
&#125;
Position FindMax(BinTree BST)
&#123;
    while(BST-&gt;Right)BST&#x3D;BST-&gt;Right;              &#x2F;&#x2F;沿右分支继续查找，直到最右结点
    return BST;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的插入操作insert"><a class="markdownIt-Anchor" href="#二叉搜索树的插入操作insert"></a> 二叉搜索树的插入操作：Insert</h2>
<p>关键是要找到元素应该插入的位置，可以采用与Find类似的方法</p>
<p>Insert操作的递归算法(非递归算法同理)</p>
<pre class="line-numbers language-none"><code class="language-none">BinTree Insert(ElementType X,BinTree BST)
&#123;
    if(!BST)                                                   &#x2F;&#x2F;若结点为空，生成并返回一个结点的二叉搜索树
    &#123;                                                          &#x2F;&#x2F;此时存在一个问题：生成的新结点并没有与树连接起来
        BST&#x3D;(BinTree)malloc(sizeof(struct TreeNode));
        BST-&gt;Data&#x3D;X;
        BST-&gt;Left&#x3D;BST-&gt;Right&#x3D;NULL;
    &#125;
    else                                                       &#x2F;&#x2F;开始找要插入元素的位置
    &#123;
        if(X&lt;BST-&gt;Data)BST-&gt;Left&#x3D;Insert(X,BST-&gt;Left);          &#x2F;&#x2F;递归插入左子树
        else if(X&gt;BST-&gt;Data)BST-&gt;Right&#x3D;Insert(X,BST-&gt;Right);   &#x2F;&#x2F;递归插入右子树
        &#x2F;&#x2F;else X已经存在，什么都不做                              &#x2F;&#x2F;注意要把插入操作后的子树根结点返回给相应的子树
    &#125; 
    return BST;              &#x2F;&#x2F;每次递归结果是返回BST，目的是在最后一次返回上一层的时候能够将插入结点与二叉搜索树连接起来
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树的删除操作delete"><a class="markdownIt-Anchor" href="#二叉搜索树的删除操作delete"></a> 二叉搜索树的删除操作：Delete</h2>
<p>需要考虑三种情况：</p>
<ul>
<li>要删除的是叶结点：直接删除，并修改其父结点指针–置为NULL</li>
<li>要删除的结点只有一个子树：将其父结点的指针指向要删除结点的孩子结点</li>
<li>要删除的结点有左、右两棵子树：另一结点替代被删除的结点：右子树的最小元素或者左子树的最大元素(这两种结点都不可能有两个孩子)</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/zvQVcUxXA25lsbo.png" width="50%" height="50%">
<p>Delete操作的递归算法</p>
<pre class="line-numbers language-none"><code class="language-none">BinTree Delete(ElementType X,BinTree BST)
&#123;
    Position Tmp;
    if(!BST)printf(&quot;要删除的元素没有找到&quot;);
    else if(X&lt;BST-&gt;Data)BST-&gt;Left&#x3D;Delete(X,BST-&gt;Left);      &#x2F;&#x2F;左子树递归删除
    else if(X&gt;BST-&gt;Data)BST-&gt;Right&#x3D;Delete(X,BST-&gt;Right);    &#x2F;&#x2F;右子树递归删除
    else&#123;                                                   &#x2F;&#x2F;找到要删除的结点
        if(BST-&gt;Left&amp;&amp;BST-&gt;Right)&#123;                          &#x2F;&#x2F;被删除结点有左右两个子结点
            Tmp&#x3D;FindMin(BST-&gt;Right);                        &#x2F;&#x2F;在右子树中找最小元素填充删除结点
            &#x2F;&#x2F;此处也可以用左子树最大元素填充 Tmp&#x3D;FindMax(BST-&gt;Left);
            BST-&gt;Data&#x3D;Tmp-&gt;Data;
            BST-&gt;Right&#x3D;Delete(BST-&gt;Data,BST-&gt;Right);        &#x2F;&#x2F;在删除结点的右子树中删除最小元素
            &#x2F;&#x2F;相应地需要在左子树中删除 BST-&gt;Left&#x3D;Delete(BST-&gt;Data,BST-&gt;Left)
        &#125;else&#123;                                              &#x2F;&#x2F;被删除元素有一个或无子结点
            Tmp&#x3D;BST;
            if(!BST-&gt;Left)BST&#x3D;BST-&gt;Right;                   &#x2F;&#x2F;有右孩子或无子结点
            else if(!BST-&gt;Right)BST&#x3D;BST-&gt;Left;              &#x2F;&#x2F;有左孩子或无子结点
            free(Tmp);
        &#125;
    &#125;
    return BST;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉搜索树操作演示"><a class="markdownIt-Anchor" href="#二叉搜索树操作演示"></a> 二叉搜索树操作演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 以下演示程序均来自浙江大学mooc数据结构 *&#x2F;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
typedef struct TreeNode *BinTree;
typedef int ElementType;
typedef BinTree Position;
struct TreeNode
&#123;
    ElementType Data;
    BinTree Left;
    BinTree Right;
&#125;;
Position FindMin( BinTree );
BinTree Insert( BinTree BST, ElementType X )
&#123;
    if( !BST )&#123; &#x2F;* 若原树为空，生成并返回一个结点的二叉搜索树 *&#x2F;
        BST &#x3D; (BinTree)malloc(sizeof(struct TreeNode));
        BST-&gt;Data &#x3D; X;
        BST-&gt;Left &#x3D; BST-&gt;Right &#x3D; NULL;
    &#125;
    else &#123; &#x2F;* 开始找要插入元素的位置 *&#x2F;
        if( X &lt; BST-&gt;Data )
            BST-&gt;Left &#x3D; Insert( BST-&gt;Left, X );   &#x2F;*递归插入左子树*&#x2F;
        else  if( X &gt; BST-&gt;Data )
            BST-&gt;Right &#x3D; Insert( BST-&gt;Right, X ); &#x2F;*递归插入右子树*&#x2F;
        &#x2F;* else X已经存在，什么都不做 *&#x2F;
    &#125;
    return BST;
&#125;
BinTree Delete( BinTree BST, ElementType X ) 
&#123; 
    Position Tmp; 

    if( !BST ) 
        printf(&quot;要删除的元素未找到&quot;); 
    else &#123;
        if( X &lt; BST-&gt;Data ) 
            BST-&gt;Left &#x3D; Delete( BST-&gt;Left, X );   &#x2F;* 从左子树递归删除 *&#x2F;
        else if( X &gt; BST-&gt;Data ) 
            BST-&gt;Right &#x3D; Delete( BST-&gt;Right, X ); &#x2F;* 从右子树递归删除 *&#x2F;
        else &#123; &#x2F;* BST就是要删除的结点 *&#x2F;
            &#x2F;* 如果被删除结点有左右两个子结点 *&#x2F; 
            if( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;
                &#x2F;* 从右子树中找最小的元素填充删除结点 *&#x2F;
                Tmp &#x3D; FindMin( BST-&gt;Right );
                BST-&gt;Data &#x3D; Tmp-&gt;Data;
                &#x2F;* 从右子树中删除最小元素 *&#x2F;
                BST-&gt;Right &#x3D; Delete( BST-&gt;Right, BST-&gt;Data );
            &#125;
            else &#123; &#x2F;* 被删除结点有一个或无子结点 *&#x2F;
                Tmp &#x3D; BST; 
                if( !BST-&gt;Left )       &#x2F;* 只有右孩子或无子结点 *&#x2F;
                    BST &#x3D; BST-&gt;Right; 
                else                   &#x2F;* 只有左孩子 *&#x2F;
                    BST &#x3D; BST-&gt;Left;
                free( Tmp );
            &#125;
        &#125;
    &#125;
    return BST;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h1>
<p>问题：二叉搜索树结点的插入顺序不同，将导致不同的深度和平均查找长度(次数)ASL</p>
<ul>
<li>ASL每个结点的左右子树越均衡，查找效率越高(高度被压缩)</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/Nczq3l8TmgOP6vX.png" width="50%" height="50%">
<h2 id="平衡二叉树的定义"><a class="markdownIt-Anchor" href="#平衡二叉树的定义"></a> 平衡二叉树的定义</h2>
<p>平衡二叉树(Balanced Binary Tree)(AVL树)</p>
<ul>
<li>空树，或者任一结点左、右子树高度差的绝对值不超过1，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><msub><mi>B</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|B_F(T)|\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>平衡二叉树通过对二叉树结构的约束，保证二叉搜索树的动态查找效率达到相当于二分查找法的效果</li>
<li>“平衡因子”(Balance Factor，简称<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>F</mi></msub></mrow><annotation encoding="application/x-tex">B_F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>)：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>B</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>h</mi><mi>L</mi></msub><mo>−</mo><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">B_F(T)=h_L-h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">F</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">h_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>R</mi></msub></mrow><annotation encoding="application/x-tex">h_R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别为T的左右子树的高度</li>
</ul>
<h2 id="平衡二叉树高度"><a class="markdownIt-Anchor" href="#平衡二叉树高度"></a> 平衡二叉树高度</h2>
<p>平衡二叉树的高度是否能达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span>，证明过程:</p>
<ul>
<li>
<p>设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">n_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是给定高度为h的平衡二叉树的最少结点数，此时:</p>
</li>
<li>
<p>将平衡二叉树分为左子树、右子树和根三部分，此时满足<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>n</mi><mrow><mi>h</mi><mo>−</mo><mn>2</mn></mrow></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_h=n_{h-1}+n_{h-2}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.791661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，与斐波那契数列的递推式类似</p>
</li>
<li>
<p>斐波那契数列的规则：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mtext> </mtext><mi>f</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>i</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(0)=1,F(1)=1,...,F(i)=F(i-1)+F(i-2)\space for\space i&gt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</li>
<li>
<p>对比最少结点数与斐波那契数列数列的规律</p>
<table>
<thead>
<tr>
<th style="text-align:center">h</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub></mrow><annotation encoding="application/x-tex">n_h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">7</td>
<td style="text-align:center">12</td>
<td style="text-align:center">20</td>
<td style="text-align:center">33</td>
<td style="text-align:center">54</td>
<td style="text-align:center">88</td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">13</td>
<td style="text-align:center">21</td>
<td style="text-align:center">34</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>可以发现从n=2开始</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大1，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">F(3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大1，因此<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi>F</mi><mo stretchy="false">(</mo><mn>3</mn><mo stretchy="false">)</mo><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">F(4)=F(2)+F(3)=n_0+1+n_1+1=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord">3</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>由归纳法可知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mtext>  </mtext><mo stretchy="false">(</mo><mi>h</mi><mo>&gt;</mo><mo>=</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n_h=F(h+2)-1\space\space (h&gt;=0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></li>
<li>由<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>h</mi></msub><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>h</mi><mo>+</mo><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo>=</mo><mo>−</mo><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><msqrt><mn>5</mn></msqrt></mfrac><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><msqrt><mn>5</mn></msqrt><mn>2</mn></mfrac><msup><mo stretchy="false">)</mo><mrow><mi>h</mi><mo>+</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">n_h=F(h+2)-1=-1+\frac{1}{\sqrt{5}}(1+\frac{\sqrt{5}}{2})^{h+2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.383108em;vertical-align:-0.5379999999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.5510085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5379999999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.3829999999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0379999999999998em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.3990085em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mtight">5</span></span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span><span class="mbin mtight">+</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>因此，在给定结点数为n的情况下，AVL树的高度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>h</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">h_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_2n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>  (n不同底的对数之间相差的一个常数)</p>
<ul>
<li>注意以上给出的是最少结点，最多结点的情况是满二叉树<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{n+1}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
</ul>
<h2 id="平衡二叉树的调整"><a class="markdownIt-Anchor" href="#平衡二叉树的调整"></a> 平衡二叉树的调整</h2>
<p>平衡二叉树的调整：向二叉查找树中插入新结点时可能会使树不再平衡，此时需要进行调整<br>
不平衡：平衡因子绝对值&gt;1 (造成不平衡至少涉及到三层结点)</p>
<ul>
<li>其中离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡树</li>
<li>将重新平衡的范围局限于子树即可(将平衡被破坏的子树重新平衡，则整棵树都会平衡)</li>
<li>造成不平衡的结点插在子树的哪边都一样，关键是看插入子树的根结点相对其祖先结点所处的子树
<ul>
<li>LL型：初始状态平衡因子=1，在左子树根结点的左子树上再插入结点(LL插入)，此时需要进行一次LL旋转(左单旋)操作</li>
<li>如：在A的左子树根结点B的左子树插入结点(LL插入)，旋转后B取代A成为整棵树根结点
<ul>
<li>B的左子树不变，右子树根结点变为A</li>
<li>A的右子树不变，左子树为原来B的右子树，</li>
</ul>
</li>
<li>LR型：初始状态平衡因子=1，在左子树根结点的右子树上再插入结点(LR插入)，此时需要进行LR二次旋转(左右双旋)操作</li>
<li>如：在A的左子树根结点B的右子树插入结点(LR插入)，经过两次单旋后B的原来右子树根结点C成为整棵树根结点
<ul>
<li>先对B和C进行一次右旋后，C成为A左子树根结点，B为C左子树的根结点，B的右子树根结点为C原来左子树的根结点</li>
<li>然后对A和C进行一次左旋，C成为整棵树的根结点，A为C右子树的根结点，A的左子树根结点为C原来右子树的根结点</li>
</ul>
</li>
<li>RR型：初始状态平衡因子=-1，在右子树根结点的右子树上再插入结点(RR插入)，此时需要进行一次RR旋转(右单旋)操作</li>
<li>RL型：初始状态平衡因子=-1，在右子树根结点的左子树上再插入结点(RL插入)，此时需要进行RL二次旋转(右左双旋)操作</li>
<li>综上，LL型与RR型对称，LR型和RL型对称，可以由中序遍历所得关键字序列自小到大有序来证明平衡调整的正确
<ul>
<li>另外，平衡二叉树的高度在插入结点前和插入结点并平衡调整之后是相同的</li>
<li>注意，插入元素即便不需要调整结构也可能需要重新计算一些平衡因子</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/tF3oC6MJNpBDviS.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/03/nqO9I1vDL6pYE7Q.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/03/tg6paOijkzbN3sK.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/03/4XvPWJZKEeyhAx6.png" width="50%" height="50%">
<img src="https://s2.loli.net/2022/05/03/CuMNrEsyVD2ptJH.png" width="50%" height="50%">
<h2 id="平衡二叉树的调整操作演示"><a class="markdownIt-Anchor" href="#平衡二叉树的调整操作演示"></a> 平衡二叉树的调整操作演示</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdlib&gt;
typedef int ElementType;
typedef struct AVLNode *Position;
typedef Position AVLTree; &#x2F;* AVL树类型 *&#x2F;
struct AVLNode&#123;
    ElementType Data; &#x2F;* 结点数据 *&#x2F;
    AVLTree Left;     &#x2F;* 指向左子树 *&#x2F;
    AVLTree Right;    &#x2F;* 指向右子树 *&#x2F;
    int Height;       &#x2F;* 树高 *&#x2F;
&#125;;

int Max ( int a, int b )
&#123;
    return a &gt; b ? a : b;
&#125;

int GetHeight( AVLTree A )
&#123;
    int lheight &#x3D; 0,rheight &#x3D; 0;
    if( A )
    &#123;
        lheight &#x3D; GetHeight( A-&gt;Left );
        rheight &#x3D; GetHeight( A-&gt;Right );
        return Max( lheight, rheight ) + 1;
    &#125;
    return 0;
&#125;

AVLTree SingleLeftRotation ( AVLTree A )
&#123; &#x2F;* 注意：A必须有一个左子结点B *&#x2F;
  &#x2F;* 将A与B做左单旋，更新A与B的高度，返回新的根结点B *&#x2F;   

    AVLTree B &#x3D; A-&gt;Left;
    A-&gt;Left &#x3D; B-&gt;Right;
    B-&gt;Right &#x3D; A;
    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Left), A-&gt;Height ) + 1;
 
    return B;
&#125;

AVLTree SingleRightRotation ( AVLTree A );

AVLTree DoubleLeftRightRotation ( AVLTree A )
&#123; &#x2F;* 注意：A必须有一个左子结点B，且B必须有一个右子结点C *&#x2F;
  &#x2F;* 将A、B与C做两次单旋，返回新的根结点C *&#x2F;
  
    &#x2F;* 将B与C做右单旋，C被返回 *&#x2F;
    A-&gt;Left &#x3D; SingleRightRotation(A-&gt;Left);
    &#x2F;* 将A与C做左单旋，C被返回 *&#x2F;
    return SingleLeftRotation(A);
&#125;

&#x2F;*************************************&#x2F;
&#x2F;* 对称的右单旋与右-左双旋请自己实现 *&#x2F;
&#x2F;*************************************&#x2F;
AVLTree SingleRightRotation ( AVLTree A )
&#123;
    AVLTree B &#x3D; A-&gt;Right;
    A-&gt;Right &#x3D; B-&gt;Left;
    B-&gt;Left &#x3D; A;
    A-&gt;Height &#x3D; Max( GetHeight(A-&gt;Left), GetHeight(A-&gt;Right) ) + 1;
    B-&gt;Height &#x3D; Max( GetHeight(B-&gt;Right), A-&gt;Height ) + 1;

    return B;
&#125;

AVLTree DoubleRightLeftRotation ( AVLTree A )
&#123;
    A-&gt;Right &#x3D; SingleLeftRotation(A-&gt;Right);
    return SingleRightRotation(A);
&#125;

AVLTree Insert( AVLTree T, ElementType X )
&#123; &#x2F;* 将X插入AVL树T中，并且返回调整后的AVL树 *&#x2F;
    if ( !T ) &#123; &#x2F;* 若插入空树，则新建包含一个结点的树 *&#x2F;
        T &#x3D; (AVLTree)malloc(sizeof(struct AVLNode));
        T-&gt;Data &#x3D; X;
        T-&gt;Height &#x3D; 0;
        T-&gt;Left &#x3D; T-&gt;Right &#x3D; NULL;
    &#125; &#x2F;* if (插入空树) 结束 *&#x2F;

    else if ( X &lt; T-&gt;Data ) &#123;     
        &#x2F;* 插入T的左子树 *&#x2F;
        T-&gt;Left &#x3D; Insert( T-&gt;Left, X);
        &#x2F;* 如果需要左旋 *&#x2F;
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &#x3D;&#x3D; 2 ) &#123;        &#x2F;&#x2F;进入左子树后先搜索
            if ( X &lt; T-&gt;Left-&gt;Data ) 
               T &#x3D; SingleLeftRotation(T);      &#x2F;* 左单旋 *&#x2F;
            else 
               T &#x3D; DoubleLeftRightRotation(T); &#x2F;* 左-右双旋 *&#x2F;
        &#125;
    &#125; &#x2F;* else if (插入左子树) 结束 *&#x2F;
  
    else if ( X &gt; T-&gt;Data ) &#123;
        &#x2F;* 插入T的右子树 *&#x2F;
        T-&gt;Right &#x3D; Insert( T-&gt;Right, X );
        &#x2F;* 如果需要右旋 *&#x2F;
        if ( GetHeight(T-&gt;Left)-GetHeight(T-&gt;Right) &#x3D;&#x3D; -2 ) &#123;      &#x2F;&#x2F;同理，进入右子树后先搜索
            if ( X &gt; T-&gt;Right-&gt;Data ) 
               T &#x3D; SingleRightRotation(T);     &#x2F;* 右单旋 *&#x2F;
            else 
               T &#x3D; DoubleRightLeftRotation(T); &#x2F;* 右-左双旋 *&#x2F;
        &#125;
    &#125; &#x2F;* else if (插入右子树) 结束 *&#x2F;

    &#x2F;* else X &#x3D;&#x3D; T-&gt;Data，无须插入 *&#x2F;

    &#x2F;* 别忘了更新树高 *&#x2F;
    T-&gt;Height &#x3D; Max( GetHeight(T-&gt;Left), GetHeight(T-&gt;Right) ) + 1;
  
    return T;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>3.二叉树的同构、判断是否同一棵二叉搜索树</title>
    <url>/posts/2c8d4a984d90</url>
    <content><![CDATA[<h1 id="二叉树的同构"><a class="markdownIt-Anchor" href="#二叉树的同构"></a> 二叉树的同构</h1>
<p>给定两棵二叉树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则称两棵二叉树是“同构”的<br>
现给定两棵树，请判断是否同构</p>
<span id="more"></span>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入给出两颗二叉树的信息</p>
<ul>
<li>先在一行中给出该树的结点数</li>
<li>随后n行中，第i行对应编号第i个结点，给出该结点中存储的字母、其左孩子结点的编号、右孩子结点的百脑汇</li>
<li>如果孩子结点为空，则在相应位置上给出’-’</li>
</ul>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">8
A 1 2
B 3 4
C 5 -
D - -
E 6 -
G 7 -
F - -
H - -

8
G - 4
B 7 6
F - -
A 5 1
H - -
C 0 -
D - -
E 2 -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="求解思路"><a class="markdownIt-Anchor" href="#求解思路"></a> 求解思路</h2>
<ul>
<li>二叉树表示</li>
<li>建二叉树</li>
<li>同构判别</li>
</ul>
<h3 id="二叉树表示"><a class="markdownIt-Anchor" href="#二叉树表示"></a> 二叉树表示</h3>
<pre class="line-numbers language-none"><code class="language-none">#define MaxTree 10
#define ElementType char
#define Tree int
#define Null -1                     &#x2F;&#x2F;注意区别于cstdlib中的NULL(0)，因为0也是下标，所以将“指针”为空的情况设置为-1
结构数组表示二叉树：静态链表             &#x2F;&#x2F;物理上的存储是使用数组，但运用链表的思想
struct TreeNode                     &#x2F;&#x2F;顺序存储实现
&#123;
    ElementType Element;
    Tree Left;
    Tree Right;
&#125;T1[MaxTree],T2[MaxTree];           &#x2F;&#x2F;T1,T2为结构数组，保存整棵二叉树<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="程序框架搭建伪代码描述"><a class="markdownIt-Anchor" href="#程序框架搭建伪代码描述"></a> 程序框架搭建：伪代码描述</h3>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    建二叉树1
    建二叉树2
    判别是否同构并输出
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="需要设计的函数"><a class="markdownIt-Anchor" href="#需要设计的函数"></a> 需要设计的函数</h3>
<ul>
<li>读数据建立二叉树</li>
<li>二叉树同构判别</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    Tree R1,R2;
    R1&#x3D;BuildTree(T1);
    R2&#x3D;BuildTree(T2);
    if(Isomorphic(R1,R2))printf(&quot;Yes\n&quot;);
    else printf(&quot;No\n&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>建立二叉树</p>
<pre class="line-numbers language-none"><code class="language-none">Tree BuildTree(struct TreeNode T[])
&#123;
    int i,N,check[N];
    Tree cl,cr,Root;
    scanf(&quot;%d\n&quot;,&amp;N);
    if(N)
    &#123;
        for(i&#x3D;0;i&lt;N;i++)check[i]&#x3D;0;         &#x2F;&#x2F;check数组用来判别结点是否有其他结点指向
        for(i&#x3D;0;i&lt;N;i++)
        &#123;
            scanf(&quot;%c %c %c\n&quot;,&amp;T[i].Element,&amp;cl,&amp;cr);
            if(cl!&#x3D;&#39;-&#39;)
            &#123;
                T[i].Left&#x3D;cl-&#39;0&#39;;
                check[T[i].Left]&#x3D;1;
            &#125;
            else T[i].Left&#x3D;Null;
            if(cr!&#x3D;&#39;-&#39;)
            &#123;
                T[i].Right&#x3D;cr-&#39;0&#39;;
                check[T[i].Right]&#x3D;1;
            &#125;
            else T[i].Right&#x3D;Null;
        &#125;
        for(i&#x3D;0;i&lt;N;i++)if(!check[i])break;
        Root&#x3D;i;                             &#x2F;&#x2F;T[i]没有任何一个结点的Left(cl)和Right(cr)指向，因此为根结点
    &#125;
    return Root;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>判别二叉树同构</p>
<pre class="line-numbers language-none"><code class="language-none">int Isomorphic(Tree R1,Tree R2)
&#123;
    if((R1&#x3D;&#x3D;Null)&amp;&amp;(R2&#x3D;&#x3D;Null))return 1;
    &#x2F;&#x2F;两树(子树)均为空
    if(((R1&#x3D;&#x3D;Null)&amp;&amp;(R2!&#x3D;Null))||((R1!&#x3D;Null)&amp;&amp;(R2&#x3D;&#x3D;Null)))return 0;
    &#x2F;&#x2F;其中一棵树(子树)为空
    if(T1[R1].Element!&#x3D;T2[R2].Element)return 0;
    &#x2F;&#x2F;根不同
    if((T1[R1].Left&#x3D;&#x3D;Null)&amp;&amp;(T2[R2].Left&#x3D;&#x3D;Null))return Isomorphic(T1[R1].Right,T2[R2].Right);
    &#x2F;&#x2F;都没有左子树
    if(((T1[R1].Left!&#x3D;Null)&amp;&amp;(T2[R2].Left!&#x3D;Null))&amp;&amp;((T1[T1[R1].Left].Element)&#x3D;&#x3D;(T2[T2[R2].Left].Element)))
        return (Isomorphic(T1[R1].Left,T2[R2].Left)&amp;&amp;Isomorphic(T1[R1].Right,T2[R2].Right));
    &#x2F;&#x2F;左右不需要交换的情况
    else return (Isomorphic(T1[R1].Left,T2[R2].Right)&amp;&amp;Isomorphic(T1[R1].Right,T2[R2].Left));
    &#x2F;&#x2F;左右需要交换的情况
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="判断是否同一棵二叉搜索树"><a class="markdownIt-Anchor" href="#判断是否同一棵二叉搜索树"></a> 判断是否同一棵二叉搜索树</h1>
<p>给定一个插入序列就可以唯一确定一棵二叉搜索树，然而一棵给定的二叉搜索树却可以有多种不同的插入序列得到</p>
<ul>
<li>如：按照序列{2,1,3}和{2,3,1}插入初始为空的二叉搜索树，都能得到同样的结果</li>
</ul>
<p>对于输入的各种插入序列，需要判断它们是否能生成相同的二叉搜索树</p>
<h2 id="输入样例-2"><a class="markdownIt-Anchor" href="#输入样例-2"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">4 2
3 1 4 2  
3 4 1 2  
3 2 4 1        
2 1   
2 1   
1 2   
0   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">YES 
NO          
NO<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="求解思路-2"><a class="markdownIt-Anchor" href="#求解思路-2"></a> 求解思路</h2>
<p>两个序列是否对应相同二叉搜索树的三种判别方法</p>
<ul>
<li>根据两个序列分别建两颗二叉搜索树的判别方法
<ul>
<li>根据两个序列分别建二叉搜索树，在判别二叉搜索树是否相同</li>
</ul>
</li>
<li>不建树的判别方法
<ul>
<li>如：序列3 1 2 4和序列3 4 1 2的构造均为{1 2} 3 {4}</li>
<li>序列3 1 2 4和序列3 2 4 1的构造则为{2,1} 3 {4}</li>
</ul>
</li>
<li>只建一棵二叉搜索树，再判断其他序列是否与该二叉搜索树一致</li>
</ul>
<p>考虑使用第三种方法，求解思路为：</p>
<ul>
<li>二叉搜索树表示</li>
<li>建二叉搜索树T</li>
<li>判别一序列是否与二叉搜索树T一致</li>
</ul>
<h3 id="二叉搜索树表示"><a class="markdownIt-Anchor" href="#二叉搜索树表示"></a> 二叉搜索树表示</h3>
<pre class="line-numbers language-none"><code class="language-none">typedef struct TreeNode *Tree;
struct TreeNode
&#123;
    Tree Left,Right;
    int v,flag;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="程序框架搭建"><a class="markdownIt-Anchor" href="#程序框架搭建"></a> 程序框架搭建</h3>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    读入数据N和L
    根据读入第一行输入序列建树T
    依据树T分别判断后面的L个序列是否能与T形成同一搜索树并输出结果
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="需要设计的主要函数"><a class="markdownIt-Anchor" href="#需要设计的主要函数"></a> 需要设计的主要函数</h3>
<ul>
<li>读数据并建搜索树</li>
<li>判别一序列时候与T构成一样的搜索树</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    int N,L,i;
    Tree T;
    scanf(&quot;%d&quot;,&amp;N);
    while(N)                                    &#x2F;&#x2F;当基准序列长度不为0时
    &#123;
        scanf(&quot;%d&quot;,&amp;L);
        T&#x3D;MakeTree(N);                          &#x2F;&#x2F;建基准二叉树
        for(i&#x3D;0;i&lt;L;i++)                        &#x2F;&#x2F;读L个序列，分别进行比较
        &#123;
            if(Judge(T,N))printf(&quot;Yes\n&quot;);
            else printf(&quot;No\n&quot;);
            ResetT(T);                          &#x2F;&#x2F;一个序列比较之后，将T中的标记重置
        &#125;
        FreeTree(T);                            &#x2F;&#x2F;L个序列均比较完成后，释放掉基准树
        scanf(&quot;%d&quot;,&amp;N);                         &#x2F;&#x2F;每次循环最后更新基准序列长度，当输入序列长度为0时跳出循环
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>建立二叉搜索树</p>
<pre class="line-numbers language-none"><code class="language-none">Tree MakeTree(int);
Tree Insert(Tree,int);
Tree NewNode(int);
Tree MakeTree(int N)
&#123;
    Tree T;
    int i,V;
    scanf(&quot;%d&quot;,&amp;V);
    T&#x3D;NewNode(V);
    for(i&#x3D;1;i&lt;N;i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;V);
        T&#x3D;Insert(T,V);
    &#125;
    return T;
&#125;
Tree Insert(Tree T,int V)
&#123;
    if(!T)T&#x3D;NewNode(V);
    else if(V&lt;T-&gt;v)T-&gt;Left&#x3D;Insert(T-&gt;Left,V);
    else if(V&gt;T-&gt;v)T-&gt;Right&#x3D;Insert(T-&gt;Right,V);
    return T;
&#125;
Tree NewNode(int V)
&#123;
    Tree T&#x3D;(Tree)malloc(sizeof(struct TreeNode));
    T-&gt;v&#x3D;V;
    T-&gt;Left&#x3D;T-&gt;Right&#x3D;NULL;
    T-&gt;flag&#x3D;0;
    return T;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>判别序列与二叉搜索树是否一致<br>
方法：在树T中依次搜索输入序列中所有的元素</p>
<ul>
<li>如果每次搜索所经过的结点在前面均出现过，则一致</li>
<li>否则(存在某次搜索中遇到前面未出现的结点)，则不一致</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int check(Tree T,int V)          &#x2F;&#x2F;搜索序列的一个元素
&#123;
    if(T-&gt;flag)                  &#x2F;&#x2F;如果flag&#x3D;1，继续递归搜索
    &#123;
        if(V&lt;T-&gt;v)return check(T-&gt;Left,V);
        else if(V&gt;T-&gt;v)return check(T-&gt;Right,V);
        else return 0;          &#x2F;&#x2F;这种情况说明数据重复了
    &#125;
    else                        &#x2F;&#x2F;如果flag&#x3D;0，检查是否是当前输入元素，如果是则结束查找并将元素标记为查找过
    &#123;                           &#x2F;&#x2F;如果不是当前元素，则说明序列与基准树不是同一棵二叉搜索树
        if(V&#x3D;&#x3D;T-&gt;v)
        &#123;
            T-&gt;flag&#x3D;1;
            return 1;
        &#125;
        else return 0;
    &#125;
    return 0;
&#125;
int judge(Tree T,int N)         &#x2F;&#x2F;这个版本有bug：当发现序列中某个数与T不一致，judge函数会直接返回，这轮输入序列的读取就停止了
&#123;                                            &#x2F;&#x2F;而这一轮输入序列剩下的数会被当作是下一轮的输入，导致程序会出错
    int i,V;
    scanf(&quot;%d&quot;,&amp;V);             &#x2F;&#x2F;先判断一下根
    if(V!&#x3D;T-&gt;v)return 0;
    else T-&gt;flag&#x3D;1;
    for(i&#x3D;1;i&lt;N;i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;V);
        if(!check(T,V))return 0;&#x2F;&#x2F;依次检查输入序列的元素，
    &#125;
    return 1;
&#125;
int judge(Tree T,int N)         &#x2F;&#x2F;更正版本
&#123;
    int i,V,flag&#x3D;0;             &#x2F;&#x2F;flag&#x3D;0代表目前序列与基准树还一致，1代表已经不一致
    scanf(&quot;%d&quot;,&amp;V);
    if(V!&#x3D;T-&gt;v)flag&#x3D;1;
    else T-&gt;flag&#x3D;1;
    for(i&#x3D;1;i&lt;N;i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;V);       
        if(!check(T,V)&amp;&amp;(!flag))flag&#x3D;1;  &#x2F;&#x2F;此时发现序列与基准情况不一致，程序唯一的工作就是将输入读完
    &#125;
    if(flag)return 0;
    return 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>清除T中各结点的flag标记，准备比较下一个输入序列</p>
<ul>
<li>与遍历原理相同，需要注意的是要对结点进行操作，所以不能遍历到结点为空再停止</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void ResetT(Tree T)
&#123;
    if(T-&gt;Left)ResetT(T-&gt;Left);
    else if(T-&gt;Right)ResetT(T-&gt;Right);
    T-&gt;flag&#x3D;0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>释放T的空间</p>
<pre class="line-numbers language-none"><code class="language-none">void FreeTree(Tree T)
&#123;
    if(T-&gt;Left)ResetT(T-&gt;Left);
    else if(T-&gt;Right)ResetT(T-&gt;Right);
    free(T);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/83086bddf7a7</url>
    <content><![CDATA[<h1 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h1>
<p>二叉树(Binary Tree):一个有穷的结点集合</p>
<ul>
<li>集合可以为空</li>
<li>若不为空，则它是由根结点以及它的左子树Tl和右子树Tr的两个不相交的二叉树组成</li>
<li>二叉树五种具体基本形态
<ul>
<li>空树/叶结点/只有左子树/只有右子树/同时具有左子树和右子树</li>
<li>二叉树的子树有左右顺序之分</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="二叉树类型结点分布形态的角度"><a class="markdownIt-Anchor" href="#二叉树类型结点分布形态的角度"></a> 二叉树类型(结点分布形态的角度)</h2>
<ul>
<li>斜二叉树(Skewed Binary Tree)
<ul>
<li>只在一个方向上有孩子结点，实际上相当于一个线性结构</li>
</ul>
</li>
<li>完美二叉树(Perfect Binary Tree)
<ul>
<li>满二叉树(Full Binary Tree)</li>
</ul>
</li>
<li>完全二叉树(Complete Binary Tree)
<ul>
<li>完全二叉树和满二叉树的关系：
<ul>
<li>有n个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为i(1&lt;=i&lt;=n)结点与满二叉树中编号为i结点在二叉树中位置相同(允许缺失最后几个结点)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的几个重要性质"><a class="markdownIt-Anchor" href="#二叉树的几个重要性质"></a> 二叉树的几个重要性质</h2>
<ul>
<li>一个二叉树第i层的最大结点数为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup><mo separator="true">,</mo><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{i-1},i\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.019104em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>深度为k的二叉树有最大结点总数(满二叉树)为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn><mo>+</mo><msup><mn>2</mn><mi>k</mi></msup><mo separator="true">,</mo><mi>k</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1+2^k,k\geq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.043548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>对任何非空二叉树T，若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示叶结点的个数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是度为2的非叶结点个数
<ul>
<li>则二者满足关系：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>
<ul>
<li>边总数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>=</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">=n-1=2n_2+n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ——&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n=2n_2+n_1+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">2</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>结点总数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo><mi>n</mi><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub><mo>+</mo><msub><mi>n</mi><mn>1</mn></msub><mo>+</mo><msub><mi>n</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">=n=n_0+n_1+n_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ——&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>0</mn></msub><mo>=</mo><msub><mi>n</mi><mn>2</mn></msub><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n_0=n_2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的抽象数据类型定义"><a class="markdownIt-Anchor" href="#二叉树的抽象数据类型定义"></a> 二叉树的抽象数据类型定义</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：二叉树
数据对象集：一个有穷的结点集合
若不为空，则由根结点和其左、右二叉树组成
操作集：BT ∈ BinTree，Item ∈ ElementType，重要操作有：
Boolean IsEmpty(BinTree BT):判别BT是否为空;
void Traversal(BinTree BT):遍历，按某顺序访问各个结点;
BinTree CreatBinTree():创建一个二叉树;
对二叉树而言，很多算法是建立在遍历之上的(很多算法需要先将二叉树的结点元素整体先读一遍)
常用的遍历方法有：
void PreOrderTraversal(BinTree BT):先序————根、左子树、右子树;
void InOrderTraversal(BinTree BT):中序————左子树、根、右子树;
void PostOrderTraversal(BinTree BT):后序————左子树、右子树、根;
void LevelOrderTraversal(BinTree BT):层序遍历，从上到下、从左到右;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的存储结构"><a class="markdownIt-Anchor" href="#二叉树的存储结构"></a> 二叉树的存储结构</h2>
<h3 id="二叉树顺序存储实现"><a class="markdownIt-Anchor" href="#二叉树顺序存储实现"></a> 二叉树顺序存储实现</h3>
<p>适合完全二叉树：</p>
<ul>
<li>按从上至下、从左到右顺序存储(完全二叉树从左到右没有空结点)</li>
<li>n个结点的完全二叉树的结点父子关系：
<ul>
<li>非根结点(序号i&gt;1)的父结点的序号是⌊i/2⌋;</li>
<li>结点(序号为i)的左孩子结点的序号是2i，(若2i&lt;=n，否则没有左孩子);</li>
<li>结点(序号为i)的右孩子结点的序号是2i+1，(若2i+1&lt;=n，否则没有右孩子);</li>
</ul>
</li>
</ul>
<p>对一般二叉树也可以采用这种结构，但需要在其相对完全二叉树而言空缺的位置上设置为空，因此会造成较多的空间浪费</p>
<h3 id="二叉树链式存储实现"><a class="markdownIt-Anchor" href="#二叉树链式存储实现"></a> 二叉树链式存储实现</h3>
<pre class="line-numbers language-none"><code class="language-none">typedef struct TreeNode *BinTree;
typedef BinTree Position;
struct TreeNode
&#123;
    ElementType Data;
    BinTree Left;
    BinTree Right;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树的遍历"><a class="markdownIt-Anchor" href="#二叉树的遍历"></a> 二叉树的遍历</h2>
<p>例：假设二叉树结构为根结点A  左子树(B(DF(E)))  右子树(C(G(H)I))</p>
<h3 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h3>
<p>遍历过程为：</p>
<ul>
<li>访问根结点</li>
<li>先序遍历其左子树</li>
<li>先序遍历其右子树</li>
</ul>
<p>上例先序遍历结果=&gt;A B D F E C G H I</p>
<p>先序遍历递归算法</p>
<pre class="line-numbers language-none"><code class="language-none">void PreOrederTraversal(BinTree BT)
&#123;
    if(BT)
    &#123;
        printf(&quot;%d&quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先序遍历非递归算法</p>
<ul>
<li>递归本质就是靠堆栈实现，因此非递归算法也可以借助堆栈</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void PreOrderTraversal(BinTree BT)
&#123;
    BinTree T&#x3D;BT;                   &#x2F;&#x2F;创建一个用于遍历的二叉树指针
    Stack S&#x3D;CreateStack(MaxSize)    &#x2F;&#x2F;创建并初始化堆栈S
    while(T||!IsEmpty(S))
    &#123;
        while(T)                    &#x2F;&#x2F;一直向左直到叶结点将沿途结点压入堆栈
        &#123;
            Push(S,T);
            cout&lt;&lt;T-&gt;Data&lt;&lt;endl;    &#x2F;&#x2F;(访问)打印结点
            T&#x3D;T-&gt;Left;
        &#125;
        if(!IsEmpty(S))
        &#123;
            T&#x3D;Pop(S);               &#x2F;&#x2F;结点弹出堆栈(左子树先出)
            T&#x3D;T-&gt;Right;             &#x2F;&#x2F;然后转向右子树(一步)
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3>
<p>遍历过程为：</p>
<ul>
<li>中序遍历其左子树</li>
<li>访问根结点</li>
<li>中序遍历其右子树</li>
</ul>
<p>上例中序遍历结果=&gt;D B E F A G H C I</p>
<p>中序遍历递归算法</p>
<pre class="line-numbers language-none"><code class="language-none">void InOrederTraversal(BinTree BT)    
&#123;
    if(BT)
    &#123;
        PreOrderTraversal(BT-&gt;Left);
        printf(&quot;%d&quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>中序遍历非递归算法(结构基本同先序的非递归遍历，只有访问时机不一样)：</p>
<ul>
<li>遇到一个结点，将其压栈，并遍历左子树</li>
<li>当左子树遍历结束后，从栈顶弹出这个结点并访问它</li>
<li>按其右指针再去中序遍历该结点的右子树</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void InOrderTraversal(BinTree BT)
&#123;
    BinTree T&#x3D;BT;
    Stack S&#x3D;CreateStack(MaxSize)  
    while(T||!IsEmpty(S))
    &#123;
        while(T)                 
        &#123;
            Push(S,T);
            T&#x3D;T-&gt;Left;
        &#125;
        if(!IsEmpty(S))
        &#123;
            T&#x3D;Pop(S);             
            cout&lt;&lt;T-&gt;Data&lt;&lt;endl;        
            T&#x3D;T-&gt;Right;          
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3>
<p>遍历过程为：</p>
<ul>
<li>后序遍历其左子树</li>
<li>后序遍历其右子树</li>
<li>访问根结点</li>
</ul>
<p>上例后序遍历结果=&gt;D E F B H G I C A</p>
<p>后序递归遍历算法</p>
<pre class="line-numbers language-none"><code class="language-none">void PostOrederTraversal(BinTree BT)
&#123;
    if(BT)
    &#123;
        PostOrderTraversal(BT-&gt;Left);
        PostOrderTraversal(BT-&gt;Right);
        printf(&quot;%d&quot;,BT-&gt;Data);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后序非递归遍历算法(非递归写法与前序中序的思路并不完全一致)</p>
<ul>
<li>算法1:采用双堆栈，使用一个堆栈记录另一个堆栈使用根右左的顺序时元素的入栈顺序，然后将该堆栈的元素逆序输出</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void PostOrderTraversal(BinTree BT)
&#123;
    BinTree T&#x3D;BT;
    Stack S1,S2;
    S1&#x3D;S2&#x3D;CreateStack(MaxSize)  
    while(T||!IsEmpty(S))
    &#123;
        while(T)                 
        &#123;
            Push(S1,T);
            Push(S2,T);
            T&#x3D;T-&gt;Right;
        &#125;
        if(!IsEmpty(S1))
        &#123;
            T&#x3D;Pop(S1);   
            T&#x3D;T-&gt;Left;         
        &#125;   
    &#125;
    while(!IsEmpty(S2))
    &#123;
        T&#x3D;Pop(S2);
        cout&lt;&lt;T-&gt;Data&lt;&lt;endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>算法2:单堆栈实现后序遍历</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void PostOrderTraversal(BinTree BT)
&#123;
    BinTree T,pre;
    Stack S;
    T&#x3D;pre&#x3D;BT;
    while(T||!IsEmpty(S1))
    &#123;
        while(T)
        &#123;
            Push(S,T);
            T&#x3D;T-&gt;Left;
        &#125;
        if(!IsEmpty(S2))
        &#123;
            T&#x3D;Pop(S1);  
            if(!T-&gt;Right||pre&#x3D;T-&gt;Right)
            &#123;
                cout&lt;&lt;T-&gt;Data&lt;&lt;endl;
                pre&#x3D;T;
            &#125;
            else
            &#123;
                Push(S,T);
                T&#x3D;T-&gt;Right;
            &#125;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>先序、中序和后序遍历过程：<br>
<strong>遍历过程中经过结点的路线一样(都是先先向左走，走到头以后回到根，然后再向右走)只是访问(如打印)各结点的时机不同</strong></p>
<img src="https://s2.loli.net/2022/05/03/p59jAgyuo1iDTGM.png" width="50%" height="50%">
<h3 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h3>
<p>二叉树遍历的核心问题：二维结构的线性化(二维的树转化为一维的线性访问序列)</p>
<ul>
<li>从结点访问其左、右孩子结点</li>
<li>访问左孩子后，右孩子怎么办
<ul>
<li>链表存在的一大问题：后面的结点不知道前面结点的位置</li>
<li>需要一个存储结构保存暂时不访问的结点</li>
<li>存储结构：堆栈、队列
<ul>
<li>两种存储结构都可以，只不过堆栈的目的是保存自身，队列是保存右孩子结点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>非递归算法：队列实现</p>
<ul>
<li>遍历从根结点开始，首先将根结点入队，然后执行循环：结点出队列、访问该结点、左右孩子入队</li>
<li>遍历过程为：
<ul>
<li>从队列中取出一个元素，访问该元素所指结点</li>
<li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队</li>
</ul>
</li>
</ul>
<p>上例层序遍历结果=&gt;A B C D F G I E H</p>
<pre class="line-numbers language-none"><code class="language-none">void LevelOrderTraversal(BinTree BT)
&#123;
    Queue Q;
    BinTree T&#x3D;BT;
    Q&#x3D;CreateQueue(MaxSize);
    AddQ(Q,T);
    while(IsEmptyQ(Q))
    &#123;
        T&#x3D;DeleteQ(Q);
        cout&lt;&lt;T-&gt;Data&lt;&lt;endl;
        if(T-&gt;Left)AddQ(Q,T-&gt;Left);
        if(T-&gt;Right)AddQ(Q,T-&gt;Right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>递归算法：求出二叉树高度，逐层遍历，以每层高度控制递归深度</p>
<pre class="line-numbers language-none"><code class="language-none">void onelevelTraversal(BinTree BT,int height)&#123;
    if(!BT||!height)return NULL;
    else if(height&#x3D;&#x3D;1)&#123;
        cout&lt;&lt;BT-&gt;Data;
        return;
    &#125;
    onelevelTraversal(BT-&gt;Left,h-1);
    onelevelTraversal(BT-&gt;Right,h-1);
&#125;
void LevelOrderTraversal(BinTree BT)&#123;
    int height&#x3D;Getheight(BT);
    for(int i&#x3D;1;i&lt;&#x3D;height;i++)onelevelTraversal(BT,i);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>层序遍历的另一种思路：由于二叉树的特点，设根结点的下标为i，则左孩子结点的下标2* i，右孩子结点的下标为2* i+1<br>
使用前序中序遍历的方法，在遍历时将孩子结点用数组存储(适用于完全二叉树情况)</p>
<pre class="line-numbers language-none"><code class="language-none">void LevelOrderTraversal(BinTree BT,int i,int* levelorder) &#x2F;&#x2F;i的初值为1
&#123;  
    levelorder[i]&#x3D;BT-&gt;Data;
    if(BT-&gt;Left)LevelOrderTraversal(BT-&gt;Left,i*2);
    if(BT-&gt;Right)LevelOrderTraversal(BT-&gt;Right,i*2+1);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从宏观角度来看：</p>
<ul>
<li>前序、中序、后序遍历属于DFS</li>
<li>层序遍历属于BFS</li>
</ul>
<h3 id="遍历二叉树的应用"><a class="markdownIt-Anchor" href="#遍历二叉树的应用"></a> 遍历二叉树的应用</h3>
<p>输出二叉树中的叶子结点</p>
<ul>
<li>在二叉树的遍历算法中增加检测结点的“左右子树是否都为空”</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void PreOrederTraversal(BinTree BT)
&#123;
    if(BT)if(!BT-&gt;Left&amp;&amp;!BT-&gt;Right)
    &#123;
        printf(&quot;%d&quot;,BT-&gt;Data);
        PreOrderTraversal(BT-&gt;Left);
        PreOrderTraversal(BT-&gt;Right);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>求二叉树的高度</p>
<pre class="line-numbers language-none"><code class="language-none">int Getheight(BinTree BT)
&#123;
    int HL&#x3D;0,HR&#x3D;0,MaxH;
    if(BT)
    &#123;
        HL&#x3D;PostOrderTraversal(BT-&gt;Left);
        HR&#x3D;PostOrderTraversal(BT-&gt;Right);
        MaxH&#x3D;(HL&gt;HR)?HL:HR;                 &#x2F;&#x2F;注意这里只能是后序遍历
        return MaxH+1;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>二元运算表达式树及其遍历</p>
<ul>
<li>叶子结点是操作数，非叶结点是运算符</li>
<li>三种遍历可以得到三种不同的访问结果：
<ul>
<li>先序遍历得到前缀表达式，如：+ + a * b c * + * d e f g</li>
<li>中序遍历得到中缀表达式，如：a + b * c + d * e + f * g
<ul>
<li>中缀表达式会受到运算符优先级的影响，所以直接遍历的结果可能不符合本来的运算规则</li>
</ul>
</li>
<li>后序遍历得到中缀表达式，如：a b c * + d e * f + g * +</li>
</ul>
</li>
</ul>
<p>已知三种遍历中任意两种遍历序列，能否唯一确定一棵二叉树</p>
<ul>
<li>其中必须要有中序序列才行</li>
<li>如果没有中序序列，则对一组双亲和孩子结点来说无法确定是左孩子还是右孩子</li>
<li>例：先序和中序遍历序列确定一棵二叉树
<ul>
<li>根据先序遍历序列第一个结点确定根结点</li>
<li>根据根结点在中序遍历序列中分割出左右两个子序列</li>
<li>对左子树和右子树分别递归使用相同方法继续分解</li>
<li>类似的，后序和中序遍历序列也可以确定一棵二叉树</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/9RZgiOcDA5Mvlb2.png" width="50%" height="50%">
<p>例：二叉树先序序列中序序列转后序序列，后序序列中序序列转先序序列</p>
<pre class="line-numbers language-none"><code class="language-none">int preorder[]&#x3D;&#123;&#39;A&#39;,&#39;B&#39;,&#39;D&#39;,&#39;E&#39;,&#39;C&#39;,&#39;F&#39;,&#39;G&#39;&#125;,
inorder[]&#x3D;&#123;&#39;D&#39;,&#39;B&#39;,&#39;E&#39;,&#39;A&#39;,&#39;F&#39;,&#39;C&#39;,&#39;G&#39;&#125;,
postorder[]&#x3D;&#123;&#39;D&#39;,&#39;E&#39;,&#39;B&#39;,&#39;F&#39;,&#39;G&#39;,&#39;C&#39;,&#39;A&#39;&#125;;
void post(int root,int start,int end)&#123;
    if(start&gt;end)return;
    int i&#x3D;start;
    for(;inorder[i]!&#x3D;preorder[root];i++);
    post(root+1,start,i-1);
    post(root+1+i-start,i+1,end);
    cout&lt;&lt;(char)inorder[i]&lt;&lt;&#39; &#39;;
&#125;
void pre(int root,int start,int end)&#123;
    if(start&gt;end)return;
    int i&#x3D;end;
    for(;inorder[i]!&#x3D;postorder[root];i--);
    cout&lt;&lt;(char)inorder[i]&lt;&lt;&#39; &#39;;
    pre(root-1-end+i,start,i-1);
    pre(root-1,i+1,end);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>例：中序和前序序列建树(中序和后序同理)</p>
<pre class="line-numbers language-none"><code class="language-none">BinTree CreateBintree(BinTree BST,int pres,int pree,int ins,int ine)&#123;
    if(pree-pres&lt;0)return nullptr;
    int pos;
    BST&#x3D;new struct TreeNode(tpreorder[pres]);
    for(pos&#x3D;ins;tinorder[pos]!&#x3D;tpreorder[pres];pos++);
    BST-&gt;left&#x3D;CreateBintree(BST-&gt;left,pres+1,pres+pos-ins,ins,pos-1);
    BST-&gt;right&#x3D;CreateBintree(BST-&gt;right,pres+pos-ins+1,pree,pos+1,ine);
    return BST;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二叉树遍历演示"><a class="markdownIt-Anchor" href="#二叉树遍历演示"></a> 二叉树遍历演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 浙江大学mooc数据结构示例程序 *&#x2F;
#include&lt;cstdio&gt;
typedef int ELementType;
typedef struct BinNode* BinTree;
struct BinNode
&#123;
    ELementType Data;
    BinTree Left,Right;
&#125;;
typedef struct Queue* List;
struct Queue
&#123;
    int Maxsize;
    List rear,front;
&#125;;
struct Queue CreatQueue();
void AddQ(Queue,BinTree);
bool IsEmpty(Queue);
BinTree DeleteQ(Queue);
void InorderTraversal( BinTree BT )
&#123;
    if( BT ) &#123;
        InorderTraversal( BT-&gt;Left );
        &#x2F;* 此处假设对BT结点的访问就是打印数据 *&#x2F;
        printf(&quot;%d &quot;, BT-&gt;Data); &#x2F;* 假设数据为整型 *&#x2F;
        InorderTraversal( BT-&gt;Right );
    &#125;
&#125;

void PreorderTraversal( BinTree BT )
&#123;
    if( BT ) &#123;
        printf(&quot;%d &quot;, BT-&gt;Data );
        PreorderTraversal( BT-&gt;Left );
        PreorderTraversal( BT-&gt;Right );
    &#125;
&#125;

void PostorderTraversal( BinTree BT )
&#123;
    if( BT ) &#123;
        PostorderTraversal( BT-&gt;Left );
        PostorderTraversal( BT-&gt;Right );
        printf(&quot;%d &quot;, BT-&gt;Data);
    &#125;
&#125;

void LevelorderTraversal ( BinTree BT )
&#123; 
    Queue Q; 
    BinTree T;

    if ( !BT ) return; &#x2F;* 若是空树则直接返回 *&#x2F;
  
    Q &#x3D; CreatQueue(); &#x2F;* 创建空队列Q *&#x2F;
    AddQ( Q, BT );
    while ( !IsEmpty(Q) ) &#123;
        T &#x3D; DeleteQ( Q );
        printf(&quot;%d &quot;, T-&gt;Data); &#x2F;* 访问取出队列的结点 *&#x2F;
        if ( T-&gt;Left )   AddQ( Q, T-&gt;Left );
        if ( T-&gt;Right )  AddQ( Q, T-&gt;Right );
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2.汉诺塔的非递归实现、File Transfer</title>
    <url>/posts/a9ffe581d7f0</url>
    <content><![CDATA[<h1 id="汉诺塔的非递归实现"><a class="markdownIt-Anchor" href="#汉诺塔的非递归实现"></a> 汉诺塔的非递归实现</h1>
<p>借助堆栈以非递归（循环）方式求解汉诺塔的问题（n, a, b, c），即将N个盘子从起始柱（标记为“a”）通过借助柱（标记为“b”）移动到目标柱（标记为“c”），并保证每个移动符合汉诺塔问题的要求。</p>
<h2 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h2>
<p>输入为一个正整数N，即起始柱上的盘数。</p>
<h2 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h2>
<p>每个操作（移动）占一行，按柱1 -&gt; 柱2的格式输出。</p>
<h2 id="输入样例"><a class="markdownIt-Anchor" href="#输入样例"></a> 输入样例</h2>
<pre class="line-numbers language-none"><code class="language-none">3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="输出样例"><a class="markdownIt-Anchor" href="#输出样例"></a> 输出样例</h2>
<pre class="line-numbers language-none"><code class="language-none">a -&gt; c
a -&gt; b
c -&gt; b
a -&gt; c
b -&gt; a
b -&gt; c
a -&gt; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="参考代码"><a class="markdownIt-Anchor" href="#参考代码"></a> 参考代码</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;*  hanoi塔的递归实现  
#include&lt;cstdio&gt;
void hanoi(int,char,char,char)；
int main()&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    hanoi(n,&#39;a&#39;,&#39;c&#39;,&#39;b&#39;);
    return 0;
&#125; 
void hanoi(int ranks,char origin,char aim,char tmp)&#123;
    if(ranks&#x3D;&#x3D;1)printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
    else&#123;
        hanoi(ranks-1,origin,tmp,aim);
        printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
        hanoi(ranks-1,tmp,aim,origin);
    &#125;
&#125; *&#x2F;
&#x2F;*  使用栈模拟系统栈运行递归的解法  
#include&lt;cstdio&gt;
#define MAXINPUT 64
&#x2F;&#x2F;定义两个宏以便于在push和hanoi_stimulation函数中批量创建同名变量拷贝栈顶活动的参数
#define PUSH_S(x) sysstack_stimulation[top].x&#x3D;x  
#define SET(x) x&#x3D;sysstack_stimulation[top].x
&#x2F;&#x2F;定义一个结构体，储存模拟活动中的参数信息
typedef struct info&#123;
    char origin,aim,tmp;
    int ranks,step;
&#125;info;
&#x2F;&#x2F;定义一个模拟栈用于模拟递归过程的活动记录
info sysstack_stimulation[MAXINPUT];
void push(int,char,char,char,int),hanoi_stimulation();
int top;   &#x2F;&#x2F;栈顶指针
int main()&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    push(n,&#39;a&#39;,&#39;c&#39;,&#39;b&#39;,0);
    while(top&gt;0)hanoi_stimulation(); &#x2F;&#x2F;模拟栈不为空则循环执行hanoi模拟函数
&#125;
void push(int ranks,char origin,char aim,char tmp,int step)&#123;
    top++;  &#x2F;&#x2F;注意push时要先新开一个栈单元，再存储活动记录
    PUSH_S(ranks);
    PUSH_S(origin);
    PUSH_S(aim);
    PUSH_S(tmp);
    PUSH_S(step);
&#125;
void hanoi_stimulation()&#123;
    int SET(ranks),SET(step);
    char SET(origin),SET(aim),SET(tmp);
    switch(step)&#123;
        &#x2F;&#x2F;根据hanoi的递归函数可知，当ranks不为1时每层的子问题需要进行三步处理
        case 0:     &#x2F;&#x2F;case为0存在两种情况，ranks为1时打印语句，ranks不为1说明是刚压入栈的“递归”子活动
            if(ranks&#x3D;&#x3D;1)&#123;
                printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
                break;
            &#125;else&#123;  
                sysstack_stimulation[top].step++;  
                push(ranks-1,origin,tmp,aim,0);    &#x2F;&#x2F;继续向栈中压入ranks规模更小的子函数
                &#x2F;&#x2F;相当于模拟hanoi(ranks-1,origin,tmp,aim);
                return;   &#x2F;&#x2F;return而不是break，这样可以不执行后面的弹栈操作，使活动记录暂时“休眠”在栈中
            &#125;
        case 1:     &#x2F;&#x2F;case为1时说明第一步的子活动递归完成返回了，后栈顶活动完成了第一步处理
            sysstack_stimulation[top].step++;
            push(1,origin,aim,tmp,0);
            &#x2F;&#x2F;将ranks为1的活动压入栈顶，实际上相当于模拟printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
            return;
        case 2:     &#x2F;&#x2F;case为2的情况同理
            sysstack_stimulation[top].step++;
            push(ranks-1,tmp,aim,origin,0);
            &#x2F;&#x2F;相当于模拟hanoi(ranks-1,tmp,aim,origin);
            return;
        default:break;
    &#125;
    top--;     &#x2F;&#x2F;正常结束的情况(即ranks规模为1，符合递归出口条件时)，将栈顶活动弹出
&#125;
&#x2F;*  使用栈模拟系统栈运行递归的解法：改进
    实际上在使用栈模拟递归时并不需要使用专门的变量step来记录模拟进行的步骤，因为只要栈中活动顺序没有问题，那么与正常递归执行的顺序是
    一致的；但是需要注意的是，如果将递归函数的三步操作一次性压入栈中的话，需要逆序压入，这样栈顶的是第一步操作，然后对栈顶活动继续模拟
    即可(由于二三步操作之前就被压入栈中，因此后续只需要对栈顶活动进行处理即可)    
#include&lt;cstdio&gt;
#define MAXINPUT 64
#define PUSH_S(x) sysstack_stimulation[top].x&#x3D;x  
#define SET(x) x&#x3D;sysstack_stimulation[top].x
typedef struct info&#123;
    char origin,aim,tmp;
    int ranks;
&#125;info;
info sysstack_stimulation[MAXINPUT];
void push(int,char,char,char),hanoi_stimulation();
int top;
int main()&#123;
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    push(n,&#39;a&#39;,&#39;c&#39;,&#39;b&#39;);
    while(top&gt;0)hanoi_stimulation(); 
&#125;
void push(int ranks,char origin,char aim,char tmp)&#123;
    top++; 
    PUSH_S(ranks);
    PUSH_S(origin);
    PUSH_S(aim);
    PUSH_S(tmp);
&#125;
void hanoi_stimulation()&#123;
    int SET(ranks);
    char SET(origin),SET(aim),SET(tmp);
    top--;   &#x2F;&#x2F;注意这种情况下只需将初始栈中的活动弹出，或替换为三个新的活动即可
    if(ranks&#x3D;&#x3D;1)printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
    else&#123;
        push(ranks-1,tmp,aim,origin);
        printf(&quot;%c -&gt; %c\n&quot;,origin,aim);
        push(ranks-1,origin,tmp,aim);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="file-transfer"><a class="markdownIt-Anchor" href="#file-transfer"></a> File Transfer</h1>
<p>We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?</p>
<span id="more"></span>
<h2 id="input-specification"><a class="markdownIt-Anchor" href="#input-specification"></a> Input Specification</h2>
<p>Each input file contains one test case. For each test case, the first line contains <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mn>2</mn><mo>≤</mo><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N (2≤N≤10^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ,the total number of computers in a network.<br>
Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format:</p>
<blockquote>
<p>I c1 c2</p>
</blockquote>
<p>where I stands for inputting a connection between c1 and c2; or</p>
<blockquote>
<p>C c1 c2</p>
</blockquote>
<p>where C stands for checking if it is possible to transfer files between c1 and c2; or</p>
<blockquote>
<p>S</p>
</blockquote>
<p>where S stands for stopping this case.</p>
<h2 id="output-specification"><a class="markdownIt-Anchor" href="#output-specification"></a> Output Specification</h2>
<p>For each C case, print in one line the word “yes” or “no”. if it is possible or impossible to transfer files between c1 and c2, respectively.<br>
At the end of each case, print in one line</p>
<blockquote>
<p>The network is connected.</p>
</blockquote>
<p>if there is a path between any pair of computers; or</p>
<blockquote>
<p>There are k components.</p>
</blockquote>
<p>where k is the number of connected components in this network.</p>
<h2 id="sample-input-1"><a class="markdownIt-Anchor" href="#sample-input-1"></a> Sample Input 1</h2>
<pre class="line-numbers language-none"><code class="language-none">5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-1"><a class="markdownIt-Anchor" href="#sample-output-1"></a> Sample Output 1</h2>
<pre class="line-numbers language-none"><code class="language-none">no
no
yes
There are 2 components.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-input-2"><a class="markdownIt-Anchor" href="#sample-input-2"></a> Sample Input 2</h2>
<pre class="line-numbers language-none"><code class="language-none">5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
I 1 3
C 1 5
S<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="sample-output-2"><a class="markdownIt-Anchor" href="#sample-output-2"></a> Sample Output 2</h2>
<pre class="line-numbers language-none"><code class="language-none">no
no
yes
yes
The network is connected.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="程序框架搭建"><a class="markdownIt-Anchor" href="#程序框架搭建"></a> 程序框架搭建</h1>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    初始化集合;
    do&#123;
    读入一条指令;
    处理指令;
    &#125;while(没结束);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    SetType S;
    int n;
    char in;
    scanf(&quot;%d\n&quot;,&amp;n);
    Initialization(S,n);
    do
    &#123;
        scanf(&quot;%c&quot;,&amp;in);
        switch(in)
        &#123;
            case &#39;I&#39;:Input_connection(S);break;     &#x2F;&#x2F;Union(Find)
            case &#39;C&#39;:Check_connection(S);break;     &#x2F;&#x2F;Find
            case &#39;S&#39;:Check_network(S,n);break;      &#x2F;&#x2F;集合的根
        &#125;
    &#125;while(in!&#x3D;&#39;S&#39;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">输入连接
void Input_connection(SetType S)
&#123;
    ElementType u,v;
    SetName Root1,Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1&#x3D;Find(s,u-1);
    Root2&#x3D;Find(s,u-1);
    if(Root1!&#x3D;Root2)Union(S,Root1,Root2);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">检查连接
void Check_connection(SetType S)
&#123;
    ElementType u,v;
    SetName Root1,Root2;
    scanf(&quot;%d %d\n&quot;,&amp;u,&amp;v);
    Root1&#x3D;Find(s,u-1);
    Root2&#x3D;Find(s,u-1);
    if(Root1&#x3D;&#x3D;Root2)cout&lt;&lt;&quot;yes&quot;&lt;&lt;endl;
    else cout&lt;&lt;&quot;no&quot;&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">检查整个路径
void Check_network(S,n)
&#123;
    int count&#x3D;0;
    for(int i;i&lt;n;i++)if(S[i]&lt;0)count++;
    if(count&#x3D;&#x3D;1)cout&lt;&lt;&quot;The network is connected.&quot;&lt;&lt;endl;
    else cout&lt;&lt;&quot;There are &quot;&lt;&lt;count&lt;&lt;&quot; components.&quot;&lt;&lt;endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="核心算法tssn版本的too-simple-and-naive"><a class="markdownIt-Anchor" href="#核心算法tssn版本的too-simple-and-naive"></a> 核心算法TSSN版本的(too simple and naive)</h2>
<p>算法1:</p>
<pre class="line-numbers language-none"><code class="language-none">SetName Find(SetType S,ElementType X)
&#123;
    for(;S[X]&gt;&#x3D;0;X&#x3D;S[X]);
    return X;
&#125;
void Union(SetType S,SetName Root1,SetName Root2)
&#123;
    S[Root1]&#x3D;Root2; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>算法2:</p>
<pre class="line-numbers language-none"><code class="language-none">int Find(SetType S[],ElementType X)
&#123;
    int i;
    for(i&#x3D;0;i&lt;MaxSize&amp;&amp;S[i].Data!&#x3D;X;i++);
    if(i&gt;&#x3D;MaxSize)return -1;
    for(;S[i].Parent&gt;&#x3D;0;i&#x3D;S[i].Parent);
    return i;
&#125;
void Union(SetType S[],ElementType X1,ElementType X2)
&#123;
    int Root1,Root2;
    Root1&#x3D;Find(S,X1);
    Root2&#x3D;Find(S,X2);
    if(Root1!&#x3D;Root2)S[Root2].Parent&#x3D;Root1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>TSSN版本的特点：永远把Root2接到Root1下面，极端情况：当需要将一个结点和其他所有结点连接且方向一致时，树的高度会一直增加</p>
<h2 id="按秩归并"><a class="markdownIt-Anchor" href="#按秩归并"></a> 按秩归并</h2>
<p>为什么树会越来越高？</p>
<ul>
<li>应该把矮树贴到高树上，此时高树的高度不变，矮树的高度+1</li>
<li>树的高度存在哪里？
<ul>
<li>使用根结点存储树高，S[Root]=-树高;  (S中的元素初值仍然初始化为1)</li>
<li>这种算法只有一种情况下高树的高度需要改变：两树高度相等的时候</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void Union(SetType S,SetName Root1,SetName Root2)
&#123;
    if(S[Root1]&lt;S[Root2])S[Root2]&#x3D;Root1;
    else
    &#123;
        if(S[Root1]&#x3D;&#x3D;S[Root2])S[Root2]++;
        S[Root1]&#x3D;Root2;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>另一种做法：比规模
<ul>
<li>小树贴到大树上 S[Root]=-元素个数</li>
<li>相对来说，这种方法与按秩归并结合的效果更佳</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void Union(SetType S,SetName Root1,SetName Root2)
&#123;
    if(S[Root1]&lt;S[Root2])
    &#123;
        S[Root1]+&#x3D;S[Root2];
        S[Root2]&#x3D;Root1;
    &#125;
    else&#123;
        S[Root2]+&#x3D;S[Root1];
        S[Root1]&#x3D;Root2;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>以上两种方法统称“按秩归并”
<ul>
<li>最坏情况下的树高：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(lgN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>  (等秩归并的次数)</li>
</ul>
</li>
</ul>
<h2 id="路径压缩"><a class="markdownIt-Anchor" href="#路径压缩"></a> 路径压缩</h2>
<pre class="line-numbers language-none"><code class="language-none">SetName Find(SetType S,ElementType X)
&#123;
    if(S[X]&lt;0)return X;
    else return S[X]&#x3D;Find(S,S[X]);              &#x2F;&#x2F;先找到根，把根变成X的父结点，再返回根
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>路径压缩的精髓在于S[X]=Find(S,S[X])<br>
当递归停止后返回的是最后的根结点，注意：同时将根结点下一层结点的父结点值赋为根结点的值，同时返回该层的父结点！<br>
到下一层后，再将下一层的父结点(即上一层结点)的值赋为递归调用返回的上一层父结点的值(根结点的值)<br>
这个过程直到最后，将结点X向上遍历过程中的所有父结点都连接到了最后的根上，使总的高度变为了2！<br>
此外，这里采用的是伪递归，伪递归是非常容易转化为循环的，所以实际上这段代码在编译过程中已经被编译器自动转化为了循环</p>
<blockquote>
<p>引理(Tarjan)：令T(M,N)为交错执行M&gt;=N次带路径压缩的查找和N-1次按秩归并的最坏情况时间，则存在正常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">k_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">k_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>使得：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mn>1</mn></msub><mi>M</mi><mi>α</mi><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>T</mi><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo><mo>≤</mo><msub><mi>k</mi><mn>2</mn></msub><mi>M</mi><mi>α</mi><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">k_1Mα(M,N)\leq T(M,N)\leq k_2Mα(M,N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
</blockquote>
<blockquote>
<p>Ackermann函数</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mi>j</mi></msup><mtext>    </mtext><mi>i</mi><mo>=</mo><mn>1</mn><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>j</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A(i,j)=2^j\space\space\space\space  i=1\space and\space j\geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span></span></span></span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo><mtext>    </mtext><mi>i</mi><mo>≥</mo><mn>2</mn><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>j</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A(i,j)=A(i-1,2)\space\space\space\space i\geq 2\space and\space j=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mtext>    </mtext><mi>i</mi><mo>≥</mo><mn>2</mn><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>j</mi><mo>≥</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">A(i,j)=A(i-1,A(i,j-1))\space\space\space\space i\geq 2\space and\space j\geq 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ul>
</blockquote>
<p>Ackermann函数增长极快，如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">)</mo><mo>=</mo><msup><mn>2</mn><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><msup><mn>2</mn><msup><mn>2</mn><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></msup></msup><mo>=</mo><msup><mn>2</mn><msup><mn>2</mn><msup><mn>2</mn><msup><mn>2</mn><mrow><mi>A</mi><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msup></msup></msup></msup><mo>=</mo><msup><mn>2</mn><msup><mn>2</mn><mn>16</mn></msup></msup><mo>=</mo><msup><mn>2</mn><mn>65536</mn></msup></mrow><annotation encoding="application/x-tex">A(2,4)=2^{A(2,3)}=2^{2^{A(2,2)}}=2^{2^{2^{2^{A(1,1)}}}}=2^{2^{16}}=2^{65536}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.0396999999999998em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0396999999999998em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9667142857142857em;"><span style="top:-2.966714285714285em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5357142857142856em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4437em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.4437em;"><span style="top:-3.4437em;margin-right:0.05em;"><span class="pstrut" style="height:3.0807em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.5438571428571428em;"><span style="top:-3.543857142857143em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:3.112857142857143em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.5579999999999998em;"><span style="top:-3.558em;margin-right:0.1em;"><span class="pstrut" style="height:3.154em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.154em;"><span style="top:-3.154em;margin-right:0.1em;"><span class="pstrut" style="height:2.75em;"></span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9869199999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9869199999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">5</span><span class="mord mtight">5</span><span class="mord mtight">3</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span></p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi><mo stretchy="false">(</mo><mi>M</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">{</mo><mi>i</mi><mo>≥</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>A</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mo stretchy="false">⌊</mo><mi>M</mi><mi mathvariant="normal">/</mi><mi>N</mi><mo stretchy="false">⌋</mo><mo stretchy="false">)</mo><mo>&gt;</mo><mi>l</mi><mi>g</mi><mi>N</mi><mo stretchy="false">}</mo><mo>≤</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>g</mi><mo>∗</mo><mi>N</mi><mo stretchy="false">)</mo><mo>≤</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">α(M,N)=min\{i\geq 1|A(i,⌊M/N⌋)&gt;lgN\}\leq O(lg*N)\leq 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">{</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">⌊</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">⌋</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p>
</blockquote>
<p>(在自然界会出现的情况中α一般不会超过4)<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">lg*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>=对N递归地求对数，直到结果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\leq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的次数(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">lg*N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>为Ackermann反函数)，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>g</mi><mo>∗</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mn>65536</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">lg*(2^{65536})=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">5</span><span class="mord mtight">5</span><span class="mord mtight">3</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span></p>
<p>α为满足Ackermann函数大于lgN的i中最小的那一个(α非常小)<br>
综上，当路径压缩和按秩归并结合使用的时候，两者结合的时间复杂度为常数级</p>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>树和集合</title>
    <url>/posts/f20d5a67d2ed</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 13%;
}
table th:nth-of-type(2){
width: 13%;
;
}
table th:nth-of-type(3){
width: 13%;
}
table th:nth-of-type(4){
width: 13%;
}
table th:nth-of-type(5){
width: 10%;
}
table th:nth-of-type(6){
width: 10%;
}
table th:nth-of-type(7){
width: 10%;
}
table th:nth-of-type(8){
width: 10%;
}
</style>
<h1 id="什么是树"><a class="markdownIt-Anchor" href="#什么是树"></a> 什么是树</h1>
<p>客观世界中许多事物存在层次结构</p>
<ul>
<li>人类社会家谱</li>
<li>社会组织结构</li>
<li>图书信息管理</li>
</ul>
<p>分层次组织在管理上具有更高的效率</p>
<span id="more"></span>
<h2 id="树的定义"><a class="markdownIt-Anchor" href="#树的定义"></a> 树的定义</h2>
<p>树(Tree)：n(n&gt;=0)个结点构成的有限集合<br>
当n=0时，称为空树<br>
对于任一棵非空树(n&gt;0)，它具备以下性质：</p>
<ul>
<li>树中有一个称为“根(Root)”的特殊结点，用r表示</li>
<li>其余结点可分为m(m&gt;0)个互不相交的有限集<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_1,T_2,…,T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一棵树
<ul>
<li>称为原来树的“子树(SubTree)”</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/yBOPd8zT7mUCgHi.png" width="50%" height="50%">
<h3 id="树与非树"><a class="markdownIt-Anchor" href="#树与非树"></a> 树与非树</h3>
<ul>
<li>树的子树是不相交的</li>
<li>除了根结点外，每个结点有且仅有一个父节点</li>
<li>一棵N个结点的树有N-1条边(m棵树(森林)有k条边，则一共有k-m个结点)</li>
<li>树将所有结点连接在一起，随便去除哪一条边都会使树不连通</li>
<li>树是使结点连通的方式之中边最少的一种</li>
</ul>
<h2 id="树的一些基本术语"><a class="markdownIt-Anchor" href="#树的一些基本术语"></a> 树的一些基本术语</h2>
<ul>
<li>结点的度(Degree)：结点的子树个数</li>
<li>数的度：树中所有结点中最大的度数</li>
<li>叶结点(Leaf)：度为0的结点</li>
<li>父结点(Parent)：有子树的结点是其子树的根结点的父结点</li>
<li>子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点</li>
<li>兄弟结点(Sibling)：具有同一父结点的各结点之间彼此是兄弟结点</li>
<li>路径和路径长度：从结点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">n_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">n_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的路径为一个结点序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>n</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>n</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n_1,n_2,…,n_k,n_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>n</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">n_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>的父结点
<ul>
<li>路径所包含边的个数为路径的长度</li>
</ul>
</li>
<li>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点</li>
<li>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙</li>
<li>结点的层次(Level)：规定根结点在1层，其他任一结点的层数是其父结点的层数加1</li>
<li>树的深度(Depth)：树中所有结点中的最大层次是这棵树的深度</li>
</ul>
<h2 id="树的表示"><a class="markdownIt-Anchor" href="#树的表示"></a> 树的表示</h2>
<p>在使用树结构描述实际问题时，大多数不是二叉树，更多的是普通的树结构，在存储之间具有普通树结构的数据时，经常使用的方法有3种：</p>
<ul>
<li>双亲表示法
<ul>
<li>数据域：Data和指针域：Parent</li>
</ul>
</li>
<li>孩子表示法
<ul>
<li>以单链表作存储结构将每个孩子结点排列起来，则n个结点有n个孩子链表</li>
</ul>
</li>
<li>孩子兄弟表示法
<ul>
<li>一个数据域和两个指针域
<ul>
<li>n个结点有2n个指针域，n-1条边，说明有n+1个指针域是空的</li>
</ul>
</li>
<li>Firstchild：第一个孩子结点</li>
<li>NextSibling：相邻的兄弟结点</li>
<li>这种情况下，将整棵树旋转45度，得到的是一棵“二叉树”(度为2)</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/GjB5cgnbHSLtCRQ.png" width="30%" height="30%">
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2>
<p>分为数据域和指针域，指针分别指向两个孩子结点</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct TNode *Position;
typedef Position BinTree;
struct TNode&#123;
    ElementType Data;
    BinTree Left;
    BinTree Right;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对一般的树而言均可以用二叉树的形式实现，因此一般数的表示和操作实现其核心和基础就是二叉树的表示和实现<br>
了解二叉树的实现和操作，实际上就解决了一般树的许多问题<br>
二叉树的研究是在树结构的研究当中最重要的一部分</p>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<h2 id="集合的操作"><a class="markdownIt-Anchor" href="#集合的操作"></a> 集合的操作</h2>
<ul>
<li>集合运算：交、并、补、差，判定一个元素是否属于某一集合</li>
<li>并查集：用于处理一些集合合并、查某元素属于什么集合的问题(只关心两种运算)</li>
</ul>
<h2 id="集合存储"><a class="markdownIt-Anchor" href="#集合存储"></a> 集合存储</h2>
<p>并查集问题中集合存储如何实现？<br>
例：有十台电脑{1,2,3,4,5,6,7,8,9,10}，已知下列电脑之间实现了连接：<br>
1和2，2和4，3和5，4和7，5和8，6和9，6和10，问2和7，5和9之间是否是连通的<br>
解决思路：</p>
<ul>
<li>将10台电脑看成10个集合{1},{2},{3}……{10}</li>
<li>已知一种连接“a和b”就是将a和b对应的集合合并</li>
<li>查询“a和b是否是连通的”就是判别a和b是否在同一集合</li>
<li>用树结构表示集合，数的每个结点代表一个集合元素，并且使用双亲表示法，可以找到结点所属的集合(根结点)</li>
</ul>
<p>例如：有三个整数集合</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub><mo>=</mo><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>7</mn></mrow><mo separator="true">,</mo><msub><mi>S</mi><mn>2</mn></msub><mo>=</mo><mrow><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn></mrow><mo separator="true">,</mo><msub><mi>S</mi><mn>3</mn></msub><mo>=</mo><mrow><mn>6</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn></mrow></mrow><annotation encoding="application/x-tex">S_1={1,2,4,7},S_2={3,5,8},S_3={6,9,10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span></span>;</li>
<li>可以采用双亲表示的树结构表示集合
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的根结点为1，2、4、7为子结点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的根结点为3，5、8为子结点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">S_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的根结点为6，9、10为子结点</li>
</ul>
</li>
<li>采用顺序存储的形式存储树(Parent域中负数表示根结点,非负数表示双亲结点的下标)
<ul>
<li>数组中元素描述为</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">typedef struct SetType
&#123;
    ElementType Data;
    int Parent;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">下标</th>
<th style="text-align:center">Data</th>
<th style="text-align:center">Parent</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">-1</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<h2 id="集合运算"><a class="markdownIt-Anchor" href="#集合运算"></a> 集合运算</h2>
<h3 id="查找某个元素所在的集合用根结点表示"><a class="markdownIt-Anchor" href="#查找某个元素所在的集合用根结点表示"></a> 查找某个元素所在的集合(用根结点表示)</h3>
<pre class="line-numbers language-none"><code class="language-none">int Find(SetType S[],ElementType X)
&#x2F;&#x2F;在数组S中查找值为X的元素所属的集合
&#x2F;&#x2F;MaxSize是全局变量，为数组S的最大长度
&#123;
    int i;
    for(i&#x3D;0;i&lt;MaxSize&amp;&amp;S[i].Data!&#x3D;X;i++);       &#x2F;&#x2F;在集合中找到X的下标
    if(i&gt;&#x3D;MaxSize)return -1;                    &#x2F;&#x2F;未找到X，返回-1
    for(;S[i].Parent&gt;&#x3D;0;i&#x3D;S[i].Parent);
    return i;                                   &#x2F;&#x2F;找到X所属集合，返回树根结点在数组S中的下标
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="集合的并运算"><a class="markdownIt-Anchor" href="#集合的并运算"></a> 集合的并运算</h3>
<ul>
<li>分别找到X1和X2两个元素所在集合数的根结点</li>
<li>如果它们不同根，则将其中一个根结点的指针设置成另一个根结点的数组下标</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">void Union(SetType S[],ElemnetType X1,ElemnetType X2)
&#123;
    int Root1,Root2;
    Root1&#x3D;Find(S,X1),Root2&#x3D;Find(S,X2);         &#x2F;&#x2F;先找到X1和X2所在的集合
    if(Root1!&#x3D;Root2)S[Root2].Parent&#x3D;Root1;     &#x2F;&#x2F;当X1和X2不属于同一子集时，才需要合并
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了改善合并以后的查找性能，可以采用小的集合合并到相对大的集合中<br>
为达到这种效果，可以在根结点记录集合的元素个数(如集合有3个元素则根结点的Parent域的值为-3)</p>
<pre class="line-numbers language-none"><code class="language-none">void ModifyRoot(SetType S[])
&#123;
    int i;
    ElementType Leafs[MaxSize];
    for(i&#x3D;0;i&lt;MaxSize;i++)Leafs[i]&#x3D;0;
    for(i&#x3D;0;i&lt;MaxSize;i++)if(S[i].Parent&gt;&#x3D;0)Leafs[S[i].Parent]++;
    for(i&#x3D;0;i&lt;MaxSize;i++)if(Leafs[i]&gt;0)S[i]&#x3D;-Leafs[i]-1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>改进后：</p>
<pre class="line-numbers language-none"><code class="language-none">void Union(SetType S[],ElemnetType X1,ElemnetType X2)
&#123;
    int Root1,Root2,MaxRoot;
    Root1&#x3D;Find(S,X1),Root2&#x3D;Find(S,X2);
    if(Root1!&#x3D;Root2)
    &#123;
        if(Root1.Parent&gt;&#x3D;Root2.Parent)
        &#123;
            S[Root1].Parent&#x3D;Root2;
            Root2+&#x3D;Root1;
        &#125;
        else 
        &#123;
            S[Root2].Parent&#x3D;Root1;
            Root1+&#x3D;Root2;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时可以看到，在集合结构的查找过程中需要遍历一个数组，效率较低，可以考虑进行简化表示</p>
<ul>
<li>任何有限集合的N个元素都可以被一一映射为整数0～N-1，所以可以进一步进行改进</li>
<li>直接使用数组(直接以下标表示Data)就可以存储一个集合</li>
</ul>
<h2 id="集合的简化表示"><a class="markdownIt-Anchor" href="#集合的简化表示"></a> 集合的简化表示</h2>
<pre class="line-numbers language-none"><code class="language-none">typedef int ElementType;                     &#x2F;&#x2F;默认元素可以用非负整数表示
typedef int SetName;                         &#x2F;&#x2F;默认根结点的下标作为集合名称
typedef ElementType SetType[MaxSize];
查找元素
SetName Find(SetType S,ElementType X)        &#x2F;&#x2F;默认集合元素全部初始化为-1
&#123;
    for(;S[X]&gt;&#x3D;0;X&#x3D;S[X]);
    return X;
&#125;       
void Union(SetType S,SetName Root1,SetName Root2)  &#x2F;&#x2F;这里默认Root1和Root2是不同集合的根结点
&#123;
    S[Root2]&#x3D;Root1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并查集操作演示"><a class="markdownIt-Anchor" href="#并查集操作演示"></a> 并查集操作演示</h2>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;* 示例程序(浙江大学mooc数据结构) *&#x2F;
#define MAXN 1000                  &#x2F;* 集合最大元素个数 *&#x2F;
typedef int ElementType;           &#x2F;* 默认元素可以用非负整数表示 *&#x2F;
typedef int SetName;               &#x2F;* 默认用根结点的下标作为集合名称 *&#x2F;
typedef ElementType SetType[MAXN]; &#x2F;* 假设集合元素下标从0开始 *&#x2F;

void Union( SetType S, SetName Root1, SetName Root2 )
&#123; &#x2F;* 这里默认Root1和Root2是不同集合的根结点 *&#x2F;
    &#x2F;* 保证小集合并入大集合 *&#x2F;
    if ( S[Root2] &lt; S[Root1] ) &#123; &#x2F;* 如果集合2比较大 *&#x2F;
        S[Root2] +&#x3D; S[Root1];     &#x2F;* 集合1并入集合2  *&#x2F;
        S[Root1] &#x3D; Root2;
    &#125;
    else &#123;                         &#x2F;* 如果集合1比较大 *&#x2F;
        S[Root1] +&#x3D; S[Root2];     &#x2F;* 集合2并入集合1 *&#x2F;
        S[Root2] &#x3D; Root1;
    &#125;
&#125;

SetName Find( SetType S, ElementType X )
&#123; &#x2F;* 默认集合元素全部初始化为-1 *&#x2F;
    if ( S[X] &lt; 0 ) &#x2F;* 找到集合的根 *&#x2F;
        return X;
    else
        return S[X] &#x3D; Find( S, S[X] ); &#x2F;* 路径压缩 *&#x2F;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>串与串的模式匹配</title>
    <url>/posts/5d5b29a8179b</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 12%;
}
table th:nth-of-type(2){
width: 8%;
;
}
table th:nth-of-type(3){
width: 8%;
}
table th:nth-of-type(4){
width: 8%;
}
table th:nth-of-type(5){
width: 8%;
}
table th:nth-of-type(6){
width: 8%;
}
table th:nth-of-type(7){
width: 8%;
}
table th:nth-of-type(8){
width: 8%;
}
table th:nth-of-type(9){
width: 8%;
}
table th:nth-of-type(10){
width: 8%;
}
table th:nth-of-type(11){
width: 8%;
}
</style>
<h1 id="什么是串"><a class="markdownIt-Anchor" href="#什么是串"></a> 什么是串</h1>
<ul>
<li>线性存储的一组数据(默认是字符)</li>
<li>是线性表的一种特殊的应用，指的就是线性存储的一组数据</li>
<li>特殊操作集
<ul>
<li>求串的长度</li>
<li>比较两串是否相等</li>
<li>两串相接</li>
<li>求子串</li>
<li>插入子串</li>
<li>匹配子串</li>
<li>删除子串</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h1 id="模式匹配"><a class="markdownIt-Anchor" href="#模式匹配"></a> 模式匹配</h1>
<p>目标：</p>
<ul>
<li>给定一段文本，从中找出某个指定的关键字。</li>
<li>例：从一本Thomas Love Peacock写于十九世纪的小说《Headlong Hall》中找到那个最长的单词
<ul>
<li>osseocarnisanguineoviscericartilaginonervomedullary</li>
</ul>
</li>
<li>或者从古希腊喜剧《Assemblywomen》中找到一道菜的名字
<ul>
<li>Lopadotemachoselachogaleokranioleipsanodrimhypotrim<br>
matosilphioparaomelitokatakechymenokichlepikossyphoph<br>
attoperisteralektryonoptekephalliokigklopeleiolagoiosiraio baphetraganopterygon</li>
</ul>
</li>
</ul>
<p>实质：</p>
<ul>
<li>给定一段文本：string=s(0)s(1)……s(n-1)</li>
<li>给定一个模式：pattern=p(0)p(1)……p(m-1)</li>
<li>求pattern在string中出现的位置
<ul>
<li>Position PatternMatch(char* string,char* pattern);</li>
</ul>
</li>
</ul>
<p>简单实现：</p>
<ul>
<li>方法1:c的库函数strstr
<ul>
<li>char* strstr(char* string,char* pattern);</li>
</ul>
</li>
<li>伪代码描述</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
typedef char*Position;
#define NotFound NULL
int main()&#123;
    char string[]&#x3D;&quot;This is a simple example.&quot;;
    char pattern[]&#x3D;&quot;simple&quot;;
    Position p&#x3D;strstr(string,pattern);
    if(p&#x3D;&#x3D;NotFound)printf(&quot;Not Found.\n&quot;);
    else printf(&quot;%s\n&quot;,p);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>时间复杂度分析：</li>
<li>假设string=“aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa” 长度为n，<br>
pattern=“aab” 长度为m</li>
<li>在最坏情况下，子串要分别与主串中每个字符开头长度为m的子串进行匹配</li>
<li>每次匹配需比较m个字符，总共需要n数量级的匹配次数
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>∗</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T=O(n*m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
</ul>
<p>大师改进：</p>
<ul>
<li>方法2:kMP(Knuth、Morris、Pratt)算法</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/UceviphKwmyo6nS.png" width="50%" height="50%">
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，通过对模式串的一个预处理，将时间复杂度减少到了一个线性的水平</li>
<li>例：string:…… a b c a b x y ……   pattern:a b c a b c a
<ul>
<li>在一次匹配当中发现子串的最后两个字符与模式串不符，匹配失败</li>
<li>但是，在匹配中发现子串与模式串中的前5个字符是可以对应上的，因此可以将这些已知的信息再次利用</li>
<li>同时观察发现，模式串中第1，2，3个字符与第4，5，6个字符是相同的，而前3个字符在上次匹配时是能够对应上的</li>
<li>因此，下次匹配可以直接将模式串指针移动3个字符</li>
</ul>
</li>
<li>算法核心：对模式串进行处理，得到match数组(一般也称next数组)
<ul>
<li>match(j)=满足p(0)……p(i)=p(j-1)……p(j)的i中最大那个</li>
<li>match(j)=-1 (如果这样的i不存在)</li>
</ul>
</li>
<li>match数组的实质：对模式串的第j个字符来说，是否存在从模式串第一个字符出发得到的子串与从第j-1个位置出发得到的子串相同的情况
<ul>
<li>如果有的话，则match(j)取子串长度可能的最大值-1(前面子串结尾处的下标)</li>
</ul>
</li>
<li>在上例中:</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">pattern</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">c</th>
<th style="text-align:center">a</th>
<th style="text-align:center">c</th>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">j</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td style="text-align:center">match</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h2 id="主体部分伪代码描述"><a class="markdownIt-Anchor" href="#主体部分伪代码描述"></a> 主体部分伪代码描述</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
typedef int Position;
#define NotFound -1
int main()&#123;
    char string[]&#x3D;&quot;This is a simple example.&quot;;
    char pattern[]&#x3D;&quot;simple&quot;;
    Position p&#x3D;KMP(string,pattern);
    if(p&#x3D;&#x3D;NotFound)printf(&quot;Not Found.\n&quot;);
    else printf(&quot;%s\n&quot;,string+p);
    return 0;
&#125;
Position KMP(char*string,char*pattern)&#123;
    int n&#x3D;strlen(string);               &#x2F;&#x2F;O(n)
    int m&#x3D;strlen(pattern);              &#x2F;&#x2F;O(m)
    int s,p,*match;
    if(n&lt;m)return NotFound;
    match&#x3D;(int*)malloc(sizeof(int)*m);
    BuildMatch(pattern,match);          &#x2F;&#x2F;T(m)&#x3D;O(m)
    s&#x3D;p&#x3D;0;
    while(s&lt;n&amp;&amp;p&lt;m)&#123;                    &#x2F;&#x2F;O(n)
        if(string[s]&#x3D;&#x3D;pattern[p])&#123;
            s++;p++;
        &#125;
        else if(p&gt;0)p&#x3D;match[p-1]+1;     &#x2F;&#x2F;这里+1很重要，不然p&#x3D;-1的时候就死循环了
        else s++;
    &#125;
    return(p&#x3D;&#x3D;m)?s-m:NotFOund;
&#125;
这部分时间复杂度：T&#x3D;O(n+m+T(m))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="buildmatch的实现"><a class="markdownIt-Anchor" href="#buildmatch的实现"></a> BuildMatch的实现</h2>
<ul>
<li>方法1：如果考虑采用逐个元素搜索最大子串的方法：for(j=0;j&lt;m;j++)
<ul>
<li>最大子串最坏情况下平均需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>时间复杂度才能找到</li>
<li>m个元素总复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(m)=O(m^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因此这种方法完全无法接受</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/6NG9UWrw8sRBZli.png" width="50%" height="50%">
<ul>
<li>方法2：假设已经得到了j-1的match值
<ul>
<li>对于j，只需直接与match[j-1]的下一个字符比较(子串开始处的下一个字符)</li>
<li>如果相等，则match[j]=match[j-1]+1
<ul>
<li>相等的话j的最大子串说明在j-1的最大子串的基础上+1即可，这里运用了动态规划的思想</li>
</ul>
</li>
</ul>
</li>
<li>如果不相等就与match[match[j-1]]+1位置的字符比对(不相等的再继续往前回溯，直到第0个match值一定为-1)
<ul>
<li>match[match[j-1]]+1代表当前字符前一个字符的next值对应字符的下一个位置</li>
</ul>
</li>
<li>if(pattern[match[j-1]+1]==pattern[j])match[j]=match[j-1]+1;</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/UceviphKwmyo6nS.png" width="50%" height="50%">
<pre class="line-numbers language-none"><code class="language-none">void BuildMatch(char*pattern,int*match)&#123;
    int i,j;
    int m&#x3D;strlen(pattern);
    match[0]&#x3D;-1;
    for(j&#x3D;1;j&lt;m;j++)&#123;
        i&#x3D;match[j-1];
        while((i&gt;&#x3D;0)&amp;&amp;(pattern[i+1]!&#x3D;pattern[j]))
        i&#x3D;match[i];                 &#x2F;&#x2F;由于i回退的总次数不会超过i增加的总次数(要先有match[j-1]才可能回退)
        if(pattern[i+1]&#x3D;&#x3D;pattern[j])
        match[j]&#x3D;i+1;
        else match[j]&#x3D;-1;               &#x2F;&#x2F;因此T(m)是关于m的线性复杂度即T(m)&#x3D;O(m)
    &#125;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="kmp算法演示"><a class="markdownIt-Anchor" href="#kmp算法演示"></a> KMP算法演示</h1>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 引自浙江大学mooc数据结构课程
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; 
#include &lt;stdlib.h&gt;

typedef int Position;
#define NotFound -1

void BuildMatch( char *pattern, int *match )
&#123;
	Position i, j;
	int m &#x3D; strlen(pattern);
	match[0] &#x3D; -1;

	for ( j&#x3D;1; j&lt;m; j++ ) &#123;
		i &#x3D; match[j-1];
		while ( (i&gt;&#x3D;0) &amp;&amp; (pattern[i+1]!&#x3D;pattern[j]) )
			i &#x3D; match[i];
		if ( pattern[i+1]&#x3D;&#x3D;pattern[j] )
		     match[j] &#x3D; i+1;
		else match[j] &#x3D; -1;
	&#125;
&#125;

Position KMP( char *string, char *pattern )
&#123;
	int n &#x3D; strlen(string);
	int m &#x3D; strlen(pattern);
	Position s, p, *match;

	if ( n &lt; m ) return NotFound;
	match &#x3D; (Position *)malloc(sizeof(Position) * m);
	BuildMatch(pattern, match);
	s &#x3D; p &#x3D; 0;
	while ( s&lt;n &amp;&amp; p&lt;m ) &#123;
		if ( string[s]&#x3D;&#x3D;pattern[p] ) &#123;
			s++; p++;
		&#125;
		else if (p&gt;0) p &#x3D; match[p-1]+1;
		else s++;
	&#125;
	return ( p&#x3D;&#x3D;m )? (s-m) : NotFound;
&#125;

int main()
&#123;
	char string[] &#x3D; &quot;This is a simple example.&quot;;
	char pattern[] &#x3D; &quot;simple&quot;;
	Position p &#x3D; KMP(string, pattern);
	if (p&#x3D;&#x3D;NotFound) printf(&quot;Not Found.\n&quot;);
	else printf(&quot;%s\n&quot;, string+p);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/posts/2eaf537c47f5</url>
    <content><![CDATA[<h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1>
<p>“队列(Queue)”：具有一定操作约束的线性表</p>
<ul>
<li>插入和删除操作：只能在一端插入(队头)，在另一端删除(队尾)</li>
<li>数据插入：入队列(AddQ)</li>
<li>数据删除：出队列(DeleteQ)</li>
<li>先来先服务、先进先出:FIFO</li>
</ul>
<p>现实中最能体现堆栈结构的实例：排队</p>
<ul>
<li>后来的人只能排在队尾，先来的人先离队</li>
</ul>
<span id="more"></span>
<h2 id="队列的抽象数据类型描述"><a class="markdownIt-Anchor" href="#队列的抽象数据类型描述"></a> 队列的抽象数据类型描述</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：队列(Queue)
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为MaxSize的队列Q ∈ Queue，队列元素item ∈ ElementType
Queue CreateQueue(int MaxSize):生成长度为MaxSize的空队列；
int IsFull(Queue Q,int MaxSize):判断队列Q是否已满；
void AddQ(Queue Q,ElementType item):将数据元素item插入Q中；
int IsEmpty(Queue Q):判断队列Q是否为空；
ElementType DeleteQ(Queue Q):将队头数据元素从队列中删除并返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="队列的顺序存储实现"><a class="markdownIt-Anchor" href="#队列的顺序存储实现"></a> 队列的顺序存储实现</h2>
<p>队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成</p>
<pre class="line-numbers language-none"><code class="language-none">#define MaxSize&lt;储存数据元素的最大个数&gt;
struct QNode
&#123;
    ElementType Data[MaxSize];
    int front,rear;                 &#x2F;&#x2F;rear指向队尾元素，front指向队头元素之前一个元素
&#125;;
typedef struct QNode *Queue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="队列的链式存储实现"><a class="markdownIt-Anchor" href="#队列的链式存储实现"></a> 队列的链式存储实现</h2>
<p>队列的链式存储结构也可以用一个单链表实现</p>
<pre class="line-numbers language-none"><code class="language-none">插入和删除操作分别在链表的两头进行    &#x2F;&#x2F;front应指向链表表头，因为删除时需要知道队列元素的位置
struct Node                     &#x2F;&#x2F;rear应指向链表表尾，因为插入时不需要知道下一个元素的位置，并且把后入队元素加在表尾
&#123;
    ElementType Data;
    struct Node *Next;
&#125;;
struct QNode
&#123;
    struct Node *rear;
    struct Node *front;
&#125;;
typedef struct QNode *Queue;
Queue PtrQ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="循环队列"><a class="markdownIt-Anchor" href="#循环队列"></a> 循环队列</h2>
<p>顺序队列存在的“假溢出”缺陷</p>
<ul>
<li>当rear指向数组空间最后时，队列无法再进入新元素</li>
<li>只要进行过一次出队列操作，front就不会指向数组开始下标</li>
<li>因此，顺序队列可能存在数组没满但无法入队列的情况</li>
</ul>
<p>解决“假溢出”：引入循环队列</p>
<ul>
<li>当队尾指针rear和队头指针front到达存储空间最大值时，让队尾指针自动转化为存储空间的最小值0(+1取余法)</li>
</ul>
<p>循环队列中，队空和队满条件都是front==rear，此时存在二义性</p>
<ul>
<li>二义性的根本原因：假设数组长度为n，则两个下标之间的差有n种可能(0,1…,n-1)，而队列长度有n+1(0,1…,n)种可能，<br>
要使用n种状态表示n+1种情况是不可能的</li>
<li>解决方案有三种：
<ul>
<li>加设标志位，让删除动作使其为1，插入动作使其为0     //当动作为插入/删除时导致front==rear，则说明队满/队空</li>
<li>使用一个计数器记录队列中元素个数(即队列长度)</li>
<li>人为浪费一个单元，令队满特征为front=(rear+1)%N</li>
</ul>
</li>
</ul>
<h1 id="队列的顺序存储演示"><a class="markdownIt-Anchor" href="#队列的顺序存储演示"></a> 队列的顺序存储演示</h1>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;以下两部分顺序存储和链式存储代码均来自浙江大学数据结构课程
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define ERROR -1
typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node &#123; &#x2F;* 队列中的结点 *&#x2F;
    ElementType Data;
    PtrToNode Next;
&#125;;
typedef PtrToNode Position;

struct QNode &#123;
    Position Front, Rear;  &#x2F;* 队列的头、尾指针 *&#x2F;
    int MaxSize;           &#x2F;* 队列最大容量 *&#x2F;
&#125;;
typedef struct QNode *Queue;

bool IsEmpty( Queue Q )
&#123;
    return ( Q-&gt;Front &#x3D;&#x3D; NULL);
&#125;

ElementType DeleteQ( Queue Q )
&#123;
    Position FrontCell; 
    ElementType FrontElem;
  
    if  ( IsEmpty(Q) ) &#123;
        printf(&quot;队列空&quot;);
        return ERROR;
    &#125;
    else &#123;
        FrontCell &#x3D; Q-&gt;Front;
        if ( Q-&gt;Front &#x3D;&#x3D; Q-&gt;Rear ) &#x2F;* 若队列只有一个元素 *&#x2F;
            Q-&gt;Front &#x3D; Q-&gt;Rear &#x3D; NULL; &#x2F;* 删除后队列置为空 *&#x2F;
        else                 
            Q-&gt;Front &#x3D; Q-&gt;Front-&gt;Next;
        FrontElem &#x3D; FrontCell-&gt;Data;

        free( FrontCell );  &#x2F;* 释放被删除结点空间  *&#x2F;
        return  FrontElem;
    &#125;
&#125;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define ERROR -1
typedef int ElementType;
typedef int Position;
struct QNode &#123;
    ElementType *Data;     &#x2F;* 存储元素的数组 *&#x2F;
    Position Front, Rear;  &#x2F;* 队列的头、尾指针 *&#x2F;
    int MaxSize;           &#x2F;* 队列最大容量 *&#x2F;
&#125;;
typedef struct QNode *Queue;

&#x2F;* Front和rear移动使用“+1取余法”实现顺序存储的“循环使用” *&#x2F;
&#x2F;* 其它基本操作可参考线性结构和堆栈的示例 *&#x2F;

Queue CreateQueue( int MaxSize )
&#123;
    Queue Q &#x3D; (Queue)malloc(sizeof(struct QNode));
    Q-&gt;Data &#x3D; (ElementType *)malloc(MaxSize * sizeof(ElementType));
    Q-&gt;Front &#x3D; Q-&gt;Rear &#x3D; 0;
    Q-&gt;MaxSize &#x3D; MaxSize;
    return Q;
&#125;

bool IsFull( Queue Q )
&#123;
    return ((Q-&gt;Rear+1)%Q-&gt;MaxSize &#x3D;&#x3D; Q-&gt;Front);            &#x2F;&#x2F;队满条件：(rear+1)%n&#x3D;front
&#125;

bool AddQ( Queue Q, ElementType X )
&#123;
    if ( IsFull(Q) ) &#123;
        printf(&quot;队列满&quot;);
        return false;
    &#125;
    else &#123;
        Q-&gt;Rear &#x3D; (Q-&gt;Rear+1)%Q-&gt;MaxSize;
        Q-&gt;Data[Q-&gt;Rear] &#x3D; X;
        return true;
    &#125;
&#125;

bool IsEmpty( Queue Q )
&#123;
    return (Q-&gt;Front &#x3D;&#x3D; Q-&gt;Rear);               &#x2F;&#x2F;必须相等(没有取模),否则比如队满后再加一个元素也满足rear%n&#x3D;front
&#125;

ElementType DeleteQ( Queue Q )
&#123;
    if ( IsEmpty(Q) ) &#123; 
        printf(&quot;队列空&quot;);
        return ERROR;
    &#125;
    else  &#123;
        Q-&gt;Front &#x3D;(Q-&gt;Front+1)%Q-&gt;MaxSize;
        return  Q-&gt;Data[Q-&gt;Front];      &#x2F;&#x2F;front原本是队头元素前一个位置，删除一个元素front+1后正好表示原来队头元素位置
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="队列的链式存储演示"><a class="markdownIt-Anchor" href="#队列的链式存储演示"></a> 队列的链式存储演示</h2>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define ERROR -1
typedef int ElementType;
typedef struct Node *PtrToNode;
struct Node &#123; &#x2F;* 队列中的结点 *&#x2F;
    ElementType Data;
    PtrToNode Next;
&#125;;
typedef PtrToNode Position;

struct QNode &#123;
    Position Front, Rear;  &#x2F;* 队列的头、尾指针 *&#x2F;
    int MaxSize;           &#x2F;* 队列最大容量 *&#x2F;
&#125;;
typedef struct QNode *Queue;

bool IsEmpty( Queue Q )
&#123;
    return ( Q-&gt;Front &#x3D;&#x3D; NULL);
&#125;

ElementType DeleteQ( Queue Q )
&#123;
    Position FrontCell; 
    ElementType FrontElem;
  
    if  ( IsEmpty(Q) ) &#123;
        printf(&quot;队列空&quot;);
        return ERROR;
    &#125;
    else &#123;
        FrontCell &#x3D; Q-&gt;Front;
        if ( Q-&gt;Front &#x3D;&#x3D; Q-&gt;Rear ) &#x2F;* 若队列只有一个元素 *&#x2F;
            Q-&gt;Front &#x3D; Q-&gt;Rear &#x3D; NULL; &#x2F;* 删除后队列置为空 *&#x2F;
        else                   
            Q-&gt;Front &#x3D; Q-&gt;Front-&gt;Next;
        FrontElem &#x3D; FrontCell-&gt;Data;

        free( FrontCell );  &#x2F;* 释放被删除结点空间  *&#x2F;
        return  FrontElem;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>继续</title>
    <url>/posts/d5d42ac5d790</url>
    <content><![CDATA[<p><em><strong>有些事情，你只要知道就可以了，这个更简单。</strong></em></p>
<p><em><strong>有些事情，你不仅要知道，还要知道为什么？更重要的是，有时还要知道我们该怎么办？这个可就不简单了。</strong></em></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>从表达式的求值到堆栈</title>
    <url>/posts/682b01a88b7a</url>
    <content><![CDATA[<h1 id="计算机如何进行表达式求值"><a class="markdownIt-Anchor" href="#计算机如何进行表达式求值"></a> 计算机如何进行表达式求值？</h1>
<p>例：算术表达式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>+</mo><mn>6</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>−</mo><mn>3</mn><mo>∗</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">5+6/2-3*4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span></p>
<p>运算时有优先次序，使得运算符后跟着的操作数并不一定参与这个运算</p>
<span id="more"></span>
<h2 id="算术表达式"><a class="markdownIt-Anchor" href="#算术表达式"></a> 算术表达式</h2>
<p>算术表达式由两类对象构成：</p>
<ul>
<li>运算数，如：2、3、4</li>
<li>运算符号，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mo separator="true">,</mo><mo>−</mo><mo separator="true">,</mo><mo>∗</mo><mo separator="true">,</mo><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">+,-,*,/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">+</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∗</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">/</span></span></span></span></li>
<li>不同运算符号优先级不同</li>
</ul>
<h2 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式"></a> 后缀表达式</h2>
<ul>
<li>中缀表达式：运算符号位于两个运算数之间，如：a+b*c-d/e</li>
<li>后缀表达式：运算符号位于两个运算数之后，如：abc*+de/-</li>
</ul>
<p>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">- 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">4</span></span></span></span> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>∗</mo><mo>+</mo><mo>=</mo><mo stretchy="false">?</mo></mrow><annotation encoding="application/x-tex">2 *+=?</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mclose">?</span></span></span></span></p>
<h2 id="求值策略和方法"><a class="markdownIt-Anchor" href="#求值策略和方法"></a> 求值策略和方法</h2>
<p>后缀表达式求值策略：从左向右“扫描”，逐个处理运算数和运算符号</p>
<ul>
<li>遇到运算数时怎么办？如何“记住”目前还不参与运算的数？
<ul>
<li>当碰到运算数时，存储当前的运算数</li>
</ul>
</li>
<li>遇到运算符号怎么办？对应的运算数是什么？
<ul>
<li>根据运算符(一元、二元、三元)所需的运算数将最近记住的几个运算数拿来运算</li>
</ul>
</li>
</ul>
<p>中追表达式求值策略：将中缀表达式转换为后缀表达式，再求值</p>
<ul>
<li>如何将中缀表达式转换为后缀表达式？</li>
<li>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mtext> </mtext><mo>+</mo><mtext> </mtext><mn>9</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mtext> </mtext><mn>3</mn><mo>−</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">2\space+\space9\space/\space3-5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">9</span><span class="mspace"> </span><span class="mord">/</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> —&gt; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mtext> </mtext><mn>9</mn><mtext> </mtext><mn>3</mn><mtext> </mtext><mi mathvariant="normal">/</mi><mo>+</mo><mn>5</mn><mtext> </mtext><mo>−</mo></mrow><annotation encoding="application/x-tex">2\space9\space3 \space/ + 5\space -</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mspace"> </span><span class="mord">9</span><span class="mspace"> </span><span class="mord">3</span><span class="mspace"> </span><span class="mord">/</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace"> </span><span class="mord">−</span></span></span></span>
<ul>
<li>运算数之间相对顺序不变</li>
<li>运算符号顺序发生改变
<ul>
<li>需要存储“等待中”的运算符号</li>
<li>要将当前运算符号与“等待中”的最后一个运算符号比较</li>
<li>有括号怎么办？</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>表达式求值问题的启示：<strong>需要某种存储方法，能顺序存储运算数，并在需要时“倒序”输出</strong></p>
<p>后缀表达式求值方法：应用堆栈<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(T(n)=O(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>
基本过程：从左到右读入后缀表达式的各项(运算符或运算数)时，碰到：</p>
<ul>
<li>运算数：压栈</li>
<li>运算符：从堆栈中弹出适当数量的运算数，计算结果并入栈</li>
<li>最后，堆栈顶的元素就是表达式的结果值</li>
</ul>
<p>中注表达式求值：应用堆栈将中缀表达式转换为后缀表达式，再利用堆栈求值<br>
基本过程：从头到尾读取中追表达式的每个对象，对不同对象按不同情景处理(T(n)=O(n))</p>
<ul>
<li>运算数：直接输出</li>
<li>左括号：压入堆栈
<ul>
<li>左括号压栈后，相当于优先级降到最低</li>
</ul>
</li>
<li>右括号：将栈顶运算符弹出并输出，直到遇到左括号(出栈，不输出)；</li>
<li>运算符：
<ul>
<li>若优先级大于栈顶运算符时，将其压栈</li>
<li>若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；依次与剩下的栈顶运算符比较，直到该运算符大于栈顶运算符优先级为止，将该运算符压栈</li>
</ul>
</li>
<li>若各对象处理完毕，则把堆栈中存留的运算符一并输出</li>
</ul>
<img src="https://s2.loli.net/2022/05/03/qR7iMKJpQVtkePO.png" width="50%" height="50%">
<h1 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h1>
<p>堆栈/栈(Stack)”:具有一定操作约束的线性表</p>
<ul>
<li>只在一端(栈顶，Top)做插入、删除</li>
<li>插入数据：入栈(Push)</li>
<li>删除数据：出栈(Pop)</li>
<li>后入先出：Last In First Out(LIFO)</li>
</ul>
<p>现实中最能体现堆栈结构的实例：放碗</p>
<ul>
<li>后放的碗只能叠在先放的碗上面，取碗时必须先取完放在上面的碗才能取下面的碗</li>
</ul>
<h2 id="堆栈的抽象数据类型描述"><a class="markdownIt-Anchor" href="#堆栈的抽象数据类型描述"></a> 堆栈的抽象数据类型描述</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：堆栈(Stack)
数据对象集：一个有0个或多个元素的有穷线性表
操作集：长度为Maxsize的堆栈S ∈ Stack，堆栈元素item ∈ ElementType
Stack CreateStack(int Maxsize):生成空堆栈，其最大长度为Maxsize;
int IsFull(Stack S,int Maxsize):判断堆栈S是否已满;
void Push(Stack S,ElementType item):将元素item压入堆栈
int IsEmpty(Stack S):判断堆栈S是否为空;
ElementType Pop(Stack S):删除并返回栈顶元素;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Push和Pop可以穿插交替进行；<br>
例：按照顺序进行如下操作</p>
<ul>
<li>Push(S,A),Push(S,B),Push(S,C),Pop(S),Pop(S),Pop(S)
<ul>
<li>堆栈输出为：在ABC的所有排列中只有CAB是不可能产生的</li>
</ul>
</li>
<li>Push(S,A),Pop(S),Push(S,B),Push(S,C),Pop(S),Pop(S)
<ul>
<li>堆栈输出为：ACB</li>
</ul>
</li>
<li>如果三个字符按ABC顺序压入堆栈，在ABC的所有排列中只有CAB是不可能产生的</li>
</ul>
<h2 id="堆栈的顺序存储实现"><a class="markdownIt-Anchor" href="#堆栈的顺序存储实现"></a> 堆栈的顺序存储实现</h2>
<p>堆栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的下标变量组成</p>
<pre class="line-numbers language-none"><code class="language-none">#define MaxSize&lt;储存数据元素的最大个数&gt;
typedef struct SNode *Stack;
struct SNode
&#123;
    ElementType Data[MaxSize];
    int Top;                               &#x2F;&#x2F;Top为-1时栈空，Top为MaxSize-1时栈满
&#125;；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆栈的链式存储实现"><a class="markdownIt-Anchor" href="#堆栈的链式存储实现"></a> 堆栈的链式存储实现</h2>
<p>堆栈的链式存储结构实际上就是一个单链表，称为链栈</p>
<pre class="line-numbers language-none"><code class="language-none">插入和删除操作只能在链栈的栈顶进行              &#x2F;&#x2F;栈顶指针Top实际就是链表头结点的指针,因为头结点知道下一个元素的位置，而下一个不知道上一个的位置
typedef struct SNode *Stack;              &#x2F;&#x2F;栈顶指针
struct SNode
&#123;
    ElementType Data;
    struct SNode *Next;                   &#x2F;&#x2F;指向链表下一个结点的指针
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="堆栈的主要应用"><a class="markdownIt-Anchor" href="#堆栈的主要应用"></a> 堆栈的主要应用</h2>
<ul>
<li>表达式求值</li>
<li>函数调用及递归实现</li>
<li>深度优先遍历</li>
<li>回溯算法</li>
<li>……</li>
</ul>
<h1 id="堆栈顺序存储演示"><a class="markdownIt-Anchor" href="#堆栈顺序存储演示"></a> 堆栈顺序存储演示</h1>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;以下两部分顺序存储和链式存储代码均来自浙江大学数据结构课程
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define ERROR -1
#define MaxSize 1000
typedef int Position;
typedef int ElementType;
struct SNode &#123;
    ElementType *Data; &#x2F;* 存储元素的数组 *&#x2F;
    Position Top;      &#x2F;* 栈顶指针 *&#x2F;
    int maxSize;       &#x2F;* 堆栈最大容量 *&#x2F;
&#125;;
typedef struct SNode *Stack;

Stack CreateStack( int maxSize )
&#123;
    Stack S &#x3D; (Stack)malloc(sizeof(struct SNode));
    S-&gt;Data &#x3D; (ElementType *)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top &#x3D; -1;
    S-&gt;maxSize &#x3D; MaxSize;
    return S;
&#125;

bool IsFull( Stack S )
&#123;
    return (S-&gt;Top &#x3D;&#x3D; S-&gt;maxSize-1);
&#125;

bool Push( Stack S, ElementType X )
&#123;
    if ( IsFull(S) ) &#123;
        printf(&quot;堆栈满&quot;);
        return false;
    &#125;
    else &#123;
        S-&gt;Data[++(S-&gt;Top)] &#x3D; X;                                   &#x2F;&#x2F;元素压入到栈顶下面一个位置(Top+1)
        return true;
    &#125;
&#125;

bool IsEmpty( Stack S )
&#123;
    return (S-&gt;Top &#x3D;&#x3D; -1);
&#125;

ElementType Pop( Stack S )
&#123;
    if ( IsEmpty(S) ) &#123;
        printf(&quot;堆栈空&quot;);
        return ERROR; &#x2F;* ERROR是ElementType的特殊值，标志错误 *&#x2F;
    &#125;
    else 
        return ( S-&gt;Data[(S-&gt;Top)--] );                             &#x2F;&#x2F;出栈时先出栈顶元素，再将Top下标-1
&#125;
&#x2F;*
    例：用一个数组实现两个堆栈，要求最大地利用数组空间，使数组只要有空间入栈操作就可以成功
    较为高效的做法是将两个栈分别从数组的两头开始向中间生长，当两个栈的栈顶指针相遇时，表示两个栈都满了
*&#x2F;
typedef struct DStack           &#x2F;&#x2F;定义两个栈
&#123;
    ElementType *Data;
    int Top1,Top2;      &#x2F;&#x2F;两个栈顶指针
&#125;ds,*dstack;
dstack CreateDS( int maxSize )
&#123;
    dstack S &#x3D; (dstack)malloc(sizeof(ds));
    S-&gt;Data &#x3D; (ElementType *)malloc(MaxSize * sizeof(ElementType));
    S-&gt;Top1 &#x3D; -1;
    S-&gt;Top2 &#x3D; MaxSize;
    return S;
&#125;
&#x2F;* 此时入栈操作改为： *&#x2F;
void Push(struct DStack *PtrS,ElementType item,int Tag)              &#x2F;&#x2F;如果没事先定义Stack指针的话，这里需要传入结构体DStack的指针
&#123;
    if(PtrS-&gt;Top1-PtrS-&gt;Top2&#x3D;&#x3D;1) printf(&quot;两个堆栈均满&quot;);               &#x2F;&#x2F;当两个指针挨上的时候说明两个栈满了
    else
    &#123;
        if(Tag&#x3D;&#x3D;1)PtrS-&gt;Data[++PtrS-&gt;Top1]&#x3D;item;               
        else PtrS-&gt;Data[--PtrS-&gt;Top2]&#x3D;item;
    &#125;
    return;
&#125;
&#x2F;* 出栈操作改为： *&#x2F;
ElementType Pop(struct DStack *PtrS,int Tag)
&#123;
    if(Tag&#x3D;&#x3D;1)
    &#123;
        if(PtrS-&gt;Top1&#x3D;&#x3D;-1)
        &#123;
            printf(&quot;堆栈1空&quot;);
            return ERROR;                                        
        &#125;
        else return PtrS-&gt;Data[PtrS-&gt;Top1--];
    &#125;
    else
    &#123;
        if(PtrS-&gt;Top2&#x3D;&#x3D;MaxSize)
        &#123;
            printf(&quot;堆栈2空&quot;);
            return ERROR;
        &#125;
        else return PtrS-&gt;Data[PtrS-&gt;Top2++];
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="堆栈链式存储演示"><a class="markdownIt-Anchor" href="#堆栈链式存储演示"></a> 堆栈链式存储演示</h1>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define ERROR -1
typedef struct SNode *PtrToSNode;
typedef int ElementType;
struct SNode &#123;
    ElementType Data;
    PtrToSNode Next;
&#125;;
typedef PtrToSNode Stack;

Stack CreateStack( ) 
&#123; &#x2F;* 构建一个堆栈的头结点，返回该结点指针 *&#x2F;
    Stack S;

    S &#x3D; (Stack)malloc(sizeof(struct SNode));
    S-&gt;Next &#x3D; NULL;
    return S;
&#125;

bool IsEmpty ( Stack S )
&#123; &#x2F;* 判断堆栈S是否为空，若是返回true；否则返回false *&#x2F;
    return ( S-&gt;Next &#x3D;&#x3D; NULL );                                 &#x2F;&#x2F;堆栈为空返回1，不为空返回0
&#125;

bool Push( Stack S, ElementType X )
&#123; &#x2F;* 将元素X压入堆栈S *&#x2F;
    PtrToSNode TmpCell;

    TmpCell &#x3D; (PtrToSNode)malloc(sizeof(struct SNode));
    TmpCell-&gt;Data &#x3D; X;
    TmpCell-&gt;Next &#x3D; S-&gt;Next;
    S-&gt;Next &#x3D; TmpCell;
    return true;
&#125;

ElementType Pop( Stack S )  
&#123; &#x2F;* 删除并返回堆栈S的栈顶元素 *&#x2F;
    PtrToSNode FirstCell;
    ElementType TopElem;

    if( IsEmpty(S) ) &#123;
        printf(&quot;堆栈空&quot;); 
        return ERROR;
    &#125;
    else &#123;
        FirstCell &#x3D; S-&gt;Next; 
        TopElem &#x3D; FirstCell-&gt;Data;
        S-&gt;Next &#x3D; FirstCell-&gt;Next;
        free(FirstCell);
        return TopElem;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Ethereum入门了解</title>
    <url>/posts/9456e876aa66</url>
    <content><![CDATA[<p>本文参考<a href="https://docs.microsoft.com/zh-cn/learn/modules/blockchain-solidity-ethereum-smart-contracts/1-introduction">Microsoft使用 Solidity 编写 Ethereum 智能合同</a>。</p>
<h1 id="用于处理智能合同的工具"><a class="markdownIt-Anchor" href="#用于处理智能合同的工具"></a> 用于处理智能合同的工具</h1>
<p>许多工具都可帮助快速高效地开发智能合同。以下各节介绍了一些集成开发环境 (IDE)、扩展和框架。</p>
<span id="more"></span>
<h2 id="ide"><a class="markdownIt-Anchor" href="#ide"></a> IDE</h2>
<ul>
<li>Visual Studio Code：此代码编辑器已经过重新定义和优化，专门用于生成和调试现代Web和云应用程序。</li>
<li>Remix：一种基于浏览器的编译器和IDE，可以通过它来使用Solidity生成Ethereum合同，使用它来编写、测试和部署自己的合同，并调试交易。</li>
</ul>
<h2 id="扩展"><a class="markdownIt-Anchor" href="#扩展"></a> 扩展</h2>
<ul>
<li>Ethereum的区块链开发工具包：此扩展可以简化在Ethereum账本上创建、生成和部署智能合同的方式。</li>
</ul>
<h2 id="框架"><a class="markdownIt-Anchor" href="#框架"></a> 框架</h2>
<ul>
<li>Truffle 套件：在将Ethereum合同部署到公共账本并产生实际成本之前，使用Truffle工具套件对其进行测试。开发人员可在本地进行开发以便于其工作。
<ul>
<li>该工具套件包括Truffle、Ganache和Drizzle。</li>
</ul>
</li>
<li>OpenZeppelin：使用OpenZeppelin工具编写、部署和操作去中心化应用程序。
<ul>
<li>OpenZeppelin提供了两个产品：合同库和SDK。</li>
</ul>
</li>
</ul>
<!--more-->
<h1 id="安装扩展"><a class="markdownIt-Anchor" href="#安装扩展"></a> 安装扩展</h1>
<p>在Visual Studio Code的左侧边栏中，选择“扩展”。搜索“区块链开发工具包”，然后选择它进行安装。</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/bdk-install.png" width="50%" height="50%">
<p>使用区块链开发工具包之前，请确保已安装：</p>
<ul>
<li>Python：大多数计算机都预先安装了Python。</li>
<li>Node.js：若要确认已安装Node.js，请打开终端并键入node或npm(node包管理器)。如果安装了Node.js，终端将返回计算机上的Node.js的版本或npm命令列表。</li>
<li>Git：若要确认已安装Git，请打开终端并键入git。 如果安装了Git，终端将返回可用的Git命令的列表。</li>
<li>Truffle套件：该扩展提供了一个安装开发人员工具Truffle套件的链接（在扩展处于公共预览阶段时需要）。 (在扩展里面搜Truffle for Vs code)
<ul>
<li>(关于Truffle的介绍看这里<a href="https://truffle.tryblockchain.org/Truffle-introduce-%E4%BB%8B%E7%BB%8D.html">Truffle - 以太坊Solidity编程语言开发框架</a>)</li>
</ul>
</li>
<li>Ganache CLI：该扩展提供了一个安装Ganache CLI的链接（在扩展处于公共预览阶段时需要）。
<ul>
<li>(实际上这个链接我并没有在扩展里面找到😓，于是另外在网上找了一个介绍Ganache的网站<a href="https://nethereum.readthedocs.io/en/latest/ethereum-and-clients/ganache-cli/">Nethereum Documentation</a>)</li>
</ul>
</li>
</ul>
<p>如果尚未安装此软件，或者未具有其最低版本，扩展会提供关于如何安装这些工具的提示。</p>
<h2 id="入门"><a class="markdownIt-Anchor" href="#入门"></a> 入门</h2>
<ul>
<li>如果已安装所有依赖项，请使用区块链开发工具包创建第一个项目：</li>
<li>在计算机上，为项目添加一个空目录。若要从Visual Studio Code中创建目录，请依次转到Terminal &gt; New Terminal，然后键入mkdir newSolidityProject，记下这个新目录的位置，稍后需要用到此信息。</li>
<li>在Visual Studio Code中，依次打开View &gt; Command Palette。在搜索框中，键入“Blockchain: New Solidity Project”。键入时，将显示一个建议列表。</li>
</ul>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/new-solidity-project-selection.png" width="50%" height="50%">
<ul>
<li>对于Solidity项目类型，选择“创建基本项目”。</li>
</ul>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/create-basic-project.png" width="50%" height="50%">
<ul>
<li>使用&quot;explorer&quot;窗格查找在步骤 1 中创建的文件夹。选择该文件夹，在窗口的右下角，可以看到&quot;creating a new project&quot;。</li>
</ul>
<p>创建Solidity项目后，打开&quot;explorer&quot;窗格以查看该项目的文件。</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/new-solidity-project.png" width="30%" height="30%">
<p>该项目包含 Solidity 代码样板，请注意以下目录：</p>
<ul>
<li>合同：包含 HelloBlockchain.sol 合同和 Migrations.sol 合同</li>
<li>迁移：包含初始迁移和部署的合同</li>
<li>测试：包含以 JavaScript 编写的对 HelloBlockchain合约的测试</li>
</ul>
<p>你还会看到下面的配置文件：</p>
<ul>
<li>package.json：定义项目详细信息和依赖项</li>
<li>truffle-config.json：定义Truffle的依赖项和配置</li>
<li>若要保存工作区，请转到File &gt; Save Workspace。将其命名为newSolidityProject。</li>
</ul>
<h2 id="编译合同"><a class="markdownIt-Anchor" href="#编译合同"></a> 编译合同</h2>
<p>首先将从&quot;contracts&quot;文件夹内的HelloBlockchain.sol智能合同开始。</p>
<ul>
<li>在&quot;explorer&quot;窗格中的&quot;contracts&quot;文件夹中，右键单击合同名称HelloBlockchain。</li>
<li>选择“生成合同”以编译智能合同。右下角的窗口会指示合同正在生成。</li>
</ul>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/build-contracts.png" width="50%" height="50%">
<ul>
<li>选择View &gt; Output以查看所编译的合同的相关信息。在此窗口中，可能需要选择“Azure 区块链”才能查看此扩展的输出。</li>
</ul>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/compile-output.png" width="50%" height="50%">
<h2 id="部署合同"><a class="markdownIt-Anchor" href="#部署合同"></a> 部署合同</h2>
<p>成功编译合同后，可以在本地部署它。 此步骤需要登录 Azure 帐户。</p>
<ul>
<li>在&quot;explorer&quot;窗格中，转到&quot;contracts&quot;文件夹，右键单击合同名称HelloBlockchain。</li>
<li>选择“部署合同”。</li>
</ul>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/deploy-contracts.png" width="50%" height="50%">
<ul>
<li>在显示的窗口中，选择“开发”。 如果你还未登录，系统将提示你登录。</li>
</ul>
<p>在“输出”窗口（位于View &gt; Output）中，将看到所部署的迁移和合同的相关信息。</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/deploy-details.png" width="50%" height="50%">
<p>可在此处查看所部署的合同的以下关键信息或元数据：</p>
<ul>
<li>合同的地址。</li>
<li>合同创建交易所属的程序块的时间戳。</li>
<li>部署合同的帐户地址。</li>
<li>交易后帐户的余额（以以太币为单位）。余额为100个以太币（初始默认值）减去总成本。</li>
<li>使用的gas量和gas价格。&quot;gas&quot;指在Ethereum区块链平台上执行交易或执行合同所需的费用。可以将它视为汽车所需的汽油。总成本=gas价格*gas使用量。
<ul>
<li>gas价格以gwei表示。1 gwei等价于0.000000001个以太币。</li>
</ul>
</li>
</ul>
<h1 id="安装truffle"><a class="markdownIt-Anchor" href="#安装truffle"></a> 安装Truffle</h1>
<p>Truffle是最常用的Ethereum开发框架。可以使用节点包管理器(NPM)安装它。</p>
<h2 id="关于truffle"><a class="markdownIt-Anchor" href="#关于truffle"></a> 关于Truffle</h2>
<p>Truffle具有以下好处：</p>
<ul>
<li>可生成、编译、部署和测试智能合同</li>
<li>可管理网络，从而部署到公共和专用网络</li>
<li>可管理项目依赖项的包</li>
<li>具有交互式控制台，可直接进行合同通信和管理</li>
<li>生成管道可配置，可自动运行检查和配置项目</li>
</ul>
<h2 id="安装truffle-2"><a class="markdownIt-Anchor" href="#安装truffle-2"></a> 安装Truffle</h2>
<p>可以使用节点包管理器安装Truffle。在终端中键入以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">npm install -g truffle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>若要确认已安装 Truffle，请键入以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">truffle<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>输出会显示已安装的版本，并显示可用于Truffle的命令列表：</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/truffle.png" width="50%" height="50%">
<h2 id="truffle入门"><a class="markdownIt-Anchor" href="#truffle入门"></a> Truffle入门</h2>
<ul>
<li>在Visual Studio Code中，依次转到Terminal&gt; New Terminal。</li>
<li>在终端中运行 truffle compile。等待源文件编译成功。</li>
<li>运行truffle migrate。等待迁移完成。</li>
</ul>
<h3 id="测试合同"><a class="markdownIt-Anchor" href="#测试合同"></a> 测试合同</h3>
<p>下一步来运行在newSolidityProject中生成的测试。<br>
可在test/HelloBlockchain.js中找到此测试。查看测试文件，尝试了解要测试的内容。<br>
在终端中键入truffle test。<br>
测试失败，因为Truffle无法连接到Ethereum客户端：</p>
<pre class="line-numbers language-none"><code class="language-none">Could not connect to your Ethereum client with the following parameters:
    - host       &gt; 127.0.0.1
    - port       &gt; 8545
    - network_id &gt; *
Please check that your Ethereum client:
    - is running
    - is accepting RPC connections (i.e., &quot;--rpc&quot; option is used in geth)
    - is accessible over the network
    - is properly configured in your Truffle configuration file (truffle-config.js)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此输出指示你需要一个处于运行状态的本地Ethereum区块链客户端，以便测试可以访问它。</p>
<h3 id="ganache-cli"><a class="markdownIt-Anchor" href="#ganache-cli"></a> Ganache CLI</h3>
<p>Ganache是最常用的本地Ethereum区块链。我们将使用CLI版本，以便可以直接从终端与它交互。Ganache CLI常用于开发和测试。<br>
若要在项目中安装Ganache CLI，请进入终端。右键单击，然后选择New Terminal。当“新终端”窗口打开时，运行以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">npm install -g ganache-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>安装 Ganache CLI 后，运行以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">ganache-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/start-ganache.png" width="50%" height="50%">
<p>请注意，区块链有10个已生成的帐户，每个帐户会收到100个测试以太币以便于使用。每个帐户还具有相应的私钥，同时也具有助记键。助记键是由12个单词构成的唯一短语，可通过它访问钱包，进而从帐户实现交易。<br>
输出还会显示区块链的地址。我们将使用此地址连接到区块链。默认情况下，该地址为 127.0.0.1:8545。<br>
现在重新运行 truffle test。<br>
在终端中，可以看到所有测试都已通过。</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/truffle-test.png" width="50%" height="50%">
<h1 id="使用ethereum的区块链开发工具包编写智能合同"><a class="markdownIt-Anchor" href="#使用ethereum的区块链开发工具包编写智能合同"></a> 使用Ethereum的区块链开发工具包编写智能合同</h1>
<p>向前面创建的newSolidityProject添加新的智能合同。</p>
<h2 id="创建装运合同"><a class="markdownIt-Anchor" href="#创建装运合同"></a> 创建装运合同</h2>
<p>将创建的智能合同用于跟踪从在线市场购买的商品的状态。创建该合同时，装运状态设置为Pending。装运商品后，则将装运状态设置为Shipped并会发出事件。交货后则将商品的装运状态设置为 Delivered，并发出另一个事件。<br>
在所创建项目的&quot;contracts&quot;目录中，右键单击该文件夹，然后选择新建名为Shipping.sol的文件。<br>
复制以下合同内容，并将其粘贴到新文件中。</p>
<pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;&#x3D;0.5.12&lt;&#x3D;0.8.0;

contract Shipping
&#123;
    &#x2F;&#x2F; Our predefined values for shipping listed as enums
    enum ShippingStatus &#123; Pending, Shipped, Delivered &#125;

    &#x2F;&#x2F; Save enum ShippingStatus in variable status
    ShippingStatus private status;

    &#x2F;&#x2F; Event to launch when package has arrived
    event LogNewAlert(string description);

    &#x2F;&#x2F; This initializes our contract state (sets enum to Pending once the program starts)
    constructor() public &#123;
        status &#x3D; ShippingStatus.Pending;
    &#125;
    &#x2F;&#x2F; Function to change to Shipped
    function Shipped() public &#123;
        status &#x3D; ShippingStatus.Shipped;
        emit LogNewAlert(&quot;Your package has been shipped&quot;);
    &#125;

    &#x2F;&#x2F; Function to change to Delivered
    function Delivered() public &#123;
        status &#x3D; ShippingStatus.Delivered;
        emit LogNewAlert(&quot;Your package has arrived&quot;);
    &#125;

    &#x2F;&#x2F; Function to get the status of the shipping
    function getStatus(ShippingStatus _status) internal pure returns (string memory) &#123;
     &#x2F;&#x2F; Check the current status and return the correct name
     if (ShippingStatus.Pending &#x3D;&#x3D; _status) return &quot;Pending&quot;;
     if (ShippingStatus.Shipped &#x3D;&#x3D; _status) return &quot;Shipped&quot;;
     if (ShippingStatus.Delivered &#x3D;&#x3D; _status) return &quot;Delivered&quot;;
    &#125;

   &#x2F;&#x2F; Get status of your shipped item
    function Status() public view returns (string memory) &#123;
         ShippingStatus _status &#x3D; status;
         return getStatus(_status);
    &#125;

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>查看该合同，以查看要发生的情况，确认你可以成功生成该合同。<br>
在&quot;Explorer&quot;窗格中，右键单击该合同名称，然后选择“生成合同”以编译该智能合同。</p>
<h2 id="添加迁移"><a class="markdownIt-Anchor" href="#添加迁移"></a> 添加迁移</h2>
<p>现在我们将添加一个迁移文件，以便我们可以将该合同部署到Ethereum网络。<br>
在&quot;Explorer&quot;窗格中，将鼠标悬停在&quot;migration&quot;文件夹上，然后选择“新建文件”。 将该文件命名为3_deploy_contracts.js。<br>
将以下代码添加到该文件：</p>
<pre class="line-numbers language-none"><code class="language-none">const Shipping &#x3D; artifacts.require(&quot;Shipping&quot;);
module.exports &#x3D; function (deployer) &#123;
  deployer.deploy(Shipping);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h2>
<p>接下来要确保可以成功部署该合同，然后再继续。右键单击合同名称，然后选择“部署合同”。在显示的窗口中，选择“开发”，然后等待部署完成。<br>
查看“输出”窗口中的信息。查找3_deploy_contracts.js部署。</p>
<img src="https://docs.microsoft.com/zh-cn/learn/reactors/blockchain-solidity-ethereum-smart-contracts/media/shipping-migration.png" width="50%" height="50%">
<h1 id="测试智能合同"><a class="markdownIt-Anchor" href="#测试智能合同"></a> 测试智能合同</h1>
<p>在此部分中，我们将为装运合同编写新的JavaScript测试。我们可以改用Solidity来编写测试，但JavaScript更为常用。我们将使用Truffle测试智能合同。</p>
<h2 id="开始测试"><a class="markdownIt-Anchor" href="#开始测试"></a> 开始测试</h2>
<p>首先我们创建一个新的测试文件。</p>
<ul>
<li>转到“终端”&gt;“新终端”。</li>
<li>在新终端中键入 truffle create test Shipping。 这将在测试文件夹中创建一个名为 Shipping.js 的新文件。</li>
<li>粘贴下面的代码，以替换该文件中的代码：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const ShippingStatus&#x3D; artifacts.require(&quot;Shipping&quot;);
contract(&#39;Shipping&#39;, () &#x3D;&gt; &#123;

  it(&quot;should return the status Pending&quot;, async ()&#x3D;&gt; &#123;
    &#x2F;&#x2F; Instance of our deployed contract
    const instance &#x3D; await ShippingStatus.deployed();
    &#x2F;&#x2F; Checking the initial status in our contract
    const status &#x3D; await instance.Status();
    &#x2F;&#x2F; Checking if the status is initially Pending as set in the constructor
    assert.equal(status, &quot;Pending&quot;);
  &#125;);
it(&quot;should return the status Shipped&quot;, async ()&#x3D;&gt; &#123;
&#x2F;&#x2F; Instance of our deployed contract
    const instance &#x3D; await ShippingStatus.deployed();

    &#x2F;&#x2F; Calling the Shipped() function
    await instance.Shipped();

    &#x2F;&#x2F; Checking the initial status in our contract
    const status &#x3D; await instance.Status();

    &#x2F;&#x2F; Checking if the status is Shipped
    assert.equal(status, &quot;Shipped&quot;);
  &#125;);

    it(&quot;should return the status Delivered&quot;, async ()&#x3D;&gt; &#123;

    &#x2F;&#x2F; Instance of our deployed contract
    const instance &#x3D; await ShippingStatus.deployed();

    &#x2F;&#x2F; Calling the Shipped() function
    await instance.Delivered();

    &#x2F;&#x2F; Checking the initial status in our contract
    const status &#x3D; await instance.Status();

    &#x2F;&#x2F; Checking if the status is Delivered
    assert.equal(status, &quot;Delivered&quot;);
  &#125;);
&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="事件测试"><a class="markdownIt-Anchor" href="#事件测试"></a> 事件测试</h3>
<p>我们将使用truffle断言包来测试合同中发送的事件。通过使用此包，我们可以断言交易过程中发出了事件。</p>
<ul>
<li>在终端中，通过键入npm install truffle-assertions安装此库。</li>
<li>请求ShippingStatus合同后，将以下代码添加到测试文件的第2行：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">const truffleAssert &#x3D; require(&#39;truffle-assertions&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>添加一个测试，以确认事件会返回所需的说明。 将此测试放在文件的最后一个测试之后。 在最后一行的一组右大括号的正前方创建新行，在其中添加此测试。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">it(&#39;should return correct event description&#39;, async()&#x3D;&gt;&#123;

    &#x2F;&#x2F; Instance of our deployed contract
    const instance &#x3D; await ShippingStatus.deployed();

    &#x2F;&#x2F; Calling the Delivered() function
    const delivered &#x3D; await instance.Delivered();

    &#x2F;&#x2F; Check event description is correct
    truffleAssert.eventEmitted(delivered, &#39;LogNewAlert&#39;, (event) &#x3D;&gt;&#123;
      return event.description &#x3D;&#x3D; &#39;Your package has arrived&#39;;
    &#125;);
  &#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用asyncawait"><a class="markdownIt-Anchor" href="#使用asyncawait"></a> 使用async/await</h3>
<p>.deployed() 数会返回一个承诺。因此我们在此函数的前面使用await，并在测试代码的前面使用async。此设置意味着，在部署合同后，直到承诺完成后才能继续进行测试。<br>
此模式常用于测试，因为几乎所有智能合同交易都是异步交易。由于需要先对交易进行验证或挖掘才能将其添加到区块链账本中，因此它们是异步交易。<br>
总之，应以对合同进行全面测试为目标，尤其是计划部署到主要的Ethereum网络（主网）时。</p>
<h2 id="运行测试"><a class="markdownIt-Anchor" href="#运行测试"></a> 运行测试</h2>
<p>在终端中键入以下内容：</p>
<pre class="line-numbers language-none"><code class="language-none">truffle test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>应该看到所有测试都成功通过：</p>
<pre class="line-numbers language-none"><code class="language-none">Contract: HelloBlockchain
    ✓ testing ResponseMessage of HelloBlockchain
    ✓ testing Responder of HelloBlockchain
    ✓ testing RequestMessage of HelloBlockchain
    ✓ testing State of HelloBlockchain
    ✓ testing Requestor of HelloBlockchain
    ✓ testing SendRequest of HelloBlockchain (51ms)
    ✓ testing SendResponse of HelloBlockchain (46ms)

  Contract: Shipping
    ✓ should return the status Pending
    ✓ should return the status Shipped (59ms)
    ✓ should return the status Delivered (58ms)
    ✓ should return correct event description (39ms)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>工具使用</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Solidity入门了解</title>
    <url>/posts/a8e179be4596</url>
    <content><![CDATA[<p>本文参考<a href="https://docs.microsoft.com/zh-cn/learn/modules/blockchain-learning-solidity/1-introduction">Microsoft了解如何使用Solidity</a>。</p>
<h1 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h1>
<p>使用一种称为Solidity的编程语言可以编写供应链、在线市场或其他用例的操作代码。<br>
通过使用Solidity，还可以指定用户操作。通过对网络上允许的这些操作进行编程，你可以创建自己的区块链网络，而这些网络对所有参与者都是安全且透明的。</p>
<span id="more"></span>
<h1 id="什么是solidity"><a class="markdownIt-Anchor" href="#什么是solidity"></a> 什么是Solidity</h1>
<p>Solidity是一种面向对象的用于编写智能合同的语言。<br>
智能合同是存储在区块链中的程序，它们指定有关数字资产传输的规则和行为。可以使用Solidity为Ethereum区块链平台对智能合同进行编程。<br>
智能合同包含状态和可编程逻辑，通过事务执行函数，因此使用智能合同可以创建业务工作流。</p>
<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>Solidity是Ethereum区块链最常用的编程语言。<br>
Solidity是一种基于其他编程语言（包括 C++、Python和JavaScript）的高级语言，如果你熟悉这些语言中的任何一种，则有助于熟悉Solidity代码。<br>
Solidity是静态类型语言，这意味着类型检查在编译时进行，而不像动态类型语言在运行时进行。<br>
Solidity支持继承，这意味着一个合同中存在的函数、变量和其他属性可以在另一个合同中使用。该语言还支持复杂的用户定义类型（如struct和enum），这使你可以将相关类型的数据组合在一起。<br>
Solidity是一种开源编程语言，协作者社区庞大。若要了解有关 Solidity 项目以及如何参与的详细信息，请参阅<a href="https://github.com/ethereum/solidity">GitHub存储库</a>。</p>
<h2 id="什么是-ethereum"><a class="markdownIt-Anchor" href="#什么是-ethereum"></a> 什么是 Ethereum？</h2>
<p>Ethereum是最受欢迎的区块链平台之一，仅次于比特币。这是一种社区构建的技术，有自己的加密货币Ether(ETH)，可以进行购买和销售。<br>
Ethereum的独特之处在于它是“全球可编程区块链”。Solidity是用于在Ethereum平台上开发的主要编程语言，由Ethereum开发人员构建和维护。</p>
<h3 id="ethereum-虚拟机"><a class="markdownIt-Anchor" href="#ethereum-虚拟机"></a> Ethereum 虚拟机</h3>
<p>Solidity合同在Ethereum虚拟机（简称EVM）的虚拟环境上运行。它是一个完全隔离的沙盒环境。<br>
除了执行的合同外，它不会访问网络上的任何其他内容。</p>
<h1 id="solidity语言基础知识"><a class="markdownIt-Anchor" href="#solidity语言基础知识"></a> Solidity语言基础知识</h1>
<p>所有Solidity合同通常都包括：</p>
<ul>
<li>Pragma指令</li>
<li>状态变量</li>
<li>函数</li>
<li>事件</li>
</ul>
<h2 id="pragma指令"><a class="markdownIt-Anchor" href="#pragma指令"></a> Pragma指令</h2>
<p>Pragma是用来指示编译器检查其Solidity版本是否与所需版本匹配的关键字。<br>
如果匹配，则表示源文件可以成功运行。如果不匹配，编译器将发出错误，因此需要始终确保在合同定义中包含Solidity最新版本。<br>
<strong>版本pragma指令</strong>如下所示：</p>
<blockquote>
<p>pragma solidity ^0.7.0;</p>
</blockquote>
<p>此行意味着源文件将使用高于0.7.0版本（最高版本为0.7.9）的编译器进行编译。从版本0.8.0开始，可能会引入一些中断性变更，导致源文件无法成功编译。<br>
若要查找Solidity的当前版本，可访问<a href="https://docs.soliditylang.org/en/v0.8.13/">Solidity</a>网站，使用源文件中的最新版本。</p>
<h2 id="状态变量"><a class="markdownIt-Anchor" href="#状态变量"></a> 状态变量</h2>
<p>状态变量是任何Solidity源文件的关键，状态变量永久存储在合同存储中。</p>
<pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;0.7.0 &lt;0.8.0;

contract Marketplace &#123;
    uint price; &#x2F;&#x2F; State variable<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>备注：合同源文件始终以“contract ContractName”开头。</p>
</blockquote>
<p>在本例中，状态变量名为price，类型为“uint”。整数类型uint表示此变量是256位的无符号整数，这意味着它可以存储<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>256</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{256}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>范围内的正数。<br>
对于所有变量定义，必须指定类型和变量名。<br>
此外，可以将状态变量的可见性指定为：</p>
<ul>
<li>public：合同接口的一部分，可以从其他合同访问。</li>
<li>internal：仅限从当前合同内部访问。</li>
<li>private：仅对定义它的合同可见。</li>
</ul>
<p>internal和private类似，不过如果某个合同继承自其父合同，这个合同即可以访问父合同中定义的“内部”函数。<br>
external与public类似，只不过这些函数只能在合同之外调用 -它们不能被合同内的其他函数调用。</p>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<p>在合同中，可执行代码单元称为函数。<br>
函数描述实现一个任务的单个操作，它们是可重用的，也可以从其他源文件（如库）进行调用。 Solidity中函数的行为类似于其他编程语言中的函数。</p>
<pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;0.7.0 &lt;0.8.0;

contract Marketplace &#123;
    function buy() public &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码显示了一个名为buy的函数，它具有公共可见性，这意味着它可以由其他合同访问。<br>
函数可以使用以下可见性说明符之一：public、private、internal和external。<br>
函数可以在内部合同进行调用，也可以从外部另一个合同进行调用。<br>
下面是一个函数示例，该函数接受一个参数（一个称为price的整数），并返回一个整数：</p>
<pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;0.7.0 &lt;0.8.0;

contract Marketplace &#123;
    function buy(uint price) public returns (uint) &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="函数修饰符"><a class="markdownIt-Anchor" href="#函数修饰符"></a> 函数修饰符</h2>
<p>函数修饰符可用于更改函数的行为。它们的工作原理是在函数执行前检查条件。<br>
例如，函数可以检查只有指定为卖方的用户才能列出要出售的商品。<br>
pragma solidity &gt;0.7.0 &lt;0.8.0;</p>
<pre class="line-numbers language-none"><code class="language-none">contract Marketplace &#123;
    address public seller;

    modifier onlySeller() &#123;
        require(
            msg.sender &#x3D;&#x3D; seller,
            &quot;Only seller can put an item up for sale.&quot;
        );
        _;
    &#125;

    function listItem() public view onlySeller &#123;
        &#x2F;&#x2F; ...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此示例介绍以下各项：</p>
<ul>
<li>类型为address的变量，用于存储卖方用户的20字节Ethereum地址。(地址变量)</li>
<li>名为onlySeller的修饰符，用于说明只有卖方才能列出商品。</li>
<li>特殊符号_;，表示函数体插入的位置。</li>
<li>使用修饰符onlySeller可以定义函数。</li>
</ul>
<p>可在函数定义中使用的其他函数修饰符包括：</p>
<ul>
<li>pure，用于描述不允许修改或不可访问状态的函数。(不能读写)</li>
<li>view，用于描述不允许修改状态的函数。(只读不写)</li>
<li>payable，用于描述可以接收Ether的函数。(调用此函数可以附加发送一些ETH)</li>
</ul>
<h2 id="事件"><a class="markdownIt-Anchor" href="#事件"></a> 事件</h2>
<p>事件描述了合同中采取的操作。与函数类似，事件具有在调用事件时需要指定的参数。<br>
若要调用事件，必须将关键字“emit”与事件名称及其参数一起使用。</p>
<pre class="line-numbers language-none"><code class="language-none">pragma solidity &gt;0.7.0 &lt;0.8.0;

contract Marketplace &#123;
    event PurchasedItem(address buyer, uint price);

    function buy() public &#123;
        &#x2F;&#x2F; ...
        emit PurchasedItem(msg.sender, msg.value);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>调用事件时，事件会被捕获为事务日志中的事务，事务日志是区块链中的一种特殊数据结构。<br>
这些日志与合同的地址相关联，已合并到区块链中，并且始终保持不变。从合同中是无法访问日志及其事件数据，并且无法修改它。</p>
<h1 id="solidity值类型"><a class="markdownIt-Anchor" href="#solidity值类型"></a> Solidity值类型</h1>
<p>值类型通过值传递，并在使用时进行复制。编写合同时将使用的主要值类型包括“整数”、“布尔”、“字符串”、“地址”和“枚举”。</p>
<h2 id="整型"><a class="markdownIt-Anchor" href="#整型"></a> 整型</h2>
<p>每个Solidity源文件中都使用整数。它们可以表示有符号整数也可以表示无符号整数。存储的整数大小介于8位到256位之间。</p>
<ul>
<li>signed：包括负数和正数。可以表示为int。</li>
<li>unigned：仅包含正数。可以表示为uint。</li>
<li>如果未指定位数，则默认值为256位。</li>
</ul>
<p>以下运算符可应用于整数：</p>
<ul>
<li>比较：&lt;=、&lt;、==、!=、&gt;=、&gt;</li>
<li>位运算符：&amp;、| 、^ 、~</li>
<li>算术运算符：+ 、- 、* 、/ 、% 、)、**</li>
</ul>
<p>以下是整数定义的一些示例：</p>
<pre class="line-numbers language-none"><code class="language-none">int32 price &#x3D; 25; &#x2F;&#x2F; signed 32 bit integer
uint256 balance &#x3D; 1000; &#x2F;&#x2F; unsigned 256 bit integer
balance - price; &#x2F;&#x2F; 975
2 * price; &#x2F;&#x2F; 50
price % 2; &#x2F;&#x2F; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="布尔型"><a class="markdownIt-Anchor" href="#布尔型"></a> 布尔型</h2>
<p>布尔使用关键字bool进行定义。它们的值始终是true或false。<br>
下面提供了定义方法：</p>
<pre class="line-numbers language-none"><code class="language-none">bool forSale; &#x2F;&#x2F;true if an item is for sale
bool purchased; &#x2F;&#x2F;true if an item has been purchased<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>布尔值通常用于比较语句中。例如：</p>
<pre class="line-numbers language-none"><code class="language-none">if(balance &gt; 0 &amp; balance &gt; price) &#123;
    return true;
&#125;

if(price &gt; balance) &#123;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>布尔值也可以用在函数参数和返回类型中。</p>
<pre class="line-numbers language-none"><code class="language-none">function buy(int price) returns (bool success) &#123;
    &#x2F;&#x2F; ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<p>大多数合同文件中也使用字符串，它们是用双引号或单引号括起来的字符或字词。</p>
<pre class="line-numbers language-none"><code class="language-none">String shipped &#x3D; &quot;shipped&quot;; &#x2F;&#x2F; shipped
String delivered &#x3D; &#39;delivered&#39;; &#x2F;&#x2F; delivered
String newItem &#x3D; &quot;newItem&quot;; &#x2F;&#x2F; newItem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此外，以下转义字符可以与字符串一起使用：</p>
<ul>
<li>&lt;newline&gt; 转义为换行</li>
<li>\n 换行</li>
<li>\r 回车</li>
<li>\t Tab</li>
</ul>
<h2 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h2>
<p>地址是一种具有20字节值的类型，它表示Ethereum用户帐户。此类型可以是常规“address”，也可以是“address payable”。<br>
两者之间的区别在于，“address payable”类型是Ether发送到的地址，它包含额外的成员transfer和send。</p>
<pre class="line-numbers language-none"><code class="language-none">address payable public seller; &#x2F;&#x2F; account for the seller
address payable public buyer; &#x2F;&#x2F; account for the user

function transfer(address buyer, uint price) &#123;
    buyer.transfer(price); &#x2F;&#x2F; the transfer member transfers the price of the item
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2>
<p>在Solidity中，可使用枚举创建用户定义类型。之所以称之为用户定义，是因为创建合同的人员才能决定要包含哪些值。<br>
枚举可用于显示许多可选择的选项，其中有一项是必需的。<br>
例如，可以使用enum来表示项目的不同状态，将枚举视为代表多项选择答案，其中所有值都是预定义的，你必须选择一个。<br>
可以在合同或库定义中声明枚举。</p>
<pre class="line-numbers language-none"><code class="language-none">enum Status &#123; 
    Pending,
    Shipped,
    Delivered 
&#125;

Status public status;

constructor() public &#123;
    status &#x3D; Status.Pending;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="solidity引用类型"><a class="markdownIt-Anchor" href="#solidity引用类型"></a> Solidity引用类型</h1>
<p>在编写合同时，还应了解引用类型。<br>
与总是传递值的独立副本的值类型不同，引用类型为值提供了一个已知位置。三种引用类型为：结构、数组和映射。</p>
<h2 id="数据位置"><a class="markdownIt-Anchor" href="#数据位置"></a> 数据位置</h2>
<p>使用引用类型时，必须<strong>显式</strong>提供该类型的数据存储位置。以下选项可用于指定存储类型的数据位置：</p>
<ul>
<li>memory:(内存，即栈中数据，生存期与调用函数相同)
<ul>
<li>存储函数参数的位置。</li>
<li>生存期限制为外部函数调用的生存期。</li>
</ul>
</li>
<li>storage:(存储，即写入本地区块链副本中，开销最高)
<ul>
<li>存储状态变量的位置。</li>
<li>生命期仅限于合同有效期。</li>
</ul>
</li>
<li>calldata:(函数参数数据，行为类似内存数据，因其不可修改因此赋值时完全不需要数据拷贝，开销最低)
<ul>
<li>存储函数参数的位置。</li>
<li>本位置对于外部函数的参数是必需的，但也可用于其他变量。</li>
<li>生存期限制为外部函数调用的生存期。</li>
</ul>
</li>
</ul>
<p>引用类型总是创建数据的独立副本。<br>
下面举例说明如何使用引用类型：</p>
<pre class="line-numbers language-none"><code class="language-none">contract C &#123;

  uint[] x;
  
  &#x2F;&#x2F; the data location of values is memory
  function buy(uint[] memory values) public &#123;
      x &#x3D; value; &#x2F;&#x2F; copies array to storage
      uint[] storage y &#x3D; x; &#x2F;&#x2F;data location of y is storage
      g(x); &#x2F;&#x2F; calls g, handing over reference to x
      h(x); &#x2F;&#x2F; calls h, and creates a temporary copy in memory
  &#125;

  function g(uint[] storage) internal pure &#123;&#125;
  function h(uint[] memory) public pure &#123;&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(注意h(x)传入memory参数后要创建一个临时拷贝)</p>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>数组是一种在集合数据结构中存储相似数据的方法。<br>
数组可以是固定大小，也可以是动态大小。它们的索引从 0 开始。<br>
若要创建固定大小k和元素类型T的数组，则需要编写T[k]。 对于动态大小数组，应编写T[]。(不指定长度即默认为动态数组，类似vector)<br>
数组元素可以是任何类型。例如，它们可以包含“uint”、“memory”或“bytes”，也可以包含“映射”或“结构”。<br>
以下示例演示如何创建数组：</p>
<pre class="line-numbers language-none"><code class="language-none">uint[] itemIds; &#x2F;&#x2F; Declare a dynamically sized array called itemIds
uint[3] prices &#x3D; [1, 2, 3]; &#x2F;&#x2F; initialize a fixed size array called prices, with prices 1, 2, and 3
uint[] prices &#x3D; [1, 2, 3]; &#x2F;&#x2F; same as above<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>(与c类似，如果声明时直接初始化相当于编译器可以直接指定内存，因此即使不给出长度也是定义一个静态数组)</p>
<h3 id="数组成员"><a class="markdownIt-Anchor" href="#数组成员"></a> 数组成员</h3>
<p>以下成员既可以操作数组，又可以获取有关数组的信息：</p>
<ul>
<li>length：获取数组的长度。</li>
<li>push：在数组末尾追加一个元素。</li>
<li>pop：从数组末尾删除元素。</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Create a dynamic byte array
bytes32[] itemNames;
itemNames.push(bytes32(&quot;computer&quot;)); &#x2F;&#x2F; adds &quot;computer&quot; to the array
itemNames.length; &#x2F;&#x2F; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2>
<p>结构是用户可以定义用来表示实际对象的自定义类型，通常用作架构或用于表示记录。<br>
结构声明示例：</p>
<pre class="line-numbers language-none"><code class="language-none">struct Items_Schema &#123;
    uint256 _id;
    uint256 _price;
    string _name;
    string _description;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="映射类型"><a class="markdownIt-Anchor" href="#映射类型"></a> 映射类型</h2>
<p>映射是封装或打包在一起的键值对。映射最接近JavaScript中的字典或对象。<br>
通常使用映射来建模实际对象，并执行<strong>快速数据查找</strong>。这些值可以包括结构等复杂类型，这使得映射类型灵活且可读性强。<br>
下面的代码示例使用结构Items_Schema ，并将Items_Schema表示的项列表保存为字典。映射通过这种方式模拟数据库。</p>
<pre class="line-numbers language-none"><code class="language-none">contract Items &#123;
    uint256 item_id &#x3D; 0;

    mapping(uint256 &#x3D;&gt; Items_Schema) public items;

    struct Items_Schema &#123;
      uint256 _id:
      uint256 _price:
      string _name;
    &#125;

    function listItem(uint256 memory _price, string memory _name) public &#123;
      item_id +&#x3D; 1;
      item[vehicle_id] &#x3D; Items_Schema(item_id, _price, _name);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>区块链</tag>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表概念和实现</title>
    <url>/posts/24e1657c8f8e</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 10%;
;
}
table th:nth-of-type(3){
width: 10%;
}
table th:nth-of-type(4){
width: 10%;
}
table th:nth-of-type(5){
width: 10%;
}
table th:nth-of-type(6){
width: 10%;
}
table th:nth-of-type(7){
width: 10%;
}
table th:nth-of-type(8){
width: 10%;
}
table th:nth-of-type(9){
width: 10%;
}
table th:nth-of-type(10){
width: 10%;
}
</style>
<h1 id="线性表"><a class="markdownIt-Anchor" href="#线性表"></a> 线性表</h1>
<p>“线性表(Linear List)”:由同类型数据元素构成有序序列的线性结构</p>
<ul>
<li>表中元素个数称为线性表的长度</li>
<li>线性表没有元素时，称为空表</li>
<li>表起始位置称表头，表结束位置称表尾</li>
</ul>
<span id="more"></span>
<h2 id="线性表的抽象数据类型描述"><a class="markdownIt-Anchor" href="#线性表的抽象数据类型描述"></a> 线性表的抽象数据类型描述</h2>
<pre class="line-numbers language-none"><code class="language-none">类型名称：线性表(List)
数据对象集：线性表是n(&gt;&#x3D;0)个元素构成的有序序列(a1,a2,…，an)
操作集：线性表L ∈ List，整数i表示位置，元素X ∈ ElementType，线性表基本操作主要有：
List MakeEmpty():初始化一个空线性表L;
ElementType FindKth(int K,List L):根据位序K，返回相应元素;
int Find(ElementType X,List L):在线性表L中查找X的首次出现位置
void Insert(ElementType X,int i,List L):在位序i前插入一个新元素X;
void Delete(int i,List L):删除指定位序i的元素;
int Length(List L):返回线性表L的长度n.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="线性表的顺序存储"><a class="markdownIt-Anchor" href="#线性表的顺序存储"></a> 线性表的顺序存储</h2>
<p>利用类似于数组的连续存储空间顺序存放线性表的各元素<br>
注意数组存储的数据结构不一定是顺序，也可能是链表式的</p>
<table>
<thead>
<tr>
<th style="text-align:center">下标i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">…</th>
<th style="text-align:center">i-1</th>
<th style="text-align:center">i</th>
<th style="text-align:center">…</th>
<th style="text-align:center">n-1</th>
<th style="text-align:center">…</th>
<th style="text-align:center">MAXSIZE-1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Data</td>
<td style="text-align:center">a1</td>
<td style="text-align:center">a2</td>
<td style="text-align:center">…</td>
<td style="text-align:center">ai</td>
<td style="text-align:center">ai+1</td>
<td style="text-align:center">…</td>
<td style="text-align:center">an</td>
<td style="text-align:center">…</td>
<td style="text-align:center">——</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-none"><code class="language-none">#define MaxSize&lt;储存数据元素的最大个数&gt;
tpedef struct LNode *List;
struct LNode
&#123;
    ElementType Data[MAXSIZE];
    int Last;
&#125;;
struct LNode L;
List PtrL;
访问下标为i的元素：L.Data[i]或PtrL—&gt;Data[i];
线性表的长度：L.Last+1或trL—&gt;Last+1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="线性表的链式存储实现"><a class="markdownIt-Anchor" href="#线性表的链式存储实现"></a> 线性表的链式存储实现</h2>
<p>不要求逻辑上相邻的两个元素物理上也相邻：通过“链”建立起数据元素之间的逻辑关系</p>
<ul>
<li>插入、删除不需要移动数据元素，只需要修改“链”</li>
<li>相应的，链式结构想要获取元素位置和线性表长度比较困难</li>
<li>头结点不存储元素，专门用来指向后面的整个链表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">tpedef struct LNode *List;
struct LNode
&#123;
    ElementType Data;
    List Next;
&#125;;
struct LNode L;
List PtrL;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>c/c++提供了指针这一功能，因此可以实现“真正”的链表，但在其他高级语言中同样存在这种数据结构<br>
<strong>“抽象的链表”</strong>：如java等语言中<br>
一块空间用于存储数据，一块区域用于存储指针(下一个结点的地址)即可</p>
<h2 id="多重链表"><a class="markdownIt-Anchor" href="#多重链表"></a> 多重链表</h2>
<p>多重链表存储结构：链表中结点可能同时隶属于多个链</p>
<ul>
<li>多重链表中结点的指针域会有多个
<ul>
<li>如前例广义表中存在Next和SubList两个指针域</li>
<li>包含多个指针域的链表并不一定是多重链表
<ul>
<li>比如双向链表就不是多重链表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>多重链表有广泛的用途：<br>
基本上如树、图等相对复杂的数据结构都可以采用多重链表方式实现存储</p>
<p>例：矩阵存储<br>
矩阵可以采用二维数组表示，但二维数组表示有两个缺陷：</p>
<ul>
<li>数组空间要提前分配</li>
<li>对于“稀疏矩阵”，将造成大量的存储空间浪费</li>
</ul>
<p>因此采用一种典型的多重链表——十字链表存储稀疏矩阵</p>
<img src="https://s2.loli.net/2022/05/01/3G4IxrkquFezbOg.png" width="50%" height="50%">
<ul>
<li>只存储矩阵非0元素项
<ul>
<li>结点的数据域：行坐标Row、列坐标Col、数值Value</li>
</ul>
</li>
<li>每个结点通过两个指针域，将同行、同列串联起来(双向、循环链表，头结点指向行/列第一个元素，行/列最后一个元素指回头结点)
<ul>
<li>行指针(或称为向右指针)Right</li>
<li>列指针(或称为向下指针)Down</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/01/akCGFjoqrZST9xc.png" width="50%" height="50%">
<ul>
<li>标识域Tag用来区分头结点和非0元素结点
<ul>
<li>头结点标识值为&quot;Head&quot;，矩阵非0元素结点标识值为&quot;Term&quot;</li>
<li>头结点没有值，只有一个Next指针；十字链表定义时通过union将两种不同结构联合起来</li>
<li>十字链表首元素记录整个十字链表的行数、列数和非零元素数</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2022/05/01/dLegioaB3KJ4p7w.png" width="50%" height="50%">
<h1 id="线性表顺序存储演示"><a class="markdownIt-Anchor" href="#线性表顺序存储演示"></a> 线性表顺序存储演示</h1>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;以下两部分顺序存储和链式存储代码均来自浙江大学数据结构课程
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#define MAXSIZE 50
typedef int Position;
typedef int ElementType;
typedef struct LNode *List;
struct LNode &#123;
    ElementType Data[MAXSIZE];
    Position Last;
&#125;;

&#x2F;* 初始化(建立空的顺序表) *&#x2F;
List MakeEmpty()        
&#123;
    List L;

    L &#x3D; (List)malloc(sizeof(struct LNode));
    L-&gt;Last &#x3D; -1;

    return L;
&#125;

&#x2F;* 查找 *&#x2F;
#define ERROR -1

Position Find( List L, ElementType X )      &#x2F;&#x2F;查找成功的平均比较次数为(n+1)&#x2F;2次，平均时间性能为O(n)
&#123;
    Position i &#x3D; 0;

    while( i &lt;&#x3D; L-&gt;Last &amp;&amp; L-&gt;Data[i]!&#x3D; X )
        i++;
    if ( i &gt; L-&gt;Last )  return ERROR; &#x2F;* 如果没找到，返回错误信息 *&#x2F;
    else  return i;  &#x2F;* 找到后返回的是存储位置 *&#x2F;
&#125;

&#x2F;* 插入 *&#x2F;
&#x2F;*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*&#x2F;
bool Insert( List L, ElementType X, Position P )        &#x2F;&#x2F;在下标为P-1(第P个)元素插入，0&lt;P&lt;n
&#123; &#x2F;* 在L的指定位置P前插入一个新元素X *&#x2F;                      &#x2F;&#x2F;平均移动次数为n&#x2F;2，平均时间性能为O(n)
    Position i;

    if ( L-&gt;Last &#x3D;&#x3D; MAXSIZE-1) &#123;
        &#x2F;* 表空间已满，不能插入 *&#x2F;
        printf(&quot;表满&quot;); 
        return false; 
    &#125;  
    if ( P&lt;0 || P&gt;L-&gt;Last+1 ) &#123; &#x2F;* 检查插入位置的合法性 *&#x2F;  &#x2F;&#x2F;PtrL-&gt;Last+1对应第n+1个元素
        printf(&quot;位置不合法&quot;);
        return false; 
    &#125; 
    for( i&#x3D;L-&gt;Last; i&gt;&#x3D;P; i-- )
        L-&gt;Data[i+1] &#x3D; L-&gt;Data[i]; &#x2F;* 将位置P及以后的元素顺序向后移动 *&#x2F;
    L-&gt;Data[P] &#x3D; X;  &#x2F;* 新元素插入 *&#x2F;
    L-&gt;Last++;       &#x2F;* Last仍指向最后元素 *&#x2F;
    return true; 
&#125; 

&#x2F;* 删除 *&#x2F;
&#x2F;*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是存储下标位置（从0开始），两者差1*&#x2F;
bool Delete( List L, Position P )                       &#x2F;&#x2F;平均移动次数为n&#x2F;2，平均时间性能为O(n)
&#123; &#x2F;* 从L中删除指定位置P的元素 *&#x2F;
    Position i;

    if( P&lt;0 || P&gt;L-&gt;Last ) &#123; &#x2F;* 检查空表及删除位置的合法性 *&#x2F;
        printf(&quot;位置%d不存在元素&quot;, P ); 
        return false; 
    &#125;
    for( i&#x3D;P+1; i&lt;&#x3D;L-&gt;Last; i++ )
        L-&gt;Data[i-1] &#x3D; L-&gt;Data[i]; &#x2F;* 将位置P+1及以后的元素顺序向前移动 *&#x2F;
    L-&gt;Last--; &#x2F;* Last仍指向最后元素 *&#x2F;
    return true;   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="线性表链式存储演示"><a class="markdownIt-Anchor" href="#线性表链式存储演示"></a> 线性表链式存储演示</h1>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
typedef int ElementType;
typedef struct LNode *PtrToLNode;
struct LNode &#123;
    ElementType Data;
    PtrToLNode Next;
&#125;;
typedef PtrToLNode Position;
typedef PtrToLNode List;

#define ERROR NULL
&#x2F;* 求表长 *&#x2F;
    int Length(List PtrL)                                    &#x2F;&#x2F;平均时间性能：O(n)
    &#123;
        List p&#x3D;PtrL;
        int j&#x3D;0;
        while(p)
        &#123;
            p&#x3D;p-&gt;Next;
            j++;
        &#125;
        return j;
    &#125;

&#x2F;* 查找：按值查找(Find)和按序号查找(FindKth) *&#x2F;
Position Find( List L, ElementType X )                      &#x2F;&#x2F;平均查找次数为n&#x2F;2，平均时间性能为O(n)
&#123;
    Position p &#x3D; L; &#x2F;* p指向L的第1个结点 *&#x2F;

    while ( p &amp;&amp; p-&gt;Data!&#x3D;X )
        p &#x3D; p-&gt;Next;

    &#x2F;* 下列语句可以用 return p; 替换 *&#x2F;
    if ( p )
        return p;
    else
        return ERROR;
&#125;
ElementType FindKth(int K,List PtrL)                        &#x2F;&#x2F;平均时间性能：O(n)
&#123;
    List p&#x3D;PtrL;
    int i&#x3D;1;
    while(p!&#x3D;NULL&amp;&amp;i&lt;K)
    &#123;
        p&#x3D;p-&gt;Next;
        i++;
    &#125;
    if(i&#x3D;&#x3D;K)return p-&gt;Data;
    else return -1;
&#125;

&#x2F;*
    插入(在第i-1(1&lt;i&lt;n+1)个结点后面插入一个值为X的新结点)                 
        *先构造一个新结点，用s指向                                        
        *找到链表的第i-1个结点，用p指向
        *修改p、s的指针，插入结点(s-&gt;next&#x3D;p-&gt;next;p-&gt;next&#x3D;s;)
*&#x2F;
&#x2F;* 带头结点的插入 *&#x2F;
&#x2F;*注意:在插入位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是链表结点指针，在P之前插入新结点 *&#x2F;
bool Insert( List L, ElementType X, Position P )                &#x2F;&#x2F;平均移动次数为n&#x2F;2，平均时间性能为O(n)
&#123; &#x2F;* 这里默认L有头结点 *&#x2F;
    Position tmp, pre;

    &#x2F;* 查找P的前一个结点 *&#x2F;    
    for ( pre&#x3D;L; pre&amp;&amp;pre-&gt;Next!&#x3D;P; pre&#x3D;pre-&gt;Next ) ;        
    if ( pre&#x3D;&#x3D;NULL ) &#123; &#x2F;* P所指的结点不在L中 *&#x2F;
        printf(&quot;插入位置参数错误\n&quot;);
        return false;
    &#125;
    else &#123; &#x2F;* 找到了P的前一个结点pre *&#x2F;
        &#x2F;* 在P前插入新结点 *&#x2F;
        tmp &#x3D; (Position)malloc(sizeof(struct LNode)); &#x2F;* 申请、填装结点 *&#x2F;
        tmp-&gt;Data &#x3D; X; 
        tmp-&gt;Next &#x3D; P;
        pre-&gt;Next &#x3D; tmp;
        return true;
    &#125;
&#125;
&#x2F;*
    删除(删除链表的第i(1&lt;i&lt;n+1)个位置上的结点)
            *先找到链表的第i-1个结点，用p指向
            *用指针s指向要被删除的结点(p的下一个结点)
            *修改指针，删除s所指向的结点
            *释放s所指向的结点的空间
*&#x2F;
&#x2F;* 带头结点的删除 *&#x2F;
&#x2F;*注意:在删除位置参数P上与课程视频有所不同，课程视频中i是序列位序（从1开始），这里P是拟删除结点指针 *&#x2F;
bool Delete( List L, Position P )                       &#x2F;&#x2F;平均移动次数为n&#x2F;2，平均时间性能为O(n)
&#123; &#x2F;* 这里默认L有头结点 *&#x2F;
    Position pre;

    &#x2F;* 查找P的前一个结点 *&#x2F;    
    for ( pre&#x3D;L; pre&amp;&amp;pre-&gt;Next!&#x3D;P; pre&#x3D;pre-&gt;Next ) ;        
    if ( pre&#x3D;&#x3D;NULL || P&#x3D;&#x3D;NULL) &#123; &#x2F;* P所指的结点不在L中 *&#x2F;
        printf(&quot;删除位置参数错误\n&quot;);
        return false;
    &#125;
    else &#123; &#x2F;* 找到了P的前一个结点pre *&#x2F;
        &#x2F;* 将P位置的结点删除 *&#x2F;
        pre-&gt;Next &#x3D; P-&gt;Next;
        free(P);
        return true;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式的表示和运算</title>
    <url>/posts/7349a87dccac</url>
    <content><![CDATA[<style>
table th:nth-of-type(1){
width: 10%;
}
table th:nth-of-type(2){
width: 10%;
;
}
table th:nth-of-type(3){
width: 10%;
}
table th:nth-of-type(4){
width: 10%;
}
table th:nth-of-type(5){
width: 10%;
}
table th:nth-of-type(6){
width: 10%;
}
table th:nth-of-type(7){
width: 10%;
}
</style>
<h1 id="多项式的表示"><a class="markdownIt-Anchor" href="#多项式的表示"></a> 多项式的表示</h1>
<p>例：一元多项式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mo>…</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><msub><mi>a</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(x)=a_0+a_1x+…+a_{n-1}x^{n-1}+a_nx^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0224389999999999em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.814392em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></p>
<p>主要运算：多项式相加、相减、相乘等</p>
<span id="more"></span>
<h2 id="如何表示多项式"><a class="markdownIt-Anchor" href="#如何表示多项式"></a> 如何表示多项式？</h2>
<p>多项式的关键数据：</p>
<ul>
<li>多项式项数n</li>
<li>各项系数ai及指数i</li>
</ul>
<p>多项式问题的启示：</p>
<ul>
<li>解决同一个问题可以有不同的表示(存储)方法</li>
<li>有一类共性问题：有序线性序列的组织和管理</li>
</ul>
<h2 id="一元多项式表示方法"><a class="markdownIt-Anchor" href="#一元多项式表示方法"></a> 一元多项式表示方法</h2>
<p>如：多项式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2000</mn></msup></mrow><annotation encoding="application/x-tex">x+3x^{2000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>的表示</p>
<ul>
<li>顺序存储结构直接表示：容易造成空间的浪费</li>
<li>更好的方法是：数组各分量对应多项式各项，即a[i]表示项<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">x^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>的系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
<h3 id="方法1-顺序存储结构各分量对应多项式各项"><a class="markdownIt-Anchor" href="#方法1-顺序存储结构各分量对应多项式各项"></a> 方法1: 顺序存储结构各分量对应多项式各项</h3>
<p>例如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>4</mn><msup><mi>x</mi><mn>5</mn></msup><mo>−</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x)=4x^5-3x^2+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span><br>
表示成：</p>
<table>
<thead>
<tr>
<th style="text-align:center">下标i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a[i]</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-3</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">项</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">-3x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><msup><mi>x</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">4x^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
</tbody>
</table>
<p>两个多项式相加的方法：两个数组对应分量相加<br>
这种方法仍存在缺陷：以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2000</mn></msup></mrow><annotation encoding="application/x-tex">x+3x^{2000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span>为例<br>
需要分配一个长度为2001(指数从0开始)的数组，并且其中只有两个非0项，在做加法运算时需要遍历整个数组，而+0实际上是在做无用功</p>
<h3 id="方法2-用顺序存储结构表示非零项"><a class="markdownIt-Anchor" href="#方法2-用顺序存储结构表示非零项"></a> 方法2: 用顺序存储结构表示非零项</h3>
<p>每个非零项<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><msup><mi>x</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">a_ix^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.974664em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>涉及两个信息：系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ai</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span></span></span></span>和指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>，可将一个多项式看成一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a_i,i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>二元组的集合<br>
用结构数组表示：数组分量是由系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ai</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span></span></span></span>、指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>组成的结构，对应一个非零项<br>
按非零项的指数大小有序存储</p>
<p>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>12</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">P_1(x)=9x^{12}+15x^8+3x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>26</mn><msup><mi>x</mi><mn>19</mn></msup><mo>−</mo><mn>4</mn><msup><mi>x</mi><mn>8</mn></msup><mo>−</mo><mn>13</mn><msup><mi>x</mi><mn>6</mn></msup><mo>+</mo><mn>82</mn></mrow><annotation encoding="application/x-tex">P_2(x)=26x^{19}-4x^8-13x^6+82</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">2</span></span></span></span></p>
<table>
<thead>
<tr>
<th style="text-align:center">下标i</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ai</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span></span></span></span></td>
<td style="text-align:center">9</td>
<td style="text-align:center">15</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></td>
<td style="text-align:center">12</td>
<td style="text-align:center">8</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">下标j</th>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">系数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">aj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></td>
<td style="text-align:center">26</td>
<td style="text-align:center">-4</td>
<td style="text-align:center">-13</td>
<td style="text-align:center">82</td>
</tr>
<tr>
<td style="text-align:center">指数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span></td>
<td style="text-align:center">19</td>
<td style="text-align:center">8</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>相加过程：从头开始，比较两个多项式当前对应项的指数</p>
<pre class="line-numbers language-none"><code class="language-none">例：P1:(9,12),(15,8),(3,2)           +
   P2:(26,19),(-4,8),(-13,6),(82,0) -&gt;
   P3(26,19),(9,12),(11,8),(-13,6),(3,2),(82,0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>结果：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>26</mn><msup><mi>x</mi><mn>19</mn></msup><mo>+</mo><mn>9</mn><msup><mi>x</mi><mn>12</mn></msup><mo>+</mo><mn>11</mn><msup><mi>x</mi><mn>8</mn></msup><mo>−</mo><mn>13</mn><msup><mi>x</mi><mn>6</mn></msup><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>82</mn></mrow><annotation encoding="application/x-tex">P_3(x)=26x^{19}+9x^{12}+11x^8-13x^6+3x^2+82</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">2</span></span></span></span></p>
<h3 id="方法3-链表结构存储非零项"><a class="markdownIt-Anchor" href="#方法3-链表结构存储非零项"></a> 方法3: 链表结构存储非零项</h3>
<blockquote>
<p>链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域以及一个指针域:coef,expon,link</p>
</blockquote>
<p>例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>1</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>12</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">P1(x)=9x^{12}+15x^8+3x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">1</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>26</mn><msup><mi>x</mi><mn>19</mn></msup><mo>−</mo><mn>4</mn><msup><mi>x</mi><mn>8</mn></msup><mo>−</mo><mn>13</mn><msup><mi>x</mi><mn>6</mn></msup><mo>+</mo><mn>82</mn></mrow><annotation encoding="application/x-tex">P2(x)=26x^{19}-4x^8-13x^6+82</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">6</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">9</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">2</span></span></span></span></p>
<pre class="line-numbers language-none"><code class="language-none">多项式链表结点的定义：        
typedef struct PolyNode *Polynomial;  
struct PolyNode
&#123;
    int coef;
    int expon;
    Polynomial link;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多项式加法运算"><a class="markdownIt-Anchor" href="#多项式加法运算"></a> 多项式加法运算</h2>
<blockquote>
<p>多项式加法运算:不带头结点的单向链表，按照指数递减的顺序排列各项</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">struct PolyNode
&#123;
    int coef,expon;
    struct PolyNode *link;
&#125;;
typedef struct PolyNode *Polynomial;
Polynomial P1,P2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>思路：两个指针P1和P2分别指向两个多项式的第一个结点，不断循环：</p>
<ul>
<li>P1-&gt;expon==P2-&gt;expon：系数相加，若结果不为0，则作为结果多项式对应项的系数。同时，P1和P2都分别指向下一项；</li>
<li>P1-&gt;expon&gt;P2-&gt;expon：将P1的当前项存入结果多项式，并使P1指向下一项</li>
<li>P1-&gt;expon <code>&lt;</code>P2-&gt;expon：将P2的当前项存入结果多项式，并使P2指向下一项</li>
<li>当某一多项式处理完时，将另一个多项式的所有结点依次复制到结果多项式中(实质上是一种归并排序)</li>
</ul>
<h2 id="二元多项式的表示广义表存储"><a class="markdownIt-Anchor" href="#二元多项式的表示广义表存储"></a> 二元多项式的表示：广义表存储</h2>
<p>例：给定二元多项式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mn>9</mn><msup><mi>x</mi><mn>12</mn></msup><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><mn>4</mn><msup><mi>x</mi><mn>12</mn></msup><mo>+</mo><mn>15</mn><msup><mi>x</mi><mn>8</mn></msup><msup><mi>y</mi><mn>3</mn></msup><mo>−</mo><msup><mi>x</mi><mn>8</mn></msup><mi>y</mi><mo>+</mo><mn>3</mn><msup><mi>x</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">P(x,y)=9x^{12}y^2+4x^{12}+15x^8y^3-x^8y+3x^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">9</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>可以将该二元多项式看作关于x的一元多项式</p>
<p>$P(x,y)=(9y<sup>2+4)x</sup>{12}+(15y<sup>3-y)x</sup>8+3x^2  <span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex">
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span> (ax<sup>{12}+bx</sup>8+cx^2)$</p>
<h3 id="广义表generalized-list广义表是线性表的推广"><a class="markdownIt-Anchor" href="#广义表generalized-list广义表是线性表的推广"></a> 广义表(Generalized List)：广义表是线性表的推广</h3>
<ul>
<li>对于线性表而言，n个元素都是基本的单元素</li>
<li>但是在广义表中，这些元素不仅可以是单元素也可以是另一个广义表</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">typedef struct GNode *GList;
struct GNode
&#123;
    int Tag;                                    &#x2F;&#x2F;Tag表示标志域：0代表结点为单元素，1表示结点是广义表
    union                                       &#x2F;&#x2F;子表指针域SubList与单元素数据域Data复用，共用存储空间
    &#123;
        ElementType Data;
        GList SubList;
    &#125;URegion;
    GList Next;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="多项式加法和乘法的实现"><a class="markdownIt-Anchor" href="#多项式加法和乘法的实现"></a> 多项式加法和乘法的实现</h1>
<p>问题：设计两个函数分别求两个多项式的乘积与和<br>
已知两个多项式：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><msup><mi>x</mi><mn>4</mn></msup><mo>−</mo><mn>5</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>6</mn><mi>x</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">3x^4-5x^2+6x-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><msup><mi>x</mi><mn>20</mn></msup><mo>−</mo><mn>7</mn><msup><mi>x</mi><mn>4</mn></msup><mo>+</mo><mn>3</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">5x^{20}-7x^4+3x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">7</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord mathdefault">x</span></span></span></span></li>
<li>两个多项式和为
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><msup><mi>x</mi><mn>20</mn></msup><mo>−</mo><mn>4</mn><msup><mi>x</mi><mn>4</mn></msup><mo>−</mo><mn>5</mn><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>9</mn><mi>x</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">5x^{20}-4x^4-5x^2+9x-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ul>
</li>
<li>两个多项式乘积为
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><msup><mi>x</mi><mn>24</mn></msup><mo>−</mo><mn>25</mn><msup><mi>x</mi><mn>22</mn></msup><mo>+</mo><mn>30</mn><msup><mi>x</mi><mn>21</mn></msup><mo>−</mo><mn>10</mn><msup><mi>x</mi><mn>20</mn></msup><mo>−</mo><mn>21</mn><msup><mi>x</mi><mn>8</mn></msup><mo>+</mo><mn>35</mn><msup><mi>x</mi><mn>6</mn></msup><mo>−</mo><mn>33</mn><msup><mi>x</mi><mn>5</mn></msup><mo>+</mo><mn>14</mn><msup><mi>x</mi><mn>4</mn></msup><mo>−</mo><mn>15</mn><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><mn>18</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>6</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">15x^{24}-25x^{22}+30x^{21}-10x^{20}-21x^8+35x^6-33x^5+14x^4-15x^3+18x^2-6x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">8</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord mathdefault">x</span></span></span></span></li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">输入样例：
4 3 4 -5 2 6 1 -2 0
3 5 20 -7 4 3 1
输出样例：
15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1 5 20 -4 4 -5 2 9 1 -2 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="求解思路"><a class="markdownIt-Anchor" href="#求解思路"></a> 求解思路</h2>
<ul>
<li>
<p>多项式表示</p>
<ul>
<li>数组：变成简单、调试容易；需实现分配空间，容易浪费</li>
<li>链表：动态性强；变成略复杂、调试困难</li>
<li>一种比较好的实现方法是动态数组(将数组长度存储为变量)</li>
</ul>
</li>
<li>
<p>程序框架</p>
<ul>
<li>需要设计的函数：
<ul>
<li>读一个多项式</li>
<li>读两个多项式</li>
<li>两多项式相加</li>
<li>多项式输出</li>
</ul>
</li>
</ul>
</li>
<li>
<p>伪代码</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    读入多项式1，读入多项式1
    乘法运算并输出
    加法运算并输出
&#125;
读多项式
Polynomial ReadPoly()
&#123;
    Polynomial P,Rear,first;
    int N,c,e;
    P&#x3D;(List)malloc(sizeof(struct Lnode));
    P-&gt;link&#x3D;NULL;
    Rear&#x3D;P;
    cin&gt;&gt;N;
    while(N--)
    &#123;
        cin&gt;&gt;c&gt;&gt;e;
        Attach(c,e,&amp;Rear);              &#x2F;&#x2F;将当前项插入多项式尾部
    &#125;
    first&#x3D;P;P&#x3D;P-&gt;link;free(first);      &#x2F;&#x2F;删除临时结点(P原本指向的动态内存)
    return P;
&#125;
4.加法实现：遍历两个链表，各项相加，返回结果即可，略
5.乘法实现：将乘法运算转换为加法运算
    将P1当前项(ci,ei)乘P2多项式，再加到结果多项式里
    t1&#x3D;P1,t2&#x3D;P2;
    P&#x3D;(Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link&#x3D;NULL;
    Rear&#x3D;P;
    while(t2)       &#x2F;&#x2F;将P2的每一项都与P1当前项相乘
    &#123;
        Attach(t1-&gt;coef*t2-&gt;coef,t1-&gt;expon+t2-&gt;expon,&amp;Rear);
        t2&#x3D;t2-&gt;link;
    &#125;
    逐项插入
    将P1当前项(c1i,e1i)乘P2当前项(c2i,e2i)，并插入到结果多项式中
    关键是如何找到插入位置
    while(t1)
    &#123;
        t2&#x3D;P2,Rear&#x3D;P;
        while(t2)
        &#123;
            e&#x3D;t1-&gt;expon+t2-&gt;expon;
            c&#x3D;t1-&gt;coef*t2-&gt;coef;
            ……;
            t2&#x3D;t2-&gt;link;
        &#125;
        t1&#x3D;t1-&gt;link;
    &#125;
6.多项式输出：略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">演示代码：
#include&lt;cstdlib&gt;
#include&lt;cstdio&gt;
struct PolyNode&#123;
    int coef,expon;
    struct PolyNode *link;
&#125;;
typedef struct PolyNode *Polynomial;
int Compare(Polynomial P1,Polynomial P2);
void Attach(int c,int e,Polynomial *prear);
Polynomial PolyAdd(Polynomial P1,Polynomial P2)&#123;
    Polynomial front,rear,temp;                     &#x2F;&#x2F;front用来返回，rear用来添加新的项，输出是从front开始
    front&#x3D;rear&#x3D;new PolyNode;
    while(P1&amp;&amp;P2)&#123;
        switch (Compare(P1,P2)) &#123;
            case 1:
                Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
                P1&#x3D;P1-&gt;link;
                break;
            case -1:
                Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
                P2&#x3D;P2-&gt;link;
                break;
            case 0:
                int sum&#x3D;P1-&gt;coef+P2-&gt;coef;
                if(sum)Attach(sum,P1-&gt;expon,&amp;rear);
                P1&#x3D;P1-&gt;link,P2&#x3D;P2-&gt;link;
                break;
        &#125;
    &#125;
    for(;P1;P1&#x3D;P1-&gt;link)Attach(P1-&gt;coef,P1-&gt;expon,&amp;rear);
    for(;P2;P2&#x3D;P2-&gt;link)Attach(P2-&gt;coef,P2-&gt;expon,&amp;rear);
    temp&#x3D;front;
    front&#x3D;front-&gt;link;
    free(temp);
    return front;
&#125;
int Compare(Polynomial P1,Polynomial P2)&#123;
    if(P1-&gt;expon&gt;P2-&gt;expon)return 1;
    if(P1-&gt;expon&lt;P2-&gt;expon)return -1;
    if(P1-&gt;expon&#x3D;&#x3D;P2-&gt;expon)return 0;
    return 0;
&#125;
void Attach(int c,int e,Polynomial * pRear)                &#x2F;&#x2F;根据Rear初值是否为NULL做不同处理(即构造的链表是否含有头结点)
&#123;                                                          &#x2F;&#x2F;最开始为空的结点(头结点)在调用结束后再决定是否删除
    Polynomial temp;
    temp&#x3D;(Polynomial)malloc(sizeof(struct PolyNode));
    temp-&gt;coef&#x3D;c;
    temp-&gt;expon&#x3D;e;
    temp-&gt;link&#x3D;(*pRear)-&gt;link;
    (*pRear)-&gt;link&#x3D;temp;
    (*pRear)&#x3D;temp;
&#125;
Polynomial Mult(Polynomial P1,Polynomial P2)
&#123;
    Polynomial P,Rear,t1,t2,t;
    int c,e;
    if(!P1||!P2)return NULL;
    t1&#x3D;P1,t2&#x3D;P2;
    P&#x3D;(Polynomial)malloc(sizeof(struct PolyNode));
    P-&gt;link&#x3D;NULL;
    Rear&#x3D;P;
    while(t2)         &#x2F;&#x2F;先用P1首项与P2各项相乘，构造初始的结果多项式
    &#123;
        Attach(t1-&gt;coef*t2-&gt;coef,t1-&gt;expon+t2-&gt;expon,&amp;Rear);
        t2&#x3D;t2-&gt;link;
    &#125;
    t1&#x3D;t1-&gt;link;
    while(t1)         &#x2F;&#x2F;依次用P1其他项与P2各项相乘，将每个乘积项插入到结果多项式中
    &#123;
        t2&#x3D;P2;
        Rear&#x3D;P;
        while(t2)
        &#123;
            e&#x3D;t1-&gt;expon+t2-&gt;expon;      &#x2F;&#x2F;计算各个乘积项的系数和指数
            c&#x3D;t1-&gt;coef*t2-&gt;coef;
            while(Rear-&gt;link&amp;&amp;Rear-&gt;link-&gt;expon&gt;e)Rear&#x3D;Rear-&gt;link;&#x2F;&#x2F;找到结果多项式中系数不大于乘积项系数的位置，插入该乘积项
            if(Rear-&gt;link&amp;&amp;Rear-&gt;link-&gt;expon&#x3D;&#x3D;e)           &#x2F;&#x2F;如果与结果多项式原有的项指数相同，则系数相加后插入
            &#123;
                if(Rear-&gt;link-&gt;coef+c)Rear-&gt;link-&gt;coef+&#x3D;c;
                else
                &#123;
                    t&#x3D;Rear-&gt;link;
                    Rear-&gt;link&#x3D;t-&gt;link;
                    free(t);
                &#125;
            &#125;
            else                                           &#x2F;&#x2F;如果与结果多项式原有的项指数不同，直接将该项插入
            &#123;
                t&#x3D;(Polynomial)malloc(sizeof(struct PolyNode));
                t-&gt;coef&#x3D;c,t-&gt;expon&#x3D;e;
                t-&gt;link&#x3D;Rear-&gt;link;
                Rear-&gt;link&#x3D;t;
                Rear&#x3D;Rear-&gt;link;
            &#125;
            t2&#x3D;t2-&gt;link;
        &#125;
        t1&#x3D;t1-&gt;link;
    &#125;
    t2&#x3D;P,P&#x3D;P-&gt;link;             &#x2F;&#x2F;删除表头的空结点(头结点)
    free(t2);
    return P;
&#125;
void PrintPoly(Polynomial P)
&#123;
    int flag&#x3D;0;         &#x2F;&#x2F;辅助调整输出格式，第一项前不输出空格
    if(!P)printf(&quot;0 0\n&quot;);
    while(P)
    &#123;
        if(!flag)flag&#x3D;1;
        else printf(&quot; &quot;);
        printf(&quot;%d %d&quot;,P-&gt;coef,P-&gt;expon);
        P&#x3D;P-&gt;link;
    &#125;
    printf(&quot;\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1.测试运行时间、最大子列和计算</title>
    <url>/posts/f8c524107860</url>
    <content><![CDATA[<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 测试运行时间
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;ctime&gt;
#include&lt;cmath&gt;
usingnamespacestd;
voidprintN1(intn);
voidprintN2(intn);
floatff1(floatx);
floatff2(floatx);
floatcost(floatt,floatf(float));
intmain()
&#123;
    constfloatx&#x3D;1.1;
    cout&lt;&lt;&quot;ff1&quot;&lt;&lt;&quot;运行结果：&quot;&lt;&lt;ff1(x)&lt;&lt;&quot;   运行时间：&quot;&lt;&lt;cost(x,ff1)&lt;&lt;&#39;s&#39;&lt;&lt;endl;
    cout&lt;&lt;&quot;ff2&quot;&lt;&lt;&quot;运行结果：&quot;&lt;&lt;ff2(x)&lt;&lt;&quot;   运行时间：&quot;&lt;&lt;cost(x,ff2)&lt;&lt;&#39;s&#39;&lt;&lt;endl;
&#125;
floatcost(floatt,float*f(float))
&#123;
    clock_ts,e;
    floatcost;
    s&#x3D;clock();
    f(t);
    e&#x3D;clock();
    cost&#x3D;(float)(s-e)&#x2F;CLK_TCK;
    returncost;
&#125;
voidprintN1(intn)            &#x2F;&#x2F;递归算法涉及到程序的调用和程序状态的记录，会额外消耗空间
&#123;                            &#x2F;&#x2F;此时空间复杂度S(n)&#x3D;c·n
    if(n&gt;1)printN1(n-1);
    printf(&quot;%d\n&quot;,n);
&#125;
voidprintN2(intn)
&#123;                            &#x2F;&#x2F;非递归算法中没有申请额外空间空间复杂度为常数级
    inti;
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        printf(&quot;%d&quot;,i);
    &#125;
&#125;
floatff1(floatx)
&#123;                            &#x2F;&#x2F;for循环执行n次，pow函数中x进行i-1次乘法，即一次循环中执行i-1次乘法和1次除法
    floati,f&#x3D;1;              &#x2F;&#x2F;加减运算相对乘除运算较为简单，对计算机而言可会略不计
    for(i&#x3D;1;i&lt;&#x3D;100;i++)f+&#x3D;pow(x,i)&#x2F;i;    &#x2F;&#x2F;算法总计进行乘除法n*(1+n)&#x2F;2，T(n)&#x3D;O(n)
    returnf;
&#125;
floatff2(floatx)
&#123;
    floati,f&#x3D;1.0&#x2F;100.0;                  &#x2F;&#x2F;for循环执行100次，每次进行2次乘除法
    for(i&#x3D;100;i&gt;1;i--)f&#x3D;x*f+1.0&#x2F;(i-1.0); &#x2F;&#x2F;T(n)&#x3D;O(n)
    f&#x3D;f*x+1;
    returnf;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<span id="more"></span>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;cmath&gt;
&#x2F;*  给定N个整数的序列&#123;A1,A2,…,AN&#125;，求函数f(i,j)&#x3D;max&#123;0,∑ij(Ak)&#125;的最大值  *&#x2F;
&#x2F;*  算法1:T(N)&#x3D;O(N^3)  *&#x2F;
    int MaxSubseqSum1(int A[],int N)    &#x2F;&#x2F;将所有子列和都算出来
    &#123;                             
        int ThisSum,MaxSum&#x3D;0;
        int i,j,k;
        for(i&#x3D;0;i&lt;N;i++)
        &#123;
            for(j&#x3D;i;j&lt;N;j++)
            &#123;
                ThisSum&#x3D;0;
                for(k&#x3D;i;k&lt;&#x3D;j;k++)ThisSum+&#x3D;A[k];         &#x2F;&#x2F;实际上，在i相等的情况下，一轮j循环结束后进入下一个j的循环时
                if(ThisSum&gt;MaxSum)MaxSum&#x3D;ThisSum;       &#x2F;&#x2F;只有最后一个元素是新增的，根本没有必要从i开始加
            &#125;                                           &#x2F;&#x2F;因此，k循环是完全多余的
        &#125;
        return MaxSum;
    &#125;
&#x2F;*  算法2:T(N)&#x3D;O(N^2) *&#x2F;
    int MaxSubseqSum2(int A[],int N)
    &#123;
        int ThisSum,MaxSum&#x3D;0;
        int i,j;
        for(i&#x3D;0;i&lt;N;i++)
        &#123;
            ThisSum&#x3D;0;
            for(j&#x3D;i;j&lt;N;j++)
            &#123;
                ThisSum+&#x3D;A[j];
                if(ThisSum&gt;MaxSum)MaxSum&#x3D;ThisSum;
            &#125;
        &#125;
        return MaxSum;
    &#125;
&#x2F;*  算法3:分而治之 *&#x2F;
&#x2F;*  T(N)&#x3D;2T(N&#x2F;2)+cN,   T(1)&#x3D;O(1)
        &#x3D;2[2T(N&#x2F;4)+cN&#x2F;2]+cN
        &#x3D;(2^k)*O(1)+ckN,    其中N&#x2F;2^k&#x3D;1
        &#x3D;O(NlogN)   *&#x2F;
    int MaxSubseqSum3(int A[],int start,int end)
    &#123;
        int mid&#x3D;(end+start)&#x2F;2,LeftSum,RightSum,lplusrSum,lMaxSum&#x3D;0,rMaxSum&#x3D;0,ThisSum&#x3D;0;
        if(start&#x3D;&#x3D;end)return A[mid];
        LeftSum&#x3D;MaxSubseqSum3(A,start,mid);
        RightSum&#x3D;MaxSubseqSum3(A,mid+1,end);
        for(int i&#x3D;mid;i&gt;&#x3D;start;i--)
        &#123;
            ThisSum+&#x3D;A[i];
            if(ThisSum&gt;lMaxSum)lMaxSum&#x3D;ThisSum;
        &#125;
        ThisSum&#x3D;0;
        for(int i&#x3D;mid+1;i&lt;&#x3D;end;i++)
        &#123;
            ThisSum+&#x3D;A[i];
            if(ThisSum&gt;rMaxSum)rMaxSum&#x3D;ThisSum;
        &#125;
        lplusrSum&#x3D;lMaxSum+rMaxSum;
        int outmax&#x3D;(LeftSum&gt;RightSum)?LeftSum:RightSum;
        return (outmax&gt;lplusrSum)?outmax:lplusrSum;
    &#125;

&#x2F;*  算法4:在线处理  
    “在线”的意思是指每输入一个数据就进行即时处理，在任何一个地方终止输入，算法都能给出正确解  *&#x2F;
&#x2F;*  T(N)&#x3D;O(N) *&#x2F;
    int MaxSubseqSum4(int A[],int N)      
    &#123;
        int ThisSum,MaxSum;
        int i;
        ThisSum&#x3D;MaxSum&#x3D;0;
        for(i&#x3D;0;i&lt;N;i++)
        &#123;
            ThisSum+&#x3D;A[i];
            if(ThisSum&gt;MaxSum)MaxSum&#x3D;ThisSum;
            else if(ThisSum&lt;0)ThisSum&#x3D;0;           &#x2F;&#x2F;如果子列左边或右边的子列和是正的，则该子列一定不是最大子列和
        &#125;
        return MaxSum;
    &#125;

&#x2F;* 分治法求最大子列和标准示例程序(来自浙江大学数据结构课程)*&#x2F;

int Max3( int A, int B, int C )
&#123; &#x2F;* 返回3个整数中的最大值 *&#x2F;
    return A &gt; B ? A &gt; C ? A : C : B &gt; C ? B : C;
&#125;

int DivideAndConquer( int List[], int left, int right )
&#123; &#x2F;* 分治法求List[left]到List[right]的最大子列和 *&#x2F;
    int MaxLeftSum, MaxRightSum; &#x2F;* 存放左右子问题的解 *&#x2F;
    int MaxLeftBorderSum, MaxRightBorderSum; &#x2F;*存放跨分界线的结果*&#x2F;
    int LeftBorderSum, RightBorderSum;
    int center, i;

    if( left &#x3D;&#x3D; right )  &#123; &#x2F;* 递归的终止条件，子列只有1个数字 *&#x2F;
        if( List[left] &gt; 0 )  return List[left];
        else return 0;
    &#125;

    &#x2F;* 下面是&quot;分&quot;的过程 *&#x2F;
    center &#x3D; ( left + right ) &#x2F; 2; &#x2F;* 找到中分点 *&#x2F;
    &#x2F;* 递归求得两边子列的最大和 *&#x2F;
    MaxLeftSum &#x3D; DivideAndConquer( List, left, center );
    MaxRightSum &#x3D; DivideAndConquer( List, center+1, right );

    &#x2F;* 下面求跨分界线的最大子列和 *&#x2F;
    MaxLeftBorderSum &#x3D; 0; LeftBorderSum &#x3D; 0;
    for( i&#x3D;center; i&gt;&#x3D;left; i-- ) &#123; &#x2F;* 从中线向左扫描 *&#x2F;
        LeftBorderSum +&#x3D; List[i];
        if( LeftBorderSum &gt; MaxLeftBorderSum )
            MaxLeftBorderSum &#x3D; LeftBorderSum;
    &#125; &#x2F;* 左边扫描结束 *&#x2F;

    MaxRightBorderSum &#x3D; 0; RightBorderSum &#x3D; 0;
    for( i&#x3D;center+1; i&lt;&#x3D;right; i++ ) &#123; &#x2F;* 从中线向右扫描 *&#x2F;
        RightBorderSum +&#x3D; List[i];
        if( RightBorderSum &gt; MaxRightBorderSum )
            MaxRightBorderSum &#x3D; RightBorderSum;
    &#125; &#x2F;* 右边扫描结束 *&#x2F;

    &#x2F;* 下面返回&quot;治&quot;的结果 *&#x2F;
    return Max3( MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum );
&#125;

int MaxSubseqSum3( int List[], int N )
&#123; &#x2F;* 保持与前2种算法相同的函数接口 *&#x2F;
    return DivideAndConquer( List, 0, N-1 );
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>数据结构实例运用</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构基本概念</title>
    <url>/posts/61f72dc1fd19</url>
    <content><![CDATA[<p>对于数据结构，官方没有统一概念，以下是三个经典著作中数据结构的定义</p>
<blockquote>
<p>数据结构是数据对象，以及存在于该对象的实例和组成该实例的数据元素之间的各种联系。<br>
这种联系可以通过定义相关的函数来给出。   --Sartaj Sahni，《数据结构、算法与应用》</p>
</blockquote>
<blockquote>
<p>数据结构是ADT（抽象数据类型 Abstract Data Type）的物理实现。<br>
–Clifford A.Shaffer  《数据结构与算法分析》</p>
</blockquote>
<blockquote>
<p>数据结构（data structure）是计算机中存储、组织数据的方式。通常情况下，精心选择的<br>
数据结构可以带来最优效率的算法。         --中文维基百科</p>
</blockquote>
<p>解决问题方法的效率，往往与数据的组织形式，跟空间的利用效率，跟算法的巧妙程度等等有关</p>
<span id="more"></span>
<h1 id="数据结构数据对象在计算机中的组织方式"><a class="markdownIt-Anchor" href="#数据结构数据对象在计算机中的组织方式"></a> 数据结构：数据对象在计算机中的组织方式</h1>
<ul>
<li>逻辑结构</li>
<li>物理存储结构</li>
</ul>
<blockquote>
<p>数据对象必定与一系列加在其上的操作相关联，完成这些操作所用的方法就是算法<br>
（数据结构研究逻辑结构和物理结构以及它们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法）</p>
</blockquote>
<h2 id="抽象数据类型abstract-data-type"><a class="markdownIt-Anchor" href="#抽象数据类型abstract-data-type"></a> 抽象数据类型（Abstract Data Type）</h2>
<ul>
<li>数据类型</li>
<li>数据对象集(数据结构)</li>
<li>数据集合相关联的操作集(数据结构对应的操作)<br>
<img src="https://s2.loli.net/2022/04/30/BGwr4JpLcbuZUCi.png" alt="1__数据结构、算法、抽象数据类型.png"></li>
</ul>
<h3 id="抽象描述数据类型的方法不依赖于具体实现"><a class="markdownIt-Anchor" href="#抽象描述数据类型的方法不依赖于具体实现"></a> 抽象：描述数据类型的方法不依赖于具体实现</h3>
<ul>
<li>与存放的机器无关</li>
<li>与数据存储的物理结构无关</li>
<li>与实现操作的算法和编程语言均无关</li>
</ul>
<p>只描述数据对象集和相关操作集“是什么”，并不涉及“如何做到”的问题(不考虑操作的具体实现，即不考虑算法)</p>
<pre class="line-numbers language-none"><code class="language-none">例：矩阵的抽象数据类型定义
数据类型名：Matrix      (不考虑存储结构)
数据对象集：一个M*N的矩阵A&#x3D;(Aij)(i&#x3D;1,…,M;j&#x3D;1,…,N)由M*N个三元组&lt;a,i,j&gt;构成，
其中a是矩阵元素的值，i是元素所在的行号，j是元素所在的列号
操作集：对于任意矩阵A、B、C ∈ Matrix，以及整数i、j、M、N
Matrix Create(int M,int N):返回一个M*N的空矩阵；
int GetMaxRow(Matrix A):返回矩阵A的总行数；
int GetMaxCol(Matrix A):返回矩阵A的总列数；
ElamentType GetEntry(Matrix A,int i,int j):返回矩阵A的第i行，第j列的元素，否则返回错误标志
Matrix Add(Matrix A,Matrix B):如果A和B的行、列数一致，则返回矩阵C&#x3D;A+B，否则返回错误标志
Matrix Multiply(Matrix A,Matrix B):如果A和B的行、列数一致，则返回矩阵C&#x3D;AB，否则返回错误标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="算法algorithm"><a class="markdownIt-Anchor" href="#算法algorithm"></a> 算法（Algorithm）</h1>
<ul>
<li>有限指令集</li>
<li>接受一些输入（有些情况下不需要输入）</li>
<li>产生输出</li>
<li>一定在有限步骤后停止</li>
<li>每一条指令必须</li>
<li>有充分明确的目标，不可以有歧义</li>
<li>计算机能处理的范围之内</li>
<li>描述应不依赖于任何一种计算机语言以及具体的实现手段</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">例：简单选择排序的伪代码描述
&#x2F;&#x2F; 将N个整数List[0],…,List[N-1]进行非递减排序
void SelectionSort()
&#123;
    for(i&#x3D;0;i&lt;N;i++)
    &#123;
        &#x2F;&#x2F;从List[i]到List[N-1]中选择最小元，并将其位置赋给MinPosition;
        MinPosition&#x3D;ScanForMin(List,i,N-1);
        &#x2F;&#x2F;将未排序的最小元换到有序部分的最后位置;
        Swap(List(i),List(MinPosition));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>伪代码的特点：<strong>抽象</strong><br>
———比如：上例中<br>
List既可以用数组实现，又可以用函数实现<br>
Swap既可以是函数实现，也可以是宏等方式实现</p>
<h2 id="什么是好的算法"><a class="markdownIt-Anchor" href="#什么是好的算法"></a> 什么是好的算法？</h2>
<ul>
<li>空间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>——根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。<br>
空间复杂度过高的算法可能导致内存超限，造成程序非正常中断。</li>
<li>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>——根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。<br>
时间复杂度过高的低效算法可能导致我们在有生之年都等不到运行结果。</li>
</ul>
<p>分析一般算法的效率时，经常关注两种复杂度</p>
<ul>
<li>最坏情况复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Tworst(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li>平均复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Tavg(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>v</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>=</mo><mi>T</mi><mi>w</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>t</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Tavg(n)&lt;=Tworst(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
</ul>
<h3 id="复杂度的渐进表示法"><a class="markdownIt-Anchor" href="#复杂度的渐进表示法"></a> 复杂度的渐进表示法</h3>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>表示存在常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mi mathvariant="normal">，</mi><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>使得当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n&gt;=n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo>=</mo><mi>C</mi><mo separator="true">⋅</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)&lt;=C·f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=Ω(g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>表示存在常数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>&gt;</mo><mn>0</mn><mi mathvariant="normal">，</mi><msub><mi>n</mi><mn>0</mn></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">C&gt;0，n_0&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord cjk_fallback">，</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>使得当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><msub><mi>n</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">n&gt;=n_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mi>C</mi><mo separator="true">⋅</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)&gt;=C·g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">⋅</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=Θ(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>表示同时有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=Ω(h(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>若两段算法分别有复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)=O(f_1(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_2(n)=O(f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，则</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)+T_2(n)=max(O(f_1(n)),O(f_2(n)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>f</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T_1(n)*T_2(n)=O(f_1(n)*f_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span> (类似于嵌套)</li>
<li>若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>是关于n的k阶多项式，那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=Θ(n^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li>
<li>一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度</li>
<li>if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大</li>
</ul>
]]></content>
      <categories>
        <category>数据结构学习</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/posts/5bdc88454c74</url>
    <content><![CDATA[<h1 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h1>
<p>在程序运行过程中，有些错误是可以预料，但不可回避的，如：</p>
<blockquote>
<p>内存空间不足，外存文件被移动到其他驱动，io设备未处理好等系统运行环境造成的错误。</p>
</blockquote>
<p>异常存在于程序的正常功能之外，一般要求程序立即处理。因此，需要考虑一种方法做到部分功能可以允许用户排除环境错误，继续运行程序，部分功能可以给出适当的同时信息。c++的异常处理机制，使得异常的引发和处理不必在同一个函数当中，这样底层的函数可以着重于解决具体问题，不需要过多考虑对异常的处理，而上层的调用者可以在适当的位置设置对不同类型异常的处理，即异常引发和处理不在同一个函数，下层解决问题，上层处理各种异常。异常处理机制提供程序中错误检测与错误处理部分之间的通信。</p>
<span id="more"></span>
<p>c++中使用throw(抛出)表达式引发(抛出)异常条件，并以try catch语句块处理异常，try catch语句块以try(检测)开始，并以一个或多个catch(捕获)结束。在try块中执行的代码所抛出的异常，通常由其中的一个catch子句进行处理。</p>
<blockquote>
<p>抛出异常的基本格式为：throw 异常数据</p>
</blockquote>
<p>异常数据可以包含任意的信息，可以是int、float、bool等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型，异常数据是什么类型，就抛出什么类型的异常。c++标准库当中还定义了一组异常类exception，专门用于在throw和try块之间传递错误信息。在try块中执行的代码所抛出的异常，通常由其中的一个catch子句进行处理。<br>
try catch语句表达式的基本格式如下：</p>
<blockquote>
<p>try{要执行的程序;}<br>
catch(异常类型1 表达式1){该类异常对应的处理;}<br>
catch(异常类型2 表达式2){该类异常对应的处理;}<br>
…<br>
catch(异常类名n 表达式n){该类异常对应的处理;}</p>
</blockquote>
<p><strong>异常是一份数据</strong>，所以有数据类型。当异常发生后，会将异常数据传递给异常变量，这和函数传参的过程类似，只有跟异常类型匹配的异常数据才会被传递给异常变量，否则catch不会接收这份异常数据，也不会执行catch块中的语句。因此可以将catch看做一个没有返回值的函数，当异常发生后catch会被调用，并且会接收实参(异常数据)。但对于catch，异常是在运行阶段产生的，所以不能在编译阶段判断类型是否正确，只有在运行阶段才能将实参和形参匹配(动态绑定)。发生异常时必须将异常明确地抛出，try才能检测到；如果不抛出，即使有异常try也检无法检测。检测到异常后程序的执行流会发生跳转，从异常点跳转到catch所在的位置，位于异常点之后的、并且在当前try块内的语句都将不再有机会执行。即使catch语句成功地处理了错误，程序的执行流也不会再回退到异常点，程序会继续执行catch块后面的代码，恢复正常的执行流。<br>
常见的标准异常有四类</p>
<blockquote>
<p>exception头文件：最常见的异常类，类名为：exception  只通知异常不提供其他信息<br>
stdexcept：定义了集中常见的异常类<br>
new：头文件定义了bad_alloc异常类型，提供因无法分配内存(分配出错)而由new抛出的异常<br>
type_info：定义了bad_cast异常类，(错误的类型转换异常)</p>
</blockquote>
<p>异常处理示例程序1：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
class Item
&#123;
    int isbn;
    friend istream &amp;operator&gt;&gt;(istream &amp;ii,Item &amp;i)
    &#123;
        ii&gt;&gt;i.isbn;
        return ii;
    &#125;
    friend int &amp;operator+(Item i1,Item i2)
    &#123;
        static int sum;
        sum+&#x3D;i1.isbn+i2.isbn;
        return sum;
    &#125;
    friend int sameisbn(Item i1,Item i2)
    &#123;
        if(i1.isbn&#x3D;&#x3D;i2.isbn)return 1;
        return 0;
    &#125;
&#125;;
int main()
&#123;
    Item item1,item2;
    while(cin&gt;&gt;item1&gt;&gt;item2)
    &#123;
        try
        &#123;
            if(!sameisbn(item1,item2))
            throw runtime_error(&quot;err:必须是同一个isbn\n&quot;);            &#x2F;&#x2F;runtime_error是异常类exception的派生类，表示运行时异常
            else cout&lt;&lt;&quot;两次销售之和：&quot;&lt;&lt;item1+item2;                 &#x2F;&#x2F;其中传入参数代表异常所描述的异常描述信息，是异常类的数据成员
        &#125;
        catch(const runtime_error err)
        &#123;
            char c;
            cout&lt;&lt;err.what()&lt;&lt;&quot;是否需要重新输入？&quot;&lt;&lt;endl;              &#x2F;&#x2F;what()是异常类的成员函数，返回字符串形式的异常描述信息
            cin&gt;&gt;c;
            if(c&#x3D;&#x3D;&#39;\0&#39;)break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>异常处理2:多层异常处理</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
void fun1(),fun2(),fun3();
void fun1()
&#123;
    try&#123;
        fun2();
    &#125;
    catch(int)&#123;cout&lt;&lt;&quot;第1层处理&quot;&lt;&lt;endl;&#125;                &#x2F;&#x2F;捕获fun2()中的int异常
    cout&lt;&lt;&quot;fun1结束&quot;&lt;&lt;endl;                            &#x2F;&#x2F;由于已经没有抛出的异常，因此fun1()中的输出语句会执行
&#125;
void fun2()
&#123;
    int a;
    try&#123;
        fun3();
    &#125;
    catch(int)&#123;cout&lt;&lt;&quot;第2层处理&quot;&lt;&lt;endl;throw a;&#125;        &#x2F;&#x2F;捕获fun3()中的char异常，同理，抛出int类型异常，可以在其上层的函数fun1()中捕获
    cout&lt;&lt;&quot;fun2结束&quot;&lt;&lt;endl;                            &#x2F;&#x2F;此句不会执行
&#125;
void fun3()
&#123;
    double a;int b;char c;
    try&#123;
        throw a;
        throw b;
        throw c;
    &#125;                                                       &#x2F;&#x2F;此处虽然抛出三个异常，但只有double类型的a(异常变量)可以在fun3()中捕获
    catch(double)&#123;cout&lt;&lt;&quot;第3层处理&quot;&lt;&lt;endl;throw b;throw c;&#125;  &#x2F;&#x2F;处理完double类型异常后数抛出char类型异常，可以在其上层的函数fun2()中捕获
    cout&lt;&lt;&quot;fun3结束&quot;&lt;&lt;endl;                                 &#x2F;&#x2F;因为异常c在fun2()中被捕获，因此fun3中的这句输出语句被跳过了
&#125;
int main()                    &#x2F;&#x2F;输出结果：第3层处理
&#123;                                     &#x2F;&#x2F;第2层处理
    fun1();                           &#x2F;&#x2F;第1层处理
    cout&lt;&lt;&quot;执行main()&quot;;                &#x2F;&#x2F;fun1结束
&#125;                                     &#x2F;&#x2F;执行main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数A在执行过程中发现异常时可以不加处理，而只是“拋出一个异常”给A的调用者，假定为函数B。拋出异常而不加处理会导致函数A立即中止，函数B可以选择捕获A拋出的异常进行处理，也可以选择置之不理</p>
<ul>
<li>如果置之不理，这个异常就会被拋给B的调用者，以此类推</li>
<li>如果一层层的函数都不处理异常，异常最终会被拋给最外层的main函数，如果main函数也不处理异常，那么程序会立即异常地中止</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>模板</title>
    <url>/posts/b10e41f86dff</url>
    <content><![CDATA[<h1 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h1>
<p>常见的代码重用技术有：<br>
函数，类与对象，继承与派生，多态(函数重载，运算符重载，虚函数，纯虚函数，抽象类等)，泛型程序设计</p>
<p>通用的代码需要不受数据类型的影响，并且可以自动适应数据类型的变化，这种程序设计类型称为泛型程序设计。<br>
在c++中，泛型实际是通过<strong>参数多态性</strong>来实现的，参数化的多态是将程序所处理的对象的类型进行参数化，使同一段程序可以处理不同类型的对象。</p>
<p>值(Value)和类型(Type)是数据的两个主要特征，它们在c++中都可以被参数化</p>
<p>问题：定义一个函数，求两个变量之间的较大值，并且使所有基本数据类型都可以使用这个功能</p>
<ul>
<li>如果采用函数重载的方法，则需要的函数数量较多，并且除了操作的数据类型不同以外，程序框架是一样的，这使代码显得累赘并且加大维护难度</li>
<li>如果采用宏定义的方法，虽然解决了代码维护的问题，但缺少类型检查，极大增加了出错的可能</li>
</ul>
<p>此时，c<ins>的模板可以解决这一问题，数据类型本身就是一个参数。模板的声明或定义只能在全局，命名空间或类的内部进行，即不能在局部范围，函数内进行，如不能main()内声明或定义一个模板。<br>
c</ins>模板非常重要，整个标准库几乎都是使用模板来开发的，STL更是经典之作。</p>
<blockquote>
<p>STL（Standard Template Library，标准模板库）就是c++对数据结构进行封装后的称呼</p>
</blockquote>
<span id="more"></span>
<h2 id="函数模板"><a class="markdownIt-Anchor" href="#函数模板"></a> 函数模板</h2>
<p>函数模板的基本格式：</p>
<blockquote>
<p>template &lt;typename 形参名1,typename 形参名2…&gt;返回类型 函数名(参数列表){函数体}</p>
</blockquote>
<p>其中typename关键字也可以用class替换</p>
<ul>
<li>注意虽然在c<ins>中struct和class基本上是同等的，但是两者很重要的区别是c</ins>没有支持使用struct定义模板参数的方法</li>
</ul>
<p>在函数内部此时既可以指定数据类型，也可以不指定而是用形参来代替，调用时根据实参的数据类型来确定相应变量的数据类型，如：</p>
<blockquote>
<p>template &lt;typename T1,typename T2&gt;T1 max(T1 x,T2 y){return x&gt;=y?x:y;}<br>
int main(){<br>
cout&lt;&lt;max(321.32,255)&lt;&lt;’ ';<br>
cout&lt;&lt;max(32,‘2’)&lt;&lt;endl;<br>
}              //输出结果：321.32 50</p>
</blockquote>
<p>此例中的max函数代表一类具有相同程序逻辑的函数，称之为函数模板。函数模板本身是<strong>无法编译</strong>的，因此不能直接使用，必须进行实例化。函数模板属于静态绑定，需要赋予具体的数据类型，编译器才能将模板扩展成合适的代码进行绑定。<br>
由函数模板实例化出的函数称为模板函数，二者间的关系类似于类和对象，即函数模板将具有相同类型正文的一类函数进行抽象，对其实例化可得模板函数。<br>
函数模板实例化的参数类型可以是类类型，但是使用时需注意类类型相对于基本数据类型有许多运算是无法进行的，在使用之前应对函数模板中涉及到该类的运算符进行重载，并确认对类对象的使用是否合法。<br>
注意，同一个模板参数只能对应一种数据类型，如果输入的实参数据类型无法匹配，则编译时会产生混乱无法生成准确的函数，即使两种数据之间是可以转换的，如：</p>
<blockquote>
<p>template&lt;typename T&gt;max(T x,T y);<br>
int main(){<br>
cout&lt;&lt;max(321.32,255);<br>
}</p>
</blockquote>
<p>此时编译器不知道应该生成max(int,int)还是max(float,float)，即无法进行实例化，这很好理解因为编译器需要靠类型信息来进行绑定，如果类型无法匹配显然产生错误(如果类型转换也算的话，那么任何类型都一样可以转换，仍然无法匹配)。这种情况可以考虑使用多个模板参数或函数重载函数模板</p>
<p>使用多个模板参数，如：</p>
<blockquote>
<p>template&lt;typename T1,typename T2&gt;max(T1 x,T2 y);</p>
</blockquote>
<p>函数重载函数模板，如：</p>
<blockquote>
<p>template<typename t>max(T x,T y);int max(int x,int y);</typename></p>
</blockquote>
<p>当存在重载时，函数调用的依据还是最佳匹配原则：</p>
<ul>
<li>如果存在完全匹配时，则优先调用完全匹配，并且普通函数优于模板函数</li>
<li>如果不能完全匹配，先看是否有提升转换(低类型-&gt;高类型)，如：</li>
</ul>
<blockquote>
<p>char,short转换为int，float转换为double等，这种情况数据不会丢失</p>
</blockquote>
<ul>
<li>无法进行提升转换，再看是否有标准转换(高类型-&gt;低类型)，如：</li>
</ul>
<blockquote>
<p>int转化为char，long double转换为double等</p>
</blockquote>
<ul>
<li>最后查看是否有用户自定义的转换，如类声明中定义的类型转换运算符</li>
</ul>
<h2 id="类模板"><a class="markdownIt-Anchor" href="#类模板"></a> 类模板</h2>
<p>与函数一样，类也可以有模板<br>
类模板的基本格式为：</p>
<blockquote>
<p>template&lt;typename 形参名1,typename 形参名2…&gt;class 类名{};</p>
</blockquote>
<p>同理，typename关键字可换成class，以及同样的可以在类模板内部使用模板形参对内置数据类型进行声明<br>
在类模板外部定义成员函数的基本格式为：</p>
<blockquote>
<p>template&lt;模板形参列表&gt;函数返回类型 类名&lt;模板形参名&gt;::函数名(参数列表){函数体}</p>
</blockquote>
<p>使用类模板生成对象，同样需要对模板参数进行实例化，基本格式为：</p>
<blockquote>
<p>类名&lt;数据类型名&gt; 对象名</p>
</blockquote>
<p>例：双向链表类模板</p>
<pre class="line-numbers language-none"><code class="language-none">template&lt;typename T&gt;class node
&#123;
    T data;
    node *next,*prev;
public:
    node()&#123;prev&#x3D;NULL,next&#x3D;NULL;&#125;
    void setvalue(T data)&#123;this-&gt;data&#x3D;data;&#125;
    void append(node *p);
&#125;;
template&lt;typename T&gt;void node&lt;T&gt;::append(node *p)      &#x2F;&#x2F;node&lt;T&gt;是模板的名字
&#123;
    this-&gt;next&#x3D;p-&gt;next;
    p-&gt;prev&#x3D;this;
    if(next)next-&gt;prev&#x3D;p;
    this-&gt;next&#x3D;p;
&#125;
int main()
&#123;
    node&lt;int&gt;*nodehead,node,node1,node2;              &#x2F;&#x2F;用模板实参int实例化类模板
    node1.setvalue(1),node2.setvalue(2);
    nodehead&#x3D;&amp;node;
    nodehead-&gt;append(&amp;node1),nodehead-&gt;append(&amp;node2);
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>多态性与虚函数</title>
    <url>/posts/c2c914ef34bc</url>
    <content><![CDATA[<h1 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h1>
<p>多态是面向对象编程的主要特征之一<br>
基类指针/引用<strong>可以按照基类的方式来做事，也可以按照派生类的方式</strong>来做事，它有多种形态，或者说有多种表现方式，这种现象即为多态<br>
简单而言，多态就是用相同或相似的方法进行处理而得到的是不同的结果<br>
即使用方法看起来没有区别，但实现的功能是完全不同的，达到一个界面，多种实现的效果</p>
<span id="more"></span>
<h2 id="多态分类"><a class="markdownIt-Anchor" href="#多态分类"></a> 多态分类</h2>
<p>多态分为两类：编译时的多态，运行时的多态</p>
<blockquote>
<p>编译时的多态包括：函数重载，运算符重载<br>
运行时的多态：虚函数实现 (动态绑定)</p>
</blockquote>
<p>继承和动态绑定在两个方面简化了程序：</p>
<ul>
<li>可以容易地编写与其他类相似但又不相同的新类</li>
<li>可以容易地编写忽略这些相似类型之间区别的程序</li>
</ul>
<p>许多应用程序的特性可以用一些相关但略有不同的概念描述，面向对象编程与这种应用非常匹配。通过继承可以定义一些类型，可以模拟不同种类，而通过动态绑定可以编写程序，使用这些类而又忽略与具体类型相关的差异。<br>
继承和动态绑定在概念上非常简单，但对于如何创建应用程序以及对于程序设计语言必须支持的特性，含义深远。<br>
面向对象编程的关键思想是多态性，因为在许多情况下可以互换地使用派生类型或基类型的许多形态，所以称通过继承而相关联的类型为多态类型。<br>
c++中，多态性仅用于通过继承而相关联的类型的引用或指针，我们称因继承而相关的类构成了一个继承层次，其中一个类称为根，所有其他类直接或间接地继承根类。</p>
<h1 id="虚函数"><a class="markdownIt-Anchor" href="#虚函数"></a> 虚函数</h1>
<p>c++提供一种相对于重载更灵活的多态机制：虚函数<br>
虚函数允许函数调用与函数体匹配在运行时才确定，提供的是一种动态绑定的机制。<br>
通过虚函数机制，将基类的成员声明为虚函数形式，就可以通过基类指针或引用来访问派生类中的同名成员函数的目的。<br>
提供虚函数的机制可以提升程序的复用性，基类使用虚函数提供一个接口，但派生类可以定义自己的实现版本。虚函数调用的解释依赖于它的对象类型，这就实现了一个接口而多种语义的概念，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Base
&#123;
public:
    virtual void print()&#123;cout&lt;&lt;&quot;打印基类&quot;;&#125;
&#125;;
class Derived:public Base
&#123;
public:
    virtual void print()&#123;cout&lt;&lt;&quot;打印派生类&quot;;&#125;
&#125;;
void p(Base &amp;b)&#123;b.print();&#125;                       &#x2F;&#x2F;注意这里必须要传引用或指针，如果传值话就是用Derived赋值一个Base对象
int main()                                        &#x2F;&#x2F;此时会发生切割，Derived类的虚函数根本不会被拷贝到Base对象中
&#123;
    int choice;Base base,*bp;Derived derived;
    cin&gt;&gt;choice;                                  &#x2F;&#x2F;此时choice的值依赖于运行时的标准输入
    if(choice!&#x3D;0)bp&#x3D;&amp;derived;                     &#x2F;&#x2F;p的初始化又依赖于choice的值
    else(bp&#x3D;&amp;base);                               &#x2F;&#x2F;因此，只有运行时才能确定指针是指向基类对象还是派生类对象
    p(*bp);                                       &#x2F;&#x2F;从而达到同样的调用方式却可以得到不同的结果
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意传值是无法实现多态的，只有指针或引用才能实现多态的效果，对于这点网上很多资料解释都不太详细，个人理解是这样的：</p>
<ul>
<li>首先是指针和引用类型只要求基地址和偏移量信息，不关心实际对象类型的含义，相当于把指向的内存解释成指针或引用的类型就行了。因此这这种情况下直接访问到派生类原本的vfptr所存储的vftable即可实现多态</li>
<li>而对于一个实际的对象来说，是要明确其类型的，把一个派生类对象转换为基类对象，那么这个对象就应该是基类的，所以vfptr中应该存储的是基类的vftable，访问的虚函数也就是基类的版本
<ul>
<li>对于不同类型的赋值来说，涉及到类型转换和基类构造函数的初始化，而vfptr正是在构造函数初始化时自动初始化的一个常量</li>
</ul>
</li>
</ul>
<h2 id="虚函数的声明"><a class="markdownIt-Anchor" href="#虚函数的声明"></a> 虚函数的声明</h2>
<p>在基类中使用virtual关键字声明的成员函数即为虚函数，虚函数可以在一个或多个派生类中被重新定义，但要求在重定义时虚函数的原型(返回值类型，函数名，参数列表)必须完全相同(更准确地说这叫重写)<br>
基类中函数具有虚特性的条件：</p>
<ul>
<li>在基类中用virtual声明</li>
<li>在公有派生类中原型一致地重载该虚函数</li>
<li>定义基类引用或指针，使其引用或指向派生类对象，当通过该引用或指针调用虚函数时，该函数将体现出虚特性来</li>
</ul>
<p>在c++中，基类必须指出需要派生类重定义哪些函数，定义为virtual的函数是基类希望派生类重新定义的，基类希望派生类继承的函数不能定义为虚函数。在派生类中重载虚函数时必须与基类中函数原型完全相同，否则该函数将丢失虚特性。</p>
<ul>
<li>在语法上来说派生类不重写基类虚函数是可以的，不过这样派生类的vfptr将指向基类(上一层)的vftable</li>
<li>如果返回类型不同则编译报错，如果原型不同仅仅函数名相同则编译器认为这只是一般的函数重载，虚特性丢失</li>
</ul>
<h2 id="虚函数的实现机制"><a class="markdownIt-Anchor" href="#虚函数的实现机制"></a> 虚函数的实现机制</h2>
<h3 id="虚函数表和虚函数表指针"><a class="markdownIt-Anchor" href="#虚函数表和虚函数表指针"></a> 虚函数表和虚函数表指针</h3>
<p>在<strong>编译</strong>时，为每个具有虚函数的<strong>类</strong>建立一张虚函数表vftable，表中存放的是这个类中所有虚函数的指针，同时用一个虚函数表指针vfptr指向这个表的入口。<br>
对象的内存空间除了保存数据成员外还保存了<strong>vfptr</strong>，<strong>vfptr由构造函数来初始化</strong>，是一个<strong>常量</strong>。当访问某个虚函数时，不是直接找到那个函数的地址，而是通过vfptr间接查到它的地址。因此，当基类指针指向派生类对象时，此时对象保存的vfptr(vfptr是基类和派生类都有的)指向的还是派生类的vftable。<br>
注意：vfptr不是只有一个，而是看继承了几个基类，一般有几个就有几个vfptr(将该派生类新定义的虚函数加入到其中一个vfptr对应的vftable中)</p>
<p>vftable和对象是相关的，本质是通过this指针找到对象保存的vfptr指针再找到vftable最后找到里面存储的虚函数在代码区的地址，因此虚函数必须是类的非静态成员函数，即虚函数不可能是全局函数、静态成员函数、全局友元函数(类中声明另一个类的虚函数为其自身的友元函数是可行的)，主要原因在于通过非静态成员函数隐含传递的this指针才能找到vfptr指针。</p>
<p>需要注意的是，不同平台、不同编译器厂商所生成的vfptr在内存中的布局是不同的，有些将vfptr置于对象内存中的开头处，有些则置于结尾处，这一点并非c++标准所要求的，而是编译器所采用的“内部方式”。至于vftable也是一样，大部分是存储在rodata段，也有的是存储在内存映射的可执行文件中，位于堆栈之间的共享库中。</p>
<img src="https://s2.loli.net/2022/05/08/gPrJTn6FK2asVHt.png" width="50%" height="50%">
<p>基于这些不确定的行为，因此最好永远不要做任何相关的内存假设，也不要使用memcpy()之类的函数复制对象，而应该使用初始化或赋值的方式来复制对象。</p>
<h3 id="在成员函数中调用虚函数"><a class="markdownIt-Anchor" href="#在成员函数中调用虚函数"></a> 在成员函数中调用虚函数</h3>
<p>在基类或派生类的成员函数中，可以直接调用类等级中的虚函数，此时根据的是this指针中指向的对象来判断调用的是哪个函数。<br>
构造函数不能定义为虚函数，因为vptr需要在构造函数中进行初始化，但析构函数可以定义为虚函数，并且通常情况下这样可以在<strong>运行时</strong>决定基类和派生类的析构层次</p>
<ul>
<li>比如delete释放<strong>基类指针所指向的派生类对象</strong>时，就可以调用派生类析构函数，而派生类的析构函数中默认合成了基类的析构函数，因此可以达到先调用基类的析构函数，再调用派生类的析构函数的目的
<ul>
<li>如果不定义虚析构函数，那么直接释放基类指针则直接调用的是基类的析构函数，则派生类对象无法释放内存</li>
</ul>
</li>
<li>不过事实上，只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，编译器都自动将其声明为虚析构函数</li>
<li>一般来说，一个类如果定义了虚函数，则最好将析构函数也定义成虚函数，因为虚函数基本上意味着程序会利用基类指针引用指向派生类对象以实现多态性</li>
</ul>
<p>例：虚析构函数和非虚析构函数的区别</p>
<pre class="line-numbers language-none"><code class="language-none">class Base1&#123;public:virtual ~Base1()&#123;cout&lt;&lt;&quot;析构Base1类&quot;&lt;&lt;endl;&#125;&#125;;
class Base2&#123;public:~Base2()&#123;cout&lt;&lt;&quot;析构Base2类&quot;&lt;&lt;endl;&#125;&#125;;
class Derived1:public Base1&#123;public:virtual ~Derived1()&#123;cout&lt;&lt;&quot;析构Derived1类&quot;&lt;&lt;endl;&#125;&#125;;
class Derived2:public Base2&#123;public:~Derived2()&#123;cout&lt;&lt;&quot;析构Derived2类&quot;&lt;&lt;endl;&#125;&#125;;
int main()&#123;
    Base1 *base1&#x3D;new Derived1();
    Base2 *base2&#x3D;new Derived2();
    delete base1;delete base2;
&#125;    &#x2F;&#x2F;输出结果：析构Derived1类 析构Base1类 析构Base2类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虚函数示例程序：书店卖书分平价和打折两种，使用相同的接口实现不同的操作</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class Bookbase
&#123;
    string bookname;
protected:
    float price;
public:
    Bookbase(string bn,float p):bookname(bn),price(p)&#123;&#125;
    virtual float net_price(int n)&#123;return n*price;&#125;
&#125;;
class Bulkitem:public Bookbase
&#123;
    int minbulk;
    float discount;
public:
    Bulkitem(string bn&#x3D;&quot;&quot;,float p&#x3D;0,int mb&#x3D;0,float dc&#x3D;0):Bookbase(bn,p),minbulk(mb),discount(dc)&#123;&#125;
    virtual float net_price(int n)&#123;if(n&gt;&#x3D;minbulk)return(1-discount)*n*price;return n*price;&#125;
&#125;;
float totalprice(Bookbase &amp;book,int n)
&#123;
    return book.net_price(n);
&#125;
int main()
&#123;
    Bookbase bookbase(&quot;我爱c++&quot;,10000);
    Bulkitem bulkitem(&quot;我爱c++&quot;,10000,10,0.01);
    cout&lt;&lt;totalprice(bookbase,15)&lt;&lt;endl;
    cout&lt;&lt;totalprice(bulkitem,15)&lt;&lt;endl;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="虚函数表与继承的关系"><a class="markdownIt-Anchor" href="#虚函数表与继承的关系"></a> 虚函数表与继承的关系</h3>
<ul>
<li>基类和派生类的vftable不是同一个，每个类有属于自己的vftable</li>
<li>如果是单继承，派生类中仅含有一个vftable，该vftable从唯一基类处拷贝，然后改写该vftable</li>
<li>多重继承的原则就是派生类只需要关心它上一级基类的虚函数表模型，然后一层层推导</li>
<li>派生类的vftable中的数据(也就是函数地址)拷贝于基类的vftable(多继承则向每个基类都拷贝一个)，如果派生类中重写了基类虚函数，那么该派生类的vftable中对应的基类虚函数地址会更改为派生类重写后的函数地址，也就是派生类的函数地址
<ul>
<li>派生类的vftable最终应包含基类中虚函数(重写的和未重写的)以及和新定义的虚函数</li>
<li>如果是多继承则要么将新定义的虚函数插入到其中一个基类的vftable的后面(一般是第一个)，要么新增一个vftable，看编译器具体实现</li>
<li>每定义一个新的虚函数，则在继承链的vftable中就会新增一个表项，所以随着继承层数增加vftable的数量和复杂度会越来越高</li>
</ul>
</li>
<li>当多继承中多个基类具有相同名字的虚函数时，派生类将一次性重写所有的同名虚函数
<ul>
<li>如果想要对不同基类的同名虚函数进行不同改写的话，可以靠增加代理实现(增加中间一层继承)</li>
</ul>
</li>
</ul>
<h1 id="纯虚函数-抽象类-接口类"><a class="markdownIt-Anchor" href="#纯虚函数-抽象类-接口类"></a> 纯虚函数、抽象类、接口类</h1>
<p>有的时候，基类是无法给出具体的功能实现的，或者尽管可以实现基类但生成的对象也是无意义的<br>
存在这样一种基类和派生类的关系：</p>
<blockquote>
<p>基类表示抽象的概念，提供一些公共的接口，表示这类对象所拥有的共同操作，而派生类体现这些接口的实现过程</p>
</blockquote>
<p>基类中这些公共接口只需要有声明而不需要具体实现，即纯虚函数，纯虚函数刻画了派生类应该遵循的协议，这些协议的具体实现由派生类来决定<br>
纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数，基本格式为：</p>
<blockquote>
<p>virtual 虚函数类型 函数名(参数列表)=0;</p>
</blockquote>
<p>当把一个函数声明为纯虚函数以后，就要求任何派生类都定义自己的实现</p>
<pre class="line-numbers language-none"><code class="language-none">class Shape                               &#x2F;&#x2F;接口类
&#123;
    virtual float perimeter()&#x3D;0;          &#x2F;&#x2F;最后的&#x3D;0并不表示函数返回值为0，它只起形式上的作用
    virtual float area()&#x3D;0;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要拥有纯虚函数的类，称其为抽象类，抽象类不能被实例化，只能作为基类被使用，抽象类的派生类需要实现纯虚函数，否则该派生类也是一个抽象类。<br>
所有成员函数都是纯虚函数的抽象类，称其为接口类，表示类本身没有实体，只是告诉使用者这个类提供了哪些功能，以及函数原型，通过提供接口类，使用者可以通过接口类的纯虚函数调用派生类的具体实现，同时使用时看不到派生类的具体实现，从而达到派生类功能独立的目的，只要接口不变，调用者无需修改调用函数，即依赖倒置原则(依赖于接口而不依赖于实现)</p>
<ul>
<li>实际上c++的定义中是没有接口类这个概念的，不过满足以上的条件的抽象类可以实现与其他语言中的接口相同的功能</li>
<li>因为所有成员函数都是虚函数，所以没有构造函数(反正也不需要生成对象)，也不需要析构函数</li>
<li>接口类可以声明静态常量作为接口的返回值状态</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符重载</title>
    <url>/posts/4b50c37306d0</url>
    <content><![CDATA[<h1 id="运算符重载"><a class="markdownIt-Anchor" href="#运算符重载"></a> 运算符重载</h1>
<p>使用c++编写程序时，不仅要使用基本数据类型，还要设计新的数据类型-&gt;<strong>类</strong></p>
<p>一般情况下，基本数据类型的运算都是用运算符来表达，语义简单并且直观，如：</p>
<blockquote>
<p>int a,b,c;a=b+c;</p>
</blockquote>
<p>对于基本数据类型运算的汇编语言实现，其中就隐含着运算符重载的概念，如：</p>
<blockquote>
<p>int a,b,c;c=a+b;float a,b,c;c=a+b;</p>
</blockquote>
<blockquote>
<p>整型加法的汇编代码为：<br>
mov eax,dword ptr[ebp-4]<br>
add eax,dword ptr[ebp-8]<br>
mov dword ptr[ebp-0Ch],eax</p>
</blockquote>
<blockquote>
<p>实数型加法的汇编代码为：<br>
fld eax,dword ptr[ebp-4]<br>
fadd eax,dword ptr[ebp-8]<br>
fstp dword ptr[ebp-0Ch],eax</p>
</blockquote>
<p>虽然都是+，整型和实数型的基本操作指令是不同的，但是对于高级程序语言使用者而言则完全感受不到<br>
这是因为通过对运算符的重载，在底层实现了相关运算的具体操作</p>
<p>如果将运算符直接作用于类对象，编译器将无法识别运算符的语义，因为对类对象的运算并没有提前实现，如：</p>
<blockquote>
<p>Complex ret,c1,c2;ret=c1+c2; 编译错误</p>
</blockquote>
<p>因此，需要一种机制重新定义运算符作用在类类型上的含义，即运算符重载，让需要的运算符在自定义类型上按要求进行操作</p>
<span id="more"></span>
<p>运算符重载的实质是<strong>函数重载</strong>，即实现过程中把指定的运算表达式转化为对运算符函数的调用，运算对象转化为运算符函数的实参，然后根据实参的类型匹配函数<br>
因此，可以在类中使用成员函数的形式来定义运算符成员函数，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Complex
&#123;
    double re,im;
public:
    Complex(double r&#x3D;0.0,double i&#x3D;0.0):re(r),im(i)&#123;&#125;
    Complex add(Complex c)&#123;return Complex(re+c.re,im+c.im);&#125;          &#x2F;&#x2F;通过定义成员函数的方法实现加法操作，但这种方法不够直观
    Complex operator+ (Complex c)&#123;re+&#x3D;c.re,im+&#x3D;c.im;return *this;&#125;    &#x2F;&#x2F;使用operator关键字重载Complex类的+运算符为成员函数形式
&#125;;                                                                    &#x2F;&#x2F;函数体实现方法与成员函数相同
int main()
&#123;
    Complex complex1(1,2),complex2(3,4),temp1,temp2;
    temp1&#x3D;complex1.add(complex2),temp2&#x3D;(complex1+complex2);           &#x2F;&#x2F;运算符+的隐式调用
    cout&lt;&lt;temp1.re&lt;&lt;&#39;+&#39;&lt;&lt;temp1.im&lt;&lt;&#39;i&#39;&lt;&lt;&#39; &#39;;                          &#x2F;&#x2F;temp2等效于显式调用形式complex1.operator+(complex2)
    cout&lt;&lt;temp2.re&lt;&lt;&#39;+&#39;&lt;&lt;temp2.im&lt;&lt;&#39;i&#39;&lt;&lt;endl;                         &#x2F;&#x2F;输出结果：4+6i 4+6i
&#125;                                                  &#x2F;&#x2F;采用运算符重载的方式更加直观，并且可以达到与基本数据类型的运算形式一样的效果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用成员函数的情况下必须先单独构造一个类对象，再调用运算符成员函数进行运算，即第一个操作数必须是已定义运算符的类对象或类对象的引用(可以理解为这个对象作为运算符函数的调用者)<br>
(此外，对象调用成员函数运算符实际上相当于默认将this绑定到操作数)</p>
<p>同时也可以考虑定义为友元函数的形式，从而可以将所有操作数直接作为参数进行运算，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Complex
&#123;
public:
    double re,im;
    Complex(double r&#x3D;0.0,double i&#x3D;0.0):re(r),im(i)&#123;&#125;
    Complex add(Complex c)&#123;return Complex(re+c.re,im+c.im);&#125;
    friend Complex operator+(Complex a,Complex b)&#123;return Complex(a.re+b.re,a.im+b.im);&#125; &#x2F;&#x2F;重载Complex类的+运算符为友元函数形式
&#125;;
int main()
&#123;
    Complex complex(5,6);
    cout&lt;&lt;(1+complex).re&lt;&lt;&#39;+&#39;&lt;&lt;(1+complex).im&lt;&lt;&#39;i&#39;&lt;&lt;endl;        &#x2F;&#x2F;编译器在见到操作数为complex后认为此处的+是友元运算符重载函数
&#125;                                                                &#x2F;&#x2F;因此在将1作为参数传递时隐式地将1强制类型换为(Complex)1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从此例可以看出，友元函数是将算术表达式中的操作数按顺序传给参数的</p>
<h2 id="友元函数和成员函数的抉择"><a class="markdownIt-Anchor" href="#友元函数和成员函数的抉择"></a> 友元函数和成员函数的抉择</h2>
<p>多数情况下，类的运算符可以重载为类的成员函数，也可以重载为友元函数，但一般说来：</p>
<ul>
<li>单目运算符最好被重载为成员函数</li>
<li>双目运算符最好被重载为友元函数，双目运算符重载为友元函数比重载为成员函数更方便，但也存在些例外
<ul>
<li>有的双目运算符不能重载为类的友元函数：= () [] -&gt; 这是c++语言标准的特殊规定
<ul>
<li>主要因为这几个运算符c++都定义了默认的成员函数，对编译器来说每当一个对象后面出现这些运算符时会默认调用这些默认或重载的成员函数运算符</li>
<li>而友元函数的运算符的行为是与成员函数的不同的(很重要的一点是没有this指针)
<ul>
<li>想象一下如果允许这种重载，那么类似于1=obj,4.5(obj),5[obj]等等在编译上都是可行的(如定义:friend void operator=(int,OBJ))</li>
<li>很明显这会导致程序极其混乱，因此c++在语法层面直接杜绝这种情况</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>类型转换函数(圆括号)只能定义为类的成员函数，不能定义为类的友元函数(实际上就是圆括号运算符的行为都是默认的)</li>
<li>如果一个运算的操作需要修改对象的状态，则重载为成员函数较好
<ul>
<li>因为成员函数自带this指针</li>
</ul>
</li>
<li>如果运算符所需要的操作数(尤其是第一个操作数)希望有隐式类型转换，或者其必须是一个不同类的对象或者基本数据类型，则只能选择友元函数
<ul>
<li>成员函数是无法对调用对象转换类型的</li>
</ul>
</li>
<li>当需要重载的运算符具有交换性时，一般重载为友元函数
<ul>
<li>因为友元函数的参数之间是等价的，随便哪个在前在后都行(只要符合定义的行为)，满足交换律</li>
</ul>
</li>
<li>对于单目运算符++，--来说前缀式和后缀式是不一样的，一般编译器默认在重载++，--时可以向运算符函数传入一个int占位参数以做区分
<ul>
<li>此时在调用自增自减的运算符函数时使用前缀式(++a,--a)调用的是不带参数的运算符函数，使用后缀式(a++,a--)调用的是带占位参数的运算符函数</li>
<li>用int做占位符的原因，个人猜测是因为在算术表达式中++\--作为单目运算符只跟一个操作数结合，如果++\--跟a结合后又跟着一个操作数，说明这是后缀的情况，因此再额外接收一个变量并且不需要其参与运算符的定义</li>
</ul>
</li>
</ul>
<p>最后，其实之所以定义为友元函数对访问对象私有成员的需求，如果重载的运算符不需要访问私有成员的话，那么定义为普通的函数也是一样的。</p>
<p>运算符重载示例程序1：实现计数器(Counter)类的自增，自减，取值，输出输入计数的运算</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
class Counter
&#123;
    int count;
public:
    Counter(int c):count(c)&#123;&#125;
    Counter operator++()                      &#x2F;&#x2F;也可以重载为友元函数friend Counter operator++(Counter &amp;c);
    &#123;                                         &#x2F;&#x2F; Counter operator++(Counter &amp;c)&#123;c.count++;return c;&#125;
        count++;                                               
        return *this;                         &#x2F;&#x2F;重载为友元函数时需注意应使用引用传参，不然无法对操作对象的值进行修改
    &#125;                                         &#x2F;&#x2F;另外其实返回引用的话效率更高
    Counter operator++(int)                  
    &#123;
        Counter temp&#x3D;*this;
        this-&gt;count++;
        return temp;                          &#x2F;&#x2F;注意后置的++关键点在于必须用一个新的对象存储自增前的状态
    &#125;
    Counter operator--()
    &#123;
        count--;
        return *this;   
    &#125;
    Counter operator--(int)
    &#123;
        Counter temp&#x3D;*this;
        this-&gt;count--;
        return temp;
    &#125;
    int operator()()
    &#123;
        return count;
    &#125;
    friend ostream &amp;operator&lt;&lt;(ostream &amp;ocounter,Counter c)    &#x2F;&#x2F;重载operator&lt;&lt;(或&gt;&gt;)必须使用引用作为返回类型
    &#123;                                                          &#x2F;&#x2F;因为系统默认的&lt;&lt;和&gt;&gt;的构造函数是全局保护成员，是不可以创建局部变量的
        ocounter&lt;&lt;c.count;                                     &#x2F;&#x2F;同理ocounter也必须使用引用，因为无法创建临时ocounter对象
        return ocounter;
    &#125;
    friend istream &amp;operator&gt;&gt;(istream &amp;icounter,Counter &amp;c)   &#x2F;&#x2F;重载operator&gt;&gt;时还要注意Counter对象也要传引用
    &#123;                                                          &#x2F;&#x2F;不然输入的值是无法修改Counter对象的
        icounter&gt;&gt;c.count;
        return icounter;
    &#125;
&#125;;
int main()
&#123;
    Counter counter(0);
    int v&#x3D;counter();
    cin&gt;&gt;counter;
    cout&lt;&lt;v&lt;&lt;endl;
    cout&lt;&lt;++counter&lt;&lt;&#39; &#39;&lt;&lt;counter&lt;&lt;&#39; &#39;&lt;&lt;--counter&lt;&lt;&#39; &#39;&lt;&lt;counter&lt;&lt;endl;
    cout&lt;&lt;counter++&lt;&lt;&#39; &#39;&lt;&lt;counter&lt;&lt;&#39; &#39;&lt;&lt;counter--&lt;&lt;&#39; &#39;&lt;&lt;counter;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于赋值运算符而言，如果没有为类重载赋值运算符，那么编译器会生成一个缺省的赋值运算符函数，其作用是通过位拷贝方式将源对象复制到目的对象，在这一点上，赋值运算符和拷贝构造函数的情况非常类似，相同之处在于都是将一个对象的数据成员复制到另一个对象中，不同点在于拷贝构造函数是在初始化一个新对象，而赋值运算符是在为这个已经创建的对象进行修改<br>
编译器的缺省赋值运算符重载函数同样存在一些缺陷，当类持有一些特殊资源时，如：</p>
<ul>
<li>动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就很难处理
<ul>
<li>此时如果使用默认赋值运算符的话对象的值会被直接修改而原来的地址空间不一定被释放，会出现很多未知的问题(说白了就是默认的没有那么多幺蛾子，不会搞这些额外操作)</li>
</ul>
</li>
</ul>
<p>运算符重载示例程序2：重载赋值运算符使赋值的同时释放掉原本的内存空间</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
class Cstring
&#123;
private:
    int size;
    char *str;
public:
    Cstring(int len)
    &#123;
        str&#x3D;new char[size];
    &#125;
    Cstring(Cstring &amp;cstring):size(cstring.size)
    &#123;
        str&#x3D;new char[size];
        strcpy(str,cstring.str);
    &#125;
    Cstring operator&#x3D;(Cstring cs);
    ~Cstring();
&#125;;
Cstring Cstring::operator&#x3D;(Cstring cs)
&#123;
    if(this&#x3D;&#x3D;&amp;cs)return *this;
    delete[]str;                             &#x2F;&#x2F;释放原本动态分配的空间
    size&#x3D;cs.size;
    str&#x3D;new char[size];
    strcpy(str,cs.str);                      &#x2F;&#x2F;这里相当于重新构造了一个Cstring对象
    return *this;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="重载运算符遵循的规则"><a class="markdownIt-Anchor" href="#重载运算符遵循的规则"></a> 重载运算符遵循的规则</h2>
<ul>
<li>大多数预定义的操作符可以被重载，重载后的<strong>优先级</strong>，<strong>结合性</strong>，及<strong>所需操作数数目</strong>都不变</li>
<li>少数几个c++运算符不可以重载，如：作用域符::，预处理符#，三目运算符?:，访问成员符.，指针或取值运算符 *，等等</li>
<li>不能重载非运算符的符号，如：分号;</li>
<li>c++不允许重载不存在的运算符(无法自创运算符)，如：$，**等</li>
<li>当运算符被重载时，是被绑定在一个特定的类之上的，当此运算符不作用在特定类型上时将保持原有含义</li>
<li>应当尽可能保持重载运算符原来的语义，比如某个程序中用+表示减，用*表示/，程序可读性会非常的差</li>
</ul>
<h2 id="特殊运算符的重载"><a class="markdownIt-Anchor" href="#特殊运算符的重载"></a> 特殊运算符的重载</h2>
<h3 id="的重载"><a class="markdownIt-Anchor" href="#的重载"></a> []的重载</h3>
<p>该重载函数在类中的声明格式如下：</p>
<blockquote>
<p>返回值类型&amp;operator<a href="%E5%8F%82%E6%95%B0"></a>;</p>
</blockquote>
<p>或者可以声明为常成员</p>
<blockquote>
<p>const 返回值类型 &amp; operator[] (参数) const;</p>
</blockquote>
<ul>
<li>使用第一种声明方式，[]不仅可以访问元素，还可以修改元素。</li>
<li>使用第二种声明方式，[]只能访问而不能修改元素。</li>
</ul>
<p>在实际开发中应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何元素。</p>
<p>例：实现变长的数组Array类，重载成员访问符[]</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
class Array&#123;
public:
    Array(int length &#x3D; 0);
    ~Array();
public:
    int &amp; operator[](int i);
    const int &amp; operator[](int i) const;
public:
    int length() const &#123; return m_length; &#125;
    void display() const;
private:
    int m_length;  &#x2F;&#x2F;数组长度
    int *m_p;  &#x2F;&#x2F;指向数组内存的指针
&#125;;
Array::Array(int length): m_length(length)&#123;
    if(length &#x3D;&#x3D; 0)&#123;
        m_p &#x3D; NULL;
    &#125;else&#123;
        m_p &#x3D; new int[length];
    &#125;
&#125;
int &amp;  Array::operator[](int i)&#123;
    return m_p[i];
&#125;
const int &amp; Array::operator[](int i) const&#123;
    return m_p[i];
&#125;
Array::~Array()&#123;
    if(m_p)delete[] m_p;
    delete this;
&#125;
void Array::display() const&#123;
    for(int i &#x3D; 0; i &lt; m_length; i++)&#123;
        if(i &#x3D;&#x3D; m_length - 1)&#123;
            cout&lt;&lt;m_p[i]&lt;&lt;endl;
        &#125;else&#123;
            cout&lt;&lt;m_p[i]&lt;&lt;&quot;, &quot;;
        &#125;
    &#125;
&#125;
int main()&#123;
    int n;
    cin&gt;&gt;n;
    Array A(n);
    for(int i &#x3D; 0, len &#x3D; A.length(); i &lt; len; i++)&#123;
        A[i] &#x3D; i * 5;
    &#125;
    A.display();
    const Array B(n);
    cout&lt;&lt;B[n-1]&lt;&lt;endl;  &#x2F;&#x2F;访问最后一个元素   
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="的重载-2"><a class="markdownIt-Anchor" href="#的重载-2"></a> ()的重载</h3>
<p>在c++中，<strong>类型的名字</strong>(包括类的名字)本身也是一种运算符，即类型强制转换运算符。</p>
<p>例：重载Complex类的(double)运算符，返回Complex的实部</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
    double real, imag;
public:
    Complex(double r &#x3D; 0, double i &#x3D; 0) :real(r), imag(i) &#123;&#125;;
    operator double() &#123; return real; &#125;  &#x2F;&#x2F;重载强制类型转换运算符 double
&#125;;
int main()
&#123;
    Complex c(1.2, 3.4);
    cout &lt;&lt; (double)c &lt;&lt; endl;  &#x2F;&#x2F;输出 1.2
    double n &#x3D; 2 + c;  &#x2F;&#x2F;根据类型提升规则将表达式中所有运算符转为double，因此调用c的类型转换符operator.double()
    cout &lt;&lt; n;  &#x2F;&#x2F;输出 3.2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="newdelete的重载"><a class="markdownIt-Anchor" href="#newdelete的重载"></a> new/delete的重载</h3>
<p>new、new[]、delete、delete[]虽然也都是系统定义的运算符，但均可以重载，并且既可以重载为友元函数也可以重载为成员函数。<br>
需要注意的是在重载new或new[]时，无论是作为成员函数还是作为友元函数，它的第一个参数必须是size_t(unsigned或unsigned long，具体看实现)类型，返回类型为void*。size_t表示的是要分配空间的大小，对于new[]的重载函数而言，size_t则表示所需要分配的所有空间的总和。重载new函数也可以有其他参数，但都必须有默认值，并且第一个参数的类型必须是size_t。(因为重载运算符必须与c++中该运算符原本的用法相同)</p>
<pre class="line-numbers language-none"><code class="language-none">void*operator new(unsigned long length)&#123;
    Array*newa&#x3D;(Array*)malloc(sizeof(Array));
    newa-&gt;m_length&#x3D;length;
    newa-&gt;m_p&#x3D;(int*)malloc(length*sizeof(int));
    return newa;
&#125;
void*operator new[](unsigned long length)&#123;
    Array*news&#x3D;(Array*)malloc(length*sizeof(Array*));
    return news;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>delete和delete[]的返回值都是void类型，并且都必须有一个void*作为参数，该指针指向需要释放的内存空间。</p>
<pre class="line-numbers language-none"><code class="language-none">void operator delete(void*ptr)&#123;
    free(((Array*)ptr)-&gt;m_p);
    free(ptr);
&#125;
void operator delete[](void*ptr)&#123;
    Array*p&#x3D;(Array*)ptr;
    while(p-&gt;m_length--)delete p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>继续</title>
    <url>/posts/7817132f8a29</url>
    <content><![CDATA[<p><em><strong>人生最清晰的脚印，往往印在最泥泞的路上。</strong></em></p>
<p><em><strong>如果你想拥有从未有过的东西，那你必须去做从未做过的事情。</strong></em></p>
<p><em><strong>去做你想做的事情，趁阳光正好，趁现在还年轻！你今日撒下的种子，会在你看不见想不到的某日，悄悄地生根发芽。</strong></em></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】大佬事迹</title>
    <url>/posts/dabc69d6aedc</url>
    <content><![CDATA[<p>绝大多数的互联网企业，要么是源起于技术咖的一个想法，要么是由技术过硬的人掌舵。<br>
这些人的创业或是成名之路其实相差甚远，但几乎所有人都有一个共同点，就是在初入编程世界时，都给自己定过“至少做十年程序员”、“只想对着电脑写代码”、“至少写十多万行代码”之类的“小目标”。虽然初心的保质期往往不长，但如果连初心都没有，后面的故事自然也不会发生。<br>
网易丁磊，创办网易时的50万元资金是他写了几年代码积攒下来的。成立网易云之后，丁磊还曾梦想在云计算上投入十亿人民币，解放全国千千万万的程序员。<br>
搜狗王小川，在清华读书时，排队看医生还要捧着计算机的书，在搜狗可以花几年时间一级一级组建产品，能让他感到兴奋的事是“有些问题没人能解决，你找到方法解决了”。<br>
京东刘强东，大学主修社会专业，课余时间却自学编程，还用 ASP 写出了第一版的京东。<br>
新浪创始人王志东，自称是“很纯粹的软件工程师”，说程序员的目标就是要实现一个很好很实用的产品。曾创立过四通利方、新浪、点击科技。<br>
“成为一个合格的程序员，怎么也要写个10万到15万行以上的代码，如果连这个量级的代码都没有达到，那说明你还不会写程序” ——周鸿祎<br>
<strong>求伯君——“中国第一程序员”</strong><br>
雷军的伯乐，求伯君，被称为“中国第一程序员”，没有之一。<br>
说第一，有时间的原因。1983年，我国第一台每秒运算1亿以上的巨型计算机“银河”在国防科大投入使用。近水楼台先得月，正在国防科大数学系读书的求伯君，担下了学校的图书管理系统软件开发的任务，4天就开发测试成功。<br>
当然，第一程序员的实力和勤奋更不容小觑。1988年，求伯君加入金山，原因之一是金山承诺他可以“专心搞软件”。当时求伯君计划要写一个汉字处理系统，最后花了1年零4个月，在医院敲完了 WPS1.0的代码，共计12万2千行。<br>
21世纪初，WPS历经几次波折，从微软手中抢回自己的市场。但就在2002年，求伯君又把WPS所有的代码都推倒重写，直到2005年9月12日，求伯君才写完 WPS Office 最新的2005版本，“如果你想要扩大 WPS 这座大厦的空间，唯一能做的，就是推倒重来。”<br>
<strong>雷军——代码被说像诗一样优雅</strong><br>
“诗一样优雅的代码”是有市场认证的。雷军在武汉大学计算机系读大三的时候，就通过写程序，赚到100万。毕业之后被金山求伯君当接班人培养，32岁时，他与求伯君合著《深入 DOS 编程》一书出版发行。和所有优秀的程序员一样，雷军热爱编程。1996年，雷军交给老师的一篇命题作文《程序人生》中，他写道，“当我学了一点电脑知识后，就发现电脑将是我人生的最爱”、“我爱编程这个工作，可以肯定我会干上一辈子”。<br>
而雷军从程序员转向产品和管理，也有一个“迫不得已”的原因。在金山30周年是，雷军曾说，转型的一个重要原因是，之前有一个新来的程序员，把自己多年写下来的代码硬盘格式化了。<br>
至今，小米的一些发布会上，雷军还多次强调：“20年前我是程序员，如今我还是程序员。”<br>
<strong>李彦宏——为检索信息写代码</strong><br>
李彦宏中学就喜欢计算机编程，还参加过全国青少年程序编程大赛，得过奖，但是在省级比赛中没能拿到名次。这个经历让李彦宏觉得，全国计算机水平在他之上的人很多。一直到高考填志愿，他都没敢报计算机专业，而是去北大读了图书馆系。但渐渐他发现如果要做图书馆系统的开发，自己比不过计算机系的学生，于是开始自学计算机课程，直接去计算机系听操作系统、数据结构的课程。<br>
到美国读研究生时，因为有在北大积累的信息检索知识，李彦宏的研究方向定为信息检索。很快，他在美国电子工程学会会刊上发表论文“利用信息检索理论解决光学识别问题”，一般博士毕业论文也很难登上这本期刊。<br>
在工作中，李彦宏终于确定自己的优势：网络编程不行，但涉及到信息检索，少有能与之比肩者，“我不再折腾网络编程，反正有很多人写。我专注在信息检索。”<br>
1996年，李彦宏想到解决搜索引擎作弊问题的方法，“我想到了我在北大所学的科技论文索引，科学论文通过索引被引用次数的多寡来确定一篇论文的好坏，超链就是对页面的引用，作弊网页没价值，不可能被很多网站主动超链。”超链代表别人评价你，超链上的描述是别人如何评价你。1997年，李彦宏提交了关于“超链分析”的专利申请。“超链”技术现在被包括 Google 在内的几乎所有搜索引擎使用，是奠定现代搜索引擎发展趋势和方向的基础发明之一。<br>
又过两年，李彦宏带着自己的技术，回国开始做搜索引擎，之后便是百度的故事了。<br>
<strong>马化腾——曾抄代码培养感觉</strong><br>
马化腾是计软专业科班出身。他曾透露，自己学编程是“用最笨的方式去领悟”，即抄代码培养感觉。至于感觉培养得怎么样，有一个流传甚广但同样不知真假的故事：<br>
知乎上的一个问答贴“马化腾写代码的水平如何？”一个匿名回复如下：<br>
曾经和 pony 一起写过代码。当时5个人挤在一个只有四个位置的房间里，埋头开发，用 C++。我当时负责写一个通讯模块，有一个 bug 弄了两天，没有一点进展，下楼准备买点东西吃，消消愁。回来发现 pony 光着膀子，捧着瓶啤酒，站在阳台，望着寂静的夜，回头冷静地和我说了句：“帮你搞好了。”<br>
虽然没有确切材料能说明马化腾当年的代码水平，但他做码农时的勤奋是有迹可循的。2015年8月，网上首次曝光马化腾写过的代码，写作日期是在1999年2月21日、大年初六。<br>
他自己也曾说过，“20 岁的时候我是一个非常内向的程序员。我不喜欢管人，不喜欢接受采访，不喜欢与人打交道，独自坐在电脑旁是我最舒服的时候。”<br>
马化腾在大学毕业之后有过很长一段低头写代码的经历。<br>
1993年，马化腾从深圳大学毕业，进入当时的传呼机市场巨头润讯公司写软件。<br>
1998年腾讯成立，刚开始，为了支撑公司运营，马化腾除了写腾讯本身的业务代码，还接下许多外包项目。2018年在接受央视采访时，马化腾称，因为当时QQ还没起来，没有投资，所以他们做了大量的系统继承，包括帮其他网站做网页等。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>名人事迹</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链入门了解</title>
    <url>/posts/0ae8ab387974</url>
    <content><![CDATA[<p>因为不久后要组队参加区块链比赛，所以新开了这个系列用于记录一些区块链开放相关的知识</p>
<p>本系列是参考<a href="https://docs.microsoft.com/zh-cn/learn/paths/ethereum-blockchain-development/">Microsoft区块链开发入门</a>内容整理得来的</p>
<span id="more"></span>
<h1 id="什么是区块链"><a class="markdownIt-Anchor" href="#什么是区块链"></a> 什么是区块链？</h1>
<p>区块链是一种用于保留记录和执行合同的技术，通过使用加密来确保极难更改以前的历史记录，并且允许参与者通过跟踪共享账本的更改来共享工作流程。</p>
<h2 id="为什么不使用集中式数据库"><a class="markdownIt-Anchor" href="#为什么不使用集中式数据库"></a> 为什么不使用集中式数据库？</h2>
<p><img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/centralized-database.png" alt="集中式数据库"><br>
下面以一个冰淇淋案例的形式作为后续讨论的基础：<br>
假设你是解决方案架构师，供职于一家生产冰淇淋的乳制品加工公司。你通过供应链接收来自多个牛奶场的未加工牛奶，你的公司将包装好的冰淇淋运输至多个零售商。<br>
运输过程中温度不正确将导致产生食物质量和安全问题，而因为有多个公司负责运输和存储产品，因此很难识别供应链中出错的一方。<br>
因此，你需要创建一个系统，用于快速识别供应链中的问题。<br>
显然，我们可以建立一个集中式数据库，让所有参与者使用它来跟踪运输，实际在许多方案中，集中式数据库都是适当的解决方案。<br>
那么假设我们有一个集中式数据库，该数据库存储有关元素和当前责任方的详细信息。可以让农场主、承运方、工厂和零售商使用同一个集中式数据库。<br>
集中式数据库的优点是可以轻松控制访问权限和一致性，每一方都使用相同的数据库，并由受信任的机构控制访问权限，由于只有一个数据库，所有参与者都使用相同的数据集。<br>
所有参与者都需要相信数据库是准确的，引申一下，就是他们需要信任数据库的所有者不会出于任何目的修改历史数据。<br>
但是如果我们的方案不存在受信任的中央机构时该怎么办？如果没有一家公司愿意负责托管集中式数据库，该怎么办？此时就可能无法满足与每个参与者的系统集成要求。</p>
<h2 id="分布式数据库"><a class="markdownIt-Anchor" href="#分布式数据库"></a> 分布式数据库</h2>
<p><img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/distributed-database.png" alt="分布式数据库"><br>
如果每个参与者都有数据库的副本会怎样？分布式数据库使用数据库的多个副本并同步更改。在我们的方案中可以让农场主、承运方、工厂和零售商使用自己的分布式数据库。<br>
分布式数据库的优点是每个参与者都有数据库的副本，在自己的数据库副本中，通常能更轻松地控制访问权限以及集成系统和流程。<br>
但是需要同步每个数据库的更改，处理失败和冲突甚至可能会增加复杂性和数据诚信问题。</p>
<h3 id="分布式账本"><a class="markdownIt-Anchor" href="#分布式账本"></a> 分布式账本</h3>
<p><img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/distributed-ledger.png" alt="分布式账本"><br>
区块链技术称为分布式账本。与会计账本一样，分布式账本也是事务的历史记录。账本中的每个事务都会影响最终状态。<br>
分布在参与者之间的区块链网络称为联盟网络。通过联盟网络，每个合作伙伴都能查看网络中发生的每个事务。<br>
区块链使用共识规则确保不同节点之间数据的一致性。它还使用加密技术，让参与者能信任数据。<br>
具体而言，它会阻止任何一个参与者或少数参与者修改历史记录。区块链是分散的，因此最适合可以使用分散式数据库的解决方案。<br>
例如，由于成本、控制或成为单一故障点方面的原因，你需要在没有中央机构的情况下支持多个公司。</p>
<h1 id="区块链的工作原理"><a class="markdownIt-Anchor" href="#区块链的工作原理"></a> 区块链的工作原理</h1>
<p>这些信息可帮助确定区块链是否适合当前方案。</p>
<h2 id="数据是如何分布的"><a class="markdownIt-Anchor" href="#数据是如何分布的"></a> 数据是如何分布的？</h2>
<p>在冰淇淋方案中，假设有多家公司。<br>
首先在乳制品加工公司建立了一个集中式数据库，但所有参与者都不想成为中央机构，因此可以使用区块链分布式账本，使用区块链将不再需要中央机构。<br>
此外，拥有区块链节点的每个参与者都可获得账本副本，以便他们能够自行审核并与自己的系统集成，但并不要求每家公司都设置属于自己的分层节点，合作伙伴之间可以共享这些节点。<br>
每个节点都通过区块链网络连接到其他节点。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/peer-network.png" alt="数据分布"><br>
例如，Dalia Pelayo农场、冰淇淋工厂和冰淇淋店都各自管理着一个节点。Contoso West和Contoso East是同属一家母公司的两个独立合作伙伴，Contoso 有一个节点。<br>
节点与公司之间不必存在一对一关系。</p>
<h2 id="状态更改"><a class="markdownIt-Anchor" href="#状态更改"></a> 状态更改</h2>
<p>区块链中的数据表示状态，这就是为什么区块链非常适合使用加密货币之类的数字令牌。<br>
可以把这种情况想象为实际货币的所有权：一枚硬币一次只能在一个人的口袋。如果硬币在你的口袋，所有权就是你的。如果将硬币给朋友，状态就会变为你的朋友拥有这枚硬币。<br>
同理，在冰淇淋方案中，货物运输通过供应链，产品的责任方也随运输转移。我们想知道的数据包括责任方、温度以及产品是否合规。区块链使用数据库事务机制将数据的状态从一个值更改为另一个值。<br>
例如，如果我们需要知道冰淇淋是否在低于冰点的温度下存储。在运输冰淇淋的过程中，温度传感器会定期报告温度，报告温度是一个事务，会发送到区块链事务节点。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/transaction.png" alt="传感器将温度发送到区块链事务节点"><br>
在冰淇淋方案中，在货物运输通过供应链的过程中，每当状态发生更改时，都会发送一个事务。例如，下图展示了向冰淇淋工厂运送货物的典型事务，每个事务都更改了责任方或温度等信息。<br>
账本的当前状态是按顺序应用事务的状态。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/transaction-history.png" alt="事务在不停地生成并发送"><br>
发送事务时，会发送到区块链事务节点。假设Dalia Pelayo农场通过Contoso West Shipping运输牛奶。Dalia Pelayo农场的发货系统会向自己的区块链节点发送一个事务。<br>
该事务会将运输责任方从农场主更新为Contoso West Shipping。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/send-transaction.png" alt="责任方更新"><br>
在整个区块链网络中，一旦某个结点发送事务，其他节点都会获取事务的副本。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/copy-transaction.png" alt="每个结点均可获取事务副本"><br>
(注：个人感觉这里面的事务指的应该是类似日志一类的记录)</p>
<h2 id="如何确保账本数据的一致性"><a class="markdownIt-Anchor" href="#如何确保账本数据的一致性"></a> 如何确保账本数据的一致性？</h2>
<p>每个节点都会处理事务，但仍需要使用共识机制进行验证。共识机制实现了分布式账本的一致性和信任。<br>
在分布式网络中，很难确定什么是真实的，因为所有节点都可能存在数据更改。如果冰淇淋工厂节点没有收到运输事务，会发生什么情况？他们如何知道牛奶已从农场运出？如果运输公司的冷藏车出了故障，牛奶变质了怎么办?送货公司是否会通过修改账本来逃避责任？</p>
<p>区块链采用一种共识机制，可验证所有区块链节点上的数据并达成一致。共识提供一种方法，让所有分散管理的节点都达到相同的状态。<br>
在转移价值或责任时，事务的顺序很重要。例如，如果你将汽车的所有权转给朋友，就无法再将该项所有权转给同事。此类问题称为双重花费(double spend)，可通过共识机制解决。共识可确保事务的顺序正确以及区块链的诚信。<br>
<strong>共识的原理是，一组事务作为一个块进行验证，至于这个块是否应属于区块链，整个网络必须达成一致。</strong><br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/consensus.png" alt="共识机制"><br>
有几种区块链共识算法，包括工作证明、所有权证明和授权证明。每个算法都以不同的方式解决一致性问题。简而言之，共识提供了一种方法，让分布式账本能达成共同的状态。</p>
<h2 id="什么是块"><a class="markdownIt-Anchor" href="#什么是块"></a> 什么是块？</h2>
<p><strong>块是区块链中存储事务信息的数据群集，块中的事务数通常是基于时间的。</strong><br>
例如，下图显示的块包含了过去 10 分钟内发生的事务。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/block.png" alt="块的示例"><br>
经过共识后，已验证的块会添加到每个节点的区块链中。由于所有节点在该链中都具有相同的块，所以账本能在网络上保持一致。因此，所有节点都以一致的顺序包含相同的<strong>已验证数据</strong>。</p>
<h2 id="如何确保账本不可变"><a class="markdownIt-Anchor" href="#如何确保账本不可变"></a> 如何确保账本不可变？</h2>
<p>你可能会认为，如果能控制自己节点中的账本，就能更改副本中的数据，这些数据怎么会不可变呢？<br>
区块链使用加密哈希在块之间创建链接。将块链接在一起后，可以通过共识算法确定事务顺序的一致性。加密哈希可将任意大小的数据映射到固定大小的位表示形式，可以将其视为数字指纹。<br>
比特币使用SHA-256哈希算法。如果在100页的文档上使用SHA-256哈希函数，则函数输出是256位哈希值。<br>
如果只更改了文档中的一个字符并重新生成了哈希，则输出将是另一个256位哈希值。<br>
现在，假设我们将一个块用作哈希函数的输入，输出是块中数据的唯一哈希值。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/hash.png" alt="块通过SHA-256生成256位哈希值"><br>
区块链使用哈希来检测这些块有没有发生任何更改。通过在生成下一个块的哈希时包含上一个块的哈希值，这些块会通过哈希链接在一起。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/linked-hash.png" alt="每个块包含上个块的哈希值"><br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/linked-blocks.png" alt="每个块包含上个块的哈希值"><br>
区块链通过使用哈希来证明数据历史记录未更改，从而实现信任。通过在创建新块时包含上一个块的哈希，将按顺序创建不可变的事务链。<br>
如果修改链中的任何块，后一个块的哈希在验证时就会发现差异。</p>
<h2 id="受信任的逻辑"><a class="markdownIt-Anchor" href="#受信任的逻辑"></a> 受信任的逻辑</h2>
<p>通过区块链，我们可以存储一致且可信的数据。那么如何添加在每个节点一致执行的逻辑？<br>
在冰淇淋方案中，需要将产品的责任从一个参与者转到另一个参与者以及使用IoT温度传感器中的数据来了解温度是否过高。<br>
分散式应用程序(DApp)是分布式计算系统上的应用程序。Ethereum DApps称为智能合同，包含作为事务的一部分执行的逻辑(操作?)。在Ethereum上使用名为Solidity的编程语言对逻辑进行编程。<br>
智能合同部署到区块链，并按地址引用。要使用智能合同，需创建一个实例，智能合同实例包含状态数据和程序逻辑。<br>
在冰淇淋方案中，智能合同实例包含各种数据，例如负责的参与者、位置以及产品温度是否不合规等，可以执行函数来转移责任或接收实例的温度遥测数据。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/smart-contract.png" alt="智能合同实例"><br>
将产品的责任转到另一方时，会执行事务，智能合同逻辑会更新状态数据。<br>
冰淇淋方案中，冰淇淋工厂运输系统会为新的冰淇淋运输活动创建一个智能合同实例。工厂运输系统将发送一个事务，该事务调用TransferResponsibility函数以将运输责任方改为Contoso East shipping。区块链网络将该事务发送到所有节点，每个节点都会执行该智能合同逻辑。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/smart-contract-transaction.png" alt="工厂运输系统广播责任变更事务"><br>
而在运输过程中，如果制冷装置出现故障且冰淇淋温度升至冰点以上时，IoT温度传感器会监视冰淇淋温度并定期发送事务。如果温度高于冰点，智能合同逻辑会将这批货物标记为不合规。<br>
<img src="https://docs.microsoft.com/zh-cn/learn/modules/intro-to-blockchain/media/iot-transaction.png" alt="温度传感器广播不合格货物事务"><br>
由于事务包含在块链中，因此当货物状态变为不合规时，会有一个不可变的记录。冰淇淋店可以拒绝收货，避免产生食品安全问题。<br>
与区块链中的数据一样，<strong>智能合同也是不可变的，逻辑在部署后便不能更改</strong>。因此你可以信任智能合同逻辑始终在所有节点上一致地执行，任何代码更改都需要在新的地址部署新的智能合同。</p>
<h2 id="智能合同是什么"><a class="markdownIt-Anchor" href="#智能合同是什么"></a> 智能合同是什么？</h2>
<p>智能合同是区块链中存储的一种程序。<br>
智能合同将区块链从数据扩展到代码，它们表示各个参与方之间的编码协议，当操作发生时，代码将运行并提供响应。<br>
此类合同的所有条款和条件都以编程方式定义。定义将为区块链的参与者指定规则、要求和奖励。它还会指定如何在各参与方之间传输数字资产。每个智能合同将分配有一个20个字节的地址，用作合同的唯一标识。<br>
智能合同将自行运行，发送事件来触发状态转换，并调用函数。它们非常适用于区块链技术，因为素不相识的人们可以通过它们按照指定的安全方式开展业务，而不需要任何中间商。<br>
智能合同通常与Ethereum一起使用。Ethereum是全球首个可编程的区块链。通过它可以定义智能合同，来帮助传输数字资产，例如以太币。<br>
用于编写合同的语言是Solidity。Solidity是图灵完备语言，这意味着可以通过明确的定义和编码编写复杂的合同。<br>
由于每个状态转换都会进行记录并且都不可变，因此在将合同发布到生产环境之前，应对它进行全面测试。Bug修复可能会产生巨大成本，甚至会严重损害系统。<br>
智能合同的主要属性和优点如下：</p>
<ul>
<li>透明：区块链用户可以读取智能合同，并可以使用API来访问这些合同。</li>
<li>不可变性：智能合同的执行将创建不可更改的日志。</li>
<li>分发：该合同的输出由该网络的节点验证。合同状态可以公开显示。在某些情况下，甚至可以看到“私有”变量。</li>
</ul>
<h3 id="用例"><a class="markdownIt-Anchor" href="#用例"></a> 用例</h3>
<p>智能合同可为许多行业和流程带来好处。可以考虑以下用例。</p>
<ul>
<li>保险：当发生某些事件时，智能合同可自动触发索赔，从而简化索赔过程。然后，若要确定用户将收到的补偿金额，可在区块链中记录索赔详细信息。此功能可以减少处理时间和人为错误。</li>
<li>投票：智能合同有助于投票自动化和透明化。每个合同都是一种投票，代表着投票者的身份。由于区块链是不可变的，这意味着区块链无法更改，因此无法篡改投票。</li>
<li>供应链：随着物品沿着供应链移动，智能合同可记录所有权，并可确认在任何给定时间由谁负责某项产品。在任何阶段，都可以通过智能合同准确查明产品应处于的位置。如果供应链中的任何一个参与方未能按时送达，其他每个参与方都会知道何处出现了问题。</li>
<li>记录保留：许多行业都可以使用智能合同来提高记录保留的速度和安全性。可以使用区块链技术将记录数字化，并对其进行安全的加密和存储。此外，可以限制访问，以便只有允许的人员才能访问记录。- 财产所有权：智能合同可以记录财产的所有者。通过它们可以快速高效地记录所有权。智能合同还有助于及时安全地转移所有权。</li>
</ul>
<h1 id="区块链类型"><a class="markdownIt-Anchor" href="#区块链类型"></a> 区块链类型</h1>
<p>区块链可以是公共的或专用的。 这两种不同的类型决定了谁能参与区块链网络。</p>
<h2 id="公共区块链网络"><a class="markdownIt-Anchor" href="#公共区块链网络"></a> 公共区块链网络</h2>
<p>如果你不需要信任任何人的网络，任何能访问Internet的人都可加入你的区块链网络，不需要进行登录，也不需要向机构申请权限。<br>
公共区块链分散在网络上，且不存在中央机构，网络上的任何节点都可以看到区块链中的所有事务。<br>
第一个区块链网络为比特币创建，比特币区块链网络是公共的，任何人都可以查看所有事务。<br>
例如，可以使用块资源管理器查看最新的比特币块和事务。<br>
公共区块链的共识算法使用加密货币作为验证块的奖励，在验证事务时还可能收取加密货币费用。<br>
公共区块链的隐私保护有限，如果想要保持事务的私密性，应仅与事务中的其他参与者共享公钥。</p>
<h2 id="专用区块链网络"><a class="markdownIt-Anchor" href="#专用区块链网络"></a> 专用区块链网络</h2>
<p>如果部分信任区块链网络的参与者，只有受邀加入区块链网络的参与者才能访问区块链中存储的信息。专用网络是不完全受信任的网络，在专用网络中所有参与者都在区块链的利用方式上达成一致。<br>
联盟区块链是专用区块链，但权限是分布式的，并按网络的最大利益行事。联盟区块链可以限制谁有权参与共识。通过限制为只有参与者可以加入验证来实现信任，由参与者构成的组称为联盟。联盟区块链的共识算法可以使用权限而不是加密货币。<br>
在冰淇淋方案中可能还需要保持部分数据的私密性。例如，各方都知道产品已运出，但可以保持运输细节的私密性。由于我们使用多家运输公司，双方之间的运输细节可能会保密。相互竞争的运输公司只知道事务发生了，无法查看运输细节。</p>
<h2 id="区块链协议"><a class="markdownIt-Anchor" href="#区块链协议"></a> 区块链协议</h2>
<p>有几个著名区块链协议。最有名的是比特币，比特币区块链网络专为比特币加密货币创建，主要功能是存储比特币值。这些值可以通过不可信的方式从一处转到另一处。<br>
Ethereum是通用协议。Ethereum扩展了比特币创建的内容，提供允许编写小型程序以及进行简单值转移的协议。最终效果是能添加逻辑和代码，而不只是进行简单的固定值转移。<br>
如果要将区块链用于实际解决方案一般使用Ethereum和Hyperledger Fabric 之类的通用协议，它们是可用于多个方案的可编程区块，通用协议使用智能合同对业务逻辑和状态进行编码。</p>
<h1 id="区块链的应用"><a class="markdownIt-Anchor" href="#区块链的应用"></a> 区块链的应用</h1>
<p>区块链技术适用于某些特定方案，不应将其用作常规用途解决方案。在许多情况下，集中式数据库是一个更好的选择。考虑使用区块链时，请思考几个关于当前方案的问题。</p>
<h2 id="参与者"><a class="markdownIt-Anchor" href="#参与者"></a> 参与者</h2>
<ul>
<li>是否需要支持多个合作伙伴或公司？</li>
<li>是否要避免存在中央机构？也许对任何一个参与者都不信任。参与者也可能不想依赖于第三方。</li>
<li>参与者是否共享数据或使用涉及多个或全部参与者的工作流？<br>
区块链技术能保证所有节点的一致性。大多数其他企业对企业 (B2B) 解决方案依赖于同步。同步数据会使B2B系统产生断裂和费用，而分布式数据的一致性是区块链技术的关键优势。</li>
</ul>
<h2 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h2>
<ul>
<li>事务吞吐量是否较低？<br>
根据区块链协议和共识机制，事务处理速率可能较低。</li>
<li>与其他业务合作伙伴进行交互时，是否定义了业务逻辑？<br>
在事务中执行业务逻辑可能会影响性能。</li>
</ul>
<h2 id="业务逻辑"><a class="markdownIt-Anchor" href="#业务逻辑"></a> 业务逻辑</h2>
<ul>
<li>业务逻辑是否足够简单？<br>
在公共区块链上执行复杂的智能合同函数比简单的函数需要更多的加密货币。</li>
<li>业务逻辑是否是静态的且不会更改？<br>
区块链数据不可变，要更改智能合同逻辑，就需要将新合同部署到新地址，因此如何控制业务逻辑的版本是一个需要考虑的问题。</li>
</ul>
<h2 id="信任"><a class="markdownIt-Anchor" href="#信任"></a> 信任</h2>
<ul>
<li>参与者之间是否需要信任和诚信？</li>
<li>事务的顺序是否重要？</li>
<li>事务是否具有私密性？</li>
</ul>
<script src="https://utteranc.es/client.js" repo="hetumessi/blogcomments" issue-term="pathname" label="comments" theme="github-light" crossorigin="anonymous" async>
</script>
]]></content>
      <categories>
        <category>区块链技术</category>
      </categories>
      <tags>
        <tag>应用技术</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>单继承和多继承、派生类构造析构规则</title>
    <url>/posts/c4844ef45beb</url>
    <content><![CDATA[<h1 id="单继承和多继承"><a class="markdownIt-Anchor" href="#单继承和多继承"></a> 单继承和多继承</h1>
<p>继承分为单继承和多继承</p>
<blockquote>
<p>单继承：派生类只有一个直接基类(如：A-&gt;B-&gt;C)<br>
多继承：派生类有多个直接基类(如：X,Y-&gt;Z)</p>
</blockquote>
<p>定义单继承派生类的基本格式：</p>
<blockquote>
<p>class 派生类名：&lt;继承方式&gt;基类名{继承基类的成员,新添加的成员};</p>
</blockquote>
<p>定义多继承派生类的基本格式：</p>
<blockquote>
<p>class 派生类名：&lt;继承方式1&gt;基类名1,&lt;继承方式2&gt;基类名2…{继承基类的成员,新添加的成员};</p>
</blockquote>
<p>定义的缺省继承方式是私有继承方式</p>
<span id="more"></span>
<h1 id="继承关系中构造与析构原则"><a class="markdownIt-Anchor" href="#继承关系中构造与析构原则"></a> 继承关系中构造与析构原则</h1>
<p>派生类继承了基类成员，对象中既包含基类成员又包含派生类成员，因此初始化时需要通过构造函数同时初始化全部成员<br>
派生类在构造对象时，先生成自己的基类部分，然后生成自己的成员对象，最后生成自身特有的部分</p>
<h2 id="构造函数-析构函数调用原则"><a class="markdownIt-Anchor" href="#构造函数-析构函数调用原则"></a> 构造函数、析构函数调用原则</h2>
<p>在创建派生类对象时(其实创建组合类的情况类似)</p>
<ul>
<li>如果派生类没有定义构造函数，则调用基类的无参数的构造函数</li>
<li>如果派生类定义了构造函数，不论是无参数还是带参数，在创建派生类的对象的时候，首先执行基类无参数的构造方法，然后执行自己的构造函数</li>
<li>如果派生类的构造函数没有显示调用基类的构造函数，则会调用基类的默认无参构造函数</li>
<li>如果派生类的构造函数没有显示调用基类的构造函数且基类自己提供了无参构造函数，则会调用基类自己的无参构造函数</li>
<li>如果派生类的构造函数没有显示调用基类的构造函数且基类只定义了自己的有参构造函数，则会出错
<ul>
<li>如果基类只有有参数的构造函数，则派生类必须显示调用此带参构造方法</li>
</ul>
</li>
<li>如果派生类调用基类带参数的构造函数，需要用初始化基类成员对象的方式</li>
</ul>
<p>析构函数因为不涉及传入参数初始化的问题，因此直接调用基类的析构函数即可</p>
<h2 id="单继承情况"><a class="markdownIt-Anchor" href="#单继承情况"></a> 单继承情况</h2>
<p>派生类初始化与组合类的初始化方式类似，(构造函数)的基本格式为：</p>
<blockquote>
<p>派生类名(初始化表):基类名(初始化表),对象成员1(初始化表)…对象成员n(初始化表){新增成员…}</p>
</blockquote>
<p>如果基类使用缺省的或不带参数的构造函数，则初始化列表中基类构造函数(参数表)可以省略<br>
如果没有初始对象成员，则初始化列表中对象成员i(参数表)也可以省略</p>
<p>例：定义基类椭圆类和派生类圆类</p>
<pre class="line-numbers language-none"><code class="language-none">class Point&#123;
    float x,y;
public:
    Point(int a,int b):x(a),y(b)&#123;&#125;
&#125;;
class Elliptic&#123;
    float a,b;
    Point centre;
public:
    Elliptic(float a1,float b1,float x,float y):a(a1),b(b1),centre(x,y)&#123;&#125;
&#125;;
class Circle:public Elliptic&#123;
public:
    Circle(float r,float x,float y):Elliptic(r,r,x,y)&#123;&#125;
&#125;;                                         &#x2F;&#x2F;创建单位圆对象，先调用Elliptic()，调用Elliptic()时先调用Point()，最后调用Circle()
int main()&#123;
    Circle circle(1,0,0);
&#125;          &#x2F;&#x2F;如果Circle类中的新增成员存在类对象的话也是先构造部分再构造整体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造函数的调用顺序为：(相当于是嵌套调用，自底向上地遍历完整棵继承树)</p>
<blockquote>
<p>基类构造函数 对象成员所属类的构造函数 派生类构造函数</p>
</blockquote>
<p>析构函数调用顺序相反：</p>
<blockquote>
<p>派生类析构函数 对象成员所属类的析构函数 基类析构函数</p>
</blockquote>
<h2 id="多继承情况"><a class="markdownIt-Anchor" href="#多继承情况"></a> 多继承情况</h2>
<p>多继承派生类在创建时也需要调用构造函数，基本格式为：</p>
<blockquote>
<p>派生类名(初始化表):<br>
基类名1(初始化表)…基类名n(初始化表),对象成员1(初始化表),…,对象成员n(初始化表){新增成员…}</p>
</blockquote>
<p>多继承构造函数调用的基本顺序与单继承是一样的，也是先基类变量、再对象成员、最后普通变量，多个基类和成员依次按照规则完成各自的构造和初始化，其中基类对象和成员对象的构造函数调用顺序和声明继承关系的顺序有关</p>
<p>至于析构函数调用顺序和构造函数相反就可以了</p>
<h1 id="二义性"><a class="markdownIt-Anchor" href="#二义性"></a> 二义性</h1>
<p>当两个或多个基类中有同名的成员时，如果直接访问该成员会产生命名冲突，编译器不知道使用哪个基类的成员，即出现二义性<br>
出现二义性存在两种可能的情况：</p>
<ul>
<li>访问不同基类具有相同名字的成员</li>
<li>访问共同基类的成员(多层继承)</li>
</ul>
<h2 id="不同基类同名成员"><a class="markdownIt-Anchor" href="#不同基类同名成员"></a> 不同基类同名成员</h2>
<p>在多继承情况下，访问不同基类的同名成员时存在二义性的问题，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class A&#123;
public:
    int value;
    void f()&#123;&#125;
&#125;;
class B&#123;
    public:int value;
    void f()&#123;&#125;
&#125;;
class C:public A,public B&#123;
public:
    void g()&#123;&#125;
    void h()&#123;&#125;
&#125;;
int main()&#123;
    C c;
    c.value&#x3D;10;
    c.f();
&#125;             &#x2F;&#x2F; 此时即出现二义性，无法通过编译<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法是用类名和作用域符对同名成员加以限定，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    C c;
    c.A::value&#x3D;10;
    c.B::value&#x3D;10;
    c.A::f();
    c.B::f();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多层继承"><a class="markdownIt-Anchor" href="#多层继承"></a> 多层继承</h2>
<p>当存在多层继承(重复继承)的时候，会存在一个基类的多份拷贝，此时也会会存在二义性<br>
基类的成员在派生类中被继承后，再次向下继承，此时单单指明最上层的基类是不够的，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class A0&#123;
public:
    int a;
&#125;;
class A11:public A0&#123;&#125;;
class A12:public A0&#123;&#125;;
class A2:public A11,public A12&#123;&#125;;
int main()&#123;
    A2 a2;
    a2.A0::a&#x3D;10
&#125;                 &#x2F;&#x2F;出现二义性，无法通过编译，因为A2继承的两个基类A1和A2都有A0的a成员，仅指明公共基类A0是不明确的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一种解决方法是明确指明成员是继承自哪个类，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    A2 a2;
    a2.A11::a&#x3D;10,a2.A12::a&#x3D;10;
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="虚继承"><a class="markdownIt-Anchor" href="#虚继承"></a> 虚继承</h2>
<p>对于多层继承，如果对一个基类每层都只有一个拷贝，就可以达到消除二义性的目的，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class A0&#123;&#125;;
class A11:public A0&#123;&#125;;
class A12:public A0&#123;&#125;;
class A2:public A11,public A12&#123;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的例子中，类A0是派生类A2两条继承路径上的公共基类，因此这个公共基类会在派生类对象中产生两个基类子对象，虽然可以通过类限定符避免二义性，但问题关键在于我们不需要在派生类对象中存在多个基类对象的拷贝，要达到这种目的则需要将基类设置为虚基类，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class A11:virtual public A0&#123;&#125;;
class A12:virtual public A0&#123;&#125;;
int main()&#123;
    A2 a2;
    a2.A0::a&#x3D;10;
    cout&lt;&lt;a2.A0::a;
&#125;  &#x2F;&#x2F;输出结果：10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>引进虚基类的目的就是为了解决二义性，使公共基类在其对象中只生成一个基类子对象(虚类子对象被合并成一个子对象)<br>
由于多继承生成对象时是按声明顺序依次调用基类的构造函数，依次如果声明为虚基类时就会检查之前的拷贝，如果已经存在虚继承自相同基类的情况则将之前的那份对象的引用作为自身的拷贝，从而达到只有一份基类拷贝的目的<br>
引申来说，虚继承只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。(因为虚派生出来的类中还是有基类的拷贝，只有当这个派生的类再次派生出类时虚继承的作用才能体现出来，即多重继承来的成员只保存一份拷贝，换句话说虚继承解决的是隔一代的问题)</p>
<p>在都定义虚基类的情况下，基类只有对具有第一份拷贝的(先声明的)那个虚继承派生类是真基类，对其余的虚继承派生类而言是假基类(虚基类)，因此虚基类是一种相对的概念</p>
<h3 id="虚基类对象的初始化"><a class="markdownIt-Anchor" href="#虚基类对象的初始化"></a> 虚基类对象的初始化</h3>
<p>虚基类构造函数调用次序的规则为：</p>
<ul>
<li>虚基类构造函数在非虚基类之前调用</li>
<li>若在同一层次中包含多个虚基类，那么虚基类构造函数按照声明的顺序调用</li>
<li>若虚基类由上层基类派生，则还是遵守先调用基类构造函数，再调用派生类构造函数的规则</li>
</ul>
<p>例：虚基类对象的初始化示例</p>
<pre class="line-numbers language-none"><code class="language-none">class A01&#123;public:A01()&#123;cout&lt;&lt;&quot;构造A01&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
class A02&#123;public:A02()&#123;cout&lt;&lt;&quot;构造A02&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
class A03&#123;public:A03()&#123;cout&lt;&lt;&quot;构造A03&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
class A11:public A01,virtual public A02&#123;public:A11()&#123;cout&lt;&lt;&quot;构造A11&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
class A12:virtual public A02,virtual public A03&#123;public:A12()&#123;cout&lt;&lt;&quot;构造A12&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
class A2:public A11,virtual public A12&#123;public:A2()&#123;cout&lt;&lt;&quot;构造A2&quot;&lt;&lt;&#39; &#39;;&#125;&#125;;
int main()&#123;
    A2 a2;
&#125;    &#x2F;&#x2F;输出结果：构造A02 构造A03 构造A12 构造A01 构造A11 构造A2  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上例的分析：</p>
<ul>
<li>定义A2对象，首先调用A2构造函数
<ul>
<li>A2构造函数先调用虚基类A12构造函数
<ul>
<li>A12构造函数先调用第一个声明的虚基类A02构造函数，打印&quot;构造A02&quot;</li>
<li>A12构造函数再调用第二个声明的虚基类A03构造函数，打印&quot;构造A03&quot;</li>
<li>A12打印&quot;构造A12&quot;，完成A12的构造</li>
<li>返回A2构造函数</li>
</ul>
</li>
<li>A2构造函数再调用非虚基类A11构造函数
<ul>
<li>A11构造函数先调用虚基类A02构造函数，打印&quot;构造A02&quot;</li>
<li>A11构造函数再调用非虚基类A01构造函数，打印&quot;构造A01&quot;</li>
<li>A11打印构造&quot;构造A11&quot;，完成A11的构造</li>
<li>返回A2构造函数</li>
</ul>
</li>
</ul>
</li>
<li>A2打印&quot;构造A2&quot;，完成A2的构造</li>
</ul>
<h3 id="虚基类表"><a class="markdownIt-Anchor" href="#虚基类表"></a> 虚基类表</h3>
<p>从内存分布角度看，对于虚继承，大部分编译器会把基类成员变量放在派生类成员变量的后面，这与正常的继承方式相反(正常是继承的成员在前，新定义的在后)。<br>
虚基类的子对象，也就是共享部分的偏移量会随着继承层次的增加而改变。关于如何计算共享部分的偏移细节，c<ins>标准并没有定义，不过c</ins>提供了虚基类表用于派生类中虚基类对象的检索与访问。</p>
<p>如果某个派生类有一个或多个虚基类，编译器就会在派生类对象中安插一个指针vbptr，指向虚基类表vbtable<br>
虚基类表其实就是一个数组，保存的是所有虚基类（包括直接继承自基类和间接继承自祖先基类得到的）成员相对于当前对象的首地址的偏移，这样通过派生类指针访问虚基类的成员变量时，不管继承层次都多深，只需要一次间接转换就可以。(注意虚基类指针本身也会被继承下去)<br>
假设A是B的虚基类，同时B又是C的虚基类，C是D的非虚基类，那么各对象的内存模型如下图所示：(仅用于举例，真正的内存分布要看不同编译器的具体实现)</p>
<img src="https://s2.loli.net/2022/05/05/Pr83SytUQHEj9eX.png" width="50%" height="50%">
<p>另外，这种方案还可以避免有多个虚基类时让派生类对象额外背负过多的指针，每派生一次只会新建一个vbptr和虚基类表</p>
<p>注意vbtable和vftable的区别</p>
<ul>
<li>最大的区别在于前者属于一个对象实例，而后者属于一个类
<ul>
<li>因为类的成员函数是在代码区中共享的，因此只需要在定义类时在类中加入一个虚函数的“接口”就可以让之后实例化的每个对象都通过这个接口访问该类独有的虚函数</li>
</ul>
</li>
<li>前者解决多重继承中数据重复的问题，后者是为了实现多态性</li>
<li>前者的作用要隔代才能体现出来，后者的作用主要体现在直接继承的关系中(因为派生类是以直接基类的vftable为模板进行改写的)</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>继承、派生</title>
    <url>/posts/39a7f361dc52</url>
    <content><![CDATA[<h1 id="继承-派生"><a class="markdownIt-Anchor" href="#继承-派生"></a> 继承、派生</h1>
<p>在自然界中，继承与派生是一种非常普遍的现象</p>
<blockquote>
<p>例：猫类，狗类都属于哺乳动物类，具备胎生，哺乳，恒温等哺乳动物的所有性质，同时又具有各自的特有的性质</p>
</blockquote>
<p>这是就是继承关系的重要性质，形成继承关系的两个类之间，具有IS_A的关系</p>
<blockquote>
<p>继承：一旦指定某种事物父代的本质特征，那么它的子代会自动具有这些性质<br>
继承是一种朴素的可重用的概念</p>
</blockquote>
<blockquote>
<p>派生：子代可以拥有父代所没有的特性，这是可扩充的概念<br>
继承就是在一个已存在的类基础上建立另一个新的类</p>
</blockquote>
<p>已存在的类，称为基类或父类，新建立的类称为派生类<br>
派生类的功能主要通过以下方式来体现：</p>
<ul>
<li>吸收基类的成员</li>
<li>改造基类的成员</li>
<li>添加新成员</li>
</ul>
<span id="more"></span>
<p>从编码的角度，派生类从基类中以较低的代价换取了较大的灵活性：<br>
派生类可以对继承的属性进行扩展，限制或改变，一旦产生可靠的基类，只需要调试派生类所作的修改即可</p>
<p>在面向对象思想发展的初期，通过继承复用代码曾经被认为是面向对象最重要的目标之一，但遗憾的是，实践中人们发现在开发中滥用继承的话是后患无穷的<br>
这是因为代码中存在一定的耦合性，基类会产生较深的类型继承树，因此常常牵一发而动全身</p>
<p>继承是对类型之间的关系建模，共享公共的东西，仅特化本质上不同的东西<br>
派生类能继承基类定义的成员，可以无需改变而使用那些与派生类型具体特性不相关的操作，并可重定义那些与派生类型相关的成员函数，将函数特化仅考虑派生类型的特性<br>
除从基类继承成员外，派生类还可以定义更多的成员<br>
注意：例外的是基类的构造函数和析构函数都是不能被继承的，因为这两种成员都是描述对象在其本身层次的行为，与基类无关</p>
<h2 id="继承方式以单继承为例"><a class="markdownIt-Anchor" href="#继承方式以单继承为例"></a> 继承方式(以单继承为例)</h2>
<h3 id="公有继承"><a class="markdownIt-Anchor" href="#公有继承"></a> 公有继承</h3>
<p>继承方式包括：public，protected，private<br>
派生类虽然继承基类的所有成员，但派生类并非都能访问基类全部成员，继承方式会影响派生类对基类中各种成员的使用<br>
在派生类中除公有成员，保护成员，私有成员外还存在不可访问成员，即在类外不可直接访问，在派生类内部也不可直接访问<br>
公有派生类基本格式为：</p>
<blockquote>
<p>class 派生类名：public 基类名{};</p>
</blockquote>
<p>在公有派生类中，基类成员的在其中的引用权限为：<br>
公有成员和保护成员访问权限不变，私有成员变为不可访问成员，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Base&#123;
    int a;
public:
    int b;
    Base(int v1&#x3D;0,int v2&#x3D;0):a(v1),b(v2)&#123;&#125;
&#125;;
class Derived:public Base&#123;
    int c;
public:int d;
    Derived(int v1&#x3D;0,int v2&#x3D;0):c(v1),d(v2)&#123;&#125;
    void func();
&#125;;
void Derived::func()&#123;
    cout&lt;&lt;a&lt;&lt;&#39; &#39;&lt;&lt;b&lt;&lt;&#39; &#39;&lt;&lt;c&lt;&lt;&#39; &#39;&lt;&lt;d&lt;&lt;endl;
&#125;
int main()&#123;
    Derived derived(0,0);           &#x2F;&#x2F;derived对象中有四个数据成员，其中a,b从基类继承，c,d从派生类派生
    derived.a&#x3D;1;                    &#x2F;&#x2F;访问失败，Base类的私有成员在派生类中不可访问，在类外更不可以访问(private权限+任何继承&#x3D;不能访问)
    derived.b&#x3D;1;                    &#x2F;&#x2F;成功通过对象访问公有成员(public继承+public权限&#x3D;public权限可以访问)
    derived.c&#x3D;1;                    &#x2F;&#x2F;访问失败，Derived类的私有成员在类外不可访问(private允许自身成员函数访问但不能通过自身对象访问)
    derived.d&#x3D;1;                    &#x2F;&#x2F;Derived类的公有成员在类外可以访问
    derived.func();                 &#x2F;&#x2F;func()中a是基类私有成员不可访问，b是基类公有成员可以访问，c，d是Derived类自己的成员允许成员函数访问
&#125;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序中的大多数情况都是公有派生，这是因为只有公有派生的情况下，才可能出现基类公有成员变成派生类公有成员的情况。想要使用派生类为基类赋值或派生类指针访问基类成员必须是在公有派生的基础上，私有和保护继承无法进行赋值，引用和指针指向，而这一点是面向对象程序设计中多态性实现的前提。</p>
<h3 id="私有继承"><a class="markdownIt-Anchor" href="#私有继承"></a> 私有继承</h3>
<p>私有派生类基本格式为：</p>
<blockquote>
<p>class 派生类名：private 基类名{};</p>
</blockquote>
<p>在私有派生类中，基类成员的在其中的引用权限为：<br>
公有成员和保护成员变为私有成员，私有成员作为不可访问成员，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Derived:private Base&#123;
    int c;
public:
    int d;
    void func();
&#125;;
void Derived::func()&#123;
    cout&lt;&lt;a&lt;&lt;&#39; &#39;&lt;&lt;b&lt;&lt;&#39; &#39;&lt;&lt;c&lt;&lt;&#39; &#39;&lt;&lt;d&lt;&lt;endl;
&#125;
int main()&#123;
    Derived derived;     &#x2F;&#x2F;无法初始化，因为Base类中的构造函数在Derived类已经变为私有
    derived.b&#x3D;1;         &#x2F;&#x2F;访问失败，Base类的公有成员在Derived类中是私有成员，不能在类外访问
&#125;                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>因此如果只存在public和private两种访问权限的情况下，对派生类来说基类的私有成员是不可见的(不可访问成员)，即使派生类已经继承了基类所有成员<br>
为了解决这种情况，c++才引入保护成员，即用protected关键字说明的成员</p>
<h3 id="保护继承"><a class="markdownIt-Anchor" href="#保护继承"></a> 保护继承</h3>
<p>若希望在派生类中能访问某个成员，并且不希望其在类外可见，应当把它声明为保护成员<br>
如果在一个类中声明了保护成员，就意味着该类可能要用作基类，在它的派生类中会访问这些成员<br>
保护成员的特点是，基类和派生类都能访问，但在类外不可访问，保护派生类基本格式为：</p>
<blockquote>
<p>class 派生类名：protected 基类名{};</p>
</blockquote>
<p>在保护派生类中，基类成员的在其中的引用权限为：<br>
公有成员和保护成员变为保护成员，私有成员仍然作为不可访问成员</p>
<pre class="line-numbers language-none"><code class="language-none">class Derived:protected Base&#123;
protected:
    int c;
public:
    int d;
    Derived(int v1&#x3D;0,int v2&#x3D;0):a(v1),b(v2)&#123;&#125;;
    void func();
&#125;;
void Derived::func()&#123;cout&lt;&lt;a&lt;&lt;&#39; &#39;&lt;&lt;b&lt;&lt;&#39; &#39;&lt;&lt;c&lt;&lt;&#39; &#39;&lt;&lt;d&lt;&lt;endl;&#125;
int main()&#123;
    Derived derived;
    derived.a&#x3D;1;
    derived.b&#x3D;1;
    derived.c&#x3D;1;      &#x2F;&#x2F;保护成员在类外都不可以访问
    derived.func();   &#x2F;&#x2F;成员函数可以访问a,b,c,d全部成员 
&#125;                                     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="同名访问原则"><a class="markdownIt-Anchor" href="#同名访问原则"></a> 同名访问原则</h2>
<p>继承关系具有同名覆盖原则(派生类成员覆盖基类成员)<br>
c++允许派生类重新定义基类中的成员，此时称派生类的成员覆盖了基类的同名成员</p>
<blockquote>
<p>在派生类中如果想使用基类中的同名成员，可以显式地使用这种基本格式：基类名::成员名</p>
</blockquote>
<p>这本质上来说还是一个作用域嵌套的问题，当存在继承关系时，派生类的作用域嵌套在基类的作用域之内<br>
当派生类对象访问成员时，会在作用域链中寻找最匹配的成员，对于成员变量直接查找该成员即可，对于成员函数，编译器仅仅根据函数名字来查找，当内层作用域有同名函数时，将这些同名函数作为一组重载候选函数。</p>
<pre class="line-numbers language-none"><code class="language-none">class Base&#123;
protected:
    int a;
public:
    Base(int v&#x3D;0):a(v)&#123;&#125;
&#125;;
class Derived:public Base&#123;
    int a;
public:
    Derived(int v):a(v)&#123;&#125;
    void func()&#123;
        Base::a&#x3D;a;
        cout&lt;&lt;Base::a;
    &#125;
&#125;;
int main()&#123;
    Derived derived(1);
    derived.func();
&#125;   &#x2F;&#x2F;输出结果：1    1为derived对象的Base::a成员值 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="赋值兼容原则"><a class="markdownIt-Anchor" href="#赋值兼容原则"></a> 赋值兼容原则</h2>
<p>赋值兼容的实现在c<ins>语言中极为重要，因为这是c</ins>面向对象体系中最为关键的多态性质实现的基础，c++多态正是靠基类指针或引用指向派生类的虚函数从而在运行时刻完成同名函数的动态绑定。<br>
基本数据类型之间都是可以相互转换的，即使不能隐式转换通常情况也可以进行强制转换，但不同类之间通常是不可以进行转换的<br>
但是，基类和派生类在满足一定条件下是可以转换的，转换的规则是赋值兼容原则<br>
在公有派生的情况下，派生类对象可以作为基类对象来使用，即</p>
<ul>
<li>派生类的对象可以直接赋值给基类的对象(基类对象将派生类对象中属于基类部分的成员数据拷贝)</li>
<li>基类的引用可以引用一个派生类的对象(同理，引用的是派生类对象中属于基类部分的成员数据)</li>
<li>基类对象的指针可以指向一个派生类对象(同理，指向属于基类部分的成员数据)</li>
</ul>
<p>这是因为派生类拥有从基类继承过来的成员，并且派生类对象和基类对象的内存布局方式是相似的<br>
当一个派生类对象直接赋值给基类对象时，不是所有数据都赋值给了基类对象，赋予的只是派生类对象的一部分，这部分即派生类对象的<strong>切片(sliced)</strong>，通过基类指针或引用能看到的是一个基类对象，派生类中成员对于基类指针或引用来说是不可见的，而反之不成立，通常情况派生类不能用基类本身、引用、指针来赋值，就像所有的狗都是动物，但不是所有动物都是狗，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Animal&#123;
public:
    void eat();
&#125;;
class Dog:public Animal&#123;
    public:void eat();
&#125;;
void Animal::eat()&#123;
    cout&lt;&lt;&quot;eating...&quot;&lt;&lt;&#39; &#39;;
&#125;
void Dog::eat()&#123;cout&lt;&lt;&quot;wang wang&quot;&lt;&lt;endl;&#125;
int main()&#123;
    Dog d;
    Animal a1&#x3D;d,*a2&#x3D;&amp;d,&amp;a3&#x3D;d;
    a1.eat();
    a2-&gt;eat();
    a3.eat();
&#125;
&#x2F;&#x2F;输出结果：eating... eating... eating...         无论是直接复制，引用，指针的方式，最后Animal对象保留的只有其自身的成员<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">int main()&#123;
    Dog d;
    Animal a;
    d&#x3D;a;
    (Dog)a&#x3D;d;
&#125;      &#x2F;&#x2F;无论是拿Animal对象给Dog对象赋值，还是对Animal强制类型转换均无法通过编译<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其实从内存分布的角度来说更好理解，派生类对象赋值给基类直接按成员拷贝甚至位拷贝都行，但是派生类对象类型接收基类对象类型的话显然是不完整的，并且c++并没有明确规定派生类的对象在内存中如何分布，在一个对象中继承自基类的部分和派生类自定义的部分<strong>不一定连续存储</strong>，这就导致基类的对象或指针没有办法处理派生类的信息。<br>
再换个角度来说，这种编译器允许的基类和派生类转换的规则称为<strong>向上转型</strong>，是没有安全隐患的。反过来用派生类指针指向基类对象，称为<strong>向下转型</strong>，默认是不允许的。把基类对象赋给派生类对象是肯定无法进行的，因为无论位拷贝还是成员拷贝都没法进行；如果是指针或引用，可以使用强制类型转换将基类转为派生类再赋值，但这种情况下派生类指针引用如果调用自身成员函数中有对基类中没有的成员的访问的话就会出现问题</p>
<ul>
<li>如果不是虚继承，那么继承的成员在前，新定义的成员在后，说明新成员的偏移量更大(必然超过基类对象的大小)，此时就会越界访问到赋值的基类对象后面的内存空间</li>
<li>这种情况也就是默认的强制类型转换static_cast&lt;目标类型&gt;(转换对象)</li>
</ul>
<p>因此，如果想要对类对象指针或引用进行类型转换，最好不要使用默认的强制转换()或者直接static_cast，而是使用dynamic_cast，后者会自动对转换对象的继承树进行遍历，如果发现是向下转换会直接转换失败返回nullptr，保证不会出现向下转换情况的发生</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>友元类、组合类</title>
    <url>/posts/cc61d4abf604</url>
    <content><![CDATA[<h1 id="友元关系"><a class="markdownIt-Anchor" href="#友元关系"></a> 友元关系</h1>
<p>封装的目的是为了实现信息隐蔽，一个对象的私有成员只能通过自己的成员访问到，类外想要访问私有成员只能通过该类提供的公有成员间接地进行<br>
但是上面这种方式通常是以函数调用的方式进行的，不方便并且开销大，因此，c++提供了友元的机制来打破私有化的界限，即一个类的友元可以访问该类的私有成员</p>
<span id="more"></span>
<h2 id="友元函数"><a class="markdownIt-Anchor" href="#友元函数"></a> 友元函数</h2>
<p>友元函数可以直接访问类对象的公有，私有成员<br>
声明可以放在类的任何位置(哪一个段都没有区别)，但是<strong>友元函数不属于类</strong>，不是该类的成员函数，因此一般的友元函数也没有this指针<br>
调用时需要将对象作为参数传入友元函数内，调用方式和普通函数一样不需要通过对象，如：</p>
<blockquote>
<p>Point类代表点(其中有点的坐标(x,y)的数据)，需要一个函数计算任意两点间的距离</p>
</blockquote>
<p>单从实现的角度来说并不复杂，首先只需要定义一个计算距离的函数，通过Point类的对象提供点的坐标，并在类外通过成员函数访问即可计算距离，或者也可以在类中定义一个成员函数，然后一个对象通过上面的方法接受另一个Point类对象提供的坐标，调用成员函数计算距离即可<br>
但这两种法式显然不如友元快捷高效，并且计算距离应该是一个独立的功能，反映两点间的关系，并不属于某一单独的点也不属于Point类</p>
<pre class="line-numbers language-none"><code class="language-none">class Point
&#123;
    float x,y;
    friend float distance(Point a,Point b);  
public:
    Point(float a,float b):x(a),y(b)&#123;&#125;
&#125;;
float distance(Point a,Point b)
&#123;
    float dx,dy;
    dx&#x3D;a.x-b.x;
    dy&#x3D;a.x-b.y;
    return sqrt(dx*dx+dy*dy);
&#125;
int main()
&#123;
    Point point1(23,42),point2(46,34);
    cout&lt;&lt;distance(point1,point2)&lt;&lt;endl;      &#x2F;&#x2F;输出结果：25.4951
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然distance()看似定义在私有区，但实际上友元函数不属于类，在类外也可以调用(并且不需要指定作用域)<br>
(如果要定义为类内的友元成员函数则需要指定作用域)</p>
<h2 id="友元类"><a class="markdownIt-Anchor" href="#友元类"></a> 友元类</h2>
<p>除将一个普通函数声明为一个类的友元函数外，也可在类X中声明另一个类Y为X的友元类<br>
友元类的特点：</p>
<ul>
<li>友元的关系是<strong>单向</strong>的而不是双向的，不具有对称性，类Y为X的友元类不代表类X是Y的友元类</li>
<li>友元的关系不能传递，不具有传递性，类Y是类X的友元类，类Z是类Y的友元类，不等于类Z是类X的友元类</li>
</ul>
<p>要想达到上面两种目的都必须单独声明<br>
友元类Y中的所有成员函数都是类X的友元函数，都能直接访问类X中所有成员，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class X
&#123;
    int x;
    friend class Y;
private:
    X(int v):x(v)&#123;&#125;
public:
    void show()&#123;cout&lt;&lt;x;&#125;
&#125;;
class Y
&#123;
public:
    void set(int x,X &amp;obj)&#123;obj.x&#x3D;x;&#125;
&#125;;
int main()
&#123;
    X obj1(5);
    Y obj2;
    obj2.set(10,obj1);
    obj1.show();           输出结果:10
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="友元成员函数"><a class="markdownIt-Anchor" href="#友元成员函数"></a> 友元成员函数</h3>
<p>友元函数虽然不是目标类的成员函数，但可以是另一个类的成员函数，注意在声明时需要加上当前类和作用域符，以说明是某个类的成员函数，如：</p>
<blockquote>
<p>class X{…};class Y{…;friend void Y::SetX(X &amp;obj,int v){}};</p>
</blockquote>
<h1 id="类的组合"><a class="markdownIt-Anchor" href="#类的组合"></a> 类的组合</h1>
<p>一个类的对象作为另一个类的成员，体现了整体与部分的关系，即对象的<strong>包含关系</strong><br>
这个作为成员的对象被称为子对象，在初始化时，如果子对象对应的类的构造函数有参数，那么包含该子对象的类必须使用<strong>参数初始化表</strong>的方式先初始化子对象即先构造部分再构造整体<br>
析构函数的调用顺序相反，先析构整体再析构部分 (实际上和基类派生类的构造方法是一致的，这一点在后面<a href="/2022/04/28/%E5%8D%95%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF/" title="单继承和多继承、派生类构造析构规则">单继承和多继承、派生类构造析构规则</a>中会详细说明)</p>
<p>注意顺序是组合类中各类对象的声明顺序(析构时为逆序)</p>
<p>例：使用点(Point)类构造一个园(Circle)类</p>
<pre class="line-numbers language-none"><code class="language-none">class Point
&#123;
    float x,y;
public:
    Point(int a,int b):x(a),y(b)&#123;&#125;
    void MoveTo(float xx,float yy);
&#125;;
void Point::MoveTo(float xx,float yy)
&#123;
    x&#x3D;xx,y&#x3D;yy;
&#125;
class Circle
&#123;
    float r;
    Point centre;
public:
    Circle(float a,float b,float c):r(a),centre(b,c)&#123;&#125;     当然也可以直接用类或类引用&#x2F;指针初始化，总之子对象完成初始化就可以
    void MoveTo(float xx,float y);
&#125;;
void Circle::MoveTo(float xx,float yy)
&#123;
    centre.MoveTo(xx,yy);                        因为是通过成员访问符调用centre的MoveTo()函数，所以可以和Circle类的成员函数同名
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过类的组合可以在已有的抽象的基础上实现更复杂的抽象<br>
类似模块化程序设计的思想，先实现各个子对象，再实现整体的组合类，自底向上完成复杂项目的实现</p>
<p>组合类示例程序：发动机类Motor，车门类Doors，车轮类Wheels，用这些类组合为汽车类Cars，并输出各个类的构造和析构顺序</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
class Motor
&#123;
public:
    Motor()&#123;cout&lt;&lt;&quot;构造Motor类&quot;&lt;&lt;&#39; &#39;;&#125;
    ~Motor()&#123;cout&lt;&lt;&quot;析构Motor类&quot;&lt;&lt;&#39; &#39;;&#125;
&#125;;
class Doors
&#123;
public:
    Doors()&#123;cout&lt;&lt;&quot;构造Doors类&quot;&lt;&lt;&#39; &#39;;&#125;
    ~Doors()&#123;cout&lt;&lt;&quot;析构Doors类&quot;&lt;&lt;&#39; &#39;;&#125;
&#125;;
class Wheels
&#123;
public:
    Wheels()&#123;cout&lt;&lt;&quot;构造Wheels类&quot;&lt;&lt;&#39; &#39;;&#125;
    ~Wheels()&#123;cout&lt;&lt;&quot;析构Wheels类&quot;&lt;&lt;&#39; &#39;;&#125;
&#125;;
class Cars
&#123;
    Motor motor;
    Doors doors;
    Wheels wheels;
public
    Cars()&#123;cout&lt;&lt;&quot;构造Cars类&quot;&lt;&lt;endl;&#125;
    ~Cars()&#123;cout&lt;&lt;&quot;析构Cars类&quot;&lt;&lt;&#39; &#39;;&#125;
&#125;;
void display()
&#123;
    Cars car;
&#125;
int main()
&#123;
    display();              &#x2F;&#x2F;输出结果：构造Motor类 构造Doors类 构造Wheels类 构造Cars类
&#125;                                   &#x2F;&#x2F; 析构Cars类 析构Wheels类 析构Doors类 析构Motor类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>静态成员、常成员</title>
    <url>/posts/e090730e1012</url>
    <content><![CDATA[<h1 id="静态成员"><a class="markdownIt-Anchor" href="#静态成员"></a> 静态成员</h1>
<p>当用关键字static说明一个类成员时，该成员为静态成员，包括静态数据成员，静态成员函数<br>
静态数据成员，如：</p>
<blockquote>
<p>class ABCD{int value;static int s_value;};</p>
</blockquote>
<p>对静态成员除了在类内声明外还必须在<strong>类声明体外</strong>进行定义和初始化(不应该在构造函数中初始化，并且大部分环境也不支持这样做)</p>
<blockquote>
<p>int ABCD:😒_value=n;</p>
</blockquote>
<p>注意初始化时还要指定数据类型。如果没有给定初始化值，那么默认初始化为0(此时分配在在bss段)。</p>
<span id="more"></span>
<p>同c中的静态数据类型相似，类中的静态成员在所有类对象中共享一个存储空间，如：</p>
<blockquote>
<p>ABCD A,B,C,D;</p>
</blockquote>
<p>其中A,B,C,D四个对象具有value和s_value两种数据成员，但value属性在每个对象中都有一份存储空间，而类的所有对象共享类的静态数据成员，无论建立多少个该类的对象，静态数据成员都只有一份拷贝，因此静态数据成员属于类，而不属于具体某个对象</p>
<ul>
<li>具体来说，静态成员变量不占用对象的内存，静态成员变量和普通的静态变量类似，都在内存分区中的静态存储区分配内存</li>
<li>创建的时间也比较特殊，不是在声明类时分配，也不是在创建对象时分配，而是在类外初始化时分配(这也许就是为什么静态变量必须在类外声明一次的原因，哪怕没有初始化)</li>
</ul>
<p>静态数据成员也有public和private之分，在类外只能访问public属性的静态数据成员，在类内可以访问所有属性的静态数据成员<br>
由于静态数据成员属于类，因此可以在类外以如下格式访问public静态数据成员：</p>
<blockquote>
<p>类名::静态数据成员;<br>
对象名.静态数据成员;<br>
对象指针-&gt;静态数据成员;</p>
</blockquote>
<p>特别的，在对象不存在时，也可以访问静态数据成员</p>
<p>静态成员函数，如：</p>
<blockquote>
<p>class ABCD{static void ShowStaticValue();}</p>
</blockquote>
<p>静态成员函数由于只属于一个类，因此<strong>没有this指针</strong>，同静态数据成员一样，静态成员函数也可以声明成public或private访问权限，调用形式同静态数据成员<br>
静态成员函数只能访问静态数据成员、静态成员函数和类以外的函数和数据，不能访问非静态数据成员，反之静态成员函数或静态数据成员可由任意访问许可的函数访问<br>
一是因为静态成员是整个类的成员，因而具体对象的情况对其是未定义的，静态成员代表的是整个类共有的性质，是独立存在的；二是在于静态成员函数没有this指针，也找不到对象的成员数据</p>
<p>静态成员示例程序1:统计合格时钟，不合格时钟，生产的总时钟数</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class Clock
&#123;
    static int qualified,inqualified,total;
    bool isqualified;
public:
    Clock(bool i);
    void ShowProduct();
&#125;;
int Clock::qualified&#x3D;0;
int Clock::inqualified&#x3D;0;
int Clock::total&#x3D;0;
Clock::Clock(bool i):isqualified(i)
&#123;
    if(i&#x3D;&#x3D;0)inqualified++;
    if(i!&#x3D;0)qualified++;
    total++;
&#125;
void Clock::ShowProduct()
&#123;
    cout&lt;&lt;qualified&lt;&lt;&#39; &#39;&lt;&lt;inqualified&lt;&lt;&#39; &#39;&lt;&lt;total&lt;&lt;endl;
&#125;
int main()
&#123;
    Clock c1(false),c2(true),c3(c1);
    c3.ShowProduct();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>构造函数一般不能作为私有类型，因为这样的话用该类创建对象时编译会出错，但是通过使用静态数据类型和成员函数就可以在不创建对象的情况下对该类进行操作<br>
静态成员示例程序2：单例设计模式，程序运行中该类永远只有一个实例</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class Simpledesign
&#123;
private:
    static Simpledesign *instance;                   &#x2F;&#x2F;声明一个Simpledesign类型的指针，用于存储唯一实例的首地址，并且不对外开放
    Simpledesign()&#123;&#125;                                 &#x2F;&#x2F;将构造函数声明为私有
public:
    static Simpledesign *Getinstance()               &#x2F;&#x2F;定义一个静态成员函数，创建单例
    &#123;
        if(instance&#x3D;&#x3D;0)instance&#x3D;new Simpledesign();  &#x2F;&#x2F;当instance为NULL时，new一个Simpledesign实例
        return instance;                             &#x2F;&#x2F;返回instance，实际上每次调用返回的都是第一次的Simpledesign对象首地址
    &#125;
&#125;;
Simpledesign Simpledesign::*instance&#x3D;NULL;           &#x2F;&#x2F;将instance初始化为NULL
int main()
&#123;
    Simpledesign *s1,*s2;
    s1&#x3D;Simpledesign::Getinstance();                  &#x2F;&#x2F;类外直接调用Simpledesign类的静态成员函数
    s2&#x3D;Simpledesign::Getinstance();
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="常对象常成员"><a class="markdownIt-Anchor" href="#常对象常成员"></a> 常对象，常成员</h1>
<p>如果某个对象不允许被修改，则称该对象为常对象，c++使用const来定义常对象，const也可以用来限制类的数据成员和成员函数，分别称为类的常数据成员和常成员函数<br>
常对象和常成员明确规定了程序中各种对象的变与不变的界限，从而进一步增强了c++程序的安全性和可控性</p>
<h2 id="常对象"><a class="markdownIt-Anchor" href="#常对象"></a> 常对象</h2>
<p>常对象的值不能被修改，常对象不能访问非常成员函数(访问非常成员函数的话就有修改数据的权限了)，只能调用常成员函数，如：</p>
<blockquote>
<p>const Clock c1(9,9,9);Clock c2(10,10,10);</p>
</blockquote>
<p>此时类似c1=c2,c1.ShowTime() 编译器都会报错</p>
<p>常对象使用场合通常是：</p>
<ul>
<li>函数返回值</li>
<li>函数形参(常引用)</li>
</ul>
<p>当对象作为参数传递进入函数时，如果不希望对象在函数内部被修改时，就可以定义为常对象的形式将其传入函数</p>
<h2 id="常数据成员"><a class="markdownIt-Anchor" href="#常数据成员"></a> 常数据成员</h2>
<p>常数据成员声明的基本格式：</p>
<blockquote>
<p>const 类型名 数据成员名 （或者const 放到类型名后面)</p>
</blockquote>
<p>注意，一般的常数据成员只能通过初始化列表的形式获得初值，静态常数据成员还是一样在类声明体外进行初始化，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class A
&#123;
private:
    const int &amp;r,a;
    static const int b;
public:
    A(int i):a(i),r(a)&#123;&#125;         &#x2F;&#x2F;因为a,r已经被声明为const不能赋值，使用形如A(int i)&#123;a&#x3D;i,r&#x3D;a&#125;的形式编译器会报错
    void Display()               &#x2F;&#x2F;所以只能通过表达式表的形式初始化
    &#123;
        cout&lt;&lt;a&lt;&lt;&#39; &#39;&lt;&lt;r&lt;&lt;endl;
    &#125;
&#125;;
const int A::b&#x3D;n;                &#x2F;&#x2F;与一般的静态数据成员一样，在类外定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="常成员函数"><a class="markdownIt-Anchor" href="#常成员函数"></a> 常成员函数</h2>
<p>常成员函数不能修改对象的非静态数据成员的值(大概是因为this指针是const对象指针类型的吧)，也不能调用该类中没有用const修饰的成员函数，其基本格式为：</p>
<blockquote>
<p>返回类型 成员函数名(参数表) const;      表示这个函数对类不会进行任何修改</p>
</blockquote>
<p>可以理解为常成员函数是供常对象操作的(不过非常对象和成员函数也是可以调用常成员函数的)</p>
<p>注意，const修饰成员函数时，放在函数名前面和后面所起的作用是不一样的：</p>
<ul>
<li>const放在函数名后，表明这个函数是常成员函数，不会对这个类对象的数据成员(准确地说是非静态数据成员)作任何改变
<ul>
<li>并且限定常对象只能调用这类常成员函数</li>
</ul>
</li>
<li>const放在函数名前面，表示函数的返回类型是常量，不能修改</li>
<li>const可以参与重载函数的区分，即可以将成员函数定义为常成员来进行重载，const重载主要是通过能否对传入的参数进行修改判断的
<ul>
<li>注意是要定义函数成员为常成员才算重载，如果是修饰参数的话则与非类成员函数的一般重载规则是一致的</li>
</ul>
</li>
</ul>
<h2 id="补充const修饰指针的情况"><a class="markdownIt-Anchor" href="#补充const修饰指针的情况"></a> 补充：const修饰指针的情况</h2>
<p>先确定一个规则：const默认与左边结合，左边没有东西则与右边结合，在这个规则下进行分析。</p>
<ul>
<li>const int*a
<ul>
<li>const与int结合，因此变量a是一个指向常量整型的指针。</li>
</ul>
</li>
<li>int const*a
<ul>
<li>const与int结合，因此变量a同const int*。</li>
</ul>
</li>
<li>int*const a
<ul>
<li>const与*结合，因此变量a是一个指向整型的常量指针。</li>
</ul>
</li>
<li>const int*const a
<ul>
<li>第1个const与int结合，第2个const与*结合，因此变量a是一个指向常量整型的常量指针。</li>
</ul>
</li>
<li>int const*const a
<ul>
<li>第1个const与int结合，第2个const与*结合，因此变量a与上同。</li>
</ul>
</li>
<li>int const* const*a
<ul>
<li>第1个const与int结合，第2个const与左边的* 结合，而变量a前还有1个多出来的* ，因此变量a是一个二级指针，即指向const int* const或int const*中常量指针的指针。</li>
</ul>
</li>
<li>int const* const*const a
<ul>
<li>第1个const与int结合，第2个const与左边的* 结合，第3个const也与左边的* 结合，因此变量a是一个常量二级指针，即指向const int* const或int const*中常量指针的常量指针。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>对象指针、对象数组、对象引用</title>
    <url>/posts/aaae95315f34</url>
    <content><![CDATA[<h1 id="对象指针"><a class="markdownIt-Anchor" href="#对象指针"></a> 对象指针</h1>
<p>与c语言类似，c++可以通过使用指向对象的指针变量来访问对象及对象的公共成员<br>
定义和用法与结构体指针相似，也是数据类型加指针名的形式，如：</p>
<blockquote>
<p>class Clock{public:void ShowTime();};<br>
Clock clock,*p=&amp;clock;p-&gt;ShowTime();</p>
</blockquote>
<span id="more"></span>
<h2 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h2>
<p>c++为每个<strong>非静态成员函数</strong>都提供了一个<strong>关键字</strong>this，代表一个指针，this指针是一个隐含的指针常量，指向被成员函数操作的那个对象，即当前类变量(对象)的首地址<br>
this的值具有特殊的含义，总是指向当前调用对象，因此值不能修改，只能用在类的内部，通过this可以访问类的所有访问属性的成员，this虽然用在类的内部，但是只有在对象被创建以后才会给this指针赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给this指针赋值。<br>
在构造函数中使用this指针会存在问题，应该尽量避免，因为通常this指针在对象构造完毕后才完全生成，而在构造函数执行过程中，对象还没有完全生成，所以this指针也是没有完全生成的</p>
<p>当成员函数的参数和成员变量重名，只能通过this区分，例：</p>
<blockquote>
<p>class Counter{int value;void SetValue(int value);}<br>
Counter counter;counter SetValue(10);</p>
</blockquote>
<p>此例中数据成员和成员函数的形参(局部变量)同名，因此在调用成员函数时其内部操作的value变量是成员函数内的局部变量，而不是对象的value成员，所以在SetValue()中可以使用this-&gt;value，来对类的value成员和成员函数SetValue()中的value变量加以区分<br>
(或者干脆不要让成员函数的变量与类的成员数据同名，比如使用SetValue(int v)😉</p>
<p>this是关键字，不能声明与this同名的变量<br>
this不能显示声明，还因为它是非静态成员函数的一个形参，在声明成员函数时会被隐含地调用，如：</p>
<blockquote>
<p>void SetValue(Counter *this,int value); 编译器做了特殊处理，隐含地加上了名为this的形参<br>
SetValue(&amp;counter,10);          在调用时<strong>隐含地</strong>将对象的首地址作为第一个参数传递，因此编译器可以通过this指针的值找到对象</p>
</blockquote>
<p>this指针示例程序:</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
class Student&#123;
public:
    void setname(char *name);
    void setage(int age);
    void setscore(float score);
    void show();
private:
    char *name;
    int age;
    float score;
&#125;;
void Student::setname(char *name)&#123;
    this-&gt;name&#x3D;name;
&#125;
void Student::setage(int age)&#123;
    this-&gt;age&#x3D;age;
&#125;
void Student::setscore(float score)&#123;
    this-&gt;score&#x3D;score;
&#125;
void Student::show()&#123;
    cout&lt;&#96;&lt;this-&gt;&#96;name&lt;&lt;&quot;的年龄是&quot;&lt;&#96;&lt;this-&gt;&#96;age&lt;&lt;&quot;，成绩是&quot;&lt;&#96;&lt;this-&gt;&#96;score&lt;&lt;endl;
&#125;
int main()&#123;
    Student *pstu &#x3D; new Student;
    pstu-&gt;setname(&quot;李华&quot;);
    pstu-&gt;setage(16);
    pstu-&gt;setscore(96.5);
    pstu-&gt;show();              输出结果：李华的年龄是16，成绩是96.5
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于this指针的存在，出现了一个衍生的问题，那就是对象中成员函数(以下默认是非静态成员)的引用问题。类和对象有一个特性很有意思，那就是对于数据成员来说它们分布于每个对象实例当中，由对象来维护；但是对于成员函数来说，实际上是所有对象共享类的一组操作，因此是由类本身来维护的，并在使用时通过this指针来与调用对象进行绑定。因此，但需要引用一个对象中的成员函数时，此时这个函数指针的this指针相当于已经绑定了(因为this指针的初始化是在对象构造完毕后就进行的，不是在调用时才赋值)，因此这this所指向的成员函数指针实际上已经带有了对象的信息，与单纯的函数指针的语义是不同的。如果将对象成员函数指针向普通函数指针一样使用的话，编译器报错，此时要使用类的成员函数指针必须采取以下格式：</p>
<blockquote>
<p>typedef 返回值 (类名::*指针类型名)(参数列表);  声明一个类的成员函数指针类型<br>
指针类型名  指针名 = &amp;类名::成员函数名;        使用类的成员函数对类的成员函数指针进行赋值(必须加&amp;，否则编译器会认为是在这里调用成员函数)<br>
(类对象.*指针名)(参数列表);                   对象调用成员函数指针所指向的成员函数<br>
(类指针-&gt;*指针名)(参数列表);</p>
</blockquote>
<p>静态成员函数属于类本身，没有this指针，因此直接将其看作普通的函数指针也没问题。</p>
<h1 id="对象数组"><a class="markdownIt-Anchor" href="#对象数组"></a> 对象数组</h1>
<p>与其他数据类型一样，可以创建一个类的对象数组，如：</p>
<blockquote>
<p>Clock clock[n];</p>
</blockquote>
<p>通过下标访问数组中的对象，进而访问该对象的公有数据成员，如：</p>
<blockquote>
<p>Clock[i].ShowTime();</p>
</blockquote>
<p>对于对象数组而言，如果没有显式定义，则自动调用该类的构造函数进行初始化<br>
对象数组的初始化实际就是调用构造函数对每个元素进行初始化的过程，同理在销毁时也要挨个调用析构函数<br>
如果在声明数组时给出每一个数组元素的初始值，在初始化过程中就会调用最匹配的构造函数，如：</p>
<blockquote>
<p>class Point{public:float x,y;Point(){x=0,y=0;},Point(float a){x=a,y=0;},Point(float a,float b){x=a,y=b;}};<br>
Point point[3]={Point(5.5),Point(6.5,7.5)};</p>
</blockquote>
<p>其中Point(5.5)按Point(float a);定义，Point(6.5,7.5)按Point(float a,float b)定义，第三个元素未显式定义的按照最佳匹配Point()进行定义</p>
<p>同样的可以通过对象指针对数组元素进行快速访问，如：</p>
<blockquote>
<p>Point *p=point;p++; 每次移动一个对象长度的空间</p>
</blockquote>
<h1 id="对象引用"><a class="markdownIt-Anchor" href="#对象引用"></a> 对象引用</h1>
<p>对象引用，就是给某类对象定义一个引用，其实质是通过将被引用对象的地址赋给引用对象，使二者指向同一内存空间<br>
这样引用对象就成了被引用对象的别名<br>
对象引用的定义和用法与结构体变量引用的定义相同，如：</p>
<blockquote>
<p>Clock &amp;cr=clock;cr.ShowTime()   定义了clock的对象引用，并使用对象的成员</p>
</blockquote>
<p>对象引用通常用作函数的参数及返回值，不仅具有对象指针的优点，而且比对象指针更简洁，方便，直观</p>
<h1 id="类作为函数参数"><a class="markdownIt-Anchor" href="#类作为函数参数"></a> 类作为函数参数</h1>
<p>常见的有三种方式：(跟结构体作参数的情况类似)</p>
<ul>
<li>对象本身作为参数
<ul>
<li>这种情况一般自定义一个拷贝构造函数，以免出现未知错误</li>
<li>c++采用传值的方式传递参数，因此使用对象本身作为参数时，形参是实参的一个拷贝，相当于重新创建了一个对象，并且如果要作为返回值的话还要在创建一个\</li>
<li>因此类对象作为函数参数往往需要调用拷贝构造函数，时间空间开销都比较大，效率极低</li>
</ul>
</li>
<li>对象引用作为函数参数
<ul>
<li>c++比较推荐的一种方式，比对象本身或对象指针做参数都容易理解和使用，同时没有任何副作用</li>
</ul>
</li>
<li>对象指针作为函数参数
<ul>
<li>对象指针指向实参对象，通过间接方式访问和修改指向的对象，实际就是在访问和修改实参对象</li>
</ul>
</li>
</ul>
<p>对象指针是三种方式里面效率最高的，因为在节省空间的同时还可以进行一些地址方面的操作，比引用更灵活</p>
<p>三种复合类型做函数参数方式的示例程序：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class Counter
&#123;
private:
    int value;
public:
    Counter(int v)
    &#123;
        value&#x3D;v;
    &#125;
    void add(int v)
    &#123;
        value+&#x3D;v;
    &#125;
    void show( )
    &#123;
        cout&lt;&lt;value&lt;&lt;endl;
    &#125;
&#125;;
Counter func1(Counter &amp;obj)
&#123;
    obj.add(6);
    return obj;
&#125;
Counter func2(Counter *obj)
&#123;
    obj-&gt;add(6);
    return *obj;
&#125;
int main( )
&#123;
    Counter b1&#x3D;5;
    Counter b2&#x3D;func1(b1);
    Counter &amp;b3&#x3D;b1,*b4&#x3D;&amp;b1;
    func1(b2);
    func1(b3);
    func2(b4);
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数、析构函数</title>
    <url>/posts/2597eea773d1</url>
    <content><![CDATA[<h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1>
<p>自动解决数据成员的初始化问题<br>
构造函数是类的一种特殊成员，本质上也是类的成员函数，函数名和类名相同，注意构造函数没有返回类型(因为没有变量来接收返回值)，可以有参数也可以没有<br>
不论声明还是定义，构造函数名前面都不能出现返回值类型，函数体中不能有return语句</p>
<span id="more"></span>
<p>当创建类的一个新对象时，构造函数被自动调用，完成对象的初始化工作，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Clock
&#123;
private:
    int hour,minute,second;
public:
    Clock(int h,int m,int s):hour(h),minute(m),second(s)&#123;&#125;;
&#125;;
int main()&#123;
    Clock clock(1,2,3);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="实现构造函数"><a class="markdownIt-Anchor" href="#实现构造函数"></a> 实现构造函数</h2>
<p>声明构造函数后需要实现构造函数：初始化数据成员</p>
<p>有两种实现构造函数的方式<br>
(在c++11的扩展以前，类的声明体内是不能初始化成员变量的，只有一个特例是static const int类型)</p>
<ul>
<li>赋值语句的方式：</li>
</ul>
<blockquote>
<p>Clock(int h,int m,int s){hour=h,minte=m,second=s;}</p>
</blockquote>
<ul>
<li>参数初始化表的方式：</li>
</ul>
<blockquote>
<p>Clock(int h,int m,int s):hour(h),minute(m),second(s){}</p>
</blockquote>
<p>需要注意的是在函数首部的小括号后面，参数初始化表前加上’:’，定义函数需要加上花括号</p>
<p>只对比两种构造方法本身的话，参数初始化表并没有效率上的优势，但是书写方便，尤其是成员变量较多时，这种写法非常简明明了，并且对于类的const成员，只能使用初始化列表，而不能在构造函数内部进行赋值操作。实际上更准确的来说，采用赋值语句的方式只能叫<strong>赋值</strong>而不能叫<strong>初始化</strong>，构造函数的初始化过程默认是在读取初始化表后完成的，因此如果不在初始化表中完成const成员的初始化，那么就相当于没有对const成员初始化，所以就产生错误了。<br>
(当然也可以在类定义的时候，就对const成员变量进行赋值，但是这样操作的话这个变量有可能就失去了意义，因为基于这个类生成的所有对象const成员的值都为同一个常量)<br>
另一方面，观察初始化表的形式可以发现对类对象成员的初始化可以直接调用其构造函数，反之如果要在构造函数中以赋值的形式对这些成员进行初始化的话，此时编译器已经调用默认构造函数(默认是无参数形式的，因为此时传入的参数默认是要在构造函数体内使用的)对该对象成员进行初始化了，无法对其再用拷贝构造函数进行初始化，因此往往只能重载=运算符进行赋值，造成其他不必要的开销。(实际上相当于无意义地多调用了一次默认构造函数)<br>
综上，一个好的原则是能使用初始化列表的时候尽量使用初始化列表</p>
<h2 id="使用构造函数进行对象初始化"><a class="markdownIt-Anchor" href="#使用构造函数进行对象初始化"></a> 使用构造函数进行对象初始化</h2>
<h3 id="向构造函数传参"><a class="markdownIt-Anchor" href="#向构造函数传参"></a> 向构造函数传参</h3>
<p>传给构造函数实参有两种方式</p>
<ul>
<li>如果构造函数只有一个参数，可以赋值的形式初始化，基本格式为：</li>
</ul>
<blockquote>
<p>类名 对象名=实参，如：<br>
class Counter{int value;Counter(int v):value(v){}};<br>
Counter counter=10;</p>
</blockquote>
<ul>
<li>如果构造函数有一个或多个参数，可以传入参数列表，</li>
</ul>
<blockquote>
<p>基本格式为：类名 对象名(参数列表)，如：<br>
Counter counter(10);<br>
Clock clock1(1,2,3);</p>
</blockquote>
<ul>
<li>如果构造函数有参数，但在创建对象时没有给出指定位置的参数，编译出错</li>
</ul>
<h2 id="重载构造函数"><a class="markdownIt-Anchor" href="#重载构造函数"></a> 重载构造函数</h2>
<p>一个类可以提供多种不同形式的构造函数，即构造函数的重载<br>
重载的目的是为了满足不同的初始化对象需要，如：</p>
<blockquote>
<p>Clock(int h,int m,int s);<br>
Clock clock(23,12,0);</p>
</blockquote>
<blockquote>
<p>Clock();<br>
Clock clock;  最好不要写成clock(),有的编译环境下默认这是在声明返回类型为Clock的函数</p>
</blockquote>
<blockquote>
<p>Clock(char *timestr);<br>
Clock clock(“23:12:00”);</p>
</blockquote>
<h2 id="具有默认参数的构造函数"><a class="markdownIt-Anchor" href="#具有默认参数的构造函数"></a> 具有默认参数的构造函数</h2>
<p>构造函数也可以有默认参数，如：</p>
<blockquote>
<p>Clock(int h=0,int m=0,int s=0);</p>
</blockquote>
<p>值得注意的是如果在类外实现构造函数时则一般不说明缺省值，因为之前已经声明过了，而构造函数的作用域一般又相同，但是如果两次声明不一致的话，编译器就不知道调用哪个构造函数了<br>
另外也要注意不能与重载函数的匹配格式相同，以免发生冲突</p>
<h2 id="默认构造函数"><a class="markdownIt-Anchor" href="#默认构造函数"></a> 默认构造函数</h2>
<p>对于没有构造函数的类，编译器会自动为其生成一个没有参数，不做任何工作的合成默认构造函数(空构造函数)<br>
但是只要声明了一个任何形式的构造函数，系统自定义的构造函数就没有了，此时如果还需要一个空构造函数的话，必须再重载一个<br>
因此对于一个对象而言，无论是否定义了构造函数，在生成对象时都一定会有一个构造函数被调用</p>
<p>注意：合成默认构造函数<strong>不会</strong>初始化类的内置类型及复合类型的数据成员<br>
从本质上来说，对类中的内置变量和复合变量的初始化是编程者份内的事，并不应当作为编译器的任务，编译器要做的仅仅是合成一个构造函数能使对象创建起来并保证基本情况的运行，哪怕这个构造函数什么都没做，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Test&#123;
public:             &#x2F;&#x2F;没有显式定义的构造函数
    int num;  
    bool istrue;
&#125;;
int main()&#123;
    Test test;
    if(istrue)printf(&quot;%d&quot;,test.num); &#x2F;&#x2F; 这里程序运行的行为是未定义的
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有在编译器需要默认构造函数来<strong>完成编译任务</strong>的时候，编译器才会为没有任何构造函数的类合成一个默认构造函数，或者是把这些操作插入到已有的构造函数中去。</p>
<ul>
<li>调用对象成员或基类的默认构造函数</li>
<li>为对象初始化虚表指针与虚基类指针</li>
</ul>
<p>合成的过程类似于在一个构造函数中嵌入另一个构造函数，如：</p>
<blockquote>
<p>A::A(int va):a(va);<br>
假设B是A的成员对象类或基类等情况需要调用构造函数<br>
当需要合成默认构造函数时，编译器的行为类似于在A()中嵌套一个空的构造函数<br>
A::A(int va):a(va){B::B();};</p>
</blockquote>
<h1 id="析构函数"><a class="markdownIt-Anchor" href="#析构函数"></a> 析构函数</h1>
<p>有时在释放类时需要做一些收尾工作，此时可能因为忘记调用这些做收尾工作的函数而出现问题，对此c++提供了析构函数专门用于处理对象销毁时的清理工作，与构造函数相对应<br>
析构函数没有返回类型，没有参数，函数名是在类名前加’~’，调用方法与其他成员函数相同，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Clock
&#123;
private:
    int hour,minute,second;
public:
    Clock(int h,int m,int s);
    ~Clock();
&#125;;
Clock::~Clock()&#123;cout&lt;&lt;&quot;对象已销毁&quot;&lt;&lt;endl;&#125;
int main()&#123;
    Clock clock(1,1,1);
    clock.~Clock();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>析构函数会在对象生存期结束后被自动调用<br>
同构造函数，如果没有显示声明，编译器自动生成一个缺省的空析构函数<br>
析构函数尤其在对象中成员的生命期不一致时具有较大的意义(这实际是因为默认析构函数的行为和正常的内存回收机制一样，不能回收堆内存，堆内存必须手动释放)</p>
<blockquote>
<p>如：对象初始化时使用指针指向动态内存，在对象生存期结束之前就应该释放掉该内存空间，因此这类操作一般在析构函数中进行处理</p>
</blockquote>
<p>此处再次强调！动态内存分配极容易出错，导致崩溃</p>
<ul>
<li>删除动态内存失败</li>
<li>读写已删除的对象</li>
<li>对同一内存空间使用多次delete(一个指针情况下多次删除)</li>
</ul>
<h1 id="拷贝构造函数"><a class="markdownIt-Anchor" href="#拷贝构造函数"></a> 拷贝构造函数</h1>
<p>如果将与自己同类的对象的引用作为参数进行构造函数初始化，该构造函数称为拷贝构造函数，如：</p>
<blockquote>
<p>Clock(Clock &amp;obj):hour=obj.hour,minute=obj.minute,second=obj.second{}</p>
</blockquote>
<p>调用拷贝构造函数进行对象初始化同样也有两种方法：直接调用和赋值形式</p>
<blockquote>
<p>Clock clock1(1,2,3);<br>
Clock clock2(clock1),clock3=clock1;</p>
</blockquote>
<p>注意用等号赋值的形式并不是真正的用对象赋值，而是调用了<strong>拷贝赋值函数</strong>(实质上这里的赋值运算符是编译器的默认运算重载符函数)<br>
拷贝构造函数的特点：</p>
<ul>
<li>首先，拷贝构造函数实质上就是一个构造函数，创建对象时系统会自动调用</li>
<li>其次，拷贝构造函数将一个已经创建好的对象作为参数，根据需要将该对象中的数据成员逐一对应地赋值给新对象</li>
</ul>
<p>如果没有定义拷贝构造函数，则编译器也会为该类定义一个<strong>缺省的拷贝构造函数</strong>，缺省的拷贝构造函数采用的是精确的<strong>位拷贝</strong>(拷贝内存)方法来完成对象到对象的复制，将第一个对象的数据成员值原封不动拷贝到第二个对象数据成员中，如：</p>
<blockquote>
<p>Clock clock1(1,2,3),clock2=clock1;<br>
std::cout&lt;&lt;memcmp(&amp;clock1,&amp;clock2,sizeof(Clock));输出结果为0</p>
</blockquote>
<p>注意：这是在成员都没有自定义的拷贝构造函数时才这么做(其实这种情况和结构体很类似，因此都采用位拷贝模式)<br>
如果一个类：</p>
<ul>
<li>本身包含、从基类继承、类的成员对象包含了虚函数</li>
<li>成员变量有显式的拷贝构造函数</li>
</ul>
<p>那么显然不能采用位拷贝的模式，此时是按成员拷贝的</p>
<p>除创建新对象时可能被调用外，拷贝构造函数还经常在以下情况被调用：</p>
<ul>
<li>对象作为函数参数</li>
<li>函数返回对象</li>
</ul>
<p>构造函数，析构函数，拷贝构造函数实例程序：自定义简易的Cstring类</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
const int n&#x3D;64;
class Cstring
&#123;
private:
    int size;
    char *str;
public:
    Cstring(int len);
    Cstring(Cstring &amp;cstring);
    void Copystring(char *string);
    void Showstring();
    ~Cstring();
&#125;;
Cstring::Cstring(int len):size(len)
&#123;
    str&#x3D;new char[size];
&#125;
Cstring::Cstring(Cstring &amp;cstring):size(cstring.size)
&#123;
    str&#x3D;new char[size];
    strcpy(str,cstring.str);
&#125;
void Cstring::Copystring(char *string)
&#123;
    strcpy(str,string);
    return;
&#125;
void Cstring::Showstring()
&#123;
    cout&lt;&lt;str;
&#125;
Cstring::~Cstring()
&#123;
    delete []str;                    &#x2F;&#x2F;析构函数中释放从堆中分配的内存
&#125;
void func1()
&#123;
    Cstring cstring1(n),cstring2&#x3D;cstring1;
    cstring1.Copystring(&quot;hello&quot;);
    cstring2.Copystring(&quot;world&quot;);
    cstring1.Showstring();
    cstring2.Showstring();
    cstring1.~Cstring();
    cstring2.~Cstring();             &#x2F;&#x2F;试想如果此处不释放内存的话，func函数被调用结束后，cstring对象被释放，但其中动态分配的空间并没有被释放
&#125;                                    &#x2F;&#x2F;很可能发生崩溃
Cstring func2(Cstring cstring)
&#123;
    cstring.Copystring(&quot;hello world&quot;);
    return cstring;
&#125;
int main()
&#123;
    Cstring cstring1(n),cstring2(n);
    func1();
    cstring2&#x3D;func2(cstring1);       &#x2F;&#x2F;第一次缺省的拷贝构造函数调用：形参cstring初始化为实参cstring1的值
    cstring2.Showstring();          &#x2F;&#x2F;第二次缺省的拷贝构造函数调用：func2()返回局部变量cstring时使用临时变量存储cstring的值
&#125;                                   &#x2F;&#x2F;第三次缺省的拷贝构造函数调用：使用cstring2接受func2(cstring1)的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>类和对象</title>
    <url>/posts/6ab4fe401c45</url>
    <content><![CDATA[<h1 id="面向对象技术"><a class="markdownIt-Anchor" href="#面向对象技术"></a> 面向对象技术</h1>
<p>面向对象技术几大关键特征：</p>
<ul>
<li>数据抽象，封装
<ul>
<li>类实现</li>
</ul>
</li>
<li>继承
<ul>
<li>类派生，能更容易地定义与其他类相似却又不相同的新类，并编写忽略相似类型之间区别的程序</li>
</ul>
</li>
<li>动态绑定
<ul>
<li>编译器在运行时决定使用基类中定义的函数还是派生类中定义的函数</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h2 id="抽象"><a class="markdownIt-Anchor" href="#抽象"></a> 抽象</h2>
<p>抽象是对具体问题(对象)进行概括，提炼出这一类对象的公共性质并加以描述的过程<br>
先注意问题的本质及描述，其次是实现过程或细节</p>
<blockquote>
<p>数据抽象：描述某类事物(对象)共有的属性或状态<br>
行为抽象：描述某类事物(对象)共有的行为特征或具有的功能</p>
</blockquote>
<p>抽象是相对的，而非绝对的<br>
研究问题时，如果侧重点不同，可能产生不同的抽象结果<br>
解决同一问题时要求不同，也可能产生不同的抽象结果</p>
<blockquote>
<p>开发一个人事管理软件，关心的是员工的姓名，性别，工龄，工资，工作部门等相关信息<br>
如果开发学籍管理系统，那么关心的是学生的姓名，性别，年龄，籍贯，所在学院等相关信息</p>
</blockquote>
<p>抽象定义了一个事物的本质，从软件设计的角度而言，使用类的封装机制来实现抽象</p>
<h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<p>类也是一种自定义的构造数据类型</p>
<h3 id="定义和使用类的基本过程"><a class="markdownIt-Anchor" href="#定义和使用类的基本过程"></a> 定义和使用类的基本过程</h3>
<ul>
<li>对事物进行抽象</li>
<li>根据抽象结果定义类的特性</li>
<li>实现类中成员函数的逻辑</li>
<li>定义类的实例，使用类的公有成员</li>
</ul>
<h3 id="类的声明"><a class="markdownIt-Anchor" href="#类的声明"></a> 类的声明</h3>
<p>类是一种<strong>抽象数据类型</strong><br>
抽象数据类型是指一组特定的数据类型和在该数据之上的一组操作<br>
这里与抽象数据类型相对应的基本数据类型包括：整型，浮点型，字符，集合，序列，字典，栈，队列，优先队列，图，树等已经定义的数据类型/数据结构<br>
另外数组，链表，哈希等都是具体的可以直接拿来用，除基本数据类型外不能直接拿来用的都是抽象的(取决于所在集合中是否定义这一类型)</p>
<p>声明的基本形式如下：形式与结构体相似</p>
<blockquote>
<p>class 类名{数据成员;函数成员;};</p>
</blockquote>
<p>class关键字用于声明一个类，类名通常大驼峰命名；<br>
成员数据、函数分别用于表达数据抽象和行为抽象</p>
<p>例：声明时钟类</p>
<pre class="line-numbers language-none"><code class="language-none">class Clock
&#123;
    char Name[10],Supplier[20];
    int Hour,Minute,Second;
    void SetTime(int h,int m,int s);
    void CheckTime(int h,int m,int s);
    void ShowTime();
&#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="访问控制"><a class="markdownIt-Anchor" href="#访问控制"></a> 访问控制</h3>
<p>“类内”和“类外”。在类的声明以内成为类内，类的声明以外称为类外<br>
数据封装的目的就是信息隐藏。为达到信息隐蔽，在c++类中，并非所有成员都是对外可见的(类外可以访问)<br>
为了控制部分成员类外不可用，部分可用，可通过设置成员的访问控制属性实现对类成员的访问控制<br>
这些控制属性有：public,private,protected，如：</p>
<blockquote>
<p>class ClassName{public:公有成员;private:私有成员;protected:保护成员;};</p>
</blockquote>
<p>public成员在类外部可见可用，private和protected成员在类外部不可见不可用，如果不特别指定默认成员是私有的<br>
关键字public后声明的公有成员是类与外部的接口(对外提供的功能/行为/服务等的操作集)</p>
<p>任何类内，类外函数均可访问公有数据和函数，如：</p>
<blockquote>
<p>public:<br>
char Name[10];                        公有数据，时钟名字<br>
void ShowTime();                      公有函数，展示时间</p>
</blockquote>
<p>关键字private后声明的私有成员只允许本类中函数访问，任何类外函数都不能访问，例：</p>
<blockquote>
<p>private：<br>
int Hour,Minute,Second;               私有数据，时间单位的组成：时，分，秒<br>
void CheckTime(int h,int m,int s);    私有函数，检查时间格式</p>
</blockquote>
<p>关键字protected后声明的保护成员对类外成员的情况与private类似，两者区别表现在继承/派生时对派生类的影响不同，例：</p>
<blockquote>
<p>protected：<br>
char Supplier[20];                    保护数据，时钟出产厂商<br>
void SetTime(int h,int m,int s);      保护函数，设置时间</p>
</blockquote>
<p>声明类时，不同访问属性的声明顺序可以任意，并且同一修饰访问属性可以多次声明，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class ClassName&#123;
public:
    int a,b;
public:
    int add(int a,int b);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个成员只能有一种访问属性，否则会出现歧义，编译器会报错。不同访问属性可以声明多次，并且顺序是任意的。</p>
<p>另外比较有意思的一点是：虽然无法通过在类外使用对象(或对应类型的指针、引用)直接访问其私有、保护数据，但假如你明确知道对象的构成或<strong>内存分布</strong>，那么还是可以直接访问到内存某一位置的数据，例：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
unsing namespace std;
class A&#123; 
public:
    A(int a,int b,int c);
private:
    int m_a;
    int m_b;
    int m_c;
&#125;; 
A::A(int a,int b,int c):m_a(a),m_b(b),m_c(c)&#123;&#125; 
int main()&#123;
    A obj(10,20,30); 
    int a&#x3D;*(int*)&amp;obj;  
    int b&#x3D;*(int*)(&amp;obj+sizeof(int));  
    int c&#x3D;*(int*)(&amp;obj+2*sizeof(int)); 
    cout&lt;&lt;&quot;a&#x3D;&quot;&lt;&lt;a&lt;&lt;&quot;,b&#x3D;&quot;&lt;&lt;b&lt;&lt;&quot;,c&#x3D;&quot;&lt;&lt;c&lt;&lt;endl;  &#x2F;&#x2F;可能输出正确结果：a&#x3D;10,b&#x3D;20,c&#x3D;30 
    &#x2F;&#x2F;主要是对象内存字节分布中可能存在碎片，如果真的想详细研究这个问题的话也许可以按位读吧，总之问题先留着暂时略过
    return 0;   
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从此可以看出访问限制是针对对象语法层次的，大概对取成员运算符.和-&gt;起作用，实际内存还是可以读取</p>
<h3 id="类的实现"><a class="markdownIt-Anchor" href="#类的实现"></a> 类的实现</h3>
<p>实现一个类，就是按照所设定的功能语义去实现类中的每个成员函数<br>
可以在类内实现成员函数，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Clock
&#123;
    char Name[10],Supplier[20];
    int Hour,Minute,Second;
    void SetTime(int h,int m,int s)       &#x2F;&#x2F;类内实现函数，编译器优先按内联函数处理
    &#123;
        Hour&#x3D;h,Minute&#x3D;m,Second&#x3D;s;
    &#125;
    void CheckTime(int h,int m,int s);
    void ShowTime();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>也可以在类内只声明函数原型，在类外实现成员函数，例：</p>
<pre class="line-numbers language-none"><code class="language-none">void Clock::ShowTime()                    &#x2F;&#x2F;::作用域符标识成员的作用域，限定成员的作用范围，如果前面不指定范围的话默认是全局的
&#123;
    cout&lt;&lt;&quot;Current Time:&quot;;
    cout&lt;&lt;Hour&lt;&lt;&#39;:&#39;&lt;&lt;Minute&lt;&lt;&#39;:&#39;&lt;&lt;Second&lt;&lt;endl;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="类的使用对象"><a class="markdownIt-Anchor" href="#类的使用对象"></a> 类的使用——对象</h2>
<p>与结构体非常相似，类是一种数据类型，而定义的类类型的变量称为类的实例，即对象<br>
定义对象的基本格式：</p>
<blockquote>
<p>类名 对象名   如：Clock aclock;</p>
</blockquote>
<p>现实世界的事物抽象出事物的种类，映射到计算机世界就是类，类的实例化就是对象，对象就是现实世界各种事物在计算机中的映射</p>
<h3 id="访问类成员的方法"><a class="markdownIt-Anchor" href="#访问类成员的方法"></a> 访问类成员的方法</h3>
<p>通过对象来访问成员，基本格式：</p>
<blockquote>
<p>对象名.公有成员函数名(实参列表);  如：aclock.ShowTime();<br>
对象名.公有数据成员                如：<a href="http://aclock.Name">aclock.Name</a></p>
</blockquote>
<p>通过对象指针访问成员，基本格式：</p>
<blockquote>
<p>对象指针-&gt;公有成员函数名(实参列表);  如：clock *c=aclock;c-&gt;ShowTime();<br>
对象指针-&gt;公有数据成员               如：c-&gt;Name</p>
</blockquote>
<p>定义类变量时，每个变量包含了类中各数据成员的存储空间，但共享类中的成员函数(成员函数入口在访问时被调用或替换，不会在每个变量中都存储)<br>
每个成员函数的功能相同，只有数据不同，例：</p>
<pre class="line-numbers language-none"><code class="language-none">class Clock&#123;
private:
    int Hour;
public:
    void SetTime(int h);
    void addHour(int h);
    void ShowTime();
&#125;;
void Clock::SetTime(int h)&#123;Hour&#x3D;h;&#125;
void Clock::addHour(int h)&#123;Hour+&#x3D;h;&#125;
void Clock::ShowTime()&#123;cout&lt;&lt;&quot;Current Time:&quot;;cout&lt;&lt;Hour&lt;&lt;&quot; &quot;;&#125;
int main()&#123;
    Clock clock1,clock2,*c1&#x3D;&amp;clock1,*c2&#x3D;NULL;
    clock1.SetTime(15),clock2.SetTime(16);
    clock1.addHour(7),clock2.addHour(9);
    clock1.ShowTime(),clock2.ShowTime();
    c1-&gt;SetTime(18),c2&#x3D;c1;
    c2-&gt;SetTime(19);
    c1-&gt;ShowTime();
    c2-&gt;ShowTime();
&#125;
&#x2F;&#x2F; 输出结果:Current Time:22 Current Time:25 Current Time:19 Current Time:19<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过类对象访问类也是在类外访问，因此不能访问私有和保护成员，只有类内的函数才是类自身的一部分</p>
<p>类与对象示例程序：实现简单的int数组类<br>
写代码前：抽象</p>
<ul>
<li>数据抽象
<ul>
<li>数组大小，数组所占据的内存区(首地址)</li>
</ul>
</li>
<li>行为抽象
<ul>
<li>能够获得数组的大小，能够将数据保存到数组中，能够获得数组中保存数据的最大值，最小值</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
const int n&#x3D;50;
class IntArray
&#123;
private:
    int size,*data;
public:
    void SetArray(int len,int *in);
    int GetSize();
    void Append(int pos,int value);
    int GetMaxMin(int condition);
&#125;;
void IntArray::SetArray(int len,int *in)     定义一个初始化函数(此例中没有定义构造函数)
&#123;
    int i;
    size&#x3D;len;
    data&#x3D;new int[len];
    for(i&#x3D;0;i&lt;len;i++)data[i]&#x3D;in[i];
&#125;

int IntArray::GetSize()
&#123;
    return size;
&#125;
void IntArray::Append(int pos,int value)
&#123;
    if(pos&lt;size&amp;&amp;pos&gt;&#x3D;0)data[pos]&#x3D;value;
&#125;
int IntArray::GetMaxMin(int condition)
&#123;
    int i,max&#x3D;*data,min&#x3D;*data;
    for(i&#x3D;0;i&lt;size;i++)
    &#123;
        if(max&lt;data[i])max&#x3D;data[i];
        if(min&gt;data[i])min&#x3D;data[i];
    &#125;
    if(condition&#x3D;&#x3D;0)return min;
    else return max;
&#125;
int main()
&#123;
    IntArray array;
    int i,len,value,in[n];
    cin&gt;&gt;len;
    for(i&#x3D;0;i&lt;len;i++)cin&gt;&gt;in[i];
    array.SetArray(len,in);
    cout&lt;&lt;&quot;数组长度为：&quot;&lt;&lt;array.GetSize()&lt;&lt;endl;
    for(i&#x3D;0;i&lt;array.GetSize();i++)
    &#123;
        cin&gt;&gt;value;
        array.Append(i,value);
    &#125;
    cout&lt;&lt;&quot;最大值是：&quot;&lt;&lt;array.GetMaxMin(1)&lt;&lt;&#39; &#39;&lt;&lt;&quot;最小值是：&quot;&lt;&lt;array.GetMaxMin(0);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数重载、默认形参</title>
    <url>/posts/f522f8bd17a1</url>
    <content><![CDATA[<h1 id="函数重载"><a class="markdownIt-Anchor" href="#函数重载"></a> 函数重载</h1>
<p>函数重载本质上是一种多态性的简单体现(<strong>静态绑定</strong>)</p>
<p>c语言中对不同数据类型的数据进行功能相似的操作时必须编写很多个不同的函数</p>
<blockquote>
<p>如：对两个整数，两个实数，一个整数一个实数，三个整数求和<br>
-&gt;此时需要四个功能相似但名称不同的函数</p>
</blockquote>
<p>而c++中可以让四个函数名称相同，即函数重载</p>
<span id="more"></span>
<p>对两个以上参数的函数具有相同的函数名，但形参个数或类型不同，编译器可以通过实参个数或者类型的最佳匹配自动决定调用哪个函数，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int a,int b)&#123;return a+b;&#125;
float add(float a,float b)&#123;return a+b;&#125;
int add(int a,int b,int c)&#123;return a+b;&#125;
float add(int a,float b)&#123;return a+b;&#125;
int main&#123;
    int a,b,c;float x,y;
    add(a,b);      &#x2F;&#x2F;调用int add(int a,int b)
    add(x,y);      &#x2F;&#x2F;调用float add(float a,float b)
    add(a,b,c);    &#x2F;&#x2F;调用int add(int a,int b,int c)
    add(a,y);      &#x2F;&#x2F;调用float add(int a,float b)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，编译器只会根据形参个数或类型来匹配函数重载，不会根据形参名和返回值(函数类型)匹配，例：<br>
(主要是一般调用的时候并不能指定返回值)</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int a,int b);
int add(int x,int y);                        &#x2F;&#x2F;编译器不能通过形参名区分函数，并且这两个函数在实际调用时没有任何区别
int add(int a,int b)&#123;return a+b;&#125;
float add(int x,int y)&#123;return (float)(x+y);&#125;;&#x2F;&#x2F;理由同上，实际调用时没区别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>不应该把不同功能的函数定义为重载函数，否则使用函数时容易混淆，如：</p>
<blockquote>
<p>int add(int a,int b){return a+b;}<br>
float add(float x,float y){return x-y;}</p>
</blockquote>
<p>函数重载示例程序：自定义Swap函数(不用模板的话)</p>
<pre class="line-numbers language-none"><code class="language-none">#include &lt;iostream&gt;
using namespace std;
void Swap(int *a,int *b)&#123;
    int temp&#x3D;*a;
    *a&#x3D;*b;
    *b&#x3D;temp;
&#125;
void Swap(float *a,float *b)&#123;
    float temp&#x3D;*a;
    *a&#x3D;*b;
    *b&#x3D;temp;
&#125;
void Swap(char *a,char *b)&#123;
    char temp&#x3D;*a;
    *a&#x3D;*b;
    *b&#x3D;temp;
&#125;
void Swap(bool *a,bool *b)&#123;
    char temp&#x3D;*a;
    *a&#x3D;*b;
    *b&#x3D;temp;
&#125;
int main()&#123;
    int n1&#x3D;100,n2&#x3D;200;
    Swap(&amp;n1,&amp;n2);
    cout&lt;&lt;n1&lt;&lt;&quot;, &quot;&lt;&lt;n2&lt;&lt;endl;
    float f1&#x3D;12.5,f2&#x3D;56.93;
    Swap(&amp;f1,&amp;f2);
    cout&lt;&lt;f1&lt;&lt;&quot;, &quot;&lt;&lt;f2&lt;&lt;endl;
    char c1&#x3D;&#39;A&#39;,c2&#x3D;&#39;B&#39;;
    Swap(&amp;c1,&amp;c2);
    cout&lt;&lt;c1&lt;&lt;&quot;, &quot;&lt;&lt;c2&lt;&lt;endl;
    bool b1&#x3D;false,b2&#x3D;true;
    Swap(&amp;b1,&amp;b2);
    cout&lt;&lt;b1&lt;&lt;&quot;, &quot;&lt;&lt;b2&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上，c++代码在编译时编译器会根据参数列表对函数进行重命名，如：</p>
<blockquote>
<p>void Swap(int a, int b)会被重命名为_Swap_int_int，<br>
void Swap(float x, float y)会被重命名为_Swap_float_float</p>
</blockquote>
<p>从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样<br>
如果对类中的成员函数进行重载的话存在两种情况：</p>
<ul>
<li>同一个类中重载，重载函数是以参数的特征进行区分的
<ul>
<li>将成员函数定义为const也算重载</li>
</ul>
</li>
<li>派生类重载基类的成员函数：由于重载函数处于不同的类中，因此它们的原型可以完全相同，调用时使用作用域符可以加以区分(实际上并不能算重载，因为作用域不同)</li>
<li>这两种重载的匹配都是在编译时静态完成的(也就是在编译时命名为不同函数或处于不同符号表中)</li>
</ul>
<p>关于const修饰函数参数算不算重载的问题大概分几种情况</p>
<ul>
<li>const修饰参数为值传递，也就是不用引用、指针参数
<ul>
<li>此时实参实际上是传入参数的一个副本(而且是在栈上的局部变量)，所以怎么修改也不会影响传入参数(尽管在函数内也是禁止修改该局部变量的)，因此加不加const对调用者是没影响的</li>
<li>因此这种情况不算重载，如果定义同名函数其中一个参数为int，另一个是const int，此时还是会报<strong>重定义</strong>错误</li>
</ul>
</li>
<li>const修饰参数为指针，这种情况函数是可能产生副作用的，此时也分两种情况
<ul>
<li>const修饰的是指针所指的基类型，比如:const int* ，这种情况是保护指针所指内容在函数内不能被修改，这种情况和int* 是算<strong>重载</strong>的</li>
<li>const修饰指针变量，比如:int* const，这种情况是指传入的指针变量值在函数不能修改，但指针所指的基类型变量值是可修改的，因此这种情况就和值传递是相通的了，属于<strong>重定义</strong></li>
</ul>
</li>
<li>const修饰参数为引用，如const int&amp;，此时和const int* 的作用类似，保护引用变量内容在函数内不能被修改，因此算<strong>重载</strong>
<ul>
<li>由于&amp;本身就是就是一种常量(从可执行程序的反汇编代码可以看出引用是一种指针常量)，因此实际上不存在int&amp;const的用法</li>
</ul>
</li>
</ul>
<h1 id="默认形参缺省形参"><a class="markdownIt-Anchor" href="#默认形参缺省形参"></a> 默认形参(缺省形参)</h1>
<p>在定义函数时预先声明默认的形参值，即缺省参数。调用时如果给出实参，则用实参初始化形参，否则采用预先声明的默认形参值，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int a&#x3D;1,int b&#x3D;2)&#123;return a+b;&#125;
int main()&#123;
    using namespace std;
    cout&lt;&lt;add(10,20)&lt;&lt;&quot; &quot;&lt;&lt;add(10)&lt;&lt;&quot; &quot;&lt;&lt;add();
&#125;   &#x2F;&#x2F;输出结果：30 12 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>默认形参值可以在函数原型中给出，</p>
<blockquote>
<p>如：int add(int x,int y=1,int z=2);</p>
</blockquote>
<p>默认形参值必须按照从右向左的顺序声明，即在有默认值的形参右边不能出现无默认值的形参，如：</p>
<blockquote>
<p>int add(int x,int y=1,int z=2);    正确<br>
int add(int x=1,int y,int z=2);    错误<br>
int add(int x=1,int y=2,int z);    错误</p>
</blockquote>
<p>原因在于输入实参时是从左向右传递<br>
如果在有默认值的形参右边存在无默认值的形参时，输入的数据会覆盖有默认值的形参，默认值失去了意义，并且后面没有默认值的形参可能传不到值</p>
<p>在相同作用域内，默认形参值应保持唯一，但在不同作用域内，允许声明不同的默认形参值，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int a&#x3D;1,int b&#x3D;2)&#123;return a+b;&#125;      &#x2F;&#x2F;全局的add函数
int func()&#123;return add();&#125;                  &#x2F;&#x2F;返回全局的add函数值
int main()
&#123;
    using namespace std;
    int add(int a&#x3D;3,int b&#x3D;4);              &#x2F;&#x2F;main()内的局部add函数
    cout&lt;&lt;add()&lt;&lt;&quot; &quot;&lt;&lt;func()               &#x2F;&#x2F;输出结果：7 3
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，函数重载和默认形参同时存在时也可能会出错：函数不能既作为重载函数，又作为有默认参数的函数，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int x,int y);
int add(int x,int y,int z&#x3D;3);
int main()&#123;
    int a,b;
    add(1,2);   &#x2F;&#x2F; 此时两个重载都是匹配的，编译器无法决定调用哪个函数 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>常量、内联函数、引用</title>
    <url>/posts/acc21ac0ef42</url>
    <content><![CDATA[<h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1>
<p>常量是指在程序运行过程中，其值不能被改变的量<br>
在程序中直接使用常量会出现可读性差，可维护性差的缺点。通常用符号常量解决常量的问题<br>
c中定义符号常量的方法有两种，第一是宏定义，宏定义不能有赋值符，不能以分号结尾，不进行类型检查，只在编译时进行简单的替换，运行时不占内存空间；<br>
第二是在c99标准中加入的const关键字的使用，但这里const定义的是一个只读的变量，并不是真正的常量(打印内存地址和普通变量、全局变量等对比一下就会发现c语言的const变量实际在栈上)<br>
c++中对const进行了扩展，使其可以真正进行符号常量的定义，基本格式为：</p>
<blockquote>
<p>const 数据类型 符号常量名=数值;</p>
</blockquote>
<p>在声明时<strong>必须初始化</strong>(即使是全局变量)，并且在程序中间不能改变其值(在类的声明中除外，const成员在声明时不需要初始化，但是在实例中必须初始化)<br>
const定义的符号常量在程序运行期间占据内存空间，只是用const来指明该内存空间的只读约束</p>
<span id="more"></span>
<h1 id="内联函数"><a class="markdownIt-Anchor" href="#内联函数"></a> 内联函数</h1>
<p>函数涉及到形参空间的分配，实参到形参的数据拷贝，函数入口的转换等等，时间空间的开销相对较高<br>
而宏定义在编译时进行简单的原样替换时开销非常低，并且适用于大多数参数类型从而达到类似函数重载的效果，但比较容易出现各种不可预料的副作用，如：</p>
<pre class="line-numbers language-none"><code class="language-none">#define abs(a) (a&gt;0?(a):(-a))      &#x2F;&#x2F;输出a的绝对值
int m&#x3D;-2;
cout&lt;&lt;abs(++m);                    &#x2F;&#x2F;输出结果：0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>原因是编译器遇到宏时只是简单的宏替换(++m&gt;0?(++m)😦<ins>m))，自增运算至少进行两次而不是一次，因此无法达到输出绝对值的目的<br>
c</ins>中内联函数既具有宏定义的优点，又克服了宏定义的缺点，内联函数定义基本格式为：</p>
<blockquote>
<p>inline void 函数名(参数列表)</p>
</blockquote>
<p>即在普通函数<strong>定义</strong>基础上在前面加上inline关键字<br>
编译时在调用func的地方用函数体进行了插入替换(注意我这里说的编译是不包含静态链接过程的)，不需要进出系统栈，所以会减少程序执行的调用开销。<br>
由于是函数，所以在运算之前还会进行参数的类型检查，并将参数值传入而不是传入整个表达式，例：</p>
<pre class="line-numbers language-none"><code class="language-none">inline abs(int a)&#123;
    return (a&gt;0?(a):(-a));
&#125;int main()&#123;
    int a&#x3D;-2;
    cout&lt;&lt;abs(a);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，并非所有函数都需要定义为内联函数，一般只会将那些频繁被调用，并且函数体较小的(只有几条语句)函数定义为内联函数。内联函数中一般不应该有循环语句和switch语句，如果有的话执行效率比较低，编译器会自动按照普通函数处理。</p>
<h2 id="inline函数的声明与定义"><a class="markdownIt-Anchor" href="#inline函数的声明与定义"></a> inline函数的声明与定义</h2>
<p>事实上，inline关键字放在函数声明的地方是没有意义的，inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。关于一个函数是否是inline的，这有点类似于一个变量是否是register类型的，函数实际上到底是不是内联的并不取决于声明的时候是否加上inline，而是要看编译器(把预处理器、链接器等当成编译器一部分)最终决定要怎样对其进行实现，用户其实没有必要、也不应该知道函数是否需要内联。<br>
声明一个函数的定义在于让其作用域内的程序知道有这样一个类型的函数存在，至于其有没有被实现在哪里实现，编译过程中一般是无法得知的，只有到了链接过程中发现找不到编译出的函数代码后才能发现错误。inline函数的内联发生在编译期间，并且内联函数是不会在代码区中持久性存储的，如果inline函数的声明和定义分离，尤其是<strong>不在一个编译模块</strong>中(比如不在一个文件中)，此时编译结束后inline并不能内联到其声明的作用域中，就会发生链接错误。<br>
从代码重复利用的角度讲，内联函数不是真正的函数(甚至更类似于宏)，将内联函数作为带参宏的替代方案更为靠谱，而不是真的当做函数使用。在多文件编程时，最好是将内联函数的定义直接放在头文件中，不用inline函数的声明(一是本来就没意义，二是内联函数本来就比较轻量直接定义就行了)。</p>
<h2 id="类的inline成员函数"><a class="markdownIt-Anchor" href="#类的inline成员函数"></a> 类的inline成员函数</h2>
<p>c++中一个的特性是在<strong>类声明体内定义</strong>的函数默认都是内联函数。如果在类内定义内联函数也可以增加inline关键字，但编译器会忽略。将inline成员函数定义体放在类外的话则不需要在类内声明时加上inline(没意义)，并且必须将定义和声明放在同一个头文件(或者从语法角度来说放在同一个源文件里也没问题)。<br>
存在这个特性可能的原因在于：</p>
<ul>
<li>首先在c++项目工程中肯定是多文件编程，而且一般是把类的声明放在头文件中，将其实现放在另一个源文件中，这种将声明与实现分离的做法
<ul>
<li>头文件的意义就是通过预处理器将其包含进其他文件，而预处理器做的就是简单的文本展开(可以理解为一个更大的“宏”)</li>
<li>如果在多个头文件中包含进了多个文件，并且这个头文件里面有函数或类成员的定义，那么展开后就相当于在所有文件中都定义了一遍，链接时这就属于重定向错误</li>
<li>因此在头文件中声明，在另一个源文件中定义，编译后再进行静态链接就可以避免这种问题</li>
</ul>
</li>
<li>类的声明体虽然可以定义函数，但是一般情况下类作为一个oo编程的基本单元是要在多个文件中引入并复用的
<ul>
<li>在类的定义体内定义成员就意味着该类很可能被其他多个文件包含，如果不定义为内联函数的话就很容易出现以上错误，因此c++标准规定类内定义的成员函数默认为内联函数</li>
</ul>
</li>
<li>此外，编译器在定义或合成默认构造函数时也是自动内联的(这一点个人认为主要是默认构造函数太简单了，本来就很适合内联)</li>
</ul>
<h1 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h1>
<p>简单地说，引用就是给一个存储单元起的一个别名，即引用与它所引用的变量共享存储单元<br>
引用常见的有三种用法：独立引用、做函数参数、做函数返回值</p>
<h2 id="独立引用"><a class="markdownIt-Anchor" href="#独立引用"></a> 独立引用</h2>
<p>作为函数参数以及作为函数返回类型，独立引用时必须进行初始化，这种情况下别名绑定是永久的，如：</p>
<blockquote>
<p>int m=8,&amp;pm=m; pm是m的引用，代表一个存储单元</p>
</blockquote>
<p>常见的初始化引用的方式：</p>
<blockquote>
<p>int a,&amp;pa=a;               引用一个变量<br>
const float &amp;pb=1.2;       引用一个常量，引用值不能修改<br>
int x=1;const int &amp;px=x;   定义常引用，引用值不能修改，可以起到只给别人可读权限不给可写权限的目的</p>
</blockquote>
<p>引用绑定后不可再绑定，这体现了引用的“常量”性质(因此也没有类似于typename&amp;const的写法)<br>
实际上，个人认为引用完全可以理解为一个指针常量的解引用</p>
<h2 id="引用作为函数参数"><a class="markdownIt-Anchor" href="#引用作为函数参数"></a> 引用作为函数参数</h2>
<p>引用作为函数参数时是c/c<ins>函数传地址调用的新的方式，效率很高，使用非常直观<br>
和c一样，c</ins>传值调用时实参和形参是两个不同的单元，结合时实参的值会被拷贝到形参中，这种情况下任何通过改变形参来改变实参的努力都是不会成功的<br>
c为解决改变实参的问题，是通过传递指针的方式来完成，可通过形参指针来间接改变实参<br>
c++的引用可以做到和指针同样的双向传递，并且<strong>不需要像指针形参一样额外分配栈空间</strong></p>
<p>传递引用时，形参的名字被看作实参的别名，即形参就是实参本身，实参传递的是实参名而不是地址，此时对形参的操作就相当于改变了实参，例：</p>
<pre class="line-numbers language-none"><code class="language-none">void func(int &amp;pnum)&#123;
    pnum++;
&#125;
int main()&#123;
    int value&#x3D;5;
    cout&lt;&lt;func(value);
&#125;   &#x2F;&#x2F;输出结果：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="引用作为函数返回值"><a class="markdownIt-Anchor" href="#引用作为函数返回值"></a> 引用作为函数返回值</h2>
<p>函数返回引用，实际上返回的是一个存储单元(变量),即<strong>左值</strong></p>
<p>如果一个函数返回引用，那么函数调用可以出现在赋值号的左边，也就是可以给函数调用赋值，这在c中是做不到的，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int &amp;f(int *pint)
&#123;
    return *pint;
&#125;
int main()
&#123;
    int a&#x3D;10,b;
    b&#x3D;f(&amp;a)*5;
    f(&amp;a)&#x3D;88;
    cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a;  &#x2F;&#x2F;输出：50 88
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>值得注意的是，因为返回的引用是一个存储单元，所以函数返回后这个单元的生命期应该不会结束，否则返回值将没有意义因此与指针一样，返回局部变量的引用是没有意义，并且容易出现未定义行为<br>
另一方面可以从上例就可以发现引用作为左值是有安全隐患的(通过一个函数调用可以修改外部传入参数的值)，此时就可以将引用定义为常引用，避免左值绑定内容被修改的问题</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>命名空间</title>
    <url>/posts/331b3d146634</url>
    <content><![CDATA[<h1 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h1>
<p>一个中大型软件往往由多名程序员共同开发，会使用大量的变量和函数，不可避免地会出现变量或函数的命名冲突，当所有人的代码都测试通过，没有问题时，但将它们结合到一起就有可能会出现命名冲突<br>
namespace关键字用来定义一个命名空间，语法格式为：</p>
<blockquote>
<p>namespace 命名空间名{}</p>
</blockquote>
<p>命名空间又称为名字空间，是表达多个变量和多个函数组合成一个组的方法，可以包含变量、函数、类、typedef、#define等，最后由花括号{}包围<br>
主要为了解决名字冲突(用户自定义的类型名，函数名，变量名等)的问题</p>
<span id="more"></span>
<h2 id="域解析操作符"><a class="markdownIt-Anchor" href="#域解析操作符"></a> 域解析操作符</h2>
<p>::是域解析操作符，在c<ins>中用来指明要使用的命名空间<br>
c</ins>标准库中的函数或者对象都是在命名空间std中定义的，所以使用<strong>标准函数库中的函数或对象都要使用std来限定</strong><br>
当然也可以引入命名空间(using namespace std)，在之后语句省略std，不用的话如果定义同名变量则该命名空间的变量会被局部变量覆盖掉</p>
<p>c++输入输出示例程序：输入十个整数，对其进行冒泡排序后输出</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
using namespace std;
int main()
&#123;
const int n&#x3D;10;
int num[n],i,j,tmp;
for(i&#x3D;0;i&lt;n;i++)
&#123;
    cin&gt;&gt;num[i];
&#125;
for(i&#x3D;1;i&lt;n;i++)
&#123;
    for(j&#x3D;0;j&lt;n-i;j++)
    &#123;
        if(num[j]&gt;num[j+1])
        &#123;
            tmp&#x3D;num[j];
            num[j]&#x3D;num[j+1];
            num[j+1]&#x3D;tmp;
        &#125;
    &#125;
&#125;
for(i&#x3D;0;i&lt;n;i++)cout&lt;&lt;num[i]&lt;&lt;&quot; &quot;;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="命名空间与作用域"><a class="markdownIt-Anchor" href="#命名空间与作用域"></a> 命名空间与作用域</h2>
<p>站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号(Symbol)。有的符号可以指代一个内存位置，例如变量名、函数名；有的符号仅仅是一个新的名称，如typedef定义的类型别名。一个命名空间是一个作用域，在不同名字空间中命名相同的符号代表不同的实体，使用变量、函数时要指明它们所在的命名空间，基本格式为：</p>
<blockquote>
<p>命名空间名::变量名，命名空间名::函数名，等等</p>
</blockquote>
<p>除了在使用时加上域解析操作符声明命名空间，还可以采用using关键字提前声明变量，例：</p>
<pre class="line-numbers language-none"><code class="language-none">using std::cout;
int main()
&#123;
    int a;
    std::cin&gt;&gt;a;
    cout&lt;&lt;a&lt;&lt;std::endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>using声明以后的程序中如果出现了未指明命名空间的符号，就使用声明的命名空间中的成员<br>
如果需要使用其他命名空间的符号，仍然可以使用作用域符来指定<br>
using声明不仅可以针对命名空间中的一个成员，也可以用于声明整个命名空间，如：using namespace std;<br>
此时可以直接使用该命名空间中的成员</p>
<p>命名空间可以在两个地方被定义：在全局范围层次或者是在另一个命名空间中被定义(形成一个嵌套名字空间)，例：</p>
<pre class="line-numbers language-none"><code class="language-none">namespace xu&#123;namespace shao &#123;namespace qian&#123;int a;&#125;&#125;&#125;
int main()
&#123;
    xu::shao::qian::a&#x3D;10;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不能在函数和类的内部定义命名空间</p>
<p>实际上，每个程序中存在一个<strong>全局命名空间</strong>，是隐式声明的<br>
可以用作用域操作符引用全局命名空间的成员，由于全局命名空间是隐含的，所以没有名字，如：</p>
<blockquote>
<p>::membername;</p>
</blockquote>
<p>注意：虽然可以用作用域符标识命名空间，但命名空间与作用域是完全不同的概念，不能搞混</p>
<ul>
<li>实际上命名空间更类似于一个将不同变量、函数、宏、类等等程序要素名字的声明和定义打包起来的一个<strong>逻辑空间</strong>，这一点很像<strong>头文件</strong>的作用，区别在于：
<ul>
<li>头文件是物理上的概念，是一个实际的文件，而命名空间通常是在头文件中定义的一个逻辑单元，相当于对其中一部分内容进行<strong>标识</strong></li>
<li>c++支持在多个头文件中定义同名命名空间，但其中成员不能重复(编译器自动将其合为一个)</li>
</ul>
</li>
<li>另一方面，命名空间的定义形式与类很像，其使用方式也与类相似，区别在于：
<ul>
<li>首先命名空间的粒度更大，其中可以包含类的定义甚至还能嵌套定义，并且可以重复定义以向其中追加内容，而类定义完毕之后就是完全封闭的</li>
<li>类通常是一种实在事物的抽象，其中定义的成员代表了这类事物的性质，是oop的基本建模工具，反观命名空间更像是一组相关事物或工具的集合，逻辑上没有类那么紧密</li>
</ul>
</li>
<li>至于作用域则是一个编译层面上的更抽象的概念，不是程序实体，它描述的是一个名字在程序中的使用范围</li>
</ul>
<h1 id="标准命名空间std"><a class="markdownIt-Anchor" href="#标准命名空间std"></a> 标准命名空间(std)</h1>
<p>c<ins>是在c的基础上开发的，早期的c</ins>还不完善，不支持命名空间，并且没有自己的编译器<br>
是通过将c<ins>代码翻译成c代码，再通过c编译器完成编译，这个时期的c</ins>仍然在使用c的库，如：stdio.h、stdlib.h、string.h等头文件依然有效<br>
此外c<ins>也开发了一些新的库增加了自己的头文件，如：iostream.h，fstream.h，complex.h等等<br>
后来c</ins>引入了命名空间的概念，计划重新编写库，将类、函数、宏等都统一纳入一个命名空间<br>
这个命名空间的名字就是std。std是standard的缩写，意思是标准命名空间<br>
为了使用老式c<ins>的程序可以继续使用原来的库，新开发的程序可以使用新版的c</ins>库，c<ins>保留原来的库和头文件可以继续使用，然后把原来的库复制一份，并在此基础上稍加修改，把新增类、函数、宏等纳入命名空间std下，成为了新版**c</ins>标准库**，因此这样共存在了两份功能相似的库<br>
为避免头文件重名，新版c++库对头文件的命名做了调整，去掉了后缀.h，如：iostream.h变成iostream，fstream.h变成fstream</p>
<ul>
<li>对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c，如：stdio.h变成cstdio，stdlib.h变成cstdlib(当然继续写.h的也可以，但是标准不推荐)</li>
<li>对于不带.h的头文件，所有的符号都位于命名空间std中，使用时需要声明命名空间std</li>
<li>对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域，这是c++标准所规定的</li>
</ul>
<p>虽然c<ins>几乎完全兼容c，c的头文件在c</ins>中依然被支持，但c<ins>新增的库更加强大和灵活，一般尽量使用c</ins>新增的头文件<br>
很多时候将std直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，因此一般是在函数内部声明std</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>从c到c++</title>
    <url>/posts/11bafae5ef49</url>
    <content><![CDATA[<p>c是c<ins>的基础，只有充分掌握c并理解c和c</ins>的不同，才能理解和运用c++解决问题</p>
<span id="more"></span>
<h1 id="c数据类型"><a class="markdownIt-Anchor" href="#c数据类型"></a> c++数据类型</h1>
<p>c中数据类型整体可以分为基本数据类型和构造数据类型</p>
<ul>
<li>基本数据类型包括：整型，实数型，字符型，空值型</li>
<li>构造数据类型包括数组，结构，指针，枚举，联合</li>
</ul>
<p>c++在c的基础上对数据类型进行了拓展，新增了基本数据类型中的逻辑类型，构造数据类型中的引用类型<br>
以及新增了一个大类：类数据类型</p>
<h2 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2>
<ul>
<li>字符：char, unsigned char</li>
<li>整型(普通，长，短）：int, unsigned, long, unsigned long, short, unsigned short</li>
<li>浮点(实数)型(单，双精度)：float, unsigned float, double, unsigned double</li>
<li>逻辑类型：bool<br>
c99借鉴c++加入了bool类型，但c程序中为避免编译环境标准不同等问题一般是将int重命名为bool(但int占用内存大于bool，后者只占1字节)</li>
</ul>
<p>类型转换：各种类型高低顺序为(低类型-&gt;高类型,按占用内存空间大小，高类型转低类型可能丢失数据)</p>
<blockquote>
<p>short/char/bool-&gt;int-&gt;unsigned-&gt;long-&gt;unsigned &gt;long-&gt;float-&gt;double-&gt;long double</p>
</blockquote>
<h2 id="构造数据类型"><a class="markdownIt-Anchor" href="#构造数据类型"></a> 构造数据类型</h2>
<ul>
<li>数组：int data[n]</li>
<li>指针：int *p</li>
<li>结构：struct stu{char name[n];bool sexy;}</li>
<li>联合：union stu{char name[n];bool sexy;}
<ul>
<li>联合表示几个变量名公用一个内存位置, 在不同的时间保存不同的数据类型和不同长度的变量</li>
<li>联合声明格式和结构体相似，但联合中的数据元素是相互独立的，联合大小由最大的成员的大小来决定（回顾）</li>
</ul>
</li>
<li>枚举：enum color{red,green,blue,yellow}
<ul>
<li>枚举是自定义的若干枚举常量的集合，每个成员都是一个以标识符形式表示的整型常量（回顾）</li>
<li>默认状态下，常量值就是成员对应的序号<br>
引用类型：int value;int &amp;p=value;   引用实际上就是给目标变量的内存空间取的别名</li>
</ul>
</li>
<li>类：class</li>
</ul>
<h3 id="类和结构体的联系和区别"><a class="markdownIt-Anchor" href="#类和结构体的联系和区别"></a> 类和结构体的联系和区别</h3>
<p>c++不但保留了结构体关键字struct，并且还扩充了其功能</p>
<ul>
<li>在c语言中，结构体只能包含不同类型的数据变量，相当于只能把几种数据组合起来，表现一个实体的静态属性</li>
<li>在c++中，结构体类似于类，既可以包含数据成员变量，又<strong>可以包含成员函数</strong>
<ul>
<li>不仅如此，结构体<strong>可以继承派生</strong>，甚至有虚函数机制，<strong>可以实现多态性</strong></li>
<li>从本质上说c++的结构体和类区别很小，能完成的功能基本相同</li>
<li>结构体在创建和销毁时一样需要调用构造函数和析构函数</li>
</ul>
</li>
</ul>
<p>二者间的区别主要是：</p>
<ul>
<li>类中的成员默认是private属性，结构体中的成员默认都是public属性
<ul>
<li>但是实际写程序一般很少见利用这个特性，因为以降低可读性、容易造成误解为代价换取少声明一个关键字是得不偿失的</li>
</ul>
</li>
<li>类继承默认是private继承，而结构体继承默认是public继承</li>
<li>两者对应的关键字struct和class中只有class可以声明模板参数，而struct不能</li>
</ul>
<h2 id="c字符串"><a class="markdownIt-Anchor" href="#c字符串"></a> c++字符串</h2>
<p>c<ins>大大增强了对字符串的支持，除了可以使用c语言风格的字符串，还可以使用内置的string类。string类处理起字符串来会方便很多，完全可以代替c语言中的字符数组或字符串指针。string 是c</ins>中常用的一个类，使用string类需要包含头文件&lt;string&gt;。</p>
<p>string支持与c语言相同风格的赋值，如：</p>
<blockquote>
<p>string str=“hello cpp”;  可以将字符串常量直接赋值给string(使用的是重载的赋值运算符函数)</p>
</blockquote>
<p>此外由于string是一个类，因此可以也可以采用对象风格的初始化</p>
<blockquote>
<p>string str1(“hello cpp”); 可以直接使用字符串常量初始化string<br>
string str2(5,‘s’);       可以用int、char类型初始化string，表示使用几个相同的字符初始化string，此例为“sssss&quot;<br>
string str3=str1;         可以通过赋值运算符直接用string对象初始化</p>
</blockquote>
<p>需要注意的是，string类中有记录字符串长度的成员，因此没有必要在末尾多加一个’\0’。基于这一点来说，一个空的string就是&quot;“而不是”\0&quot;，同时声明一个string类而不初始化会调用默认无参构函数将其初始化为&quot;&quot;，而不是随机值。string字符串的长度就是字符串本身的长度，而不是像char[]和char*那样是长度+1。</p>
<p>string重载了其’&lt;&lt;‘和’&gt;&gt;'运算符，与c语言风格字符串可以进行同样的输入输出。同时它也重载了[]运算符，可以像c语言风格的字符串一样按照下标来访问和修改其中的每一个字符，如：</p>
<blockquote>
<p>string str=“hello”;<br>
str[4]=‘h’;<br>
std::cout&lt;&lt;str[0];</p>
</blockquote>
<p>注意string也是存在越界问题的。string本质上是对动态数组的一层封装，在开始的时候根据初始化内容申请适当大小的容量(一般就等于初始化字符串的长度，有些编译器可能会额外多给一点容量)，之后只有通过其重载的+=运算符或append()、resize()等成员函数才能扩容，直接下标访问实际上跟c语言的数组一样是基址加偏移量的模式，并不能改变其容量。</p>
<p>string还重载了+和+=的运算符函数，使得其可以非常简单地实现c语言中字符串拼接函数strcat的操作，并且因为string是动态数组，不需要担心空间溢出，如：</p>
<blockquote>
<p>string str4=str1+str2;<br>
string str4+=str3;</p>
</blockquote>
<p>用+来拼接字符串时，运算符的两边可以都是string字符串，也可以是一个string字符串和一个c风格的字符串，甚至可以是一个string字符串和一个单独的字符(这是因为char*和char可以隐式转换为string)。</p>
<h3 id="string转换为c语言字符串"><a class="markdownIt-Anchor" href="#string转换为c语言字符串"></a> string转换为c语言字符串</h3>
<p>由于在某些场合下必须使用c语言风格的字符串，最明显的例子就是使用c标准库的函数(c标准库的函数不可能支持string，肯定是拿char*作参数和返回值)，此时就涉及到string与char*的互换，如：</p>
<blockquote>
<p>string path=&quot;/home/hello.c&quot;<br>
fopen(path.c_str(),‘w’);</p>
</blockquote>
<p>string类提供了一个转换函数c_str()，该函数能够将string字符串转换为c语言风格的字符串，并返回该字符串的const指针(const char*)</p>
<h3 id="string的增删改查操作"><a class="markdownIt-Anchor" href="#string的增删改查操作"></a> string的增删改查操作</h3>
<p>string类中封装了大量的成员函数，可以很方便地完成其作为抽象数据类型所定义的一系列操作。</p>
<p>insert()成员函数可以在string字符串中指定的位置插入另一个字符串，它的一种原型为：</p>
<blockquote>
<p>string&amp;insert(size_t pos,const string&amp;str);<br>
pos表示要插入的位置，也就是下标，str表示要插入的字符串，它可以是string字符串，也可以是c语言风格的字符串。</p>
</blockquote>
<p>erase()函数可以删除string中的一个子字符串。它的一种原型为：</p>
<blockquote>
<p>string&amp;erase(size_t pos=0,size_t len=npos);</p>
</blockquote>
<p>pos表示要删除的子字符串的起始下标，len表示要删除子字符串的长度。如果不指明len的话，那么直接删除从pos到字符串结束处的所有字符(len=str.length-pos)，前提也是pos不能越界，当pos+len&gt;=str.length时，len=str.length-pos。</p>
<p>substr()函数用于从string字符串中提取子字符串，它的原型为：</p>
<blockquote>
<p>string substr(size_t pos=0,size_t len=npos)const;  注意这是个常成员函数，不能改变原string</p>
</blockquote>
<p>pos为要提取的子字符串的起始下标，len为要提取的子字符串的长度。与erase()函数的行为类似，最多提取到string的结尾。</p>
<p>以上三个函数的第一个参数pos有越界可能的，如果越界则会产生运行时异常。</p>
<p>find()函数用于在string字符串中查找子字符串出现的位置，它其中的一种原型为：</p>
<blockquote>
<p>size_t find(const string&amp; str,size_t pos=0)const;  查找相关的成员函数基本都是常成员函数</p>
</blockquote>
<p>第一个参数为待查找的子字符串，它可以是string字符串，也可以是c语言风格的字符串。第二个参数为开始查找的下标，如果不指明，则从第0个字符开始查找。最终返回的是子字符串第一次出现在字符串中的起始下标，如果没有查找到子字符串，那么会返回一个无穷大值4294967295(UINT_MAX)。</p>
<p>rfind()函数与find()功能类似，区别在于rfind的pos参数为查找结束的下标(从第0个字符开始查起)，返回值含义与find()相同。<br>
find_first_of()函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。</p>
<h1 id="c输入输出"><a class="markdownIt-Anchor" href="#c输入输出"></a> c++输入输出</h1>
<p>需要在预处理中包含头文件：&lt;iostream&gt;  (流库) 注意没有.h，头文件的内容在命名空间std中。&lt;iostream&gt;与c中&lt;stdio.h&gt;非常相像，但二者有本质不同，&lt;stdio.h&gt;是一个函数库的头文件，而&lt;iostream&gt;是一个流对象库的头文件。c++没有新增输入输出语句，而是增加了输入输出库(io库)，提供了大量关于输入输出的设施。“流”是一个术语，指从某个io设备上读入或写出数据流，并随着时间顺序生成消耗。输入输出库分为两个基础库：istream(输入流)，ostream(输出流)。</p>
<h2 id="c的基本io对象4个"><a class="markdownIt-Anchor" href="#c的基本io对象4个"></a> c++的基本io对象(4个)</h2>
<ul>
<li>输入流对象(istream对象)：针对设备输入操作进行处理的类</li>
<li>输出流对象(ostream对象)：针对设备输出操作进行处理的类</li>
<li>输入输出流中包含任意要输出的数据，可以是整型、浮点型、字符串等</li>
<li>系统中预定义流对象：cin，cout
<ul>
<li>cin处理标准输入，即键盘输入istream对象(输入内容)</li>
<li>cout处理标准输出，即屏幕输出ostream对象(输出内容)</li>
</ul>
</li>
<li>除此外还有2个基本流对象
<ul>
<li>cerr:标准错误流，用来输出警告和错误信息给程序使用者</li>
<li>clog:日志流，用于产生程序执行的一般信息</li>
</ul>
</li>
</ul>
<p>基本io对象示例：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
    &#123;
        std::cout&lt;&lt;&quot;enter two numbers&quot;&lt;&lt;std::endl;    &#x2F;&#x2F;可以引入标准命名空间standard(using namespace std)，在之后语句省略std
        int v1,v2;                                    &#x2F;&#x2F;C99以及C++中在首次使用变量之前可在块的任何位置声明变量，不一定需要在复合语句最前面
        std::cin&gt;&gt;v1&gt;&gt;v2;
        std::cout&lt;&lt;&quot;the sum of &quot;&lt;&lt;v1&lt;&lt;&quot; and &quot;&lt;&lt;v2&lt;&lt;&quot; is &quot;&lt;&lt;v1+v2&lt;&lt;std::endl;    &#x2F;&#x2F;在c++标准输出中操作数可以是全部内置数据类型
        return 0;                                                               &#x2F;&#x2F;endl表示换行，大体上与&#39;\n&#39;是一样的
    &#125;                                        &#x2F;&#x2F; 输入：34782 42388 输出结果：the sum of 34782 and 42388 is 77170<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意!!!当输入没有满足程序期望的时候，如:</p>
<blockquote>
<p>对于一个int类型的变量a，输入字符H，这种情况下将不会改变变量a的值，并返回0(也就是写入失败)</p>
</blockquote>
<p>这一特性经常被用在循环条件中以终止循环，如:</p>
<blockquote>
<p>for(;cin&gt;&gt;a;);</p>
</blockquote>
<p>在执行程序时系统将io对象与执行窗口关联起来。并且大部分操作系统提供重定向输入输出流的方法，将所选择的文件与流关联起来(对文件中内容进行io)</p>
<h2 id="和运算符"><a class="markdownIt-Anchor" href="#和运算符"></a> &gt;&gt;和&lt;&lt;运算符</h2>
<p>运算符’&lt;&lt;’,’&gt;&gt;‘将数据与io流对象关联起来，’&lt;&lt;'是预定义的插入符(输出流运算符)，作用在cout上可实现屏幕输出，基本格式为：</p>
<blockquote>
<p>cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;… 其中，表达式可以是变量，常量，以及各种运算符连接的运算表达式等</p>
</blockquote>
<p>每个表达式本身<strong>返回一个cout对象</strong>，因此可以将多个表达式连接起来依次输出，如：</p>
<blockquote>
<p>cout&lt;&lt;“enter two numbers”&lt;&lt; endl;等效于(cout&lt;&lt;“enter two numbers”)&lt;&lt; endl;等效于cout&lt;&lt;“enter two numbers”;cout&lt;&lt; endl;</p>
</blockquote>
<p>'&gt;&gt;'是与定义的提取符(输入流运算符)，作用在cin上可实现屏幕输出，基本格式为：</p>
<blockquote>
<p>cin&gt;&gt;表达式1&gt;&gt;表达式2&gt;&gt;… 将输入数据放到表达式里，因此表达式必须要具有存储空间(变量或内存区)</p>
</blockquote>
<p>对于’&gt;&gt;’，如果需要连续输入多个数据，可以有两种方法:(其实跟scanf差不多，关键是缓冲区机制)</p>
<ul>
<li>每行输入一个数据，以换行符结束，如：</li>
</ul>
<blockquote>
<p>int a,b;cin&gt;&gt;a&gt;&gt;b; 输入：a (换行) b</p>
</blockquote>
<ul>
<li>一行输入多个数据，数据间用空格符隔开，以换行符结束一行数据输入，如：</li>
</ul>
<blockquote>
<p>int a;char buf[32];cin&gt;&gt;a&gt;&gt;b;  输入：5 cheng (换行)</p>
</blockquote>
<h1 id="c动态内存"><a class="markdownIt-Anchor" href="#c动态内存"></a> c++动态内存</h1>
<p>c中使用动态内存时必须指定分配空间大小，有时很不方便<br>
c<ins>中使用new和delete实现动态内存的分配和回收，new和delete既是C</ins>中的关键字也是一种特殊的运算符，使用时的一般格式为：</p>
<blockquote>
<p>typename *p;p=new type;delete p;</p>
</blockquote>
<p>编译器会自动计算type类型大小，无需指定字节数<br>
new分配分配内存空间时可以直接对数据进行<strong>初始化</strong>，初始值可以是常量、变量以及表达式，如：</p>
<blockquote>
<p>new int(100)，此时该动态内存空间内的值就是100</p>
</blockquote>
<p>如果初始化数据与指定数据类型不符，会对数据进行强制类型转换，如：</p>
<blockquote>
<p>new int(98.55)，此时存储数据为98(double转int)</p>
</blockquote>
<p>使用过后，可以用delete释放p所指向的动态内存，用delete释放的空间必须是new分配的空间(堆内存)，否则可能发生严重的错误</p>
<p>new，delete关键字可以分配数组空间，一般格式为：</p>
<blockquote>
<p>typename *p=new type[n];delete[] p;</p>
</blockquote>
<p>注意delete时指针前要加[]，表示删除数组空间而不是p指向的数组首地址(type指针常量)所代表的type类型空间</p>
<p>c++动态内存示例程序：分配n个整型空间，用随机数初始化其中的数据，输出最大值和最小值</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;
int main()
&#123;
    using namespace std;
    int *p,i,j,tmp,n;
    srand((float)time(0));
    cin&gt;&gt;n;
    p&#x3D;new int[n];
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        p[i]&#x3D;rand()%(n-1);
    &#125;
    for(i&#x3D;1;i&lt;n;i++)
    &#123;
        for(j&#x3D;0;j&lt;n-i;j++)
        &#123;
            if(p[j]&gt;p[j+1])
            &#123;
                tmp&#x3D;p[j];
                p[j]&#x3D;p[j+1];
                p[j+1]&#x3D;tmp;
            &#125;
        &#125;
    &#125;
    cout&lt;&lt;&quot;max&#x3D;&quot;&lt;&lt;p[0]&lt;&lt;&quot; &quot;&lt;&lt;&quot;min&#x3D;&quot;&lt;&lt;p[n-1];
    delete p;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>常见标准库函数</title>
    <url>/posts/8cc46b833174</url>
    <content><![CDATA[<p>标准库提供了很多功能各异的函数<br>
不同的头文件中声明了功能各不相同的库函数，不同的库函数的实现有时也需要借助其他的库函数<br>
一般情况只供标准库中其他函数使用的名字以下划线开始，防止与用户程序中的名字冲突，所有标准库都遵循该约定<br>
以下对其中一些特别有用的函数做一个简要概述，更多详细信息参见网上的文档</p>
<span id="more"></span>
<h1 id="字符串操作函数"><a class="markdownIt-Anchor" href="#字符串操作函数"></a> 字符串操作函数</h1>
<p>此类函数一般在头文件&lt;string.h&gt;中定义<br>
下面的各个函数中，s与t是char*类型，c与n是int类型<br>
注意s和t的返回，避免发生越界错误</p>
<blockquote>
<p>strcat(s,t)     将t指向的字符串连接到s指向的字符串的末尾<br>
strncat(s,t,n)  将t指向的字符串中前n个字符连接到s指向的字符串的末尾<br>
strcpy(s,t)     将t指向的字符串复制到s指向的位置<br>
strncpy(s,t,n)  将t指向的字符串中前n个字符复制到s指向的位置<br>
strcmp(s,t)     根据s指向的字符串小于(s&lt;t)、等于(s==t)或大于(s&gt;t)t指向的字符串的不同情况，分别返回负整数、0或正整数<br>
strncmp(s,t,n)  同strcmp相同，但只在前n个字符中比较<br>
strlen(s)       返回s指向的字符串的长度<br>
strchr(s,c)     在s指向的字符串中查找c，若找到，则返回指向它第一次出现的位置的指针，否则返回NULL<br>
strrchr(s,c)    在s指向的字符串中查找c，若找到，则返回指向它最后一次出现的位置的指针，否则返回NULL</p>
</blockquote>
<h1 id="字符类别测试和转换函数"><a class="markdownIt-Anchor" href="#字符类别测试和转换函数"></a> 字符类别测试和转换函数</h1>
<p>此类函数一般在头文件&lt;ctype.h&gt;中定义<br>
下面的各个函数中，c是一个可表示为unsigned char类型或EOF的int类型，函数的返回值类型为int</p>
<blockquote>
<p>isalpha© 若c是字母，则返回一个非0值，否则返回0<br>
isupper© 若c是大写字母，则返回一个非0值，否则返回0<br>
islower© 若c是小写字母，则返回一个非0值，否则返回0<br>
isdigit© 若c是数字，则返回一个非0值，否则返回0<br>
isalnum© 若isalpha©或isdigit©，则返回一个非0值，否则返回0<br>
isspace© 若c是空格、横向制表符、换行符、回车符、换页符或纵向制表符，则返回一个非0值，否则返回0<br>
toupper© 返回c的大写形式<br>
tolower© 返回c的小写形式</p>
</blockquote>
<h1 id="字符输入输出函数"><a class="markdownIt-Anchor" href="#字符输入输出函数"></a> 字符输入输出函数</h1>
<blockquote>
<p>int ungetc(int c,FILE*fp)  将字符c写回到文件fp中，如果执行成功则返回c，否则返回EOF，每个文件只能接收一个写回字符</p>
</blockquote>
<h1 id="命令执行函数"><a class="markdownIt-Anchor" href="#命令执行函数"></a> 命令执行函数</h1>
<p>函数system(char*s)执行包含在字符串s中的命令，然后继续执行当前程序<br>
s的内容在很大程度上与所用的操作系统有关</p>
<pre class="line-numbers language-none"><code class="language-none">如:在UNIX操作系统环境中，system(&quot;date&quot;)将执行程序date，它将在标准输出上打印当天的日期和时间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>system函数返回一个整型的状态值，其值来自于执行的命令，并同具体系统有关，在UNIX系统中返回的状态是exit的返回值</p>
<h1 id="存储管理函数"><a class="markdownIt-Anchor" href="#存储管理函数"></a> 存储管理函数</h1>
<p>函数malloc和calloc用于动态地分配存储块</p>
<blockquote>
<p>void<em>malloc(size_t n)             当分配成功时返回一个指针，该指针指向n字节长度的未初始化的存储空间，否则返回NULL<br>
void</em>calloc(size_t n,size_t size) 当分配成功时返回一个指针，该指针指向足以容纳n个指定长度的对象组成的数组，否则返回NULL<br>
free§释放p指向的存储空间，其中p是此前通过调用malloc或calloc函数得到的指针</p>
</blockquote>
<h1 id="数学函数"><a class="markdownIt-Anchor" href="#数学函数"></a> 数学函数</h1>
<p>头文件&lt;math.h&gt;中声明了20多个数学函数，下面介绍一些常用的数学函数<br>
每个函数带有一个或两个double类型的参数，并返回一个double类型的值</p>
<blockquote>
<p>sin(x)      x的正弦函数，其中x用弧度表示<br>
cos(x)      x的余弦函数，其中x用弧度表示<br>
atan2(y,x)  y/x的反正切函数，其中，x和y用弧度表示<br>
exp(x)      指数函数e^x<br>
log(x)      x的自然对数(以e为底)，其中，x&gt;0<br>
log10(x)    x的常用对数(以10为底)，其中，x&gt;0<br>
pow(x,y)    计算x^y的值<br>
sqrt(x)     x的平方根(x&gt;=0)<br>
fabs(x)     x的绝对值</p>
</blockquote>
<h1 id="随机数发生器函数"><a class="markdownIt-Anchor" href="#随机数发生器函数"></a> 随机数发生器函数</h1>
<blockquote>
<p>函数rand()生成介于0和RAND_MAX之间的伪随机整数序列，其中RAND_MAX是在头文件&lt;stdlib.h&gt;中定义的符号常量</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">如:#define frand() ((double)rand()&#x2F;(RAND_MAX+1.0))是一种生成大于等于0但小于1的随机浮点数的典型方法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>(如果所用的函数库中已经提供了一个生成随机浮点数的函数，那么它可能比上面这个函数具有更好的统计学特性)</p>
<blockquote>
<p>函数srand(unsigned)设置rand函数的种子数</p>
</blockquote>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>存储分配</title>
    <url>/posts/2284ab999c4d</url>
    <content><![CDATA[<h1 id="c程序的内存映像"><a class="markdownIt-Anchor" href="#c程序的内存映像"></a> c程序的内存映像</h1>
<p>c语言当中数据存储的内存空间是有区分的  (我自己分的不准确，差不多理解这个意思就行，而且这个问题实际是由操作系统具体实现决定的)</p>
<blockquote>
<p>程序代码和只读数据(部分常量)存放在 代码段 当中<br>
程序的静态数据存放在 静态数据段 当中<br>
程序的动态数据存放在 动态数据段(栈/堆) 当中</p>
</blockquote>
<ul>
<li>一般用户进程空间(低-&gt;高)从一小段保留地址，接下来就是代码段(.text)，存放的是编译好的机器码</li>
<li>静态存储区分配 全局变量、静态变量、常量
<ul>
<li>数据段(.data)、常量段(.rodata)、未初始化的全部和静态变量段(.bss)</li>
</ul>
</li>
<li>在堆(heap)上存放用户申请的内存(这部分空间容量比栈大一个量级(GB和MB)，所以程序中实际数据对象最好在这里分配)，堆一般向上生长<br>
在程序运行期间，用 动态内存分配函数 来申请的内存都是从堆上分配的，动态内存的生存周期由人为的进行决定</li>
<li>在栈(stack)上存放的是 函数参数，局部变量值等，栈一般向下增长，当栈堆指针相等时就说明内存空间必然是不够了<br>
在执行函数调用时，系统在栈上为函数的局部变量和形参分配内存，函数执行结束时，自动释放这些内存</li>
<li>此外，实际上中间堆栈中间可能还存在动态共享库</li>
<li>最后在栈之后是用户进程空间中执行内核程序的保留空间</li>
</ul>
<span id="more"></span>
<h2 id="内存分配函数"><a class="markdownIt-Anchor" href="#内存分配函数"></a> 内存分配函数</h2>
<p>尽管动态存储分配函数需要为不同对象分配存储空间，但显然一般程序中只会设定一个内存分配函数，但是假定用一个分配程序来处理多种类型的请求，如:</p>
<blockquote>
<p>指向char类型的指针和指向struct tnode类型的指针</p>
</blockquote>
<p>此时则存在两个问题</p>
<ul>
<li>如何在大多数机器中满足各种类型对象的对其要求
<ul>
<li>如:整型对象通常必须分配在偶数地址上</li>
</ul>
</li>
<li>使用什么样的声明能处理分配程序必须能返回不同类型指针的问题</li>
</ul>
<p>对齐要求一般只需要确保分配程序始终满足所有对齐限制要求的指针即可，其代价是牺牲一些空间，对于任何执行严格类型检查的语言来说，像malloc()这样的函数的类型声明总是很令人头疼的问题。在c语言中，一种合适的方法是将返回值类型声明为void*，然后再显式地将该指针强制转换为所需类型，malloc并不是一个在编译时就确定的固定大小的数组中分配空间，而是在需要时向操作系统申请空间。</p>
<p>由于程序中某些地方可能并不通过malloc()调用申请空间(通过其他方式申请空间)，因此通过malloc()可以申请的空闲空间不一定是连续的，而这些malloc()管理的空闲存储空间以空闲块链表的形式组织，每个块包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。</p>
<ul>
<li>这些空闲块按照存储地址的升序组织，最后一块指向第一块(循环链表)，当有申请请求时，malloc()扫描空闲块链表，直到找到一个足够大的空闲块为止，该算法称为“首次适应”(first fit)- 与之相对的算法是“最佳适应”(best fit)，它寻找满足条件的最小空闲块，如果找到的空闲块恰好与请求的大小相符合，则将它从链表中移走并返回给用户，如果该块太大，则将它分成两半:大小合适的块返回给用户，剩下的块留在空闲块链表中。</li>
</ul>
<p>如果找不到一个足够大的空闲块，则向操作系统申请一个大块加入到空闲块链表中，具体实现是通过sbrk、brk等系统调用，UNIX系统调用sbrk返回一个指针，该指针指向n个字节的存储空间。尽管如果没有存储空间时返回NULL更恰当，但sbrk系统调用返回的是-1，因此必须将-1转换为char*类型，以便于返回值进行比较，此处进行强制类型转换的另一个好处是不会受不同机器中指针表示不同的影响，但仍有一个前提是其返回的多个指针之间可以进行有意义的比较，而ANSI标准中没有保证这一点，它只允许指向同一个数组的指针之间的比较。</p>
<p>最后的释放过程也是首先搜索空闲块链表，以找到可以插入被释放块的合适位置，将被释放块插入到空闲块中，如果与被释放块相邻的任一边是一个空闲块，则将两个块合成一个大空闲块，以使存储空间不会有太多的碎片，由于空闲块链表是以地质递增顺序链接在一起的，所以很容易判别相邻的块是否空闲(通过链表指针)，malloc()返回的存储空间需要满足将要保存对象的对齐要求。虽然机器类型各异，但每个机器都有一个最受限的类型:如果最受限的类型可以存储在某个特定地址中，则其他所有类型都可以存放在此地址中。在某些机器中，最受限的类型是double类型，而在另外一些机器中，最受限的是int或long类型，位于空闲块开始处的控制信息称为“头部”。为了简化块的对齐，所有块的大小都必须是头部大小的整数倍，且头部已正确地对齐，这通过一个联合实现，该联合包含所需的头部结构以及一个对齐要求最受限的类型的实例，如:</p>
<pre class="line-numbers language-none"><code class="language-none">typedef long Align;             &#x2F;&#x2F;按long类型的边界对齐(假定long为最受限的类型)
union header&#123;                   &#x2F;&#x2F;块的头部
    struct&#123;
        union header*ptr;       &#x2F;&#x2F;空闲块链表中的下一块(供下次申请时找到空闲块)
        unsigned size;          &#x2F;&#x2F;本块的大小，空闲块被要求是头部长度的整倍数，而size就是这个倍数
    &#125;s;
    Align x;                    &#x2F;&#x2F;强制块的对齐
&#125;;
typedef union header Header;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该联合中，Align永远不会被使用，它仅仅用于强制每个头部在最坏情况下满足对其要求，在malloc()中，请求的长度(以字符为单位)将被舍入，以保证它是头部大小的整数倍。实际分配的块(请求到的块)将多包含一个单元，用于头部本身，块的大小将被记录在头部的size字段中。malloc()返回的指针将指向空闲空间(头部的下一个可供使用的空闲单元)，而不是块的头部，用户可对获得的存储空间进行任何操作，但是如果在分配的存储空间之外写入数据则可能会破坏链表(写在未被分配的空闲块中)，头部中的size字段是必须的，因为由malloc()控制的块不一定是连续的，所以无法通过指针算数运算计算每个块的大小。</p>
<h2 id="动态内存分配函数"><a class="markdownIt-Anchor" href="#动态内存分配函数"></a> 动态内存分配函数</h2>
<p>需包含头文件&lt;stdib.h&gt;，malloc()和calloc()函数原型如下：</p>
<blockquote>
<p>void* malloc(size_t n);<br>
当分配成功时，返回一个指针，该指针指向n字节长度的未初始化的存储空间，若申请不成功则返回NULL</p>
</blockquote>
<blockquote>
<p>void* calloc(size_t n,size_t size);<br>
当分配成功时，返回一个指针，该指针指向的空闲空间足以容纳由n个指定长度的对象组成的数组，若申请不成功则返回NULL，该存储空间被初始化为0</p>
</blockquote>
<p>size表示申请的字节数，如果不清楚要申请的具体字节数可以用sizeof(要申请的变量类型)来输入size，根据请求的对象类型，malloc()或calloc()返回的指针满足正确的对齐要求。<br>
void*类型可以强制转换为任何其它类型的指针，因此malloc()通常需要根据申请的变量空间类型强转相应的指针(Type*)，如：</p>
<blockquote>
<p>p=(int*)malloc(n*sizeof(int));if(p==NULL)printf(“内存分配失败”);<br>
for(i=0;i&lt;n;i++){*(p+i)=i+1;printf(&quot;%d&quot;,*(p+i));}       *p为分配的10个整型空间的首地址，依次向10个空间输入数据并输出</p>
</blockquote>
<p>在c语言的部分编译环境下void*可以为其他类型指针赋值，因此有时不进行类型转换也是可以的，如:</p>
<blockquote>
<p>p=malloc(n*sizeof(int));(但是在c++中使用malloc函数必须进行强制类型转换)</p>
</blockquote>
<h2 id="动态内存释放函数"><a class="markdownIt-Anchor" href="#动态内存释放函数"></a> 动态内存释放函数</h2>
<p>malloc()和calloc()申请的内存块都由free()函数进行释放，原型如下：</p>
<blockquote>
<p>void free(void* p); p只能为malloc()或calloc()返回的指针，不能是其他的任何变量<br>
free时系统标记此内存为未占用，可被重新分配</p>
</blockquote>
<p>需要注意的是，此时p指向的空间没有变，但动态内存空间已被系统回收，如果再用*p对此块内存空间作修改，可能会出现很多错误，如:</p>
<blockquote>
<p>for(p=head;p;p=p-&gt;next)free§;是一个非常典型的错误代码段，p在释放后是无法找到p-&gt;next的</p>
</blockquote>
<p>正确处理方法是在释放项目以前将一切必要的信息保存起来</p>
<blockquote>
<p>for(p=head;p;p=q)q=p-&gt;next,free§;</p>
</blockquote>
<p>因此在释放空间后通常将p设置为空指针(p=NULL)。存储空间的释放顺序没有限制，malloc()和calloc()尽量一起使用，防止出现内存空间分配不足等问题。不用的内存空间要么释放，要么用指针变量保存起来，以便之后使用时可以找得到此处内存空间。</p>
<h2 id="常见的内存错误和分配原则"><a class="markdownIt-Anchor" href="#常见的内存错误和分配原则"></a> 常见的内存错误和分配原则</h2>
<ul>
<li>内存分配未成功就开始使用</li>
<li>内存分配成功但未进行初始化就开始使用</li>
<li>内存分配成功并初始化，但发生越界错误</li>
<li>申请内存后没有直接释放内存</li>
<li>释放内存后仍继续使用</li>
</ul>
<p>关于内存分配编程的建议原则：</p>
<ul>
<li>尽在需要时才使用动态分配函数</li>
<li>malloc()和free()要配对使用，malloc()在函数入口，free()在函数出口</li>
<li>使用malloc()时要检查函数返回值</li>
<li>使用free()后将指针设置为NULL(防止多个指针指向同一块区域，对同一块内存空间多次释放)</li>
<li>不要把局部变量的地址作为函数返回值返回</li>
</ul>
<p>动态内存示例程序：</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
&#123;
    const int n&#x3D;10;
    int i;
    int *p，*q;                        &#x2F;&#x2F;q指针用于记录分配空间并最后释放空间。对分配空间内的操作通过p指针完成
    p&#x3D;(int*)malloc(n*sizeof(int));     &#x2F;&#x2F;分配空间
    q&#x3D;p;
    if(p)
    &#123;
        for(i&#x3D;0;i&lt;n;i++,p++)           &#x2F;&#x2F;如果取到n以后的数，则超过了系统给p分配的空间，会发生越界错误
        &#123;
            *p&#x3D;i+1;                    &#x2F;&#x2F;必须分配空间并初始化后才能输出，否则输出一个随机数

            printf(&quot;%d&quot;,*p);
        &#125;
    &#125;
    free(q);                           &#x2F;&#x2F;如果此处直接free(p)，此时p已经指向了i&#x3D;n+1的地址空间，超过了系统分配空间的范围，因此也会发生越界错误
    q&#x3D;NULL;                            &#x2F;&#x2F;释放内存后，将q置为空指针
    return 0;
&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>unix系统调用</title>
    <url>/posts/bfce6ab57436</url>
    <content><![CDATA[<h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1>
<p>UNIX操作系统通过一系列系统调用提供服务，而这些系统调用实际上是操作系统内的函数，可以被用户程序调用<br>
在UNIX系统中，经常会需要借助于系统调用以获得最高的效率，或访问标准库中没有的某些功能<br>
尤其是，ANSI C标准函数库是以UNIX系统为基础建立起来的(比如fopen等文件操作函数是基于open等系统调用接口实现的)<br>
此外，在任何特定的系统中，标准库函数的实现往往必须通过宿主系统提供的功能来实现<br>
另一方面，许多程序并不是系统程序，而是仅仅使用由操作系统维护的信息<br>
对于这样的程序，很重要的一点是信息的表示仅出现在标准头文件中，使用它们的程序只需要在文件中包含头文件即可，而不需要包含每个相应的声明<br>
其次，在构建应用程序时为了可移植性，有可能需要为与系统相关的对象创建一个与系统无关的接口</p>
<span id="more"></span>
<h2 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h2>
<p>在UNIX系统中，所有的外围设备(包括键盘和显示器)都被看作文件系统的文件，因而所有输入/输出都要通过读文件或写文件完成<br>
即，在UNIX系统中通过单一的接口就可以处理外围设备和程序之间的所有通信<br>
通常，读写文件之前必须将意图通知系统，该过程称为打开文件<br>
如果是写一个文件，则可能需要先创建该文件，也可能需要丢弃该文件中原先已存在的内容<br>
UNIX系统会检查该文件是否存在，以及用户是否有访问它的权限<br>
如果一切正常，操作系统将向程序返回一个小的非负整数，该整数称为文件描述符<br>
任何时候对文件的输入/输出都是通过文件描述符标识文件，而不是通过文件名(文件描述符类似于c标准库中的文件指针或MS-DOS中的文件句柄)<br>
系统负责维护已打开文件的所有信息，用户程序只能通过文件描述符引用文件<br>
大多数的输入/输出是通过键盘和显示器来实现的，因此为方便起见，UNIX对此做出了特别的安排<br>
当命令解释程序(即“shell”)运行一个程序时，它将打开三个文件，对应的文件描述符分别是0,1,2，依次表示标准输入、标准输出和标准错误<br>
如果程序从0中读，对1和2进行写，就可以进行输入/输出而不必关心打开文件的问题</p>
<blockquote>
<p>程序使用者可以通过&lt;和&gt;重定向程序的I/O，格式为：prog &lt;输入文件名&gt;输出文件名</p>
</blockquote>
<p>在这种情况下，shell将文件描述符0(标准输入)和1(标准输出)的默认赋值改变为指定的文件<br>
通常情况下，文件描述符2(标准错误)仍然与显示器相关联，这样出错信息仍然输出到显示器上<br>
与管道相关的输入/输出同样有类似的特性<br>
在任何情况下，文件赋值的改变都不是由程序完成的，而是由shell完成的<br>
只要程序使用文件0作为输入，文件1和2作为输出，它无需知道程序的输入从哪里来，输出到哪里去</p>
<h2 id="低级ioread和write"><a class="markdownIt-Anchor" href="#低级ioread和write"></a> 低级I/O——read和write</h2>
<p>程序的输入与输出是通过read和write系统调用实现的，在c中可以通过函数read()和write()访问这两个系统调用</p>
<blockquote>
<p>函数原型:<br>
int read(int fd,char* buf,int n);<br>
int write(int fd,char* buf,int n);</p>
</blockquote>
<p>两个函数中，第一个参数是文件描述符，第二个参数是程序中用于存放要读或写数据的数组，第三个参数是要传输的字节数<br>
两个函数的调用正常情况均返回实际传输的字节数，可以用整型变量接收，函数的返回值可能会小于请求的字节数<br>
此外还存在一些特殊情况：<br>
读文件时，如果返回值为0，表示已到达文件的末尾，如果返回值为-1，则表示发生了某种错误<br>
写文件时，返回值是实际写入的字节数，如果返回值与请求写入的字节数不相等，此时说明写入文件过程中发生了错误<br>
在一次调用中，读出或写入数据的字节数可以为任意大小<br>
最常用值为1，即每次读出或写入1个字符(无缓冲)，或者类似于1024或4096这样的与外围设备物理块大小</p>
<pre class="line-numbers language-none"><code class="language-none">例:将输入复制到输出
#include&quot;syscalls.h&quot;
int copy()&#123;
    char bufs[BUFSIZ];
    int n;
    while((n&#x3D;(int)read(0,buf,BUFSIZE))&gt;0)write(1,buf,n);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>(K&amp;R书中中使用syscalls.h头文件存放系统调用相关的函数原型和宏常量，不过该头文件不是标准的)<br>
(UNIX C标准的存放系统调用相关内容的头文件为unistd.h）<br>
(此外常量BUFSIZ存放在stdio.h，定义了该系统下缓冲区的最佳大小，通常值为1024，根据不同操作系统而言不一样)<br>
上例中如果文件大小不是BUFSIZ的整数倍，<br>
则对read的某次调用(最后一次)会返回一个较小的字节数，而write再按这个字节数写，最后再调用read返回0</p>
<pre class="line-numbers language-none"><code class="language-none">例:使用read和write，实现getchar()
int getchar()&#123;
    static char buf[BUFSIZ];
    static char*bufp;
    static int n&#x3D;0;
    if(n&#x3D;&#x3D;0)&#123;
        n&#x3D;read(0,buf,sizeof buf);
        bufp&#x3D;buf;
    &#125;
    return (--n&gt;&#x3D;0)?*bufp++:EOF;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果要在包含头文件&lt;stdio.h&gt;的情况下编译自定义的getchar()，有必要用#undef预处理指令取消名字getchar的宏定义<br>
(宏替换发生在预处理阶段，先于函数调用)</p>
<h2 id="低级文件操作open-creat-close-unlink"><a class="markdownIt-Anchor" href="#低级文件操作open-creat-close-unlink"></a> 低级文件操作——open、creat、close、unlink</h2>
<p>除默认的标准输入、标准输出和标准错误文件外，其他文件都必须在读或写之前显式地打开<br>
系统调用open和creat用于实现打开文件的功能，同样在c中可以通过函数open和creat访问这两个系统调用</p>
<blockquote>
<p>函数原型:int open(char*name,int flags,int perms);</p>
</blockquote>
<p>与fopen类似，参数name是一个包含文件名的字符串，第二个参数flags是一个int类型的值，说明以何种方式打开文件，主要的几个取值如下：</p>
<ul>
<li>O_RDONLY 以只读方式打开文件</li>
<li>O_WRONLY 以只写方式打开文件</li>
<li>O_RDWR   以读写方式打开文件</li>
<li>O_CREAT  打开并创建文件，如果文件不存在就按照参数perms中给出的模式创建文件；</li>
</ul>
<p>在System V UNIX系统中，flags常量定义在&lt;fcntl.h&gt;头文件，而在Berkeley(BSD)版本中则在&lt;sys/file.h&gt;中定义的<br>
(同unistd.h，fcntl.h是UNIX C下存放关于文件管理方面的宏和函数原型的头文件)<br>
第三个参数perms指定创建文件时的访问权限，只有当flags=O_CREAT时需要此参数，其余情况都可以省略或置0即可<br>
系统调用open与c的fopen()很相似，不同的是后者返回一个文件指针，而前者返回一个文件描述符(int类型)，如果发生错误open将返回-1<br>
如果用open打开一个不存在的文件将导致错误，可使用creat系统调用创建新文件或覆盖旧文件</p>
<blockquote>
<p>函数原型:int creat(char*name,int perms);</p>
</blockquote>
<p>如果creat成功地创建了文件，它将返回一个文件描述符，否则返回-1<br>
如果此文件已存在，creat将把该文件的长度截断为0，从而丢弃原先已有的内容，使用creat创建一个已存在的文件不会导致错误<br>
如果要创建的文件不存在，则creat用perms指定的权限创建文件<br>
在UNIX系统中，每个文件对应一个9比特的权限信息，每个位分别控制文件的所有者、所有者组和其他成员对文件的读、写和执行访问<br>
因而通过一个三位的八进制数可以方便地说明不同的权限，如：</p>
<pre class="line-numbers language-none"><code class="language-none">0755说明文件的所有者可以对它进行读、写和执行操作，而所有者组和其他用户只能进行读和执行操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:简单实现UNIX程序cp
#include&lt;cstdarg&gt;
void error(const char*fmt,...)&#123;
    va_list args;
    va_start(fmt,args);
    fprintf(stderr,&quot;error:&quot;);
    vfprintf(stderr,fmt,args);
    fprintf(stderr,&quot;\n&quot;);
    va_end(args);
    exit(1);
&#125;
int cpmain(int argc,char*argv[])&#123;
    int f1,f2,n;
    if(argc!&#x3D;3)error(&quot;Usage:cp from to&quot;);
    if((f1&#x3D;open(argv[1],O_RDONLY,0))&#x3D;&#x3D;-1)error(&quot;cp:can&#39;t open %s&quot;,argv[1]);
    if((f2&#x3D;creat(argv[2],PERMS))&#x3D;&#x3D;-1)error(&quot;cp:can&#39;t create %s, mode %03o&quot;,argv[2],PERMS);
    while((n&#x3D;(int)read(f1,buf,BUFSIZ))&gt;0)if(write(f2,buf,n)!&#x3D;n)error(&quot;cp:write error on file %s&quot;,argv[2]);
    return 0;
&#125;
这个版本仅仅能将文件复制到另一个文件，不允许用目录作为第二个参数，并目标文件的权限没有复制原文件而是重新指定的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中标准库函数vprintf()与printf()函数类似，不同的是它用一个va_list参数取代了变长参数表，且此参数通过调用va_start进行初始化<br>
同样，vfprintf()和vfsprintf()分别与fprintf()和fsprintf()类似<br>
一个程序同时打开的文件数是有限制的(通常为20)，相应地，如果一个程序需要同时处理许多文件，那么其必须重用文件描述符<br>
函数close(in fd)用来断开文件描述符和已打开文件之间的连接，并释放此文件描述符，以供其他文件使用<br>
close()与标准库中的fclose()函数相对应，但它不需要清洗(flush)缓冲区<br>
如果程序通过exit()函数退出或从主程序中返回，所有打开的文件将被关闭<br>
函数unlink(char*name)将文件name从文件系统中删除，它对应于标准库函数remove</p>
<h2 id="随机访问lseek"><a class="markdownIt-Anchor" href="#随机访问lseek"></a> 随机访问——lseek</h2>
<p>输入/输出通常是顺序进行的:每次调用read和write进行读写的位置紧跟在前一次操作的位置之后<br>
但是有时候需要以任意的顺序访问文件，而系统调用lseek可以在文件中任意移动位置而不实际读写任何数据</p>
<blockquote>
<p>函数原型:long lseek(int fd,long offset,int origin);</p>
</blockquote>
<p>lseek将文件描述符为fd的文件的当前位置设置为offset，其中offset是相对于origin指定的位置而言的<br>
origin的值可以为0、1或2，分别用于指定offset从文件开始、从当前位置或从文件结束处开始算起</p>
<pre class="line-numbers language-none"><code class="language-none">如:为向一个文件尾部添加内容(在UNIX shell程序中使用重定向符&gt;&gt;或在库函数fopen中使用参数&quot;a&quot;)，
则在写操作之前必须使用lseek(fd,0L,2);找到文件末尾(其中参数0L也可写成(long)0，或仅仅写成0，但必须与声明格式保持一致)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>同理，若要返回文件开始处(即反绕)，使用lseek(fd,0L,0);<br>
使用lseek系统调用时，可以将文件视为一个大数组，其代价是访问速度会慢一些<br>
lseek返回一个long类型的值，此值表示文件的新位置，若发生错误则返回-1<br>
标准库函数fseek()与lseek类似，不同在于前者第一个参数是FILE*，且在错误发生时返回一个非0值</p>
<pre class="line-numbers language-none"><code class="language-none">例:从文件任意位置读入任意数目字节，返回读入的字节数，发生错误返回1
int get(int fd,long pos,char*buf,int n)&#123;
    if(Iseek(fd,pos,0)&gt;&#x3D;0)return read(fd,buf,n);
    else return -1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="目录列表"><a class="markdownIt-Anchor" href="#目录列表"></a> 目录列表</h2>
<p>除获取或修改文件具体内容外外，有时还需要获得文件系统的其他相关信息，目录列表程序就是其中的一个例子</p>
<pre class="line-numbers language-none"><code class="language-none">如:UNIX命令ls，可以打印目录中的文件名及其他可选信息如文件长度、访问权限等，MS-DOS操作系统中dir命令也有类似功能<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>由于在UNIX中目录是一种文件，因此ls只需读目录文件即可获得所有的文件名<br>
但如果需要获取文件的其他信息，如长度等，就需要使用其他系统调用<br>
在其他一些系统(比如MS-DOS)中，甚至获取文件名也需要使用系统调用<br>
在UNIX系统中，目录就是文件，它包含了一个文件名列表和一些指示文件位置的信息<br>
“位置”是一个指向其他表(其i结点表)的索引，文件的i结点是存放除文件名外所有文件信息的地方<br>
目录项通常仅包含两个条目：文件名和i结点编号<br>
结构Dirent包含i结点信息和文件名，文件名最大长度由NAME_MAX设定，NAME_MAX值由系统决定<br>
opendir返回一个指向称为DIR的结构的指针，该结构与FILE类似，可以被readdir和closedir使用，如:</p>
<pre class="line-numbers language-none"><code class="language-none">typedef struct Dirent&#123;          &#x2F;&#x2F;可移植的目录项结构
    long ino&#123;&#125;;                 &#x2F;&#x2F;i结点编号
    char name[NAME_MAX+1]&#123;&#125;;    &#x2F;&#x2F;文件名加字符串结束符
&#125;Dirent;
typedef struct DIR&#123;             &#x2F;&#x2F;最小的DIR：无缓冲等特性
    int fd&#123;&#125;;                   &#x2F;&#x2F;目录的文件描述符
    Dir ent d;                  &#x2F;&#x2F;目录项
&#125;DIR;
DIR*opendir(char*dirname);
Dirent*readdir(DIR*dfd);
void closedir(DIR*dfd);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关于目录项的信息存放在头文件&lt;dirent.h&gt;<br>
系统调用stat以文件名作为参数，返回文件i结点中的所有信息，若出错则返回-1，如:</p>
<pre class="line-numbers language-none"><code class="language-none">char*name;
struct stat stbuf;
int stat(char*,struct stat*);
stat(name,&amp;stbuf);
stat用文件name的i结点信息填充结构stbuf，头文件&lt;sys&#x2F;stat.h&gt;定义了stat的返回值的结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该结构的一个典型形式为:</p>
<pre class="line-numbers language-none"><code class="language-none">struct stat&#123;            &#x2F;&#x2F;由stat返回的i结点信息
    dev_t st_dev;       &#x2F;&#x2F;i结点设备
    ino_t st_ino;       &#x2F;&#x2F;i结点编号
    short st_mode;      &#x2F;&#x2F;模式位
    short st_nlink;     &#x2F;&#x2F;文件的总链接数
    short st_uid;       &#x2F;&#x2F;所有者的用户id
    short st_gid;       &#x2F;&#x2F;所有者的组id
    dev_t st_rdev;      &#x2F;&#x2F;用于特殊的文件
    off_t st_size;      &#x2F;&#x2F;用字符数表示的文件长度
    time_t st_atime;    &#x2F;&#x2F;上一次访问的时间
    time_t st_mtime;    &#x2F;&#x2F;上一次修改的时间
    time_t st_ctime;    &#x2F;&#x2F;上一次改变i结点的时间
&#125;;
其中dev_t和ino_t等所有系统相关的类型在&lt;sys&#x2F;types.h&gt;中定义
st_mode项包含了描述文件的一系列标志，在&lt;sys&#x2F;stat.h&gt;定义，如:
#define S_IFMT 016000   &#x2F;&#x2F;文件的类型
#define S_IFDIR 004000  &#x2F;&#x2F;目录
#define S_IFCHR 002000  &#x2F;&#x2F;特殊字符
#define S_IFBLK 006000  &#x2F;&#x2F;特殊块
#define S_IFREG 010000  &#x2F;&#x2F;普通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>文件输入输出</title>
    <url>/posts/1783fd2451bc</url>
    <content><![CDATA[<h1 id="文件访问"><a class="markdownIt-Anchor" href="#文件访问"></a> 文件访问</h1>
<p>UNIX系统程序cat可以说明访问的文件是否已经连接到程序，它把一批命名文件串联后输出到标准输出上<br>
cat可用来在屏幕上打印文件，对于无法通过名字访问文件的程序而言，它还可以用作通用的输入收集器</p>
<span id="more"></span>
<pre class="line-numbers language-none"><code class="language-none">如:命令行 cat x.c y.c 将在标准输出上打印文件x.c和y.c的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>对一个访问文件的程序而言，关键的问题在于如何设计命名文件的读取过程，即如何将用户需要使用的文件的外部名同读取数据的语句联系起来<br>
方法其实很简单：<br>
在读写一个文件之前，必须通过库函数fopen()打开该文件</p>
<blockquote>
<p>fopen函数原型:FILE* fopen(char* name,char* mode);</p>
</blockquote>
<p>fopen()用类似于x.c或y.c这样的外部名与操作系统进行某些必要的连接和通信，并返回一个随后可以用于文件读写操作的指针<br>
该指针称为文件指针，指向一个包含文件信息的结构，这些信息包括:</p>
<ul>
<li>一个指向缓冲区位置的指针，通过它可以一次读入文件的一大块内容;</li>
<li>一个记录缓冲区中剩余字符数的计数器;</li>
<li>一个指向缓冲区下一个字符的指针;</li>
<li>文件描述符;</li>
<li>描述读/写模式的标志;</li>
<li>描述错误状态的标志等</li>
</ul>
<p>用户无需关心这些细节的实现，因为stdio.h中已经定义了一个包含这些信息的结构FILE<br>
在程序中只需按照基本格式声明一个文件指针即可:FILE*fp;<br>
上面的fp是一个指向结构FILE的指针，并且fopen函数返回一个指向FILE的指针<br>
注意FILE像int一样是一个类型名而不是结构标记，它是通过typedef定义的<br>
在程序中一种常见的形式是fp=fopen(name,mode);<br>
其中fopen的第一个参数是一个字符串，包含文件名，第二个参数是访问模式，也是一个字符串，用于指定文件的使用方式<br>
允许的模式包括:</p>
<ul>
<li>读(“r”)、写(“w”)以及追加(“a”)，某些系统还区分文本文件和二进制文件，对后者的访问需要追加字符’b’</li>
<li>如果打开一个不存在的文件用于写或追加，该文件将被创建(如果可行的话)</li>
<li>当以写模式打开一个已经存在的文件时，该文件原来的内容将被覆盖，以追加模式打开一个文件，则该文件原来的内容保持不变</li>
</ul>
<p>读一个不存在的文件将导致错误，其他一些操作也可能导致错误，如试图读取一个无读取权限的文件，如果发生错误fopen将返回NULL</p>
<h1 id="文件输入输出"><a class="markdownIt-Anchor" href="#文件输入输出"></a> 文件输入输出</h1>
<p>文件打开后，需要考虑使用哪种方式对文件进行读写<br>
有多种方法可供考虑，其中最为简单的是getc()和putc()</p>
<blockquote>
<p>getc函数原型为:int getc(FILE*fp);</p>
</blockquote>
<p>getc()从文件中返回下一个字符，它需要知道文件指针，以确定对那个文件执行操作<br>
getc()返回fp指向的输入流中下一个字符，如果到达文件尾或出现错误，该函数返回EOF<br>
相对应的，putc()是一个输出函数</p>
<blockquote>
<p>putc函数原型:int putc(int c,FILE*fp);</p>
</blockquote>
<p>putc()将字符c写入到fp指向的文件中，并返回写入的字符，如果发生错误则返回EOF<br>
当启动一个c程序时，操作系统环境负责打开三个文件，并将三个文件的指针提供给该程序<br>
这三个文件分别是标准输入、标准输出和标准错误，相应的文件指针常量分别为stdin、stdout、stderr(声明在stdio.h中)<br>
在大多数环境中，stdin指向键盘，stdout和stderr指向默认输出终端(stdin和stdout可以被重定向到其他文件中或管道中)<br>
类似于getchar()和putchar()以及getc()和putc()的实现方式一般是宏而不是函数(不然对每个字符都需要进行一次函数调用的话开销过大)<br>
并且实际上getchar()和putchar()可以通过getc()、putc()、stdin、stdout进行定义</p>
<pre class="line-numbers language-none"><code class="language-none">如:#define getchar() getc(stdin)
   #define putchar(c) putc((c),stdout)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">例：&lt;stdio.h&gt;的部分典型片段
#define NULL 0
#define EOF (-1)
#define BUFSIZ 1024
#OPEN_MAX 20                 &#x2F;&#x2F;一次最多可打开的文件数
typedef struct _iobuf&#123;
    int cnt;                 &#x2F;&#x2F;剩余的字符数
    char*ptr;                &#x2F;&#x2F;下一个字符的位置
    char*base;               &#x2F;&#x2F;缓冲区的位置
    int flag;                &#x2F;&#x2F;文件访问模式
    int fd;                  &#x2F;&#x2F;文件描述符
&#125;FILE;
extern FILE _iob[OPEN_MAX];
#define stdin (&amp;_iob[0])
#define stdout (&amp;_iob[1])
#define stderr (&amp;_iob[2])
enum _flags&#123;
    _READ&#x3D;01;                &#x2F;&#x2F;以读写方式打开文件
    _WRITE&#x3D;02;               &#x2F;&#x2F;以写方式打开文件
    _UNBUF&#x3D;04;               &#x2F;&#x2F;不对文件进行缓冲
    _EOF&#x3D;010;                &#x2F;&#x2F;已到文件的末尾
    _ERR&#x3D;020;                &#x2F;&#x2F;该文件发生错误
&#125;;
int _fillbuf(FILE*);
int _flushbuf(int,FILE*);
#define feof(p) (((p)-&gt;flag&amp;_EOF)!&#x3D;0)   &#x2F;&#x2F;p一般为传入的FILE*，当p-&gt;flag的第二个位字段为0时(p)-&gt;flag&amp;_EOF)&#x3D;0
#define ferror(p) (((p)-&gt;flag&amp;_ERR)!&#x3D;0) &#x2F;&#x2F;同feof(p)
#define getc(p) (--(p)-&gt;cnt&gt;&#x3D;0?(unsigned char)*(p)-&gt;ptr++:_fillbuf(p))
#define putc(x,p) (--(p)-&gt;cnt&gt;&#x3D;0?*(p)-&gt;ptr++&#x3D;(x):_flushbuf((x),p)
#define getchar() getc(stdin)
#define putchar(x) putc((x),stdout)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>宏getc一般先将计数器减1，将指针移到下一个位置，然后返回字符，<br>
如果计数器变为负值，getc就调用函数_fillbuf填充缓冲区，重新初始化结构的内容，并返回一个字符<br>
返回的字符为unsigned long类型，确保所得字符为正值<br>
宏putc的操作与getc非常类似，当缓冲区满时调用_flushbuf<br>
对文件的格式化输入或输出，同样有函数fscanf和fprintf<br>
它们与printf和scanf的区别仅仅在于它们的第一个有名参数是一个指向所要读写文件的指针，第二个有名参数才是格式串<br>
(格式串的转换法则基本相同，区别在于需要指定向哪个文件中进行读写)<br>
函数原型分别为:</p>
<blockquote>
<p>int fscanf(FILE* fp,char* format,…);<br>
int fprintf(FILE* fp,char* format,…);</p>
</blockquote>
<p>函数fclose()执行和fopen()相反的操作，它断开由fopen函数建立的文件指针和外部之间的连接，并释放文件指针以供其他文件使用</p>
<blockquote>
<p>fclose函数原型:int fclose(FILE*fp);</p>
</blockquote>
<p>由于大多数操作系统都限制了一个程序可以同时打开的文件数，所以当文件指针不再需要时就应当释放，这是一个好的编程习惯<br>
对输出文件执行fclose()还有另外一个原因:它将把缓冲区中由putc()正在收集的输出写到文件中<br>
当程序正常终止时，程序实际上会自动为每个打开的文件调用fclose()<br>
(如果不需要使用stdin和stdout，可以将它们关闭掉，同时也可以通过库函数freopen()选择重新指定它们)</p>
<h1 id="错误处理stderr和exit"><a class="markdownIt-Anchor" href="#错误处理stderr和exit"></a> 错误处理——stderr和exit</h1>
<p>如果程序因为某种原因而造成其中的一个文件无法访问，相应的诊断信息要在该连接的末尾(fclose())才能打印出来<br>
当输出到stdout时，这种处理方法尚可接受，但如果需要输出到一个文件或通过管道输出到另一个程序时，就难以接受了(屏幕上看不到出错信息)<br>
为处理这种情况，单独设立一个输出流以与stdin和stdout相同的方式分派给程序，即stderr<br>
而即使对标准输出进行重定向，写到stderr的输出通常也能显示在显示器(默认输出终端)上<br>
标准库函数exit()可以终止调用程序的执行(exit()的作用类似于main中的return，可以终止程序的执行，但exit()可以出现在程序的任何位置)<br>
(注意exit并不是关键字)<br>
当该函数被调用时，任何调用该程序的进程都可以获取exit()的参数值，因此可通过另一个将该程序作为子进程的程序来测试该程序是否执行成功<br>
按照惯例。返回值0表示一切正常，而非0返回值通常表示异常情况<br>
exit()可以为每个已打开的输出文件调用fclose()，以将缓冲区中所有输出写到相应的文件中<br>
在主程序main()中，语句return expr等价于exit(expr)，但使用exit()有一个额外的优点，它可以从其他函数中以及程序中调用<br>
函数ferror可以在流fp中出现错误时返回一个非0值</p>
<blockquote>
<p>ferror函数原型:int ferror(FILE*fp);</p>
</blockquote>
<p>尽管输出错误很少出现，但还是存在的(比如磁盘满时)，因此成熟产品程序应当检查这种类型的错误<br>
函数feof()与ferror()类似，如果指定的文件指针到达文件末尾，它将返回一个非0值</p>
<blockquote>
<p>feof函数原型:int feof(FILE*fp);</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">例:cat函数，连接多个文件
void filecopy(FILE*,FILE*);
int catmain(int argc,char*argv[])
&#123;
    FILE*fp;
    char*prog&#x3D;argv[0];                             &#x2F;&#x2F;记下程序名，供错误处理用
    if(argc&#x3D;&#x3D;1)filecopy(stdin,stdout);             &#x2F;&#x2F;如果没有命令行参数，则复制标准输入
    else while(--argc)
    if(!(fp&#x3D;fopen(*++argv,&quot;r&quot;)))
    &#123;   &#x2F;&#x2F;如果fp为空输出错误信息
        fprintf(stderr,&quot;%s: can&#39;t open %s\n&quot;,prog,*argv);
        exit(1);
    &#125;
    else
    &#123;
        filecopy(fp,stdout);
        fclose(fp);
    &#125;
    if(ferror(stdout))
    &#123;
        fprintf(stderr,&quot;%s: error writing stdout\n&quot;,prog);
        exit(2);
    &#125;
    exit(0);
&#125;
&#x2F;&#x2F;filecopy函数：将文件ifp复制到文件ofp
void filecopy(FILE*ifp,FILE*ofp)
&#123;
    int c;
    while((c&#x3D;getc(ifp))!&#x3D;EOF)putc(c,ofp);
&#125;
该程序通过两种方式发出出错信息
首先将fprintf()产生的诊断信息输出到stderr上，因此诊断信息会显示在屏幕上而不仅仅输出到管道或输出文件中
诊断信息中包含argv[0]中的程序名，因此当该程序和其他程序一起运行时可以识别错误的来源
其次，使用exit()，当该函数被调用时将终止调用程序的执行(exit实际上是访问系统调用)
在上面的小程序中，主要目的是为了说明问题，因此并不太关心程序的退出状态，但对于任何重要的程序而言，都应让程序返回有意义且有用的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="行输入和行输出"><a class="markdownIt-Anchor" href="#行输入和行输出"></a> 行输入和行输出</h1>
<p>标准库提供了一个输入函数fgets()进行行输入</p>
<blockquote>
<p>fgets函数原型:char* fgets(char* line,int maxline,FILE* fp);</p>
</blockquote>
<p>fgets()可以从fp指向的文件中读取下一个输入行(包括换行符)，并将它放在字符数组line中<br>
最多可以读取maxline-1个字符，读取的行将以’\0’结尾保存在数组中<br>
通常情况下，fgets返回line，但如果遇到文件结尾或发生了错误，则返回NULL<br>
输出函数fputs()将一个字符串(不需要包含换行符)写入到一个文件中</p>
<blockquote>
<p>fputs函数原型:int fputs(char* line,FILE* fp);</p>
</blockquote>
<p>如果发生错误，该函数将返回EOF，否则返回一个非负值<br>
库函数gets()和puts()的功能与fgets()和fputs()相似，但它们是对stdin和stdout操作<br>
值得注意的是，gets()在读取字符串时将删除结尾的换行符’\n’，而puts()函数在写入字符串时将在结尾处添加一个换行符<br>
(在对待换行符的行为上，gets()、puts()和fgets()、fputs()正好相反)</p>
<pre class="line-numbers language-none"><code class="language-none">例:标准库中的fgets()和fputs()
char* fgets(char* s,int n,FILE* iop)
&#123;
    int c;
    char*cs&#x3D;s;
    while((c&#x3D;getc(iop))!&#x3D;EOF)if((*cs++&#x3D;(char)c)&#x3D;&#x3D;&#39;\n&#39;)break;
    *cs&#x3D;&#39;\0&#39;;
    return (cs&#x3D;&#x3D;s&amp;&amp;c&#x3D;&#x3D;EOF)?nullptr:s;
&#125;
int fputs(char*s,FILE*iop)
&#123;
    char c;
    while((c&#x3D;*s++))putc(c,iop);
    return ferror(iop)?EOF:1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>标准输入输出</title>
    <url>/posts/73fc4b87a401</url>
    <content><![CDATA[<blockquote>
<p>输入与输出并不是c本身的功能<br>
一般讨论的输入输出都是建立在标准输入输出之上的，标准输入(stdin)和标准输出(stdout)是操作系统自动提供给程序访问的<br>
ANSI标准精准地定义了包括输入\输出函数、字符串处理函数、存储管理函数以及数学函数等标准库函数<br>
在任何可以使用c的系统中都有这些函数兼容形式，如果程序的系统交互部分仅用了标准库提供的功能，则可以不经修改地从一个系统移植到另一个系统<br>
这些库函数的属性分别在十多个头文件中声明，如&lt;stdio.h&gt;、&lt;string.h&gt;、&lt;ctype.h&gt;等</p>
</blockquote>
<span id="more"></span>
<h1 id="标准输入输出"><a class="markdownIt-Anchor" href="#标准输入输出"></a> 标准输入输出</h1>
<p>标准库实现了简单的文本输入和输出模式<br>
文本流由一系列行组成，每行结尾是一个换行符，如果系统没有遵循这种模式，则标准库将通过一些措施使得该系统适应这种模式</p>
<pre class="line-numbers language-none"><code class="language-none">如:标准库可以在输入端将回车符和换页符都转换为换行符，而在输出端进行反向转换<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="字符输入函数getchar"><a class="markdownIt-Anchor" href="#字符输入函数getchar"></a> 字符输入函数getchar()</h2>
<p>使用getchar函数从标准输入(一般为键盘)中一次读取一个字符</p>
<blockquote>
<p>函数原型:int getchar(void);</p>
</blockquote>
<p>getchar函数每次在被调用时返回下一个输入字符，若遇到文件结尾则返回EOF，符号常量EOF在头文件&lt;stdio.h&gt;中定义，其值一般为-1<br>
不过一般在程序中应使用符号常量EOF来测试文件是否结束，这样才能保证程序与EOF的特定值无关<br>
在许多环境中，可以使用符号’&lt;'来实现输入重定向，它把键盘输入替换为文件输入</p>
<pre class="line-numbers language-none"><code class="language-none">如:在程序prog中使用了函数getchar()，则命令行prog &lt;infile将使得程序prog从文件infile(而不是键盘)中getchar()
并且在事实上程序prog本身并不在意输入方式的改变，字符串&quot;&lt;infile&quot;也不包含在argv的命令行参数中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果输入通过管道机制来自于另一个程序，那么这种输入切换也是不可见的</p>
<pre class="line-numbers language-none"><code class="language-none">如:在某些系统中，命令行otherprog|prog将运行两个程序otherprog和prog
并将程序otherprog的标准输出通过管道重定向到程序prog的标准输入上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="字符输出函数putchar"><a class="markdownIt-Anchor" href="#字符输出函数putchar"></a> 字符输出函数putchar</h2>
<blockquote>
<p>函数原型:int putchar(int);</p>
</blockquote>
<p>用于输出数据，在程序中往往可以交叉调用函数putchar和printf，输出将按照函数调用的先后顺序依次产生</p>
<h2 id="格式化输出函数printf"><a class="markdownIt-Anchor" href="#格式化输出函数printf"></a> 格式化输出函数printf</h2>
<p>输出函数printf将内部数值转换为字符的形式</p>
<blockquote>
<p>函数原型:int printf(char*format,arg1,arg2,…);</p>
</blockquote>
<p>基本格式：printf(“格式字符串”,输出项列表)<br>
printf在输出格式format的控制下将其参数进行转换与格式化，并在标准输出设备上打印，返回值为打印的字符数<br>
输出项可以为变量，常量，表达式，其间用逗号分隔<br>
格式字符串包含两种类型的对象:普通字符和转换说明(以及%)<br>
输出时，普通字符将原样不动地复制到输出流中，而转换说明不直接复制到输出流中，而是用于控制printf中参数的转换与打印<br>
每个转换说明都由一个百分号字符(即%)开始，并以一个转换字符结束，使用修饰符可以控制输出宽度，精度，小数位数，对齐方式等<br>
在字符%和转换说明中间可能按顺序依次包含下列修饰符:</p>
<ul>
<li>负号:用于指定被转换的参数按照左对齐的形式输出</li>
<li>数(小数点前):用于指定最小字段宽度，转换后的参数将打印不小于最小字段宽度的字段</li>
<li>如果有必要，字段左边(如果使用左对齐，则为右边)多余字符位置用空格填充以保证最小字段宽度</li>
<li>小数点:用于将字段宽度和精度分开</li>
<li>数(小数点后):用于指定精度，即字符串中要打印的最大字符数、浮点数小数点后的位数、整型最少输出的数字数目</li>
<li>字母h或l:字母h表示将整数作为short类型打印，字母l表示将整数作为long类型打印</li>
</ul>
<p>printf转换说明(如果%后面的字符不是一个合法的转换说明则该行为是未定义的):</p>
<ul>
<li>%d或%i:参数类型为int，用于输出十进制整型数(整型指本质为整型的数，如int、short、char等)</li>
<li>%c:参数类型为int，用于输出单个字符</li>
<li>%s:参数类型为char*，顺序打印字符串中的字符，直到遇到’\0’或已打印了事先指定的精度数的字符数为止</li>
<li>%o:参数类型为int，以无符号八进制形式输出整数值(没有前导0)</li>
<li>%x或%X:参数类型为int，以无符号十六进制形式输出整数值(没有前导0或0x)，10-15分别用abcdef或ABCDEF表示</li>
<li>%u:以无符号形式输出十进制数</li>
<li>%f:参数类型为double，用于输出十进制小数[-]m.dddddd，d的个数由精度指定(缺省值为6)</li>
<li>%e或%E:参数类型为double，以科学计数的形式输出十进制小数[-]m.dddddde±xx，[-]mm.ddddddE±xx，d的个数由精度指定(缺省值为6)</li>
<li>%g或%G:参数类型为double，如果指数小于等于-4或大于等于精度，用%e或%E格式输出，否则用%f格式输出，尾部的0和小数点不打印</li>
<li>%p:参数类型为void*，指针的值(取决于具体实现)</li>
<li>%%:参数为’%’，直接打印一个%<br>
此外，在转换说明中，宽度和精度可以用*表示，这时宽度或精度的值通过转换下一参数(必须为int类型)进行计算</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">如:printf(&quot;%*s&quot;,max,s);表示从字符串s中至多打印max个字符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">例: int i&#x3D;123;
printf(&quot;%6d&quot;,i); 输出结果:(三个空格)123        输出结果字段宽度为6字节，不足位用空格填充
printf(&quot;%06d&quot;,i); 输出结果:000123            6前加0表示字段宽度为6字节，不足位用0填充
float j&#x3D;1234.567;
printf(&quot;%9.3f&quot;,j); 输出结果: (空格)1234.567   输出结果共9字段，小数点后保留三位
printf(&quot;%-9.3f&quot;,j); 输出结果: 1234.5657(空格) 使用负号为左对齐，不用负号为右对齐
printf(&quot;%0*d&quot;,i); 输出结果: 000123
printf(&quot;%0*.*f&quot;9,3,j); 输出结果: 01234.567<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对字符串而言，其输出的字符个数由转换说明中的精度来指定，在宽度不足时用空格填充，空格填充的位置由对齐方式决定</p>
<pre class="line-numbers language-none"><code class="language-none">例: 
cout&lt;&lt;printf(&quot;%s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;        输出结果:hello, world12
cout&lt;&lt;printf(&quot;%10s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;      输出结果:hello, world12
cout&lt;&lt;printf(&quot;%.10s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;     输出结果:hello, wor10
cout&lt;&lt;printf(&quot;%-10s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;     输出结果:hello, world12
cout&lt;&lt;printf(&quot;%.15s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;     输出结果:hello, world12
cout&lt;&lt;printf(&quot;%-15s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;     输出结果:hello, world   15
cout&lt;&lt;printf(&quot;%15.10s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;   输出结果:     hello, wor15
cout&lt;&lt;printf(&quot;%-15.10s&quot;,&quot;hello, world&quot;)&lt;&lt;endl;  输出结果:hello, wor     15
注意，printf由第一个参数判断后面参数的个数及类型，如果参数的个数不够或者类型错误则将得到错误的结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:printf(s)中如果字符串包含%则输出错误，printf(&quot;%s&quot;,s)则输出一定正确<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="格式输入函数scanf"><a class="markdownIt-Anchor" href="#格式输入函数scanf"></a> 格式输入函数scanf</h2>
<p>输入函数scanf对应于输出函数printf，它在后者相反的方向上提供同样的转换功能</p>
<blockquote>
<p>函数原型:int scanf(char* format,…);</p>
</blockquote>
<p>基本格式：scanf(“格式字符串”,输入项列表)<br>
scanf函数从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余参数中<br>
其他所有无名参数都必须是指针，用于指定经格式转换后的相应输入保存位置<br>
当scanf函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止<br>
同时成功匹配并赋值的输入项的个数将作为函数值返回，因此scanf函数的返回值可以用来确认已匹配的输入项的个数，如果到达文件的结尾，该函数将返回EOF<br>
注意，返回EOF与0是不同的，0表示第一个输入字符与格式串中的第一个格式说明不匹配，下次调用scanf将从上一次转换的最后一个字符的下一个字符开始搜索<br>
同printf一样，scanf的格式串通常也包含转换说明和普通字符，对普通字符而言分两种情况:<br>
(格式串中加入可打印字符可忽略输入流中的相同字符)<br>
空格或制表符:在处理过程中所有空白符(包括但不限于空格和制表符)均被忽略(一般用于处理最后的输入项后的空格，因为scanf本身忽略输入项以前和之间的空格)<br>
普通字符(不包括%):用于匹配输入流中的下一个非空白符字符(该字符将被忽略，只有与输入流中全部字符均匹配成功时scanf函数才能进行赋值)<br>
scanf的转换说明用于控制下一个输入字段的转换，一般来说，转换结果存放在相应的参数指向的变量中<br>
同理，转换说明与%中间可能包含修饰符，用于控制输入的转换:</p>
<ul>
<li>星号(* ):赋值禁止字符，如果转换说明中有*则跳过一个(用以表示该输入项，读入后不赋予相应的变量，即跳过该输入值)，输入字段不进行赋值</li>
<li>数:指定最大字段宽度</li>
<li>字母h、l或L:指定目标对象的长度(字节数)，l表示输入长整型数据和双精度浮点数，h表示输入短整型数据，可以加在转换说明d、i、o、u或x的前面</li>
</ul>
<p>前缀h表明参数表的相应参数是一个指向short而非int类型的指针，前缀h表明参数表的相应参数是一个指向long类型的指针<br>
类似的，转换说明e、f和g的前面也可以加上前缀l，它表明参数表的相应参数是指向double类型而非float类型的指针<br>
输入字段定义为一个不包含空白符的字符串其边界定义为到下一个空白符或到达指定的字段宽度，这表明scanf函数将越过行边界读取输入，因为换行符也是空白符<br>
(空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符)<br>
转换说明指定对输入字段的解释，对应的参数必须是指针，这是c通过值调用语义所要求的<br>
scanf转换说明(如果%后面的字符不是一个合法的转换说明则该行为是未定义的):</p>
<ul>
<li>%d:参数类型为int*，输入十进制整数</li>
<li>%i:参数类型为int*，输入整数，可以是八进制(以0开头)或十六进制(以0x或0X开头的)</li>
<li>%o:参数类型为int*，输入八进制整数(可以0开头也可以不0开头)</li>
<li>%u:参数类型为unsigned int*，输入无符号十进制整数</li>
<li>%x:参数类型为int*，输入十六进制整数(可以0x或0X开头也可以不0x或0X开头)</li>
<li>%c:参数类型为char*，输入字符，将接下来的多个输入字符(默认为1个字符)存放到指定位置，该转换规范通常不跳过空白符，如果需要读入下一个非空白符可使用%1s</li>
<li>%s:参数类型为char*，输入字符串(不加引号)，指向一个足以存放该字符串的字符数组(包括尾部的字符’\0’的位置)，字符串的末尾将被添加一个结束符’\0’</li>
<li>%e或%f或%g:参数类型为float*，输入浮点数，它可以包括正负号(可选)、小数点(可选)以及指数部分(可选)</li>
<li>%%:输入字符%，不进行任何赋值操作</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">例: *可以跳过对应数据赋值操作
scanf(&quot;%d%*d&quot;,&amp;a,&amp;b); 输入34 45时 a&#x3D;34 b赋到的值是空格(跳过了第二个输入项45)
scanf(&quot;%d%c&quot;,&amp;a,&amp;b); 输入 45 a时 a&#x3D;45 b值为空格
scanf(&quot;%d %c&quot;,&amp;a,&amp;b); 输入 45 a时 a&#x3D;45 b&#x3D;a 可以解决上面赋值空格的问题
scanf(&quot;%d,,,,%c&quot;,&amp;a,&amp;b); 输入 45,a时 a&#x3D;45 b&#x3D;a 同理，可以忽略输入流中的,,,,
double sum&#x3D;0,v;while(scanf(&quot;%1f&quot;,&amp;v))printf(&quot;\t.2f&quot;,sum+&#x3D;v); 简易计算器
int day,year;char monthname[20];scanf(&quot;%d %s %d&quot;,&amp;day,monthname,&amp;year); 读取日期格式的输入如:25 Dec 1988
(数组名本身就是指针，因此monthname的前面 没有加取地址运算符&amp;)
int day,month,year;scanf(&quot;%d&#x2F;%d&#x2F;%d&quot;,&amp;day,&amp;month,&amp;year); 读取日期格式的输入如:dd&#x2F;mm&#x2F;yy
如果要读取格式不固定的输入，最好每次读一行，然后再用sscanf将合适的格式分离出来读入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:假定需要读取一些包含日期数据的输入行，日期的格式可以是多种形式
while(getline(line,sizeof(line))&gt;0)
&#123;
    if(sscanf(line,&quot;%d %s %d&quot;,&amp;day,monthname,&amp;year)&#x3D;&#x3D;3)printf(&quot;valid:%s\n,line&quot;);  格式形如:25 Dec 1988
    else if(sscanf(line,&quot;%d&#x2F;%d&#x2F;%d&quot;,&amp;day,&amp;month,&amp;year)&#x3D;&#x3D;3)printf(&quot;valid:%s\n,line&quot;);格式形如:dd&#x2F;mm&#x2F;yy
    else printf(&quot;invalid:%s\n,line&quot;);                                              日期格式无效
&#125;
scanf函数可以和其他输入函数混合使用，无论调用哪个输入函数，下一个输入函数的调用将从scanf没有读取的第一个字符处开始读取数据
最后，再次强调注意scanf和sscanf函数的所有参数都必须是指针，最常见的错误是将输入语句scanf(&quot;%d&quot;,&amp;n);写为:scanf(&quot;%d&quot;,n);
部分编译器在编译时可能是检测不到这类错误的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="格式化输出函数sprintf与格式化输入函数sscanf"><a class="markdownIt-Anchor" href="#格式化输出函数sprintf与格式化输入函数sscanf"></a> 格式化输出函数sprintf与格式化输入函数sscanf</h2>
<p>函数sprintf和printf执行的转换与函数printf相同，但它将输出保存到一个字符串中，函数sscanf用于从一个字符串中(而不是标准输入)中读取字符序列</p>
<blockquote>
<p>函数原型:<br>
int sprintf(char* string,char* format,arg1,arg2,…);<br>
int sscanf(char* string,char* format,arg1,arg2,…);</p>
</blockquote>
<p>sprintf函数和printf函数一样，按照format格式格式化参数序列arg1、arg2、…<br>
区别在于sprintf将输出结果存放到string中，而不是输出到标准输出<br>
存储字符串的变量string必须足够大以存放输出结果<br>
函数sscanf用于从一个字符串中(而不是标准输入)中读取字符序列，并将结果分别保存在arg1、arg2、…这些参数中，这些参数必须是指针<br>
许多程序只需要从一个数据流中读取数据，并且只向一个输出流中输出数据<br>
对于这样的程序只需使用函数getchar()、putchar()、printf等实现输入输出即可，并且对程序而言一般已经足够<br>
特别是，如果通过重定向将一个程序的输出连接到另一个程序的输入，仅使用这些函数就足够了</p>
<pre class="line-numbers language-none"><code class="language-none">如:int main()
   &#123;
        int c;
        while((c&#x3D;getchar())!&#x3D;EOF)putchar(tolower(c));
        &#x2F;&#x2F;函数tolower定义在&lt;ctype.h&gt;，将大写字母转换小写形式，并降其余字符原样返回
        return 0;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际上，头文件&lt;stdio.h&gt;的getchar()和putchar()“函数”以及&lt;ctype.h&gt;中的tolower“函数”一般都是宏<br>
因此可以避免对每个字符都进行函数调用的开销，并且无论&lt;ctype.h&gt;中的函数在给定机器上如何实现，使用这些函数的程序都不必了解字符集的知识</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数、指针、复杂声明</title>
    <url>/posts/34762e3fe2b4</url>
    <content><![CDATA[<h1 id="函数与指针"><a class="markdownIt-Anchor" href="#函数与指针"></a> 函数与指针</h1>
<h2 id="指针函数"><a class="markdownIt-Anchor" href="#指针函数"></a> 指针函数</h2>
<p>函数内部数据是地址，需要传递给调用函数，可以将指针返回给函数<br>
或者也可以通过双向传递参数来获取地址，但一般不推荐<br>
不用函数参数双向传递的原因在于：<br>
一旦调用的函数中对指针的值做了修改，原指针的值并没有变化(此时相当于传值调用)，那么程序中接下来围绕指针的操作就与愿指针指向的值无关了</p>
<span id="more"></span>
<p>返回指针的函数一般定义格式为：</p>
<blockquote>
<p>数据类型 *函数名(参数列表){函数体;}     数据类型为返回的指针指向的数据类型，同时也要return指针类型</p>
</blockquote>
<p>函数返回指针示例程序1：<br>
实现匹配函数match：在输入字符串中查找一个给定字符，如果找到则从该字符开始打印余下的子字符串，及该字符是字符串的第几个字符，- 否则输出&quot;no match found&quot;</p>
<ul>
<li>由于函数的功能一般是独立的，函数的输出一般通过函数双向传递的参数或返回值获得，因此函数的输出一般是函数计算结果反馈给调用者</li>
<li>至于调用者是把结果输出到屏幕还是作为其他函数的输出，由调用者根据需要而定，除非必要一般不在函数内部通过打印函数这种显示语句输出数据</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
char *match(char c,char *sp);          match函数原型，一个字符串，一个查找字符，返回值为字符串地址
int main()
&#123;
    char s[80],ch,*p;
    int pos;
    gets(s);
    ch&#x3D;getchar();
    p&#x3D;match(ch,s);                     &#x2F;&#x2F;调用match函数
    if(p)                              &#x2F;&#x2F;如果指针不为空
    &#123;
        pos&#x3D;strlen(s)-strlen(p)+1;     &#x2F;&#x2F;原字符串长度减子字符串长度的差再加上字符本身就表示该字符在字符串中是第几个字符
        printf(&quot;%s %d\n&quot;,p,pos);       &#x2F;&#x2F;输出子字符串和给定字符在字符串中的位置
    &#125;
    else printf(&quot;no match found&quot;);
&#125;
char *match(char c, char *sp)
&#123;
    int count&#x3D;0;
    while(c!&#x3D;sp[count]&amp;&amp;sp[count]!&#x3D;&#39;\0&#39;)  &#x2F;&#x2F;如果c与字符串中的字符不相等，并且不是结束字符，则指针向下移动
    count++;                              &#x2F;&#x2F;记录指针向下移动次数，循环结束则指针移动结束
    if(sp[count])                         &#x2F;&#x2F;如果此时指针指向的字符不为空则说明在字符串中匹配到了该字符
    return(&amp;sp[count]);                   &#x2F;&#x2F;所以返回此时的指针
    else return NULL;                     &#x2F;&#x2F;如果没有匹配到，返回NULL
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了对字符，数组操作经常存在获取地址信息的情况外，如果函数内部有动态分配空间等操作也经常需要返回地址信息<br>
函数返回指针示例程序2:获取动态内存，通过形参双向传递地址信息</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
void Getmemory(int n,int **p);            &#x2F;&#x2F;定义一个二重指针形参**p用来对指针值进行双向传递
int main()
&#123;
    int n,*add&#x3D;NULL;                      &#x2F;&#x2F;令主调函数的指针add初值为空，防止后续调用函数结束后给*add赋值时才分配空间，从而引起混淆
    scanf(&quot;%d&quot;,&amp;n);
    Getmemory(n,&amp;add);                    &#x2F;&#x2F;调用Getmemory函数
    *add&#x3D;1;                               &#x2F;&#x2F;向add指向的空间中写入数据
    printf(&quot;%p是%d&quot;,add,*add);
&#125;
void Getmemory(int n,int **p)
&#123;
    *p&#x3D;(int*)malloc(n*sizeof(int));       &#x2F;&#x2F;此时二重指针p指向实参add的地址，将动态分配的地址空间赋给add
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意局部变量的地址一般不作为函数的返回值，例：</p>
<pre class="line-numbers language-none"><code class="language-none">    int *test();
    int main()
    &#123;
        int *t1,*t2;
        t1&#x3D;test();
        *t1&#x3D;10;                              &#x2F;&#x2F;修改t1指针指向的变量a的值为10
        t2&#x3D;test();                           &#x2F;&#x2F;再次调用test()，a又被赋值为5
        printf(&quot;t1&#x3D;%p,*t1&#x3D;%d\n&quot;,t1,*t1);     &#x2F;&#x2F;输出结果：t1&#x3D;0x7ffeec1a55dc,*t1&#x3D;5         虽然结果为5，但此时t1指向的a其实已经被回收了
        printf(&quot;t2&#x3D;%p,*t2&#x3D;%d\n&quot;,t2,*t2);     &#x2F;&#x2F;输出结果：t2&#x3D;0x7ffeec1a55dc,*t2&#x3D;983229963 此时test()函数调用结束，a的内存空间被释放
    &#125;                                                                                &#x2F;&#x2F;t2指向的空间中是一个随机数
    int *test()
    &#123;
        int a&#x3D;5;
        return &amp;a;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>局部变量作为返回值时，一般是系统申请一个临时对象存储局部变量，也就是找个替代品，这样系统就可以回收局部变量，返回的只是个替代品。但如果是指针，因为返回的局部变量是地址，地址虽然返回了但所指向的内存中的值已经被回收，主函数再去调就可能有问题。</p>
<h2 id="函数指针"><a class="markdownIt-Anchor" href="#函数指针"></a> 函数指针</h2>
<p>函数指针：指向函数的指针<br>
在c中，函数本身不是变量，但可以定义指向函数的指针。一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似，可以把函数的这个首地址(或称入口地址)赋予一个指针变量，使指针变量指向函数所在的内存区域，通过指针变量就可以找到并调用该函数，这种类型的指针即为函数指针，可以被赋值、存放在数组中、传递给函数以及作为函数返回值等。</p>
<blockquote>
<p>函数指针定义的基本形式为：返回类型 (*指针名)(参数列表);</p>
</blockquote>
<p>参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。注意()的优先级高于*，因此第一个括号不能省略，尤其如果在函数参数中省略则通常是一个非法的表示(先计算括号内再转换为int*)，如果写作</p>
<blockquote>
<p>返回值类型 *指针名(参数列表);</p>
</blockquote>
<p>就成了指针函数原型，它表明函数的返回值类型为指针，指针名实际上是函数名</p>
<p>函数指针示例程序：用指针来实现对函数的调用</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
using namespace std;
int max(int a, int b)
&#123;
    return a&gt;b?a:b;
&#125;
int main()
&#123;
    int (*pmax)(int,int)&#x3D;max;              &#x2F;&#x2F;因为函数名代表首地址，本质上也是个指针常量，所以将整型函数赋值给整型指针pmax
    printf(&quot;%d\n&quot;,pmax(1,2));              &#x2F;&#x2F;此时pmax存储的就相当于函数首地址指针，因此可以直接用pmax()调用函数
    printf(&quot;%d\n&quot;,(*pmax)(1,2));           &#x2F;&#x2F;*pmax相当于函数的内容，因此*pmax()也可以调用函数
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以使用typedef来声明函数类型和函数指针类型，如：</p>
<blockquote>
<p>typedef 返回类型 函数类型名(参数列表);<br>
typedef 返回类型 *指针函数类型名(参数列表);<br>
typedef 返回类型 (*函数指针类型名)(参数列表);</p>
</blockquote>
<p>注意c语言的定义中是没有函数类型的，因此它的函数变量会自动退化成函数指针(不过在c++中好像是可以的，在这里主要说明的是形式上的相似性)<br>
使用typedef定义函数指针，代码看起来更简洁，也更不容易出错，并且可以将定义的函数指针类型作为返回值，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int add(int a, int b) &#123;
    return a + b;
&#125;
typedef int (PTypeFun1)(int, int); &#x2F;&#x2F; 声明一个函数类型
typedef int (*PTypeFun2)(int, int); &#x2F;&#x2F; 声明一个函数指针类型
int (*padd)(int, int); &#x2F;&#x2F; 传统形式，定义一个函数指针变量 
int (*padd)(int, int); &#x2F;&#x2F; 传统形式，定义一个函数指针变量 
&#x2F;&#x2F; PTypeFun1 getfuncptr()&#123;  &#x2F;&#x2F; 返回函数类型不可以的
&#x2F;&#x2F;     return padd;
&#x2F;&#x2F; &#125;
PTypeFun1*getfuncptr()&#123;  &#x2F;&#x2F; 返回函数类型不可以的
    return padd;
&#125;
int usefuncptr(PTypeFun1 p1,PTypeFun2 p2)&#123;
    return p1(1,2)+p2(1,2);
&#125;
int main() &#123;
    PTypeFun1 *pTypeAdd1 &#x3D; add;
    PTypeFun2 pTypeAdd2 &#x3D; add;
    padd &#x3D; add;
    printf(&quot;%d\n&quot;,pTypeAdd1(1,2)); &#x2F;&#x2F;pTypeAdd1相当于退化成了函数指针类型
    printf(&quot;%d\n&quot;,pTypeAdd2(1,2));  
    printf(&quot;%d\n&quot;,usefuncptr(getfuncptr(),pTypeAdd2));
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="复杂声明"><a class="markdownIt-Anchor" href="#复杂声明"></a> 复杂声明</h1>
<p>c语言常常因为声明的语法问题而受到人们的批评，特别是涉及函数指针的语法。c语言的语法力图使声明和使用相一致，对于简单的情况，c的做法是很有效的，但如果情况较为复杂则容易让人混淆。<br>
主要原因是c的声明不能从左至右阅读，而且使用了太多的圆括号，如:</p>
<blockquote>
<p>int* f();int(* pf)();其中f是一个函数，它返回一个指向int类型的指针，而pf是一个指向函数的指针，该函数返回一个int类型的对象</p>
</blockquote>
<p>f和pf之间的含义差别说明:<br>
*是一个前缀运算符，其优先级低于()，因此在声明中必须使用圆括号以保证正确结合顺序。实际中其实很少用到过于复杂的声明，但是懂得如何理解以及使用这些复杂声明是很重要的。简化复杂声明的方法有很多，主要有两种方法:</p>
<ul>
<li>一种较好的方法是使用typedef通过简单的步骤合成</li>
<li>另一种方法:使用两个程序，一个程序(dcl)用于将正确的c声明转换为文字描述，另一个程序完成文字描述顺序的转换，从左向右阅读(direct-dcl)<br>
通过程序将声明转换为文字说明，就可以充分理解声明的含义</li>
</ul>
<p>使用效果例:</p>
<blockquote>
<p>char ** argv<br>
argv:pointer to pointer to char<br>
int (* daytab)[13]<br>
daytab:pointer to array[13] of int<br>
int * daytab[13]<br>
daytab:array[13] of pointer to int<br>
void * comp()<br>
comp:function returning pointer to void<br>
void (* comp)()<br>
comp:pointer to function returning void<br>
char (* (* x())[])()<br>
x:function returning pointer to array[] of pointer to function returning char<br>
char(* (* x[3])())[5]<br>
x:array[3] of pointer to function returning pointer to array[5] of char</p>
</blockquote>
<p>dcl是基于声明符的语法编写的，其简化的语法形式为:</p>
<blockquote>
<p>dcl:            前面带有可选的*  的direct-dcl<br>
direct-dcl:     name|(dcl)|direct-dcl()|direct-dcl[可选的长度]</p>
</blockquote>
<p>简而言之:-</p>
<ul>
<li>声明符dcl是前面可能带有多个*的direct-dcl(因为多个指针连在一起可以理解为指向…指向…指向的指针)</li>
<li>direct-dcl可以是name、由一对圆括号括起来的dcl、后面有一对圆括号的direct-dcl、后面有用方括号括起来的表示可选长度的direct-dcl</li>
</ul>
<p>该语法可对c的声明进行分析，如:</p>
<blockquote>
<p>(*pfa[])();</p>
</blockquote>
<p>按该语法分析，pfa将被识别为一个name，从而被认为是一个direct-dcl，然后pfa与[]结合也是一个direct-dcl，接着** pfa[]被识别为一个dcl(非direct-dcl)，然后(* pfa[])被识别为一个direct-dcl，最后(* pfa[])()是一个direct-dcl</p>
<p>程序dcl的核心是两个函数:dcl，dirdcl，它们根据声明符的语法对声明进行分析</p>
<p>由于语法是递归定义的，所以在识别一个声明的组成部分时，这两个函数是相互递归调用的，称该程序是一个<strong>递归下降语法分析</strong>程序</p>
<pre class="line-numbers language-none"><code class="language-none">enum &#123;NAME,PARENS,BRACKETS&#125;;
void dcl(),dirdcl();
char token[MAXTOKEN],name[MAXTOKEN],datatype[MAXTOKEN],out[MAXLINE];
int gettoken(),tokentype;
&#x2F;&#x2F;tokentype:token的类型，定义了三种类型分别是NAME:标识符,PARENS:函数,BRACKETS:数组
void dclmain()
&#123;
    while(gettoken()!&#x3D;EOF)
    &#123;   
        strcpy(datatype,token);
        *out&#x3D;&#39;\0&#39;;
        dcl();
        if(tokentype!&#x3D;&#39;\n&#39;)cout&lt;&lt;&quot;syntax error&quot;&lt;&lt;endl;
        cout&lt;&lt;name&lt;&lt;&quot;:&quot;&lt;&lt;out&lt;&lt;&#39; &#39;&lt;&lt;datatype&lt;&lt;endl;
    &#125;
&#125;
void dcl()
&#123;
    int ns&#x3D;0;
    while(gettoken()&#x3D;&#x3D;&#39;*&#39;)ns++;
    dirdcl();
    while(ns--&gt;0)strcat(out,&quot; pointer to&quot;);
&#125;
void dirdcl()
&#123;
    int type;
    if(tokentype&#x3D;&#x3D;&#39;(&#39;)
    &#123;
        dcl();
        if(tokentype!&#x3D;&#39;)&#39;)cout&lt;&lt;&quot;error:missing &#39;)&#39;&quot;&lt;&lt;endl;
    &#125;
    else if(tokentype&#x3D;&#x3D;NAME)strcpy(name,token);
    else cout&lt;&lt;&quot;error:expected name or (dcl)&quot;&lt;&lt;endl;
    while((type&#x3D;gettoken())&#x3D;&#x3D;PARENS||type&#x3D;&#x3D;BRACKETS)
    if(type&#x3D;&#x3D;PARENS)strcat(out,&quot; function returning&quot;);
    else
    &#123;
        strcat(out,&quot; array&quot;);
        strcat(out,token);
        strcat(out,&quot; of&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该程序的目的旨在说明问题，并不想做得尽善尽美，所以对dcl有很多的限制，它只能处理类似于char或int的简单数据类型，无法处理函数中的参数类型或类似于const这样的限定符，不能处理带有不必要空格的情况。由于没有完备的出错处理，因此它也无法处理无效的声明。</p>
<pre class="line-numbers language-none"><code class="language-none">int gettoken()
&#123;
    int c;
    char *p&#x3D;token;
    while((c&#x3D;getch())&#x3D;&#x3D;&#39; &#39;||c&#x3D;&#x3D;&#39;\t&#39;);
    if(c&#x3D;&#x3D;&#39;(&#39;)
    &#123;
        if((c&#x3D;getch())&#x3D;&#x3D;&#39;)&#39;)
        &#123;
            strcpy(token,&quot;()&quot;);
            return tokentype&#x3D;PARENS;
        &#125;
        else
        &#123;
            ungetch(c);
            return tokentype&#x3D;&#39;(&#39;;
        &#125;
    &#125;
    else if(c&#x3D;&#x3D;&#39;[&#39;)
    &#123;
        for(*p++&#x3D;(char)c;(*p++&#x3D;(char)getch())!&#x3D;&#39;]&#39;;);
        *p&#x3D;&#39;\0&#39;;
        return tokentype&#x3D;BRACKETS;
    &#125;
    else if(isalpha(c))
    &#123;
        for(*p++&#x3D;(char )c; isalnum(c&#x3D;getch());)*p++&#x3D;(char )c;
        *p&#x3D;&#39;\0&#39;;
        ungetch(c);
        return tokentype&#x3D;NAME;
    &#125;   
    else return tokentype&#x3D;c;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果不在乎生成多余的圆括号，则另一个方向的转化要容易一些<br>
为了简化输入将&quot;x is a function returning a pointer to an array of pointers to functions returning char&quot;<br>
(x是一个函数，返回一个指针，该指针指向一个数组，数的元素是指针，这些指针分别指向多个函数，这些函数的返回类型是char)<br>
程序undcl将该形式转化为</p>
<blockquote>
<p>char (* (* x())[])()</p>
</blockquote>
<p>由于对外部输入的格式进行了限定，所以可以重用上方的gettoken()函数和外部变量</p>
<pre class="line-numbers language-none"><code class="language-none">void undclmain()
&#123;
    int type,braket;
    char temp[MAXTOKEN];
    while(gettoken()!&#x3D;EOF)
    &#123;
        strcpy(out,token);
        while((type&#x3D;gettoken())!&#x3D;&#39;\n&#39;)
        if(type&#x3D;&#x3D;PARENS||type&#x3D;&#x3D;BRACKETS)strcat(out,token);
        else if(type&#x3D;&#x3D;&#39;*&#39;)
        &#123;
            nexttoken&#x3D;YES;
            braket&#x3D;gettoken();
            if(braket&#x3D;&#x3D;PARENS||braket&#x3D;&#x3D;BRACKETS)
                sprintf(temp,&quot;(*%s)&quot;,out);
            else if(braket!&#x3D;&#39;\n&#39;)sprintf(temp,&quot;*%s&quot;,out);
            else break;
            strcpy(out,temp);
        &#125;
        else if(type&#x3D;&#x3D;NAME)
        &#123;
            sprintf(temp,&quot;%s %s&quot;,token,out);
            strcpy(out,temp);
        &#125;
        else cout&lt;&lt;&quot;invalid input at &quot;&lt;&lt;token&lt;&lt;endl;
        cout&lt;&lt;out&lt;&lt;endl;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数递归</title>
    <url>/posts/586bfaec841d</url>
    <content><![CDATA[<h1 id="递归函数"><a class="markdownIt-Anchor" href="#递归函数"></a> 递归函数</h1>
<p>函数可以调用其他函数，也可以调用自身<br>
递归函数(Recursive Function),即自调用函数,在函数体内有直接的或间接地自己调用自己的语句<br>
递归函数很特殊，因为自己调用自己，很容易出现死循环<br>
因此自调用过程在函数内必须设置某些条件，当条件成立时终止自调用过程，并使程序控制逐步从函数中返回,称为条件递归\</p>
<span id="more"></span>
<p>递归程序必然包含两部分：</p>
<ul>
<li>递归循环继续的过程</li>
<li>递归调用结束的过程</li>
</ul>
<p>递归程序分析：</p>
<ul>
<li>根据观察，找到输入变量：m1,m2…mn</li>
<li>设求的递归函数是f(m1,m2…mn)</li>
<li>前一个项和后一个项肯定是有关系的，不然递归无法进行。即f(m1n,m2n…mnn)与f(m1n-1,m2n-1…mnn-1)之间有一定关系</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">例1:求n的阶乘
    算法分析：
    n&#x3D;0 n!&#x3D;1; 
    n!&#x3D;0 n!&#x3D;n*(n-1)!

int Factorial(int n)
&#123;
    if(n&#x3D;&#x3D;0)return 1;                    递归结束条件       
    if(n!&#x3D;0)return Factorial(n-1)*n;     
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数调用过程：<br>
函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新自动变量集合<br>
以n=3为例，首先n!=0,Factorial(3)=Factorial(2)*3，此处Factorial(3)调用了Factorial(2)<br>
进入Factorial(2)，n=2,n!=0, Factorial(2)=Factorial(1)*2,同理，继续调用Factorial(1)<br>
进行3次递归后，n==0,此时返回Factorial(0)=1<br>
将Factorial(0)依次向上传递后，得到Factorial(3)的结果<br>
Factorial()属于尾递归，即递归调用位于函数体的结尾处，除了尾递归外还有中间递归，多层递归等\</p>
<pre class="line-numbers language-none"><code class="language-none">例2:一个能够较好说明递归的例子是快速排序，快速排序算法是C.A.R.Hoare于1962年发明的
    对于一个给定数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集
    一个子集中所有元素都小于该元素，另一个子集中所有元素都大于或等于该元素
    对这样两个子集递归执行这一过程，当某个子集元素数小于2时，这个子集就不需要排序，终止递归
    每次划分子集时，选取各个子数组的中间元素，从执行速度上来讲此算法版本的快速排序可能不是最快，但是最简单的算法之一
void swap(int t[],int a,int b)                                         因为单次递归过程要交换三次元素
&#123;                                                                      所以将其单独封装为函数
    int tmp;
    tmp&#x3D;t[a],t[a]&#x3D;t[b],t[b]&#x3D;tmp;
&#125;
void qsort(int t[],int start,int end)&#123;                                 KR书上的快速排序
    int pivot,i;
    if(end&lt;&#x3D;start)return;                                              若数组元素数小于2，不进行任何操作
    swap(t,start,(start+end)&#x2F;2);                                       划分子集的元素(枢轴)移动到v[0]
    pivot&#x3D;start;
    for(i&#x3D;start+1;i&lt;&#x3D;end;i++)if(t[i]&lt;t[start])swap(t,++pivot,i);       划分子集
    swap(t,start,pivot);                                               恢复枢轴元素
    qsort(t,start,pivot-1);
    qsort(t,pivot+1,end);
&#125;
标准库中提供了一个qsort函数，可用于对任何类型的对象排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数调用之间用参数传递和返回值联系<br>
递归调用机制是由栈数据结构实现的<br>
使用递归函数使程序代码和递归关系几乎一致，代码紧凑，可读性很强，直观精炼，符合人的思维习惯，接近数学公式的表示，更易于编写和理解，<br>
递归尤其适合非数值计算领域，如：汉诺塔，骑士游历，八皇后问题<br>
在描述树等递归定义的数据结构时使用递归尤其方便<br>
但递归不断调用函数并在栈中分配空间保存参数返回地址，会大量增加系统开销，时间空间消耗都较高，执行效率低下<br>
因此在很多需要运行效率的场合中需要将递归转为非递归形式\</p>
<pre class="highlight"><code class>递归函数示例程序：找出a和b的最大公约数
    算法分析：
    a和b的最大公约数是b和a%b的最大公约数
    a=kb+a%b=kb+r,r&lt;nb,n&gt;=2
    充分性证明：
    设d为(a,b)的最大公约数，则d可以整除b和kb+r，所以d整除r，所以d是(b,a%b)的公约数
    如果(b,a%b)存在比d大的公约数d'，则d'可以整除kb+r，d不是(a,b)的最大公约数，矛盾
    因此d是(b,a%b)的最大公约数
    必要性证明：
    设d为(b,r)的最大公约数，则d可以整除b和r，因此可以整除a=kb+r，因此d是a和b的公约数
    同理，如果(a,b)存在比d大的公约数d''，则d''可以整除r，dd是(a,b)的最大公约数
#include&lt;stdio.h&gt;
int Divisor(int a,int b)
&#123;
    if(a&gt;=b)
    &#123;
        if(a%b==0)return b;
        else return Divisor(b,a%b);
    &#125;
&#125;
int main()
&#123;
    printf(&quot;%d&quot;,Divisor(43278,4237));     输出结果：1
&#125;
Divisor()也可以转换为非递归形式(迭代)         递归中一定有迭代，但是迭代中不一定有递归；大部分可以相互转换。
int Divisor(int a,int b)            
&#123;
    int tmp;
    while(a%b!=0)
    &#123;
        tmp=a;
        a=b;
        b=tmp%a;
    &#125;
    return b;
&#125;</code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数参数、函数调用</title>
    <url>/posts/235554bce98c</url>
    <content><![CDATA[<h1 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h1>
<p>数据传递，函数调用的过程实际上就是将实参数据原样拷贝到形参当中<br>
参数会出现在两个地方，分别是函数定义处和函数调用处，这两个地方的参数是有区别的<br>
用void定义参数表示没有参数，不接收外部传输数据</p>
<span id="more"></span>
<h2 id="形参形式参数"><a class="markdownIt-Anchor" href="#形参形式参数"></a> 形参（形式参数）</h2>
<p>在函数定义中出现的参数可以看做是一个占位符，它没有数据，只能等到函数被调用时接收传递进来的数据，所以称为形式参数，简称形参<br>
形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。</p>
<h2 id="实参实际参数"><a class="markdownIt-Anchor" href="#实参实际参数"></a> 实参（实际参数）</h2>
<p>函数被调用时给出的参数包含了实实在在的数据，会被函数内部的代码使用，所以称为实际参数，简称实参<br>
实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时都必须有确定的值<br>
实参和形参在数量上、类型上、顺序上必须严格一致\</p>
<h1 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h1>
<p>函数调用实质，程序执行流程转向由函数名指定的被调用函数<br>
主要流程为：</p>
<ul>
<li>实参一一对应地传递给函数定义中的形参</li>
<li>执行函数定义中的函数体</li>
<li>执行结束，通过return语句将值返回到调用处</li>
<li>程序执行流程返回调用处，执行后面的语句</li>
</ul>
<h2 id="传值传址"><a class="markdownIt-Anchor" href="#传值传址"></a> 传值，传址</h2>
<p>函数参数传值调用过程：将函数调用语句中实参的一份副本传给函数的形参<br>
c语言是以传值方式将参数值传递给被调用函数的，因此被调用函数不能直接修改主调函数中变量的值，例：</p>
<pre class="line-numbers language-none"><code class="language-none">void Getnum(int num)         &#x2F;&#x2F;实参n将值传给形参num
&#123;
    num&#x3D;10;                  &#x2F;&#x2F;形参num的值发生改变，由于参数传递采用传值方式，因此该函数仅仅改变了num副本的值
    return;
&#125;
int main()
&#123;
    int n&#x3D;20;                &#x2F;&#x2F;实参赋值
    Getnum(n);               &#x2F;&#x2F;返回主调函数，形参num的内存空间被释放掉，实参n的值没有发生改变
    printf(&quot;%d&quot;,n);          &#x2F;&#x2F;输出结果：20
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数参数传地址调用过程：将变量的地址传递给函数的形参<br>
指针参数使得被调用函数能够访问和修改主调函数中对象的值<br>
形参和实参指向了同一个内存地址，对形参的操作同时影响了实参的值，从而实现了双向传递，例:</p>
<pre class="line-numbers language-none"><code class="language-none">void Getnum(int *num)        &#x2F;&#x2F;实参n将地址值传给指针形参num
&#123;
    *num&#x3D;10;                 &#x2F;&#x2F;形参num对&amp;n地址的值进行操作，通过指针间接访问指向的操作数
    return;
&#125;
int main()
&#123;
    int n&#x3D;20;                 &#x2F;&#x2F;实参赋值
    Getnum(&amp;n);               &#x2F;&#x2F;返回主调函数，此时实参n的值已经发生了变化
    printf(&quot;%d&quot;,n);           &#x2F;&#x2F;输出结果：10
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上面示例程序中ReadInfo()也可以发现，如果函数中存在需要对读取学生人数进行修改等操作情况，就需要将形参设置为整型指针*num<br>
另外如标准库函数scanf等的实现也借助了这种方法:<br>
scanf将标识是否到达文件末尾的状态作为getint函数的返回值，同时使用一个指针参数存储转换后得到的整数并传回给主调函数<br>
另外，指针在传入参数时实际上也是值传递，因此只能通过取址操作改变指针所指向空间中的值，对指针本身是无法进行操作的，例:</p>
<pre class="line-numbers language-none"><code class="language-none">int strlen(char*s)
&#123;
    int n;
    for(n&#x3D;0;*s!&#x3D;&#39;\0&#39;;s++)n++;
    return n;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中执行s++运算不会影响到strlen函数调用者中的字符串，它仅对指针在strlen函数的私有副本进行自增运算</p>
<h1 id="返回值"><a class="markdownIt-Anchor" href="#返回值"></a> 返回值</h1>
<p>函数的返回值是指函数被调用之后，执行函数体中的代码所得到的结果，这个结果通过return语句返回<br>
被调用函数通过return语句向调用者返回值，return语句后面可以跟任何表达式，表达式两边通常加一对圆括号，此处的括号式可选的<br>
return只能用在函数中，用来返回处理结果，是提前结束函数的唯一办法\</p>
<p>若函数没有返回值，调用函数可以忽略返回值，此时通常用void定义返回值类型，并且return后不加表达式<br>
当被调用函数执行到最后的花括号而结束执行时，控制流同样返回给调用者<br>
return出来的数据的类型要和函数数据类型相同，必要时表达式将被转换为函数的返回值类型(return出来的数据实质上代表函数本身)<br>
return语句可以有多个，可以出现在函数体的任意位置，但是每次调用函数只能有一个return语句被执行，所以只有一个返回值<br>
某些情况下(多数编译环境是不支持的)，如果函数从一个地方返回有返回值从另一个地方返回没有返回值，该函数并不非法，但是可能发生问题的征兆<br>
任何情况下，如果一个函数没有成功返回一个值，则其值肯定是无用的<br>
主函数main也可以返回一个值，该值通常代表状态，可以在调用该程序的环境中使用\</p>
<p>某些情况下，函数的定义与声明必须一致，如果函数与调用的函数放在同一源文件，并且类型不一致，编译器会检测到该错误<br>
但是如果函数是单独编译的，这种不匹配的错误则无法检测出来，最后结果值将毫无意义<br>
如果没有函数原型，则函数将在第一次出现的表达式中被隐式声明，即如果一个没有声明过的名字出现在表达式中并且其后紧跟着一个圆括号时<br>
则上下文认为该名字是一个函数名，该函数将被假定为int类型，且上下文不对参数做任何假定<br>
如果函数声明中本身就不包含参数，则编译程序也不会对函数参数作任何假定，并且会关闭所有参数检查<br>
(同样，目前大部分编译环境已经不支持)\</p>
<p>对空参数表的特殊处理是为了能使新式编译器能编译老的c程序，不过在新编写的程序中如果函数带有参数则应声明，如果没有参数则使用void声明<br>
(空参数表说明函数不需要参数，并不代表就不可以传入参数,只不过传入的参数用不到而已，如int test();test(a);可以运行(只针对c，c++不行))<br>
(而加入void参数就限定了函数无法传入任何类型的参数，使程序更严谨)\</p>
<pre class="line-numbers language-none"><code class="language-none">例：返回两个整数中的较大的一个
int max(int a, int b)
&#123;
    if(a&lt;0|b&lt;0)return;        &#x2F;&#x2F;如果a或b小于0，则直接终止函数
    return (a&gt;b) ? a : b;     &#x2F;&#x2F;返回三目表达式
    printf(&quot;Function is performed\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="变长参数表"><a class="markdownIt-Anchor" href="#变长参数表"></a> 变长参数表</h1>
<p>在c中能以可移植的方式编写可处理变长参数表的函数</p>
<pre class="line-numbers language-none"><code class="language-none">如:printf的正确声明格式为int printf(char*fmt,...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其中省略号表示参数表中参数的数量和类型是可变的，并且省略号只能出现在参数表的尾部<br>
标准头文件&lt;stdarg.h&gt;中包含一组宏定义，他们对如何遍历参数表进行了定义，该文件的实现因不同的机器而不同，但提供的接口是一致的<br>
va_list类型通常用于声明一个指针变量，该变量依次引用各参数<br>
宏va_start将参数指针初始化为第一个无名参数的指针，使用参数指针前该宏必须被调用一次<br>
va_start参数表必须至少包括一个有名参数，va_start将最后一个有名参数作为起点<br>
宏va_arg使用一个类型名来决定返回的对象类型、指针移动的步长，每次调用va_arg都将返回一个参数，并将参数指针指向下一个参数<br>
最后，在va_arg返回之前必须调用宏va_end以完成一些必要的清理工作\</p>
<pre class="line-numbers language-none"><code class="language-none">例:简化的printf函数simprintf()
void simprintf(char*fmt,...)
&#123;
    va_list ap;                          &#x2F;&#x2F;定义va_list类型的参数指针ap，依次指向每个无名参数
    char*p,*sval;int ival;double dval;   &#x2F;&#x2F;指针p用于遍历模式字符串，ival,dval,sval用于接受输入流中的字符
    va_start(ap,fmt);                    &#x2F;&#x2F;带参宏va_start将ap指向最后一个有名参数fmt的后一个参数，即第一个无名参数
    for(p&#x3D;fmt;*p;p++)
    &#123;                                    &#x2F;&#x2F;遍历模式字符串
        if(*p!&#x3D;&#39;%&#39;)
        &#123;                                &#x2F;&#x2F;如果没有遇到字符&#39;%&#39;则直接输出其中的内容并跳过switch
            putchar(*p);
            continue;
        &#125;
        switch (*++p)
        &#123;                                &#x2F;&#x2F;移动*p，根据其值进行转换
            case &#39;d&#39;:
                ival&#x3D;va_arg(ap,int);     &#x2F;&#x2F;调用va_arg移动ap只指向下一个无名参数，同时返回int类型
                printf(&quot;%d&quot;,ival);       &#x2F;&#x2F;输出ival
                break;
            case &#39;f&#39;:
                dval&#x3D;va_arg(ap,double);  &#x2F;&#x2F;同理，移动ap返回double，输出dval
                printf(&quot;%f&quot;,dval);
                break;
            case &#39;s&#39;:
                for(sval&#x3D;va_arg(ap,char*);*sval;sval++)putchar(*sval); &#x2F;&#x2F;移动ap，返回char*遍历字符串后输出
                break;
            default:
                putchar(*p);             &#x2F;&#x2F;其他情况则直接输出
                break;
        &#125;
    &#125;
    va_end(ap);                          &#x2F;&#x2F;结束时的清理工作
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="命令行参数"><a class="markdownIt-Anchor" href="#命令行参数"></a> 命令行参数</h1>
<p>main()也有参数，并且参数表元素个数和数据类型都是固定的(已经声明)<br>
在支持c的环境中，可以在程序开始执行时将命令行参数传递给程序</p>
<pre class="line-numbers language-none"><code class="language-none">main()函数原型：
int main(int argc,char *argv[]);
调用主函数main时它带有两个参数
第一个参数习惯上称为argc，用于参数计数，其值表示运行程序时命令行中参数的数目
第二个参数习惯上称为argv，用于参数向量，是一个指向字符串数组的指针，每个字符串对应一个参数，通常用多级指针处理这些字符串(指针数组)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个参数字符串在输入时通过空格隔开</p>
<pre class="line-numbers language-none"><code class="language-none">例：arg[0]指向程序本身(类似于数组)，arg[n]指向命令行参数的第n个字符串常量。argc和argv是默认的参数名，也可以另取名字
    最简单的例子是程序echo，它将命令行参数回显在屏幕上的一行中，命令行各参数之间用空格隔开
    因此，命令echo programming is fun
    将打印输出:programming is fun
    此时argc&#x3D;4,argv[0]&#x3D;&quot;echo.exe&quot;,argv[1]&#x3D;&quot;programming&quot;,argv[2]&#x3D;&quot;is&quot;,argv[3]&#x3D;&quot;fun&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>按照c语言的约定，argv[0]的值是启动该程序的程序名，因此argc的值至少为1，如果argc=1则表示程序名后没有命令行参数<br>
因此第一个可选参数为argv[0]，最后一个可选参数为argv[argc-1]<br>
ANSI标准要求argv[argc]的值必须是一个空指针\</p>
<pre class="line-numbers language-none"><code class="language-none">回显程序的简单实现:
int main()
&#123;
    while(--argc&gt;0)cout&lt;&lt;*++argv&lt;&lt;(argc&gt;1?&#39; &#39;:&#39;&#39;); 或者打印语句也可以写成printf(argc&gt;1?&quot;%s &quot;:&quot;%s&quot;,*++argv)
    cout&lt;&lt;endl;    argv是一个指向参数字符串数组起始位置的指针，++argv可以使它刚开始就指向argv[1]，跳过存储程序名的argv[0]
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在GUI界面以前，计算机操作界面都是字符式的命令行界面(DOS,Linux,UNIX)<br>
在命令行界面中输入：文件名 命令行参数 这样的格式可以执行文件<br>
其中多个命令行参数字符串使用空格分隔(如果参数中本身带有空格则放在&quot;&quot;或’'中)</p>
<pre class="line-numbers language-none"><code class="language-none">命令行参数示例程序:模式查找程序的命令行参数模拟
#include&lt;iostream&gt;
using namespace std;
int grepmain(int argc,char*argv[])
&#123;
    char gline[MAXLINE];
    int found&#x3D;0;
    if(argc!&#x3D;2)cout&lt;&lt;&quot;Usge:find pattern&quot;&lt;&lt;endl;
    else while(getline_ptr(gline,MAXLINE)&gt;0)
        if(strstr(line,argv[1])!&#x3D; nullptr)
        &#123;
            cout&lt;&lt;gline;
            found++;
        &#125;
    return found;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>标准库函数strstr(s,t)返回一个指针，该指针指向字符串t在字符串s中第一次出现的位置，如果字符串t没有在字符串s中出现则返回空指针NULL<br>
该函数声明在头文件&lt;string.h&gt;<br>
为进一步解释指针结构，可以假定允许程序带两个可选参数，其中一个表示打印除匹配模式之外所有行，另一个参数表示每个打印文本行前加相应行号<br>
UNIX系统中的c程序有一个公共的约定:以负号开头的参数表示一个可选标志或参数<br>
假定以-x(代表“除…之外”)表示打印所有与模式不匹配的文本行，用-n(代表“行号”)表示打印行号</p>
<pre class="line-numbers language-none"><code class="language-none">如:find -x -n 模式 表示打印所有与模式不匹配的行，并在每个打印行的前面加上行号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>可选参数应该允许以任意次序出现，同时程序的其余部分应该与命令行中参数的数目无关，并且如果可选参数能组合使用，将给使用者带来更多的便利\</p>
<pre class="line-numbers language-none"><code class="language-none">如:find -nx 模式
#include&lt;iostream&gt;
using namespace std;
int grepmain_nx(int argc,char*argv[])
&#123;
    char gline[MAXLINE];
    long lineno&#x3D;0;
    int except&#x3D;0,number&#x3D;0,found&#x3D;0;
    while(--argc&gt;0&amp;&amp;**++argv&#x3D;&#x3D;&#39;-&#39;)while(*++*argv)
    switch (**argv)
    &#123;
        case &#39;x&#39;:except&#x3D;1;
                break;
        case &#39;n&#39;:number&#x3D;1;
                break;
        default:
            cout&lt;&lt;&quot;find:illegal option&quot;&lt;&lt;&quot; -&quot;&lt;&lt;**argv;
            argc&#x3D;0,found&#x3D;-1;
            break;
    &#125;
    if(argc!&#x3D;1)cout&lt;&lt;&quot;Usge:find -x -n pattern&quot;&lt;&lt;endl;
    else while(getline_ptr(gline,MAXLINE)&gt;0)
    &#123;
        lineno++;
        if((strstr(gline,*argv)!&#x3D; nullptr)!&#x3D;except)
        &#123;
            if(number)cout&lt;&lt;lineno;
            cout&lt;&lt;gline;
            found++;
        &#125;
    &#125;
    return found;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，<em>++argv是一个指向参数字符串的指针，**++argv是它的第一个字符，另一种有效表达方式是</em>(++argv)[0]<br>
如果在上述表达式中不加圆括号变成*<ins>argv[0]的话，实际上是*(<ins>argv[0])，相当于<em>argv[0][1]或</em></ins><em>argv<br>
实际上在内层循环中就使用了</em></ins><em>argv或</em>++argv[0]，其目的是遍历一个特定的字符串<br>
实际上很少有人会使用比这更复杂的指针表达式了，如果遇到这种情况可以考虑分为两三步来理解会更直观一些</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数</title>
    <url>/posts/a6bd64132687</url>
    <content><![CDATA[<h1 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h1>
<blockquote>
<p>函数是c语言模块化编程的最小单位，可以把每个函数看作一个“模块”(module)<br>
把这些函数单独设计，测试，调试好，用时再拿来装配，总体调试，这些函数可以是自己设计制造/别人设计制造/现成的标准产品</p>
</blockquote>
<span id="more"></span>
<h2 id="函数的概念"><a class="markdownIt-Anchor" href="#函数的概念"></a> 函数的概念</h2>
<p>函数是按给定的任务，把相关语句组织在一起的程序块，也称为例程或过程<br>
可以将大的计算任务分解成若干较小的任务，并且可以基于函数进一步构造程序，而不需重新编写一些代码<br>
设计得当的函数可以将程序中不需要了解的具体操作细节隐藏起来，从而使整个程序结构更加清晰，降低修改程序的难度<br>
若干相关的函数可以合并成一个模块(源程序文件)，一个c程序结构一般由一个或多个源程序文件组成<br>
c在设计中考虑了函数的高效性和易用性两个因素，c程序一般都由许多小的函数组成，而不是少量较大的函数组成<br>
函数之间通信可以通过参数，函数返回值以及外部变量进行，<br>
函数在源文件中出现的次序可以是任意的，只要保证每个函数不被分离到多个文件，源程序就可以分为多个文件<br>
通常在解决实际问题中，最好将程序划分成若干个与问题的自然划分相一致的函数，并通过主函数控制其他函数的执行</p>
<h2 id="函数的分类"><a class="markdownIt-Anchor" href="#函数的分类"></a> 函数的分类</h2>
<ul>
<li>标准库函数(ANSI/ISO C定义的标准库函数)符合标准的c编译器必须提供这些函数，函数的行为必须符合ANSI/ISO C的定义\</li>
<li>第三方库函数<br>
由其他厂商自行开发的c语言函数库，不在标准范围内，能扩充c语言的功能(图形，网络，数据库等)\</li>
<li>自定义函数<br>
自己定义使用的函数，也可以包装成函数库发布出来</li>
</ul>
<h2 id="函数的执行流程"><a class="markdownIt-Anchor" href="#函数的执行流程"></a> 函数的执行流程</h2>
<p>c程序的执行从main()函数开始，一个函数可以调用其他函数，也可以被其他函数调用<br>
调用其他函数后流程回到main()函数<br>
在main函数中结束整个程序运行</p>
<blockquote>
<p>模块化设计:“拿来主义”提高软件开发效率<br>
函数体现了分治算法的思想，即求解问题采用逐步分解、分而治之的方法，将大问题分解为比较容易求解的小问题，小问题求解完后大问题就容易求解了<br>
程序设计的模块化程序设计方法就是这种思路，采用函数求解<br>
程序模块化，是程序设计简单直观，提高程序可读性和可维护性，提高代码复用性，减少编程和修改的工作量<br>
采用自顶向下的程序设计思路，自下向上实现的模块化设计方法(先设计框架，然后从各个组成部分开始实现)<br>
函数+函数构成程序<br>
成熟软构件+修订=新软件<br>
成熟软构件1+成熟软构件2+…=新软件系统</p>
</blockquote>
<p>ANSI标准对c做的最明显的修改是函数声明和函数定义两方面</p>
<pre class="line-numbers language-none"><code class="language-none">早期版本的c函数声明和定义的实现，例:
    int power();    函数声明中不包含参数列表，并且默认返回int类型的值，因此很多时候整个函数声明甚至可以完全省略
    power(base,n)   函数定义时参数名在圆括号内指定，
    int base,n;     参数类型在左花括号之前声明，如果没有声明某个参数的类型，则默认为int类型
    &#123;…&#125;             函数体与ANSI C中形式相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相比于ANSI C，早期版本的方式很难检测出函数调用中参数数目和类型方面的错误<br>
ANSI C仍然支持旧式的函数声明与定义(保持一个过渡阶段)，但新式编译器中应一律使用ANSI C规定的新式函数原型声明方式(很多编译器已不支持)<br>
ANSI C改编后的c函数声明、定义语法</p>
<h2 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h2>
<p>让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用\</p>
<pre class="line-numbers language-none"><code class="language-none">如:status ReadInfo(char *name, struct student stu[], int *num);
声明只是指出了函数的名字，并没有为其分配存储空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>基本格式为：函数数据类型 函数名(数据类型1 形参1,数据类型2 形参2…)<br>
函数声明给出了函数名、返回值类型、参数列表等与该函数有关的其他信息，称为函数原型<br>
函数声明的时候只要让编译器知道这个函数参数个数、参数类型即可，编译器并不会检查变量名</p>
<pre class="line-numbers language-none"><code class="language-none">如：int func(int,int)和int func(int a,int b)对编译器是一样的，此时两个整型参数无法使用，称为占位参数
参数声明得当(一般尽量声明范围较大的参数类型)，程序就可以自动进行适当的表达式强制类型转换
函数名称要满足标识符定义，同时与要实现的功能相关，函数名称后面跟一个小括号，表明不是普通变量名称而是函数名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2>
<p>定义表示创建或分配存储单元<br>
将代码段封装成函数的过程叫做函数定义，基本格式如下：<br>
函数返回值类型  函数名(数据类型1 形参1，数据类型2 形参2…){声明语句序列 可执行语句序列(函数体);}</p>
<pre class="line-numbers language-none"><code class="language-none">例：计算整数n的阶乘
    int Fact(int n)
    &#123;
        int i,result&#x3D;1;             函数内部可以定义只供自己使用的变量，称内部变量
        for(i&#x3D;1;i&lt;&#x3D;n;i++)
        &#123;
            result*&#x3D;i;
        &#125;
        return result;              返回值作为函数调用表达式的值
    &#125;
    int main()
    &#123;
        printf(&quot;%d&quot;,Fact(10));      函数调用，实参传递
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中函数体描述函数整体的功能，是函数的主体部分，即使只有一个语句，函数体也要由{}包围<br>
如果有返回值，需要在函数体中使用return语句返回<br>
函数不能嵌套定义，不能在一个函数中定义另外一个函数，函数的作用域默认是全局的，必须定义在函数以外(但可以在函数内部声明)<br>
main()也是一个函数定义，因此也不能在main()函数内部定义新函数，main()函数要求必须返回int类型数据\</p>
<pre class="line-numbers language-none"><code class="language-none">函数示例程序：从文件中读取数据(程序仅为大体的结构，无法运行)
status ReadInfo(char *name,struct student stu[],int *num);      status是自定义的类型，用以描述返回状态值,一种伪代码
int main()                                      开始执行;        typedef int Status;大致上是用来返回本函数是否执行成功
&#123;
    char *name&#x3D;“stuScores.txt”;struct student[40];int n;        实参
    if(ReadInfo(name,student,&amp;n)&#x3D;&#x3D;fail)       调用ReadInfo(); name为字符串常量(文件名)student为结构数组 n指向整型变量n
    &#123;
        printf(“open file error\n”);
        return-1;
    &#125;
&#125;
status ReadInfo(char *name,struct student stu[],int *num）       形参
&#123;
    status s&#x3D;fail;                                               调用后开始执行
    int i&#x3D;0;
    FILE *fp&#x3D;fopen(name,“r”);
    if(fp&#x3D;&#x3D;NULL)return s;
    while(!feof(fp))
    &#123;
        fread(fp,&amp;stu[i],sizeof(struct student),1);
        ++i;
    &#125;
    *num&#x3D;i;
    s&#x3D;success;
    return s;                                                   回到main()函数，表达式有没有括号都正确
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数定义中的各构成部分有时候可以省略，如:dummy(){}<br>
该函数不执行任何操作也不返回任何值，可以在程序开发期间用以保留位置(留待以后填充代码)<br>
如果函数定义中省略返回值类型，则默认为int类型(注意，这些行为在大部分编译器中是不支持的)</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>指针、数组、结构体</title>
    <url>/posts/54e92e94d217</url>
    <content><![CDATA[<h1 id="指针与一维数组"><a class="markdownIt-Anchor" href="#指针与一维数组"></a> 指针与一维数组</h1>
<p>通过指针访问内存，执行速度快于通过数组名访问内存，同时可以通过指针移动的方式访问数组<br>
任何通过数组下标所能完成的操作都可以通过指针来实现<br>
指针，数组名都是地址，都可以访问数组元素<br>
缺点是，用指针实现的程序理解稍微困难，不够直观\</p>
<span id="more"></span>
<pre class="line-numbers language-none"><code class="language-none">数组元素值和地址的等价引用形式，例：
int a[4]&#x3D;&#123;1,2,3,4&#125;;
int *pa&#x3D;a;                   等价于初始化int *pa&#x3D;&amp;a[0]; 因为a中存放的地址就是数组中首元素地址
pa&#x3D;a，相当于用数组名给指针赋值，pa就相当于数组名这一指针，可以用指针名加下标的方式表示元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果pa指向数组中某个特定元素，那么根据指针运算的定义，pa+i指向pa所指对象之后的第i个对象，pa-i指向pa所指对象之前第i个对象<br>
此时：a[i],pa[i],<em>(a+i),</em>(pa+i)是完全等价的<br>
对应地址：&amp;a[i],&amp;pa[i],(a+i),(pa+i)也是完全等价的<br>
无论数组中元素的类型或长度是什么，以上结论都成<br>
产生这种现象的原因在于，数组名存储的是数组连续空间的首地址本质上就是一个指针常量<br>
实际上，c在计算a[i]的时候就是现将其转换为*(a+i)的形式再进行求值，因此在程序中完全等价，同理&amp;a[i]和a+i也是一样<br>
不过数组名是指针常量不可修改指向，因此不能给数组名赋值，也无法进行单目运算等操作</p>
<pre class="line-numbers language-none"><code class="language-none">如:pa&#x3D;a和pa++都是合法的，但类似于a&#x3D;pa和a++形式的语句都是非法的<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结:</h2>
<p>简而言之，一个通过数组和下标实现的表达式都可以等价地通过指针和偏移量实现<br>
获取数组元素首地址的方式：数组名或数组首元素地址<br>
通过首地址访问数组元素的方式：</p>
<ul>
<li>
<p>数组元素直接访问，即下标变量的方式</p>
</li>
<li>
<p>指针加偏移量类型的间接地址访问</p>
</li>
<li>
<p>数组名作为指针值的直接地址访问</p>
</li>
<li>
<p>把指针看作数组名的下标变量方式</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">5种访问数组元素的方法示例程序：
#include&lt;stdio.h&gt;
int main()
&#123;
    int sum1,sum2,sum3,sum4,sum5;
    int iarray[]&#x3D;&#123;1,4,2,7,13,32,21,48,16,30&#125;;
    int *iptr,n,i;
    sum1&#x3D;sum2&#x3D;sum3&#x3D;sum4&#x3D;sum5&#x3D;0;
    const int size&#x3D;sizeof(iarray)&#x2F;sizeof(*iarray);
    for(n&#x3D;0;n&lt;size;n++)
    &#123;
	sum1+&#x3D;iarray[n];
	sum2+&#x3D;iptr[n];
	sum3+&#x3D;*(iarray+n);
	sum4+&#x3D;*(iptr+n);
	sum5+&#x3D;*iptr++;
    &#125;
    printf(&quot;%d %d %d %d %d&quot;,sum1,sum2,sum3,sum4,sum5);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="指针与二维数组"><a class="markdownIt-Anchor" href="#指针与二维数组"></a> 指针与二维数组</h1>
<p>c中按行优先顺序存放数据，对二维数组而言，数组a[i]代表的是第i行元素的首地址<br>
对二维数组而言，a[i]代表一个一维数组，相当于一个数组名</p>
<h2 id="二维数组的行"><a class="markdownIt-Anchor" href="#二维数组的行"></a> 二维数组的行</h2>
<p>假设a代表二维数组首地址，也是第0行的首地址<br>
&amp;a[i]或a+i代表行地址，每次加1移动一行<br>
*(a+i)或a[i]不代表具体元素，仍然是一个地址</p>
<h2 id="二维数组的列"><a class="markdownIt-Anchor" href="#二维数组的列"></a> 二维数组的列</h2>
<p>对于每一个一维数组a[i]或*(a+i),a[i]+j或*(a+i)+j表示一维数组a[i]中第j个元素的地址，即&amp;a[i][j]<br>
<em>(a[i]+j)或</em>(*(a+i)+j)表示一维数组a[i]中第j个元素的值，即a[i][j]<br>
a[i]或a+i表示列地址，每次加1移动一个元素</p>
<pre class="line-numbers language-none"><code class="language-none">用指针快速访问二维数组，到底增1是增行还是增列(增列是由于在指针数组中增1相当于换了一个数组)由指针类型决定，例：
int (*p)[4];p&#x3D;a;        此时p-&gt;*-&gt;[4]-&gt;int 表示定义指针指向一个整型数组，数组有4个元素，这时指针+1代表增加一个整型数组的长度
int *p&#x3D;*a;              此时指针指向*a即&amp;a[0]，这时指针+1表示只增加一个整型
int *p[4];              此时定义的是一个长度为4的指针数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，括号(包括()和[]) 的优先级最高，因此int(* p)[4]表明的是一个int<em>指向int[4]的数组，说明是一个二维数组级别指针<br>
但如果不加圆括号的话变成int</em>p[4]，此时表示的是一个int4*的数组，是一个指针数组(一个指向指针的指针)</p>
<h2 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结:</h2>
<p>二维数组首地址是行地址，要用行指针指向，行指针+1，移动一行<br>
行指针+i表示第i行的行地址，取*就转换为列地址，转为一维数组的处理<br>
指针访问二维数组示例程序：用指针增行和增列两种方式输出二维数组a[m][n]中的每个数据元素</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
int main()
&#123;
    const int m&#x3D;4,n&#x3D;4;
    int array[m][n]&#x3D;&#123;&#123;1,2,3,4&#125;,&#123;1,2,3,4&#125;,&#123;1,2,3,4&#125;,&#123;1,2,3,4&#125;&#125;;
    int *pline,(*prow)[n],i,j;
    prow&#x3D;array;
    pline&#x3D;*array;
    for(i&#x3D;0;i&lt;m;i++)
    &#123;
	for(j&#x3D;0;j&lt;n;j++)
	&#123;
	    printf(&quot;增行 %d&quot;,prow[i][j]);       此时*(*(prow+i)+j),(*(prow+i))[j],*(prow[i]+j),prow[i][j]是等价的
	    printf(&quot;增列 %d&quot;,*(pline+i*n+j));   此时*(pline+i*n+j),pline[i*n+j]是等价的
	    printf(&quot;\n&quot;);
	&#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="指针与结构体"><a class="markdownIt-Anchor" href="#指针与结构体"></a> 指针与结构体</h1>
<pre><code>结构体和指针结合，可以直接访问结构变量成员，也可以通过指向结构的指针进行结构成员的访问
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">声明结构指针的基本格式:struct 类型名 *指针名
例：typedef struct info
    &#123;
	short num;
	char name[5];
    &#125;info;
    info myinfo1,myinfo2,*pinfo1,*pinfo2;          定义指向结构变量的结构指针
    pinfo1&#x3D;&amp;myinfo1,pinfo2&#x3D;&amp;myinfo2;               pinfo1指向myinfo1，pinfo2指向myinfo2
    pinfo1-&gt;num&#x3D;1;
    strcpy(pinfo1-&gt;name,&quot;good&quot;);
    *pinfo2&#x3D;*pinfo1;                               将myinfo2的值赋给myinfo1，结构变量之间可以相互赋值
    printf(&quot;%d %s&quot;,(*pinfo2).num,(*pinfo2).name);
    pinfo2&#x3D;pinfo1;                                 将pinfo2的值赋给pinfo1,此时pinfo2指向myinfo1
    printf(&quot;%d %s&quot;,(*pinfo2).num,(*pinfo2).name);  输出结果：1 good<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>三种存取结构成员的方式：
</code></pre>
<ul>
<li>结构变量名下标方式</li>
<li>通过指向结构的指针和间接运算符*</li>
<li>通过指向结构的指针和指向成员运算符-&gt;<br>
以上面的例子为例：myinfo.num, (<em>pinfo).num, pinfo-&gt;num 为等价引用形式<br>
注意如果使用过</em>间接引用结构指针所指的结构变量再访问成员的话，必须要用括号括起来<br>
因为结构成员运算符’.‘的优先级高于’<em>’，因此表达式</em>pp.x的含义等价于*(pp.x)，因为x不是指针，所以该表达式非法(原理同指针)<br>
结构指针的使用频率非常高，为了使用方便c提供了一种简写方式，假定p是一个指向结构体的指针，可用 p-&gt;结构成员 引用相关结构成员</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">如:struct rect&#123;struct point pt1,pt2;&#125;r,*rp&#x3D;&amp;r; 其中表达式r.pt1.x;rp-&gt;pt1.x;(r.pt1).x;(rp-&gt;pt1).x中
   操作符-&gt;只能在结构指针指向结构成员时使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在所有运算符中，结构运算符’.‘和’-&gt;’、用于函数调用的’()‘以及用于用于下标的’[]'优先级最高，因此它们同操作数之间的结合也紧密\</p>
<pre class="line-numbers language-none"><code class="language-none">如:struct&#123;int len;char *str;&#125;*p;++p-&gt;len;将增加len的值而不是p的值，因为隐含括号关系是++(p-&gt;len)
可以使用括号改变结合次序，如:(++p)-&gt;len将先执行p的加1操作，再对len执行操作，(p++)-&gt;len则先读取len然后再将p加1
同理，*p-&gt;str读取的是指针str所指的对象的值，*p-&gt;str++先读取指针str指向对象的值，然后再将str加1(与*s++相同)
(*p-&gt;str)++将指针str指向的对象值加1，*p++-&gt;str先读取str指向的对象的值，然后再将p加1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="指针数组"><a class="markdownIt-Anchor" href="#指针数组"></a> 指针数组</h1>
<p>由于指针也是变量，所以他们也可以像其他变量一样存储在数组中<br>
一个数组中如果每个元素都是一个指针，则称为指针数组<br>
每个指针基类型相同，使用前必须初始化</p>
<pre class="line-numbers language-none"><code class="language-none">定义一个指针数组并初始化，例：
char *proname[]&#x3D;&#123;&quot;Fortran&quot;,&quot;C&quot;,&quot;C++&quot;&#125;;     指针数组中每个元素为字符串常量的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>proname声明的是一个一维数组，数组元素是字符指针，通过字符串列表实现，列表中每个字符串常量赋值给数组相应位置的字符指针<br>
第i个字符串的所有字符存储在存储器的某个位置，指向它的指针存储在proname[i]中</p>
<h3 id="指针数组与二维数组的区别"><a class="markdownIt-Anchor" href="#指针数组与二维数组的区别"></a> 指针数组与二维数组的区别</h3>
<p>对c的初学者而言，很容易混淆二维数组与指针数组的区别，因为两者有时可以实现相同的功能</p>
<pre class="line-numbers language-none"><code class="language-none">如:int a[10][20],*b[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>从语法角度讲，a[i][j]和b[i][j]都是对一个整型对象的合法引用<br>
但a是一个真正的二维数组，它分配了200个int类型长度的存储空间，并通过常规的“矩阵”式的下标计算公式20*i+j计算得到a[i][j]的位置<br>
而对b来说该声明仅仅要求分配10个整型指针的空间，并且没有进行初始化，指针数组的初始化必须以显式进行，如静态初始化或表达式初始化<br>
假定b每个元素均指向一个具有20个元素的数组，则编译器需要为它分配200个整型空间和10个整型指针空间<br>
指针数组的优势在于指针所指向的元素长度可以不同(因为在指针数组中存储的可以是整型标量或整型数组的首元素地址值，类似于链表的结构)<br>
虽然以上讨论是借助于整型，但到目前为止指针数组最频繁的用处是存放具有不同长度的字符串常量(初始化较为方便，并且是固定的数据结构)</p>
<pre class="line-numbers language-none"><code class="language-none">如:char*name[]&#x3D;&#123;&quot;Illegal month&quot;,&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:假设有100个字符串，其中90个字符串长度为2，10个长度为50
   使用二维字符数组存放：const int m&#x3D;50,n&#x3D;100;char str[n][m];
   总存储空间&#x3D;50*100&#x3D;5000B
   使用指针数组存放：const int n&#x3D;50;char *pstr[n];
   每个地址占4字节，总存储空间为指针空间+字符串实际存储空间&#x3D;4*100+90*2+10*50&#x3D;1080B
   使用指针数组可以存放不规则的字符串长度，每个字符串实际多长就占多大的存储空间，存储空间可不要求连续(链表的思想)
   而二维字符数组的每个元素长度必须相同，在定义时就已确定并分配存储空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">指针数组示例程序：对n个国家的国名按照字母顺序排序：
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define N 5
void sort(char *name[]) &#x2F;&#x2F;排序
&#123;
    int i,j;
    char *sp; &#x2F;&#x2F;用于临时交换
    for(i &#x3D; 0;i &lt; N-1;i++) &#x2F;&#x2F;利用选择排序法进行排序
    &#123;
	for(j &#x3D; i+1;j &lt; N;j++)
	&#123;
	    if(strcmp(name[i],name[j]) &gt; 0)&#96;&lt;span style&#x3D;&quot;font-family: Arial, Helvetica, sans-serif;&quot;&gt;&#96;&#x2F;&#x2F;当name[i]&gt;name[j]时进行交换来排序①
	    &#123;
		sp &#x3D; name[i];
		name[i] &#x3D; name[i+1];
		name[i+1] &#x3D; sp;
	    &#125;
	&#125;
    &#125;
&#125;
void prins(char *put[]) &#x2F;&#x2F;输出
&#123;
    int i;
    for(i &#x3D; 0;i &lt; N;i++)
    printf(&quot;%s &quot;,put[i]); &#x2F;&#x2F;不能写*put[i]②
&#125;
int main() &#123;
    char *spa[] &#x3D; &#123;&quot;China&quot;,&quot;America&quot;,&quot;Australia&quot;,&quot;France&quot;,&quot;Germany&quot;&#125;;
    sort(spa);
    prins(spa);
    getch();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h1 id="结构数组"><a class="markdownIt-Anchor" href="#结构数组"></a> 结构数组</h1>
<p>所谓结构数组，是指数组中的每个元素都是一个结构体<br>
声明结构数组和声明结构变量的方式类似，基本格式为struct {…}结构数组名[数组长度];</p>
<pre class="line-numbers language-none"><code class="language-none">如:struct key&#123;
	char *word;
	int count;
   &#125;keytab[NKEYS]; 或单独声明struct key keytab[NKEYS];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种结构数组的初始化方法同前面所述的初始化方法类似——在定义的后面通过一个用圆括号括起来的初值表进行初始化</p>
<pre class="line-numbers language-none"><code class="language-none">如:keytab[]&#x3D;&#123;
    &quot;auto&quot;,0,&quot;break&quot;,0,&quot;case&quot;,0,&quot;char&quot;,0,&quot;const&quot;,0,
    &quot;continue&quot;,0,&quot;default&quot;,0,&quot;unsigned&quot;,0,&quot;void&quot;,0,&quot;volatile&quot;,0,&quot;while&quot;,0
   &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意，初值要与结构成员相对应以成组的方式列出，更精确的做法是将每一行(即每个结构)初值都在花括号中</p>
<pre class="line-numbers language-none"><code class="language-none">如:keytab[]&#x3D;&#123;
    &#123;&quot;auto&quot;,0&#125;,&#123;&quot;break&quot;,0&#125;,&#123;&quot;case&quot;,0&#125;,&#123;&quot;char&quot;,0&#125;,&#123;&quot;const&quot;,0&#125;,
    &#123;&quot;continue&quot;,0&#125;,&#123;&quot;default&quot;,0&#125;,&#123;&quot;unsigned&quot;,0&#125;,&#123;&quot;void&quot;,0&#125;,&#123;&quot;volatile&quot;,0&#125;,&#123;&quot;while&quot;,0&#125;
   &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>指针</title>
    <url>/posts/64e329d9289e</url>
    <content><![CDATA[<h1 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h1>
<pre><code>指针是一种保存变量地址的变量

在c中指针的使用非常广泛，原因之一是指针常常是表达某个计算的唯一途径

另一个原因是同其他方法相比较，使用指针往往可以生成更高效更紧凑的代码

指针和数组之间的关系十分密切，使用数组的场景下基本上都会涉及指针

指针和goto语句一样，会导致程序难以理解

如果使用者不够细心的话，指针很容易就会指向错误的地方，但如果谨慎地使用指针，就可以利用其写出简单，清晰的程序

ANSI C的一个最重要的变化在于，它明确规定了操纵指针的规则，而事实上这些规则早已被很多优秀的程序设计人员和编译器所采纳

此外，ANSI C使用类型void*(指向void的指针)代替char*作为通用指针的类型

void*可以指向任意类型的数据，可用任意类型指针对void*赋值，在部分编译环境下也可用void*给任何类型赋值

但void*无法进行算数运算，因为不知道需要操作几字节的数据
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">(注意在c++中void*可以接受任何类型，反过来不可以，也就是一个有类型的指针不能指向一个void*所指向的地址)
(void几乎只有说明和限制程序的作用，从来没有人会定义一个void变量，如:void a; 编译器会报错，并且即使不会出错也没有任何实际意义) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<span id="more"></span>
<p>通常的机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操作，也可以连续成组的方式进行操作</p>
<p>一般情况下机器的一个字节可以存放一个char类型，2个相邻字节存储单元可存储一个short类型，4个相邻字节存储单元可存储一个long类型的数据</p>
<pre><code>指针是能够存放一个地址的一组存储单元(通常是2或4个字节，保证能将32位机的最大地址存放进来)
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">案例：输出变量的值和地址
#include&lt;stdio.h&gt;
int main()
&#123;
    int a&#x3D;0,b&#x3D;0;
    char c&#x3D;&#39;A&#39;;
    printf(&quot;a is %d, &amp;a is %p\n&quot;,a,&amp;a);      输出结果： a is 0, &amp;a is 0x7ffeef1df60c
    printf(&quot;b is %d, &amp;b is %p\n&quot;,b,&amp;b);               b is 0, &amp;b is 0x7ffeef1df608     a和b的值相等，但地址不同
    printf(&quot;c is %c, &amp;c is %p\n&quot;,c,&amp;c);               c is A, &amp;c is 0x7ffeef1df607
&#125;
    指针变量是一种特殊的变量，变量中存放的是一个变量或常量的地址，例：
    int value&#x3D;150;char ch&#x3D;&#39;M&#39;;
    int *pv&#x3D;&amp;value;char *pc&#x3D;&amp;ch;
    由于pv,pc中存放的分别是value和ch的地址，故称pv和pc为指针变量，简称为指针(pointer)
    指针指向的对象称为目标或目标变量
    指针存放地址，访问速度更快，访问数组更加灵活，增加了访问内存空间的方法
    以上面pv和pc的例子为例。value，ch分别为整型和字符型变量，占4字节和1字节的空间，内存中地址按字节编号，每个字节存储单元均对应一个地址
    假设value所分配的地址空间为1000H-1003H，值为150，ch所分配空间为1050H
    但是通过指针访问数据时需按照指针类型决定访问空间的大小
    因此&amp;value和&amp;ch值分别为1000H和1050H(通常只包括首地址)，而指针变量pv和pc分别储存&amp;pv和&amp;pc的值，假设为11A0H-11A3H和11A4H-11A7H
    计算机可以通过&amp;value,&amp;ch和pv,pc两种方式查询value和ch的地址(直接寻址，间接寻址)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="指针声明"><a class="markdownIt-Anchor" href="#指针声明"></a> 指针声明</h2>
<pre class="line-numbers language-none"><code class="language-none">指针声明格式：数据类型 *指针变量名
例：int *ptr;char *name;float *ptf;       分别定义为指向整型，字符型和浮点型数据的指针；
    int a,bb,*pt;                        只要数据类型相同也可以与普通变量一起定义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>指针变量同普通变量一样可以定义为外部，内部和静态等不同类型</p>
<h2 id="指针初始化"><a class="markdownIt-Anchor" href="#指针初始化"></a> 指针初始化</h2>
<pre><code>使用指针前，必须给指针赋以指向目标变量的地址值

同其他类型变量一样，指针也可以初始化

通常对指针有意义的初始化值只能是0或者表示地址的表达式，表达式所代表的地址必须是在此前已定义的具有适当类型的数据的地址

c保证0永远不是有效的数据地址，因此返回值0可用来表示发生了异常事件

指针和整数之间不能相互转换，但0是唯一的例外:常量0可以赋值给指针，指针也可以和常量0进行比较

程序中经常用符号常量NULL代替常量0，这样便于说明常量0是一个指针的特殊值，NULL定义在标准头文件&lt;stddef.h&gt;中

“野指针”问题应尽量避免；没有初始化值需要给指针初始化NULL变成空指针，不能使用没有初始化的指针
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">初始化格式：指针名&#x3D;地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>一元运算符&amp;可用于取一个对象的地址，&amp;只能应用于内存中的对象，即变量和数组元素，不能作用于表达式、常量或register类型的变量

一元运算符*是间接寻址或间接引用运算符，当其作用于指针时，将访问指针所指的对象

在声明指针时，“*”作为说明符，如:int *p相当于表明表达式*p是int类型，对函数参数的声明也采用这种方式，如:double atof(char*);

在使用指针时，“*”是运算符，用于访问目标变量的值(间接引用)

因此，变量名和指针所指空间是是等效的，因此对变量进行的操作与对记录了该变量地址的指针进行操作是一样的，例：
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">int x&#x3D;1,y&#x3D;2,z[10],*ip;    ip是指向int类型的指针
ip&#x3D;&amp;x,y&#x3D;*ip+1;            ip现在指向x，y的值现在为2

一元运算符*和&amp;的优先级比二元高，因此*ip&#x3D;*ip+1等同于*ip+&#x3D;1，++*ip，(*ip)++，
其中(*ip)++的圆括号是必需的，否则的话使用*ip++是先取指针指向空间的值再将指针进行自增运算，等价于*(ip+1)
原因是由于包括*在内的一元运算符都是从右向左的结合顺序

*ip&#x3D;*ip+10;               x的值为10，只要ip指向x，则x可以出现的任何上下文都可以使用*ip代替
ip&#x3D;&amp;z[0];                 ip现在指向z[0]
指针也是变量，所以在程序中可以直接使用，而不是只能通过间接引用(*)的方法使用
相同类型的指针间可以相互赋值，如:int *pa&#x3D;&amp;a,*pb;pb&#x3D;pa; 将pa的值拷贝到pb当中，使指针pb也指向pa指向的对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>指针变量的类型和目标变量的类型应一致(一个例外情况是void*可以存放指向任意类型的指针)，例：
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">int c&#x3D;10;char *pc&#x3D;&amp;c;
此时编译器会发出警告；可以考虑将地址转换成对应的指针变量类型pc&#x3D;(char*)&amp;c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code>但在这种做法下pc仍然是char*，所以还是无法正确访问整型变量c的地址空间对c进行操作，例：
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">char c;int *pc&#x3D;&amp;c;*pc&#x3D;12891;       此时char类型的c接收不了这么大的值，发生越界错误<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>指针使用原则：指针使用非常容易出错，需要格外注意
</code></pre>
<ul>
<li>
<p>永远清楚每个指针指向了哪里，指针必须指向一块有意义的内存</p>
</li>
<li>
<p>永远清楚每个指针指向的内容是什么</p>
</li>
<li>
<p>永远不要使用未经初始化的指针</p>
</li>
</ul>
<h2 id="地址算数运算"><a class="markdownIt-Anchor" href="#地址算数运算"></a> 地址算数运算</h2>
<pre><code>指针&lt;-&gt;地址 指针运算&lt;-&gt;地址运算

c中的地址运算方法是一致且有规律的，将指针、数组和地址的算术运算集成到一起是该语言特性中的一大优点

指针的各类运算都与其所指向的基类型有关，移动字节数以其基类型占有的字节数为基本单位

指针的算术运算具有一致性，所有的指针运算都会自动考虑它所指向对象的长度

有效的指针运算包括:

相同类型指针之间的赋值运算，指针同整型之间的加减法运算，指向相同数组中元素的两指针间减法或比较运算，将指针赋值为0或与0进行比较的运算

其他所有运算都是非法的，如:

两指针间的加法、乘法、除法、移位或屏蔽运算，指针同float或double类型之间加法运算

以及不经强制类型转换而直接将指向一个类型的指针值赋给指向另一种类型的指针(两指针之一是void*的情况除外)

赋值运算 pa=&amp;a;pa=pb;

取地址运算&quot;&amp;&quot;与取内容运算&quot;*&quot;互为逆运算,例：int x,*ptr=&amp;x;cout&lt;&lt;(*(&amp;x)==1);输出结果为1

指针间关系运算：&gt;, &lt;, ==, !=, &gt;=, &lt;=

若指针p和q指向同一个数组成员，p指向的数组元素位置在q指向的数组元素位置之前，则p&lt;q的值为真

任何指针与0进行相等或不等的比较运算都有意义，但指向不同数组的元素之间的指针进行算数或比较运算通常没有意义

(有一个特殊情况下该操作可能是有意义的:有时指针的算术运算会使用数组最后一个元素的下一个地址)

(c的定义保证数组末尾之后的第一个元素的指针运算可以正确执行)

比较运算必须在同类型的指针之间进行

指针间减法运算

同理指针的减法运算也是有意义的，如果p、q指向相同数组中的元素且p&lt;q，则q-p+1就是位于p和q指向元素之间(包括p、q)的元素个数

指针的减法运算也必须在相同类型指针之间进行，例:
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">size_t strlen(char*s)
&#123;
    char*p&#x3D;s;
    if(!*s)return 0;
    while(*++s!&#x3D;&#39;\0&#39;);
    return s-p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>(由于字符串中的字符数有可能超过int类型所能表示的最大范围

因此可考虑使用头文件&lt;stddef.h&gt;中定义类型ptrdiff_t，该类型足以表示两个指针之间的带符号差值

不过这里使用size_t以和标准库中的版本匹配,size_t是由sizeof返回的无符号整型(typedef unsigned size_t))

指针与整数的加减运算，常见于指针与数组结合进行的运算(因为数组中的元素地址是连续的)，例：

int a[5],*pa=a;p++;     此时指针p自增代表指针从数组的首地址开始每次向下增加一个数组元素数据类型的空间

指针与整数n相加（减）代表：初始地址+（-）n*sizeof(指向目标变量类型的大小)

由于一元运算符'+'和'-'既可以作为前缀运算符也可以作为后缀运算符，因此二者与*有多种组合使用方式，不过用法不多见
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:*--p在读取指针p指向的对象前对p先执行自减操作
   *p++&#x3D;val表示将val压入栈，val&#x3D;*--p表示将栈顶元素弹出到val中，这两种是进栈和出栈的标准用法
    (压栈时指针+1后再将存储到指针原先的位置，出栈时把当前指向的值弹出然后指针-1，栈顶指针始终在栈顶元素的下一个位置)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>指针运算示例程序：依次输入两个数据，先输出小的，后输出大的</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
int main()                  在不修改原变量值的情况下实现递增输出的目的
&#123;
    int a,b;
    int *pa&#x3D;&amp;a,*pb&#x3D;&amp;b,*tmp;
    scanf(&quot;%d %d&quot;,*pa,*pb);
    if(*pa&gt;*pb)
    &#123;
       tmp&#x3D;pa;
       pa&#x3D;pb;
       pb&#x3D;tmp;
    &#125;
    printf(&quot;min is %d max is %d&quot;,*pa,*pb);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字符指针"><a class="markdownIt-Anchor" href="#字符指针"></a> 字符指针</h2>
<pre class="line-numbers language-none"><code class="language-none">关于指针和数组的规则同样也适用于字符指针和字符数组，例：
    char buffer1[]&#x3D;&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;&#125;;
    char buffer2[]&#x3D;&quot;hello&quot;;
    char *pcr1&#x3D;buffer1,*pcr2&#x3D;buffer2;
    printf(&quot;%s %s\n&quot;,pcr1,pcr2);        按字符数组输出时数组如果末尾找不到\0的话会一直向下非法读取其他空间的数据
    printf(&quot;%c %c\n&quot;,*pcr1,*pcr2);*pcr和*pcr2取的是首元素的值，此时输出结果为h h
    printf(&quot;%d&quot;,*pcr1-*pcr2);           输出0
    void strcpy(char*s,char*t)          strcpy函数，将指针t指向的字符串复制到指针s所指向的位置
    &#123;
       while(*s++&#x3D;*t++);
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>(虽然这种写法初看不易理解，但这种表示方法很有好处，c程序中经常用到这种写法，应当充分掌握

标准库&lt;string.h&gt;中提供的函数strcpy除拷贝外还会将目标字符串作为函数值返回)

printf如果按照%s输出的话默认会向下移动指针到存储\0的空间

也就是说对于字符串而言，以字符串形式输出字符数组中某一元素的地址，会默认该地址为字符串指针，输出原字符数组的字符串中剩下的部分，例:
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    char string[]&#x3D;&quot;programming&quot;;
    char *p&#x3D;string;
    p+&#x3D;5;
    printf(&quot;%s&quot;,p);                  输出结果：amming
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>字符串区别与普通数组的一大特点是字符串可以直接作为常量为指针赋值
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:char *par&#x3D;&quot;hello&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>注意：使用字符串常量对字符数组和字符指针的定义是不同的，例:
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">char amessage[]&#x3D;&quot;now is the time&quot;;
char *pmessage&#x3D;&quot;now is the time&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code>此时，amessage是一个长度等于初始化字符串加空字符'\0'的一维数组，数组中的字符元素可修改，但amessage指向的内存地址是始终不变的

另一方面pmessage是一个字符指针，初值指向字符串常量，指向的地址可以被修改，但由于其指向的是一个常量，因此修改其值是非法且没有定义的

不过用字符数组存储字符串常量，再用指针修改数组中字符是可行的，不过这种方法无法进行字符串整体的修改
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:char buffer[]&#x3D;&quot;hello&quot;,*par&#x3D;buffer;*par&#x3D;&#39;c&#39;; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="二重指针"><a class="markdownIt-Anchor" href="#二重指针"></a> 二重指针</h2>
<pre><code>指针也是变量，但指针变量不能存储指针的值
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如果在一个指针变量中存放指向另一个变量的指针地址，则称该指针为指向指针的指针，即二重指针，例：
int v&#x3D;120;int *q&#x3D;&amp;v;int **p&#x3D;&amp;q;
此时 v&#x3D;*q&#x3D;*(*p)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre><code>二重指针只能用来存储指针的地址，不能存放普通变量的地址，否则编译器会报错
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">对于指针数组名，由于其本身就是一个二重指针常量(指向指针数组首元素指针的地址)，因此可以给二重指针赋值，例：
char *pc&#x3D;&#123;&quot;abc&quot;,&quot;def&quot;,&quot;hig&quot;&#125;;char **pc;ppc&#x3D;pc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">二重指针示例程序：用二重指针输出数组元素
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
    const int n&#x3D;3;
    int array[n]&#x3D;&#123;1,2,3&#125;,*parray[n]&#x3D;&#123;&amp;array[0],&amp;array[1],&amp;array[2]&#125;;
    int **pa,i;
    pa&#x3D;parray;
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        printf(&quot;%d &quot;,**pa);
        pa++;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体、联合</title>
    <url>/posts/d1d3086360dd</url>
    <content><![CDATA[<h1 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h1>
<p>结构体是一个或多个变量的集合，这些变量可能为不同的类型，为了方便处理而将这些变量组织在一个名字之下(某些语言称之为“记录”，比如Pascal语言)。<br>
区分于数组，结构中变量类型可以不同，结构将一组复杂数据组织在同一连续(一般情况，但不保证)存储单元下，而不是视为独立个体，有助于分析处理复杂的数据，特别是在大型程序中，如:</p>
<blockquote>
<p>工资记录就是用来描述结构的一个传统例子，每个雇员由一组属性描述，包括姓名、地址、社会保险号、工资等</p>
</blockquote>
<p>其中某些属性也可以是结构，例如姓名可以分几部分，地址甚至公司也可能出现类似的情况<br>
c中更典型的一个例子来自于图形领域：点由一对坐标定义，矩形由两个点定义等</p>
<blockquote>
<p>struct point{int x,y;};struct rect{struct point pt2,pt2;};</p>
</blockquote>
<p>ANSI标准在结构方面最主要的变化是定义了结构的赋值操作———结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值。实际在ANSI标准多年以前这些操作就已经被大多数编译器所支持，但直到这一标准才对其属性进行了精确定义。ANSI标准中，自动(非外部的)结构和数组现在也可以通过成员赋值进行初始化。</p>
<span id="more"></span>
<h2 id="结构体类型声明和定义"><a class="markdownIt-Anchor" href="#结构体类型声明和定义"></a> 结构体类型声明和定义</h2>
<p>关键字struct引入结构声明，结构声明由包含在花括号内的一系列声明组成，关键字struct后面的名字是可选的，称为结构标记，用于为结构命名<br>
struct声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的<br>
定义结构体基本格式为:</p>
<blockquote>
<p>struct 结构标记     struct 关键字<br>
{<br>
类型名1 成员1;            每个成员定义与普通变量相同<br>
类型名2 成员2;            每个成员既可以是基本数据类型，也可以是结构等复杂数据类型<br>
…<br>
类型名n 成员n;<br>
};</p>
</blockquote>
<p>结构类型定义(声明)以后需要加一个分号(struct后面相当于声明语句，需要加分号)，如:</p>
<blockquote>
<p>struct{…;}x,y,z; 从语法角度来说，这种方式的声明与声明int x,y,z;具有类似的意义</p>
</blockquote>
<p>这两个声明都将x、y与z声明为指定类型的变量，并为它们分配存储空间，如果结构声明后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版或轮廓。在定义之后，结构标记代表花括号内的声明，可作为该声明的简写形式，结构中定义的变量称为“成员”，如：</p>
<blockquote>
<p>struct student<br>
{<br>
char name[20];<br>
int id;<br>
float chinese;<br>
float math;<br>
float english;<br>
};</p>
</blockquote>
<h2 id="结构体命名"><a class="markdownIt-Anchor" href="#结构体命名"></a> 结构体命名</h2>
<p>结构成员、结构标记和普通变量(非结构的成员)可以采用相同的名字(结构标记在使用时要加struct)，不同结构的成员也可以使用相同名字，相同名字之间不会冲突，因为通过上下文分析总可以对它们进行区分，但是从编程风格方面来说，通常只有密切相关的对象才会使用相同的名字。<br>
定义完结构类型，结构变量后，就可以引用，结构变量中各成员的引用格式为：</p>
<blockquote>
<p>结构变量名.成员名</p>
</blockquote>
<p>其中的结构成员运算符’.'将结构名和成员名连接起来，如:</p>
<blockquote>
<p><a href="http://student.name">student.name</a> 表示student结构的name成员   .是成员运算符，可以理解为“的”</p>
</blockquote>
<p>在表达式中也可以使用该形式引用某个特定结构中的成员，如:</p>
<blockquote>
<p>printf(&quot;%d,%d&quot;,pt.x,pt.y); 打印点pt的坐标<br>
double dist=sqrt((double)pt.x*pt.x+(double)pt.y*pt.y); 计算原点(0,0)到pt的距离</p>
</blockquote>
<p>结构可以嵌套，如:</p>
<blockquote>
<p>struct rect{struct point pt1,pt2;}; 结构包含两个point类型成员，可以代表矩形的一对对角线上的坐标<br>
struct rect screen;screen.pt1.x; 可以引用矩形结构体screen的成员pt1的x坐标    结构变量初始化</p>
</blockquote>
<p>如果结构声明中带有标记，则在以后定义结构实例时便可以用该结构标记定义结构变量，如:</p>
<blockquote>
<p>struct point pt; 定义了一个struct point类型的变量pt</p>
</blockquote>
<p>结构的初始化可以在定义的后面使用初值表进行，初值表中同每个成员对应的初值必须是常量表达式，如:</p>
<blockquote>
<p>struct point maxpt={320,200};</p>
</blockquote>
<p>初始化基本格式为:</p>
<blockquote>
<p>struct 结构标记 结构变量名={结构成员数据1,结构成员数据2…结构成员数据n}</p>
</blockquote>
<p>直接定义的话，struct也在数据类型名当中，花括号中初始化数据依次赋给结构变量各成员，数据类型，顺序要与成员相匹配。<br>
与数组不同，结构变量名不代表结构变量首地址，因此可以用相同类型的结构变量名在他们之间相互赋值，如：</p>
<blockquote>
<p>struct weather{float temp, wet;};<br>
struct weather today={21,5.5},yesterday={25.5,4};<br>
today = yesterday;<br>
printf(&quot;%.1f %.1f&quot;,today.temp,today.wet);        输出结果：25.5,4.0    自引用结构</p>
</blockquote>
<p>一个结构包含其自身的实例是非法的，但是包含其指针是合法的，在结构的定义中，可以采用类似于递归(不是真正的递归)的方式，如:</p>
<blockquote>
<p>struct tnode<br>
{<br>
char*word;<br>
int count;<br>
struct tnode*left,*right;<br>
};</p>
</blockquote>
<p>这种对结点的递归声明方式看上去好像是不确定的，但它的确是正确的，它将left声明为指向tnode的指针，而不是tnode实例本身。</p>
<p>偶尔也可能会使用自引用结构的一种变体:两个结构相互引用，如:</p>
<blockquote>
<p>struct t{<br>
struct s*p;          p指向一个s结构<br>
};<br>
struct s{<br>
struct t*q;          q指向一个t结构<br>
};</p>
</blockquote>
<h2 id="结构体运算"><a class="markdownIt-Anchor" href="#结构体运算"></a> 结构体运算</h2>
<p>结构的合法操作只有几种:</p>
<ul>
<li>作为一个整体进行赋值和拷贝，通过&amp;运算符取地址，访问成员</li>
<li>赋值和拷贝包括向函数传递参数以及从函数返回值</li>
<li>可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化</li>
<li>结构之间不可以进行比较，加减等算数和关系运算</li>
</ul>
<h2 id="结构体的长度"><a class="markdownIt-Anchor" href="#结构体的长度"></a> 结构体的长度</h2>
<p>注意:千万不要认为结构的长度等于各成员长度的和<br>
由于不同对象有不同的对齐要求，因此结构中可能出现未命名的“空穴”(hole)，如:</p>
<blockquote>
<p>假设char类型占用一个字节，int类型占用4个字节<br>
则struct{char c;int i;};可能占用8个字节而不是5个字节</p>
</blockquote>
<p>结构示例程序：要求存储本年级100名学生学号，姓名，语文，数学，外语三门课程成绩，根据语文成绩递减排序，按名次输出学生信息</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
int main()
&#123;
    const int m&#x3D;20,n&#x3D;4;
    int i,j,max;
    typedef struct student
    &#123;
        char name[m];
        int id;
        float chinese,math,english;
    &#125;student;
    student st[n],tmp;
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        scanf(&quot;%s %d %f %f %f&quot;,st[i].name,\
            &amp;st[i].id,&amp;st[i].chinese,&amp;st[i].math,&amp;st[i].english);
    &#125;
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        max&#x3D;i;
        for(j&#x3D;i+1;j&lt;n;j++)
        &#123;
            if(st[j].chinese&gt;&#x3D;st[max].chinese)max&#x3D;j;
            tmp&#x3D;st[i];
            st[i]&#x3D;st[max];
            st[max]&#x3D;tmp;
        &#125;
    &#125;
    for(i&#x3D;0;i&lt;n;i++)
    &#123;
        printf(&quot;%s %d %f %f %f\n&quot;,st[i].name,st[i].id,st[i].chinese,st[i].math,st[i].english);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>学生信息排序程序分析<br>
程序整体可分为四个部分：</p>
<ul>
<li>声明student类型和各变量
<ul>
<li>const int m,n 分别为name字符串长度 学生个数</li>
<li>使用typedef定义student结构类型，</li>
<li>这部分关键在于定义名为st，长度为n的结构数组，其中每个元素都是一个student结构类型</li>
<li>然后定义一个student类型的变量tmp，以及i,j,max用来处理循环和排序的问题</li>
</ul>
</li>
<li>输入学生数据
<ul>
<li>使用for循环为数组输入初始化数据，初始化数据的内容是结构数组中每个元素的各个成员数据</li>
</ul>
</li>
<li>根据语文成绩排序
<ul>
<li>简单选择排序</li>
<li>这部分关键在于交换a，b的值，使用一个中间变量c，令a=c,a=b,b=c即可完成两个数据的对换</li>
<li>此程序的方法是对st[i]的元素的Chinese成员与其之后的元素依次进行对比，遇到比st[i]大的就互换两元素的值，保证st[i]总是比之后的元素大</li>
<li>首先max=i，如果st[j].chinese&gt;=st[max].chinese就将max值换为j</li>
<li>然后用tmp存放st[i]的值，令st[max]（此时就是st[j]）的值换成st[i],最后令st[i]=st[max],st[j]=tmp,就完成了两数据的互换</li>
</ul>
</li>
<li>输出学生信息
<ul>
<li>两层循环完成后，st[n]中的每个元素的Chinese值都保证比之后的元素大即排序完成</li>
<li>此时按顺序输出st[n]中元素的成员即可</li>
</ul>
</li>
</ul>
<h1 id="类型定义typedef"><a class="markdownIt-Anchor" href="#类型定义typedef"></a> 类型定义(typedef)</h1>
<p>c提供了一个被称为typedef的功能，用于建立新的数据类型名，如:</p>
<blockquote>
<p>声明typedef int Length; 则Length可用于类型声明、类型转换等，它和类型int完全相同<br>
Length len,maxlen;<br>
Length &gt;*lengths[];<br>
typedef char*String;<br>
String p,lineptr[MAXLINES];<br>
int strcmp(String,String);<br>
p=(String)malloc(100);    注意，typedef中声明的类型在变量名的位置出现，而不需要紧接在typedef后面</p>
</blockquote>
<p>typedef在语法上类似于修饰符extern,static等，一般将typedef定义的类型的首字母定义为大写字母<br>
typedef用于为结构标记命名的情况非常常见，如果想在结构类型中省略struct 可使用typedef关键字定义习惯的数据类型名，如：</p>
<blockquote>
<p>typedef struct student{;}student;<br>
student stu1,stu2;            这时student等效于struct student<br>
typedef struct tnode*Treeptr; 声明一个指向struct tnode结构的指针Treeptr<br>
typedef struct tnode{<br>
char*word;<br>
int count;<br>
Treeptr left,right;<br>
}Treenode;                    创建一个struct tnode实例</p>
</blockquote>
<p>需要强调的是，从任何意义上讲，typedef声明没有创建一个新类型，它只是为某个已存在的类型(可能是已有类型的组合)增加了一个新的名称而已，typedef声明也没有增加任何新的语义：通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。实际上，typedef类似于#define语句，但由于typedef是由编译器解释的，因此它的文本替换功能要超过预处理器的能力，如:</p>
<blockquote>
<p>typedef int (*PFI)(char*,char*);PFI strcmp,numcmp;</p>
</blockquote>
<p>该语句定义了类型PFI是一个“指向函数的指针，该函数有两个char*类型的参数，并且返回值类型为int”，并且与宏扩展不同，typedef定义的函数指针可以指定返回类型并创建数据类型，能更好地适应上下文。<br>
除表达式简洁外，使用typedef还有另外的重要原因</p>
<ul>
<li>typedef可以使程序中的数据类型参数化，以提高程序的可移植性</li>
<li>如果typedef声明的数据类型同机器有关，那么当程序移植到其他机器上时，只需改变typedef类型定义就可以了</li>
</ul>
<p>一个经常用到的情况是，对于各种不同大小的整型值来说，都使用通过typedef定义的类型名，然后分别为不同的宿主机选择一组合适的int、short和long类型大小进行声明即可，标准库中有一些例子，如:</p>
<blockquote>
<p>size_t,ptrdiff_t等</p>
</blockquote>
<p>此外，在c++中，像std::string和std::ofstream这样的typedef还隐藏了长长的，难以理解的模板特化语法，如：</p>
<blockquote>
<p>basic_string&lt;char, char_traits&lt;char&gt;，allocator&lt;char&gt;&gt; 和 basic_ofstream&lt;char, char_traits&lt;char&gt;&gt;。</p>
</blockquote>
<p>其次，typedef的第二个作用是为程序提供更好的说明性，如:</p>
<blockquote>
<p>Treeptr类型显然比一个声明为指向复杂结构的指针更容易理解</p>
</blockquote>
<p>typedef不能和static等存储类型指示符同时使用，因为每个变量只能有一种存储类型，因此假设把一种存储类型的变量直接取别名的话，用这个名字定义的变量就不能加其他存储类型前缀，这样的就会影响typedef声明变量的语法，因此c语言干脆不允许typedef定义某种特定存储类型的变量，如:</p>
<blockquote>
<p>typedef static int i;是非法的</p>
</blockquote>
<p>实际上，根据c语言规范，在进行句法分析的时候，typedef的用法和存储类型指示符是相同的，因此任何存储类型类型可以出现的地方typedef同样可以出现，如：</p>
<blockquote>
<p>static int i;<br>
typdef int i;<br>
extern int i();<br>
typedef int i();<br>
int const register i;<br>
int const typedef i;</p>
</blockquote>
<h1 id="联合"><a class="markdownIt-Anchor" href="#联合"></a> 联合</h1>
<p>联合可以在(不同时刻)保存不同类型和长度的对象的变量，在此过程中编译器负责跟踪对象的长度和对齐要求。联合提供了一种方式以在单块存储区中管理不同类型的数据，而不需要在程序中嵌入任何同机器有关的信息，它类似于Pascal语言中的变体记录，特定类型的常量值必须保存在合适类型的变量中，而如果常量的不同类型占据相同大小的存储空间且保存在同一位置，表管理将最方便。这就是联合的目的——一个变量可以合法地保存多种数据类型中的任何一种类型的对象<br>
其基本语法格式是基于结构的:</p>
<blockquote>
<p>union 联合标记<br>
{<br>
类型名1 成员1;<br>
类型名2 成员2;<br>
…<br>
类型名n 成员n;<br>
}u;</p>
</blockquote>
<p>联合必须足够大，以保存成员类型中最大的一种，具体长度和具体实现有关。上例中任意一种成员类型的对象都可以赋值给u，且可使用在随后的表达式中，但必须保证是一致的，读取的类型必须是最后一次存储后更新的类型，对当前保存在联合中的类型由程序员负责跟踪。如果保存的类型与读取的类型不一致，其结果取决于具体的实现。同样的，与访问结构的方式相同，可根据下列语法访问联合中的成员:</p>
<blockquote>
<p>联合名.成员 或 联合指针-&gt;成员<br>
如:if(utype<mark>INT)cout&lt;&lt;u.idval&lt;&lt;endl;<br>
else if(utype</mark>FLOAT)cout&lt;<code>&lt;uptr-&gt;</code>fval&lt;&lt;endl;</p>
</blockquote>
<p>联合可以使用在结构和数组中，反之亦可，访问结构中的联合(或反之)的某一成员的表示法与嵌套结构相同，如:</p>
<blockquote>
<p>struct{<br>
char*name;<br>
int flags,utype;<br>
union{<br>
int ival;<br>
float fval;<br>
char*sval;<br>
}u;<br>
}symtab[NSYM];<br>
symtab[i].u.ival; 可引用联合成员ival<br>
symtab[i].u.sval; 可引用联合成员sval的第一个字符</p>
</blockquote>
<p>注意，联合的值只能使用其第一个成员类型的值进行初始化，因为联合的值默认是按第一个成员类型进行存储。联合中只存有一个值，所以不同通过哪一个成员进行引用都是将联合的值(第一个成员类型的值)转化成对应成员的类型再引用，如果联合中存储的值无法转换成被访问成员的数据类型，则会出错，如:</p>
<blockquote>
<p>union<br>
{<br>
int ival;<br>
float fval;<br>
char*sval;<br>
}u={0.5};<br>
cout&lt;&lt;u.fval;   输出0<br>
cout&lt;&lt;u.sval;   运行错误</p>
</blockquote>
<p>实际上，联合就是一个结构，特殊在于它的所有成员相对于基地址的偏移量都为0，此结构空间只需要大到足够容纳最“宽”的成员即可，并且能够保证其对齐方式适合于联合中所有类型的成员。<br>
对联合允许的操作与对结构允许的操作相同:作为一个整体单元进行赋值、复制、取地址以及访问其中一个成员。</p>
<h1 id="位字段"><a class="markdownIt-Anchor" href="#位字段"></a> 位字段</h1>
<p>在存储空间很宝贵的情况下，有可能需要将多个对象保存在一个机器字(8bit)中，一种常用的方法是，使用类似于编译器符号表的单个二进制位标志集合。另外，外部强加的数据格式(如硬件设备接口)也经常需要从字的部分位中读取数据。考虑编译器中符号表操作的有关细节:程序中的每个标识符都有与之相关的特定信息，如:</p>
<blockquote>
<p>是否为关键字、是否是外部的且(或)是静态的等等</p>
</blockquote>
<p>对这些信息进行编码的最简洁的方法就是在一个char或int对象(flags)中使用位标志操作集合来操作(尤其是一些布尔类型的判断实际只需1位就可完成)，通常采用的方法是，定义一个与相关位的位置对应的“屏蔽码”集合，如:</p>
<blockquote>
<p>#define KEYWORD 01 或 enum{KEYWORD=01,EXTERNAL=02,STATIC=04};<br>
#define EXTERNAL 02<br>
#define STATIC 04</p>
</blockquote>
<p>这些数字都是2的整数次幂，因而访问这些位就可以通过使用移位运算、屏蔽运算及补码运算进行简单的位运算<br>
下列语句在程序中经常出现，如:</p>
<blockquote>
<p>flags|=EXTERNAL|STATIC;     该语句将flags中的EXTERNAL和STATIC位(第2和第3位)置为1<br>
flags&amp;=~(EXTERNAL|STATIC);  该语句将flags中上面的位置为0<br>
当这两位都为0时，表达式:if((flags&amp;(EXTERNAL|STATIC))==0)值为真</p>
</blockquote>
<p>使用这种方法就实现了记录数据特定二进制位的信息，从而使用一个字节的char就可以记录多种不同数据，尽管这种方法很容易掌握，但c仍然提供了另一种可替代的方法:在结构(或联合)中直接定义和访问一个字中的位字段的能力，而不需通过按位逻辑运算符。</p>
<p>位字段(bit-field，或简称字段，是“字”中相邻位的集合，主要用于一些使用空间很宝贵的程序设计中，如嵌入式程序设计。<br>
“字”(word)是机器中单个的存储单元，同具体实现有关，连续声明多个位字段，编译器会将它们合并成一个机器字。位字段是C语言中一种存储结构，一般常作为结构体成员出现，不同于一般结构体成员的是它在定义时需要指定所占位数，如:</p>
<blockquote>
<p>struct{<br>
unsigned int is_keyword:1;<br>
unsigned int is_extern:1;<br>
unsigned int is_static:1;<br>
}flags;</p>
</blockquote>
<p>结构变量flags包含3个一位的位字段成员，冒号后的数字表示位字段的宽度(用二进制位数表示)，位字段声明为unsigned int类型以保证它们是无符号量。</p>
<p>单个位字段的引用方式与其他结构成员相同，如:</p>
<blockquote>
<p>flags.is_keyword、flags.is_extern等</p>
</blockquote>
<p>位字段的作用与屏蔽码相似，同其他整数一样，字段可以出现在算术表达式中，如:</p>
<blockquote>
<p>flags.is_extern=0,flags.is_static=1; 该语句将flags的is_extern位置为0、is_static位置为1<br>
if(!flags.is_extern&amp;&amp;!flags.is_static)用于对is_extern和is_static进行测试</p>
</blockquote>
<p>位字段的所有属性几乎都同具体的实现有关</p>
<ul>
<li>位字段也可以仅仅声明为int，不过为方便移植一般需要显式声明该int类型是signed还是unsigned类型</li>
<li>位字段不是数组，并且没有地址，因此不能对它们使用&amp;运算符(位字段通常不会占据可寻址的内存位置)</li>
<li>位字段是否能覆盖字边界由具体的实现定义(一般必须小于等于指定类型的位宽)，特殊宽度0可以用来强制在下一个字边界上对齐。</li>
<li>位字段可以不命名，无名字段(只有一个冒号和宽度)起填充作用</li>
</ul>
<p>某些机器上字段的分配是从字的左端至右端进行的(大端小端)，而某些机器上则相反，这意味着尽管字段对维护内部定义的数据结构很有用。但在选择外部定义数据的情况下，必须仔细考虑哪端优先的问题，而依赖于这些问题的程序是不可移植的。</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/posts/59e83767d17a</url>
    <content><![CDATA[<h1 id="数组一组具有相同数据类型变量的集合"><a class="markdownIt-Anchor" href="#数组一组具有相同数据类型变量的集合"></a> 数组：一组具有相同数据类型变量的集合</h1>
<blockquote>
<pre><code>数组名：表示这组数据的名字
</code></pre>
</blockquote>
<blockquote>
<pre><code>索引：标识数组中数据的位置
</code></pre>
</blockquote>
<blockquote>
<pre><code>数据元素：构成数组的每个数据项，数组名+索引 如:a[i]表示数组a的第i个元素
</code></pre>
</blockquote>
<span id="more"></span>
<h2 id="一维数组"><a class="markdownIt-Anchor" href="#一维数组"></a> 一维数组</h2>
<pre class="line-numbers language-none"><code class="language-none">定义一维数组格式：数据类型 数组名[正整数] 例：float score[10];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>数组的初始化是在声明后面紧跟一个初始化表达式列表，列表用花括号括起来，各初始化表达式之间通过逗号分隔
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:int days[]&#x3D;&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>定义了一个由12个对象组成的集合，对象存储在相邻的内存区域中
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">定义数组时可对数组进行初始化，存在几种不同情况，例：                以按行存储为准
    int a[5]&#x3D;&#123;12,34,56,78,9&#125;;    标准形式，全部初始化
    int a[5]&#x3D;&#123;0&#125;;                初始化表达式的个数比数组元素数少，则没有初始化表达式的外部变量、静态变量和自动变量元素将被初始化为0
    int a[]&#x3D;&#123;11,22,33,44,55&#125;;    不指定的数组长度，则数组空间的长度为初始化的数据个数
    int a[5]&#x3D;&#123;11&#125;;               部分初始化，第一个数据是11，其余为0
    int a[5];                    未初始化，其中数据是杂乱无章的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>如果初始化表达式的个数比数组元素数多，则是错误的

不能跳过前面的数组元素而直接初始化后面的数组元素

一维数组使用：数组名+数组下标

数组下标(index)：从0开始，数组元素的索引
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">数组下标可以为常量，整型表达式，并且允许快速随机访问 如：score[i] 可以像普通变量一样使用<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>一维数组的存储：系统分配一块连续的存储空间，大小为 数据类型大小*数组元素个数

数组名表示数组的首地址(相当于整个数组的地址)，值等于首个元素的地址
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:int a[10];  假设a的首地址为1000，int占4个字节空间，则 &amp;a[n]为1000+4*n 如 &amp;a[5]&#x3D;1020<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>因为是连续的地址空间，所以数组中元素的访问速度是非常快的

数组名表示数组的首地址，其值不可改变(常量)

定义两个数组int a[4]=&#123;1,2,3,4&#125;,b[4]; b=a; 是错误的，因为b的值不可改变
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">因此，如果想令b的值等于a，则需依次对b中的元素进行修改，如:a[0]&#x3D;b[0],a[1]&#x3D;b[1],a[2]&#x3D;b[2],a[3]&#x3D;b[3];
                                              或：for(i&#x3D;0,;i&lt;4;i++)b[i]&#x3D;a[j];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code>数组的长度在编译时已经完全确定，它等于数组项的长度乘以项数

因此，可得出项数为:keytab的长度/struct key的长度

c提供了一个编译时(compile-time)一元运算符sizeof，它可以用来计算任一对象的长度

表达式:sizeof 对象 以及 sizeof(类型名) 将返回一个整型值，其数值等于对象或类型占用的存储空间字节数

(严格地说，sizeof的返回值是无符号整型，其类型为size_t，该类型定义在头文件&lt;stddef.h&gt;中定义)

其中对象可以是变量、数组或结构；类型可以是基本类型如int、double、也可以是派生类型如结构类型或指针类型
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:#define NKEYS (sizeof keytab&#x2F;sizeof(struct key))
 或#define NKEYS (sizeof keytab&#x2F;sizeof keytab[0]) 使用这种方法即使类型变了也不需要改动程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">一维数组示例程序：显示键盘输入的月份拥有的天数，不包括闰年的天数
#include&lt;stdio.h&gt;
int main()
&#123;
    int month,i;
    int days[12]&#x3D;&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;
    scanf(&quot;%d&quot;,&amp;month);
    printf(&quot;%d月有%d天&quot;,month,days[month-1]);
&#125;
一维数组示例2：输入10个学生成绩，输出其中最高分和其在数组中的位置
#include&lt;stdio.h&gt;
int main()
&#123;
    int score[10];
    int num,i,j;
    int highest,topstudent;
    for(i&#x3D;0;i&lt;10;i++)
    &#123;
        scanf(&quot;%d&quot;,&amp;num);
        score[i]&#x3D;num;              &amp;score[i]与score+i相同都表示score中第i个元素的地址
        for(j&#x3D;0;j&lt;i;j++)
    	&#123;
   	    if(num&lt;&#x3D;score[j])break;
	    else if(j&#x3D;&#x3D;i-1)highest&#x3D;num,topstudent&#x3D;i;
        &#125;
    &#125;
    printf(&quot;%d\n%d&quot;,highest,topstudent);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h2>
<pre><code>c提供了类似于矩阵的多维数组，但实际上这种数组的应用不如指针数组广泛(空间浪费过于严重)

二维数组：在c中二维数组就是一种特殊的一维数组，一个二维数组的元素本身是一个一维数组

同理可推 n维数组：一个一维数组的元素本身是一个n-1维数组
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">n维数组定义：数据类型 数组名[元素个数1][元素个数2]...[元素个数n]
例：int two[10][20];two[2][8]&#x3D;1;
   int three[4][5][3];three[i][j][k]&#x3D;3;
   错误的写法:two[10,20];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>除表示方式的差别外，c中二维数组的使用与其他语言一样

数组元素按行存储，因此当按存储顺序访问数组时，最右边的数组下标(列)变化的最快

二维数组的逻辑结构：
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例：两行三列数组a的逻辑结构
             第一列   第二列   第三列       行数为第一个括号中的数，列数为第二个括号中的数
    第一行   a[0][0] a[0][1] a[0][2]      行数实际指定了二维数组的长度，列数指定元素的长度
    第二行   a[1][0] a[1][1] a[1][2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>二维数组的存储空间大小为 数据类型大小*一维数组个数*一维数组元素数量

二维数组的初始化

数组可以用花括号括起来的初值进行初始化，二维数组每一行由相应的子列表进行初始化

声明二维数组时必须指明数组的列数，而数组行数没有太大的关系

这是由于二维数组在用于函数参数传递等用途时，函数调用的是一个指针，对二维数组而言指针指向“行向量”构成的一维数组

而这个一维数组的长度是需要声明的，否则指针的类型无法确定(指针算术运算时也无法确定应该移动几个连续存储单元)

如:f(int daytab[2][13])&#123;&#125;、f(int daytab[][13])、f(int (*daytab)[13])

一般而言，除数组的第一维可以不指定大小外，其余各维都必须明确指定大小
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">二维数组的初始化的几种情况，例：
    int a[3][3]&#x3D;&#123;1,2,3,4,5,6,7,8,9&#125;;
    按元素初始化，第1-3个数据为第0行数据，第4-6个是第1行数据，第7-9个是第2行数据
    int a[3][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;
    按行初始化，第1个一维数组内为第0行数据，第2个一维数组内是第1行数据，第3个一维数组内是第2行数据
    int a[][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;
    省略行数的按行初始化，根据一维数组数确定行数为3，然后按行初始化即可，编译时将对初值个数进行统计并将这一准确数字填入数组长度
    int a[3][3]&#x3D;&#123;1,2&#125;;
    部分初始化，行列数已确定，只初始化前两个元素即第0行第1、2个元素，其他用0填充
    int a[3][3]&#x3D;&#123;&#123;1,2&#125;,&#123;4&#125;,&#123;7,8,9&#125;&#125;;
    按行部分初始化，行列数已确定，将给定行的前几个数据初始化，其他用0填充
    int a[][3]&#x3D;&#123;&#123;1&#125;,&#123;4,5&#125;,&#123;7,8,9&#125;&#125;;
    省略行数的按行部分初始化，根据一维数组数确定行数为3，然后将给定行的前几个数据初始化，其他用0填充
    int a[][3]&#x3D;&#123;1,2,3,4,5,6,7&#125;
    省略行数的按元素部分初始化，列数已确定，给定数据依次为第0，1行和第2行第1个数据，其他用0填充
    例：int a[][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6&#125;,&#123;0&#125;&#125;;
    printf(&quot;%d,%d,%d&quot;,a[1][1],a[2][1],a[3][1]);   输出结果：5,0,0 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="字符数组"><a class="markdownIt-Anchor" href="#字符数组"></a> 字符数组</h2>
<pre><code>字符数组是存放字符的数组，每个元素为一个字符

一个一维字符数组可以存放一个字符串

一个二维数组可以存放多个字符串

字符数组声明与初始化
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例：char str[10];                       一般必须指定长度，因为不指定长度char类型默认为1个字符
    字符数组中因为不一定包含字符串结束符&#39;\0&#39;，所以不一定是字符串
    与正常的数组一样，可以逐个元素赋值，也可在定义时初始化，例：
    char str[10]&#x3D;&#123;&#39;c&#39;,&#39;h&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;&#125;; 用字符进行逐个元素的初始化,前5个元素初始化，不足的用0填充
    char s1[20]&#x3D;&#123;&quot;How do you do&quot;&#125;;      直接以字符串进行初始化，字符串常量初始化后，自动在结尾加入结束标志\0(或者数值0)
    char s2[20]&#x3D;&quot;How do you do&quot;         花括号可以省略，此时s2[20]本身就代表一个字符串常量，可以直接按字符串形式输出
    通过输入输出操作进行初始化，例：
    单个字符输入输出
    char str[10];
    for(i&#x3D;0;i&lt;5;i++)scanf(&quot;%c&quot;,&amp;str[i]);     注意：visual studio中对字符要求使用安全输入函数scanf_s,需要在参数中指定字符长度
    for(j&#x3D;4;j&gt;&#x3D;0;j--)printf(&quot;%c&quot;,str[j]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串常量"><a class="markdownIt-Anchor" href="#字符串常量"></a> 字符串常量</h3>
<pre><code>字符串常量是一个字符数组(但字符数组不一定是字符串)

如:&quot;I am a string&quot;在字符串的内部表示中，字符数组以空字符'\0'结尾

因此程序可以通过检查空字符找到字符串结尾，字符串常量占据的存储单元数也因此比双引号内的字符数大1

字符串常量的主要用法也许就是作为函数参数，如:printf(&quot;hello,world\n&quot;);

在上面的语句中，当类似的字符串出现在程序中是通过字符指针访问字符串，实际上printf接受的就是一个指向字符数组的第一个字符的字符指针

因此字符串常量也可以通过指向其第一个元素的指针访问
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">除作为函数参数外，字符串常量还可以对字符指针和字符数组进行赋值，如:char *pmessage&#x3D;&quot;now is the time&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre><code>该赋值过程没有进行字符串的拷贝，而只涉及指针的操作，实际上此时*pmessage='n'(首元素地址存储的值)而不是整个字符串

同样的，c没有提供将整个字符串作为整体进行处理的运算符
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">字符数组示例程序：寻找姓名中含有James的校友
#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
&#123;
    const int n&#x3D;20,m&#x3D;6;
    char name[][n]&#x3D;&#123;&quot;Kate.Wate&quot;,&quot;James.Tan&quot;,&quot;Bull.Ben&quot;,&quot;James.Tide&quot;,&quot;James.Ting&quot;,&quot;Lebron.James&quot;&#125;;
    char James[]&#x3D;&quot;James&quot;;
    int i,j,k,l,len&#x3D;strlen(&quot;James&quot;);
    for(i&#x3D;0;i&lt;m;i++)
    &#123;
        for(j&#x3D;0;j&lt;len;j++)
        &#123;
            if(name[i][j]!&#x3D;James[j])break;
        &#125;
        if(j&#x3D;&#x3D;len)printf(&quot;%s\n&quot;,name[i]);
        for(k&#x3D;strlen(name[i])-len,l&#x3D;0;k&lt;strlen(name[i])&amp;&amp;l&lt;len;k++,l++)
        &#123;
            if(name[i][k]!&#x3D;James[l])break;
	&#125;
	if(l&#x3D;&#x3D;len)printf(&quot;%s\n&quot;,name[i]);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>变量作用域、存储类型</title>
    <url>/posts/412f02e6cd7d</url>
    <content><![CDATA[<p><strong>c程序可以看作是一系列外部对象构成</strong>，这些外部对象可能是变量或函数</p>
<h1 id="外部对象和内部对象"><a class="markdownIt-Anchor" href="#外部对象和内部对象"></a> 外部对象和内部对象</h1>
<p>external和internal是相对应的，internal用于描述定义在函数内部的函数参数及变量，外部变量定义在函数之外，可以在许多函数中使用。默认情况下，外部变量与函数(默认是external)具有下列性质：</p>
<ul>
<li>通过同一个名字引用的所有外部变量(即使这种引用来自单独编译的不同文件)实际上都是引用同一个对象(标准中将这一性质称为<strong>外部链接</strong>)</li>
<li>在这个意义上，外部变量类似于Fortran语言的COMMON块或Pascal语言中在最外层程序块中声明的变量</li>
</ul>
<p>每个源文件中包含一个编译预处理命令和若干函数和变量定义，各个文件可以<strong>单独编译</strong>，并可以与库中已经编译过的函数一起加载。源文件里的内容一般都是相对独立的，在编译时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接就行了。在不同系统中，保存在多个源文件中的c程序的编译和加载工作是不同的，如在UNIX系统中可使用cc命令：</p>
<blockquote>
<p>cc main.c geline.c strindex.c 编译文件后，将生成的目标代码分别放在文件main.o，geline.o与strindex.o中</p>
</blockquote>
<p>然后再将三个文件一起加载到a.out可执行文件中，若源程序存在错误(比如main.c存在错误)，则可以通过命令对main.c文件重新编：</p>
<blockquote>
<p>cc main.c geline.o strindex.o</p>
</blockquote>
<p>并将编译的结果与以前已编译过的目标文件getline.o与strindex.o一起加载到可执行文件中，cc命令使用.c与.o两种扩展名来区分源文件与目标文件</p>
<span id="more"></span>
<h1 id="变量作用域scope"><a class="markdownIt-Anchor" href="#变量作用域scope"></a> 变量作用域(scope)</h1>
<p>变量作用域指在源程序中定义的变量位置及其能被读写访问的范围。作用域可以分为：全局作用域，局部作用域，其中声明的变量分别对应于局部变量和全局变量。对于在函数开头声明的自动变量，其作用域是声明该变量名的函数，不同函数中声明的具有相同名字的各局部变量之间则没有任何关系，函数的参数也是一样，实际可以将其看作是局部变量。当然全局和局部的说法主要是在单个文件中划分的，如果要涉及多个文件的链接的话，不同作用域内的变量更适合从内部和外部的角度进行讨论。</p>
<h2 id="内部变量interanl-variable"><a class="markdownIt-Anchor" href="#内部变量interanl-variable"></a> 内部变量(Interanl Variable)</h2>
<p>在<strong>语句块</strong>内定义的变量，包括形参，分动态和静态，缺省定义的是动态内部变量(自动变量)，特点：</p>
<ul>
<li>生存期是该语句块的生存期，进入语句块时获得内存，仅能由语句块内语句访问，退出语句块时释放内存并且不再有效</li>
<li>定义时不会自动初始化，除非设定初值</li>
<li>并列语句块各自定义的同名变量互不干扰</li>
<li>形参和实参可以同名</li>
</ul>
<p>c语言并不是Pascal等语言意义上的程序块结构式语言，它不允许在函数中定义函数，但在函数中可以以程序块结构的形式定义变量。变量的声明(包括初始化)除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其他标识复合语句开始的左花括号之后，这种方式声明的变量可以隐藏程序块外与之同名的变量，并在与左花括号匹配的右花括号出现之前一直存在，如：</p>
<blockquote>
<p>if(n&gt;0){int i;for(i=0;i&lt;n;i++);}中变量i的作用域是if语句的‘真’分支，与程序块外声明的i无关</p>
</blockquote>
<p>每次进入程序块时，程序块内声明以及初始化的自动变量都将被初始化，静态变量只在第一次进行时初始化一次。</p>
<p>自动变量也可以隐藏同名的外部变量和函数，如：</p>
<blockquote>
<p>int x,y;f(double x){double y;}</p>
</blockquote>
<p>一个好的程序设计风格中，应当避免出现变量名隐藏外部作用域中相同名字的情况，否则很容易引起混乱和错误，外部变量或函数作用域从声明它的地方开始，到其所在的(待编译的)文件末尾结束。</p>
<h2 id="外部变量external-variable"><a class="markdownIt-Anchor" href="#外部变量external-variable"></a> 外部变量(External Variable)</h2>
<p>在所有函数之外定义的变量，特点：</p>
<ul>
<li>生存期是整个程序，从程序运行起占据内存，程序运行过程中可随时访问，程序退出时释放内存</li>
<li>有效范围是从定义变量的位置开始到本程序结束
<ul>
<li>注意作用范围不是从变量定义处到该文件结束，在其他文件中也有效</li>
</ul>
</li>
</ul>
<p>构成c程序的函数与外部变量可以分开进行编译，一个程序可以放在几个文件中，原先已经编译过的函数可以从库中进行加载，如：</p>
<blockquote>
<p>main(){…}int sp=0;double val[MAXVAL];void push(double);double pop(void);</p>
</blockquote>
<p>push和pop不需任何声明就可以访问sp与val，但sp，val，push和pop都不能用在main函数中。另一方面，如果在外部变量定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件，则必须在相应的变量声明中强制使用extern，定义格式：</p>
<blockquote>
<p>extern 数据类型 变量名</p>
</blockquote>
<p>extern最基本的用法是声明外部变量(注意得是非静态的)，可以扩大该变量的作用域，extern用于声明函数的话仅仅是暗示这个函数可能在别的源文件里定义，无实际作用</p>
<ul>
<li>这主要是因为函数声明和定义区别很明显，从是否有定义体就能看出来，因此用不用extern都能区分</li>
<li>外部数据变量则不同，因为是在全局作用域所以默认会自动初始化，如果不加extern的话就必须为这个变量分配空间，所以加上extern就是让编译器知道这是个声明不用为其分配空间</li>
</ul>
<p>原本外部变量的作用域是从定义点处开始直到文件结束，使用extern提前声明之后就变成从声明处开始，直到文件结束，例：</p>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    extern int x;         &#x2F;&#x2F;声明外部变量，如果不提前声明编译器到这里找不到x
    printf(&quot;%d&quot;,x);
&#125;  
int x&#x3D;1;                  &#x2F;&#x2F;外部变量定义点在main()函数以后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>外部变量(和函数)的声明与定义必须要严格区分，变量声明用于说明变量的属性(主要是类型)，而变量定义除此外还将引起存储器的分配(主要是外部变量和函数要么在其他地方有定义，要么在声明的同时初始化)，如：</p>
<blockquote>
<p>int sp;double val[MAXVAL]; 写在所有函数之外则相当于直接定义了该文件中的外部变量，并为之分配存储单元(自动初始化)，以及作为该文件中其余部分的声明<br>
extern int sp;extern double val[];只作为该文件中其余部分的声明(数组长度在其他部分确定)，声明没有建立变量或分配存储单元</p>
</blockquote>
<p>变量定义中必须指定数组的长度，但extern声明不一定需要，因为变量的初始化(指的是真正的为内存中的变量赋值的过程)只能出现其定义中，这进一步体现了声明不需要实际分配存储空间的特点。</p>
<p>一个外部变量是不可能在另一个文件中同时定义的，否则必然是重定义错误(就像在同一个作用域内不能定义同名变量)。在一个程序的所有源文件中，一个外部变量只能在某个文件中定义一次，其他文件可以通过extern声明来访问。假定函数push和pop定义在同一个文件中，而变量val和sp在另一个文件中定义并被初始化(通常不大可能这样组织程序)，如：</p>
<blockquote>
<p>file1:<br>
int sp=0;double val[MAXVAL];<br>
file2:<br>
extern int sp;extern double val[];void push(double f){}double pop(void){}</p>
</blockquote>
<p>通过这样的声明和定义可以将函数和变量“绑定”在一起，file2中的extern声明不仅放在函数定义外面，还要在它们的前面，适用于该文件所有函数，如果要在同一文件中先使用后定义变量，也需要像这样的方式来组织文件。</p>
<p>相比于内部变量，外部变量具有更大的作用域和更长的生存期，外部变量为函数的数据交换提供了一种可以代替函数参数与返回值的方式，任何函数都可以通过名字访问一个外部变量，如：</p>
<blockquote>
<p>int a=-1;void Function(){int a=5;}int main(){int a=10;{int a=5;}Function();printf(“a=%d”,a);}<br>
输出结果：a=10</p>
</blockquote>
<p>上例中外部变量a的生存期和程序生存期相同，Function()被调用，里面的内部变量a=5才分配空间，Function()执行完成生存期结束，作用域范围是从定义位置开始到函数体末尾，主函数main()中定义的a在程序执行时分配空间，main()执行完成生存期结束，作用域范围也是从定义位置开始到函数体末尾。main()中复合语句的内部变量只在程序块中执行，生存期和作用域范围也都是在程序块内。如果函数之间需要共享大量的变量，使用外部变量要比使用一个很长的参数表更方便有效，比如两个函数互不调用对方，但必须共享某些数据，这种情况下最方便的方式是将这些共享定义为外部变量，而不是分别作为函数参数传递，不过这样做也可能对程序结构产生不良的影响，导致程序中各个函数之间具有太多的数据依赖。</p>
<p>实际上需要理解外部变量这一概念的关键在于理解编译器的工作原理：<br>
简单说编译器是并不关心程序的具体实现的(当然优秀的编译器会进行语义检查和优化，不过这不属于它必须要做的事)，它只关心程序在“逻辑”上能不能运行起来。编译器的要求是只要程序在适当位置有声明，能够将变量函数之类的用符号表存储起来并为其进行适当的逻辑上的存储分配，满足程序的过程调用关系就可以了，它检查完这些就进行“文本翻译”，将源程序编译为其他程序(汇编程序、可重定位目标程序)。<br>
那么，真正需要完成地址绑定的是链接器(当然一般编译器软件都是包含配套链接器的)。链接器链通过编译器提供的全局符号表找到相对应的符号，将每个引用符号的地方进行地址修改，如果是外部符号就由链接器在其输入的可重定义目标文件中查找该符号，此时就要求符号声明要在对应文件中有无二义性的定义实现，如果找不到就会报链接错误。另一方面也就是说，假如在多个文件中同时定义外部变量，这时候它们会各自存在于所在的源文件编译出来的可重定位目标文件中，链接器根本不知道应该要链接哪个，也会产生错误。</p>
<h1 id="变量存储类型storage-class"><a class="markdownIt-Anchor" href="#变量存储类型storage-class"></a> 变量存储类型(storage class)</h1>
<p>存储类型指数据在内存中存储的方式，即编译器为数据分配内存的方式，决定变量的生存期。在定义变量时可以指定变量存储类型，基本格式为：</p>
<blockquote>
<p>存储类型 数据类型 变量名;</p>
</blockquote>
<p>c程序变量的读写类型分为：auto型-自动变量，static型-静态变量，extern型-外部变量，register型-寄存器变量</p>
<p>在内存(RAM)中，代码在代码区，常量在常量区(也有部分在代码区)，变量存储区域分静态存储区和动态存储区，分别是数据区和栈/堆。静态存储区主要包括静态局部变量和全局变量，动态存储段主要存放自动变量(动态局部变量)，寄存器变量存放在cpu的寄存器中（普通变量是运行时cpu从内存读取需要的数据到寄存器中进行运算，而寄存器变量直接在寄存器读取即可）。当然这只是语言定义的一种理想化模型，实际上如何分配属于编译器和操作系统的行为。<br>
静态存储区中变量与整个程序“共存亡”，动态存储区中变量和寄存器变量与所在函数“共存亡”。(生存期)</p>
<h2 id="动态局部变量"><a class="markdownIt-Anchor" href="#动态局部变量"></a> 动态局部变量</h2>
<p>动态局部变量是缺省的存储类型，如果变量定义在局部(函数内)时，称为自动变量(动态局部变量)，定义格式：</p>
<blockquote>
<p>auto 数据类型 变量名 (或者直接省略auto)</p>
</blockquote>
<p>动态局部变量在执行流进入语句块时自动申请内存，退出时自动释放内存。</p>
<h2 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h2>
<p>静态变量(静态局部变量或全局变量) 定义格式：</p>
<blockquote>
<p>static 数据类型 变量名</p>
</blockquote>
<p>使用static修饰变量，对内部变量而言是改变生存期，对外部变量是改变作用域。在函数内部定义的话静态变量作用同动态局部变量，生存期为整个程序运行期间。不管其所在函数是否被调用，static类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。<br>
如果用static声明限定外部变量和函数，则可以将其后声明的对象作用域限制在编译源文件的剩余部分，通过static限定外部对象，可以达到隐藏外部对象的目的(类似于private的效果)。外部的static声明通常多用于变量，当然也可声明用于函数，通常情况下函数名是全局可访问的，对程序的各个部分而言都可见，但如果把函数声明为static类型则除了对该函数所在文件仍然可见外，其他文件都无法访问。在这种情况下不同源文件中同名的外部变量甚至是不冲突的，可以认为非静态外部变量的作用域是整个源程序，静态外部变量的作用域是单个源文件。</p>
<p>(内部)静态变量示例程序：使用静态变量输出1-10的阶乘</p>
<pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;
int Factorial(int n)
&#123;
    static int p&#x3D;1;              &#x2F;&#x2F;静态变量只初始化一次，函数调用结束后不释放内存，值可以保存到下次进入函数，是函数具有了记忆功能
    p*&#x3D;n;                        &#x2F;&#x2F;p从1开始，每调用一次就乘一次n，即为阶乘
    return p;
&#125;
int main()
&#123;
    int i,n;
    scanf(&quot;%d&quot;,&amp;n);
    for(i&#x3D;1;i&lt;n;i++)
    &#123;
        printf(&quot;%d!&#x3D;%d\n&quot;,i,Factorial(i));
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="寄存器变量"><a class="markdownIt-Anchor" href="#寄存器变量"></a> 寄存器变量</h2>
<p>寄存器变量定义格式：</p>
<blockquote>
<p>register 数据类型 变量名</p>
</blockquote>
<p>cpu内部容量有限但运算速度极快，register声明就是告诉编译器，其所声明的变量在程序中使用频率较高，其思想是将register变量放在cpu寄存器中，将使用频率比较高的变量声明为寄存器变量，可使程序更小，执行速度更快。不过编译器本身也是可以忽略这一选项的，一些现代编译器有能力自动将普通变量优化为寄存器变量，并且可以忽略用户的指定，所以现在一般已经无需特别声明变量为register类型。register声明只适用于自动变量以及函数的形式参数，如：</p>
<blockquote>
<p>f(register unsigned m,register long n){register int i;}</p>
</blockquote>
<p>这主要是因为extern和static类型变量本身在存储分配、生存期、作用域方面有其特殊性，其实现并不容易让寄存器参与进去。另外实际使用时，底层硬件环境实际情况会对寄存器变量的使用有一些限制，不同机器中对寄存器变量的数目和类型的具体限制也是不同的，每个函数中只有很少变量可以保存在寄存器中，且只允许某些类型的变量。不过过量声明也没太多坏处就是了(但不意味着可以瞎写等着编译器优化)，因为编译器可以自动过滤，无论寄存器变量是不是真正存放在寄存器中，它的地址都是不能访问的(因为地址格式和内存不一定相同故而无法进行取地址运算)。</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>头文件、预处理器、宏</title>
    <url>/posts/382e8937ecec</url>
    <content><![CDATA[<h1 id="头文件"><a class="markdownIt-Anchor" href="#头文件"></a> 头文件</h1>
<p>在考虑将一个程序分解为若干个源文件的情况下，一般主要考虑的是实际程序中分别来自于不同的单独编译的库，这种情况下，必须考虑定义和声明在这些文件中的共享问题。应尽可能将共享部分集中在一起，这样就只需要一个副本，维护程序时也可以提升可维护性。所谓的头文件，其实它的内容跟源文件中的内容是一样的，都是c的源代码，但头文件一般是不用来进行编译的，只是把把所有的函数声明全部放进一个头文件中，当某一个源文件需要它们时，就可以通过宏命令 “#include”包含进这个源文件中，从而把它们的内容合并到源文件中去，当包含该头文件的源文件被编译时，这些被包含进去的头文件的作用便发挥了。注意，头文件起到的是将程序的不同源文件声明串联起来的作用，与库文件完全不是一个概念(后者是已经编译过的可执行文件)。<br>
实际应用中，通常一方面希望每个源文件只能访问完成任务所需的信息，另一方面维护过多的头文件较为困难。对于中等规模的程序，最好只用一个头文件存放程序中各部分的共享对象，较大程序可能需要使用更多的头文件，需要精心进行组织。</p>
<p>一般的c语言项目工程的头文件应该具有的内容：</p>
<ul>
<li>宏定义（#define)，包括带参和不带参的</li>
<li>结构体、联合体和枚举类型等自定义类型的定义</li>
<li>函数的声明</li>
<li>全局变量的声明(当然全局变量是默认初始化的，定义不定义都差不多)</li>
<li>typedef的声明</li>
</ul>
<p>除了static，inline，extern函数，正常的函数不在.h里实现，只将声明放在头文件里，实现放在源文件里，永远不把外部函数原型(即外部函数声明)放到源文件中。声明或宏定义需要在多个文件中共享时，尤其需要把它们放入头文件中，但如果宏定义或声明为一个源文件私有的(意思是只有该源文件用得到)，则最好留在源文件中。</p>
<ul>
<li>不把定义放在头文件中，因为头文件可能会被程序中的多个文件包含(通过预处理器在包含位置展开)，此时发生重定义错误</li>
<li>不把声明放在源文件中，因为要引用的地方可能与定义并不在一个文件中，如果在源文件中声明的话就意味着声明定义不在同一文件，在编译时就无法进行一致性检查(虽然编译阶段没有问题，但实际运行可能有各种问题)</li>
</ul>
<p>实际开发中一般是将函数和变量的声明放到头文件，再在对应的源文件中#include进来，如果变量的值是固定的，最好使用宏来代替。.h和.c在项目中承担的角色不一样：.c 件主要负责实现，也就是定义函数和变量；.h文件主要负责声明（包括变量声明和函数声明）、宏定义、类型定义等，这些不是c语言语法规定的内容，而是约定成俗的规范，或者说是长期形成的事实标准。<br>
在项目开发中可以将一组相关的变量和函数定义在一个.c文件中，并用一个同名的.h文件（头文件）进行声明，其他模块如果需要使用某个变量或函数，那么引入这个头文件就可以。这样做的另外一个好处是可以保护版权，在发布相关模块之前可以将它们都编译成目标文件或者打包成静态或动态库，只要向用户提供头文件，用户就可以将这些模块链接到自己的程序中(这也是标准库的做法)。</p>
<h2 id="标准头文件和标准库"><a class="markdownIt-Anchor" href="#标准头文件和标准库"></a> 标准头文件和标准库</h2>
<p>c语言在发布的时候已经将标准库打包成了静态库，并提供了相应的头文件，如：stdio.h、stdlib.h、string.h等。Linux系统一般将库文件放在/lib和/user/lib目录下，头文件放在/usr/include目录下。很久以前，Linux下的c标准库是libc，不过后来渐渐已经不再维护了，目前的Linux大多以glic(GNU C Library)作为c标准库的实现(GNU C函数库最开始本质上是个第三方库，因为GNU组织是研发编译套件的，它本身就可以附带自己的库以增加功能，方便用户开发，争夺市场份额)。不过现在的不同的Linux发行版对这两个函数库有不同的处理方法，有的可能已经集成在同一个库里了。</p>
<p>以下是在我自己的系统上的测试结果：(两个系统只找到了c++库，难道现在默认没有标准c库了吗？有待考证)</p>
<img src="https://s2.loli.net/2022/05/14/nsX5KECLqSgv7FJ.png" width="50%">
<img src="https://s2.loli.net/2022/05/14/7znoRbVEFIkCsX5.png" width="50%">
<ul>
<li>在GNU/Linux上，c++库为GNU的libstdc++
<ul>
<li>动态库：/usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.so.6</li>
<li>静态库：/usr/lib/gcc/x86_64-linux-gnu/11/libstdc++.a</li>
</ul>
</li>
<li>在MacOS，c++库为LLVM的libc++
<ul>
<li>/usr/lib/libSystem.B.dylib</li>
</ul>
</li>
</ul>
<p>windows系统我是没有的，据说在windows下标准库由Visual Studio IDE携带，在安装目录下的\VC\include文件夹中会看到头文件，包括常用的stdio.h、stdlib.h等；在\VC\lib文件夹中有.lib文件，是链接器要用到的静态库。</p>
<h1 id="c语言预处理器"><a class="markdownIt-Anchor" href="#c语言预处理器"></a> c语言预处理器</h1>
<p>c语言通过预处理器提供了一些功能，从概念上讲，预处理是编译过程中单独执行的第一个步骤(宏替换——&gt;预处理——&gt;编译)。两个最常用的预处理命令是#include指令(用于在编译期间把指定文件的内容包含进当前文件中)以及#define指令(用于以任意字符序列替代一个标记)。预处理指令的语法与c语言本体的语法是完全独立的(主要是为了提前把预处理的部分搞完再进行程序编译)。在gcc中其实也有专门的预处理命令生成.i文件：</p>
<blockquote>
<p>$gcc -E demo.c -o demo.i  -E表示只进行预编译</p>
</blockquote>
<p>.i文件也是包含c语言代码的源文件，只不过所有的宏已经被展开，所有包含的文件已经被插入到当前文件中，当你无法判断宏定义是否正确，或者文件包含是否有效时，可以查看.i文件来确定问题。只不过.i实际大体上相当于是比较臃肿的并且加入了一些辅助信息的c语言文件，在开发中大多数情况意义不太大，所以.i文件和上面的gcc命令较少提及用的也不多。</p>
<h2 id="文件包含"><a class="markdownIt-Anchor" href="#文件包含"></a> 文件包含</h2>
<p>文件包含指令，即#include指令可以使处理大量#define指令以及声明更加方便，基本格式为：</p>
<blockquote>
<p>#include “文件名” 或 #include&lt;文件名&gt;</p>
</blockquote>
<p>形如以上两种形式的行实际上是将被替换为由文件名指定的文件的内容</p>
<ul>
<li>如果文件名用引号引起来，则在源文件所在的位置(目录)查找该文件</li>
<li>如果在该位置没有找到文件，或者文件名用尖括号括起来，则根据相应的规则查找该文件，这个规则同具体实现有关
<ul>
<li>在多数情况下，使用尖括号&lt;&gt;编译器会到系统路径(环境变量)下查找头文件，而使用双引号&quot;&quot;编译器首先在当前目录下查找头文件，如果没有找到再到系统路径下查找
<ul>
<li>一般情况下Linux中c/c++头文件路径对应环境变量为C_INCLUDE_PATH或CPLUS_INCLUDE_PATH</li>
<li>静态库和动态库文件路径对应环境变量分别为LIBRARY_PATH和LD_LIBRARY_PATH</li>
</ul>
</li>
<li>使用绝对路径的方式引入头文件时，&lt;&gt;和&quot;&quot;没有任何区别，因为头文件路径已经写死了，都是从根部开始查找</li>
</ul>
</li>
<li>虽然文件既可以指定绝对路径，也可以指定相对路径，但是一般情况下都使用相对路径
<ul>
<li>因为实际开发中一般头文件放在当前工程目录下，这样即使后来改变了工程所在目录，也无需修改包含语句，因为源文件的相对位置没有改变</li>
<li>使用绝对路径的情况一般是环境变量出现问题时难以解决，此时指定绝对路径一定可以找到包含文件</li>
</ul>
</li>
<li>除了默认的环境变量外，用户还可以自定义环境变量或者在编译时指定参数(比如gcc -I指定头文件、gcc -L指定链接的库)，从而自己指定搜索路径
<ul>
<li>虽然可以添加环境变量但其实这种做法并不好，因为这样属于是系统层面上全局的配置，影响所有项目并且增加维护难度，如果非要指定一个路径的话可能写个makefile好点</li>
</ul>
</li>
</ul>
<p>在UNIX系统中，头文件一般放在目录/usr/include中，被包含的文件本身也可包含#include指令。文件的开始处通常都会有多个#include指令，用以从头文件中包含常见的#define语句和extern声明，以及访问该文件需要的库函数的函数原型声明(严格地说，这些内容没有必要单独存放在文件中，访问头文件的细节与具体实现有关)。<br>
在较大的程序中，#include指令是将所有声明捆绑在一起的较好实现，他保证所有源文件都具有相同的定义与变量声明，可以避免出现不必要的错误。但是另一方面，如果某个包含文件的内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译。</p>
<h2 id="宏替换"><a class="markdownIt-Anchor" href="#宏替换"></a> 宏替换</h2>
<p>在c语言中，可以采用命令#define来定义宏，该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理器都会把它用定义时指定的文本替换掉。宏的作用域是从定义位置开始，到其当前所在文件结束或宏对应的#undef指令，即宏定义只属于当前这个文件，其他文件如果没有这个文件就不能使用这个宏定义。如果相同作用域内定义了同名的宏，那么原来的宏也会被覆盖。宏虽然可以在预处理指令中展开，但是并不能用于生成整个预处理指令(因为预处理指令的处理是有先后的，比如至少要在包含进其他头文件以后再依次展开所有的宏定义)。</p>
<p>宏定义的基本格式为:</p>
<blockquote>
<p>#define 名字 替换文本</p>
</blockquote>
<p>这是最基本的宏替换格式，后续所有出现<strong>宏名字记号</strong>的地方都将被换为替换文本。#define指令中名字与变量名的命名方式相同，替换文本可以是任何字符串，惯例将宏名称每个字母采用大写，这有助于区分宏与一般的变量。通常情况下#define指令单独占一行，替换文本是#define指令行尾部的所有剩余部分内容。#define指令定义的名字的作用域从其定义点开始，到被编译的源文件末尾处结束。#define指令也可以使用之前定义过的宏，如:</p>
<blockquote>
<p>#define TEST1<br>
#define TEST1 TEST2</p>
</blockquote>
<p>替换只对整个记号进行，并且对字符串常量(字符串字面量是不同于宏的预处理记号)是不能进行替换的，如：</p>
<blockquote>
<p>#define YES ‘1’<br>
YESMAN;printf(“YES”);      其中的YES均不会被进行替换</p>
</blockquote>
<p>替换文本可以是任意的，如：</p>
<blockquote>
<p>#define forever while(1); 无限循环</p>
</blockquote>
<p>宏定义也可以带参数，使之可以对不同的宏调用使用不同的替换文本，带参宏定义的基本格式为：</p>
<blockquote>
<p>#define 宏名(形参列表) 替换文本</p>
</blockquote>
<p>调用格式为：</p>
<blockquote>
<p>宏名(实参列表)</p>
</blockquote>
<p>宏的使用很像是函数调用，但宏调用是直接将替换文本插入代码中，形式参数的每次出现都将被替换成对应的实际参数，如：</p>
<blockquote>
<p>#define max(A,B) ((A)&gt;(B)?(A):(B))           宏可以将A,B自动识别为参数<br>
x=max(p+q,r+s);                              将被替换为x=((p+q)&gt;(r+s)?(p+q):(r+s));</p>
</blockquote>
<p>这种带参宏定义的一个好处在于如果对各种类型参数的处理是一致的，则可将该宏应用于任何数据类型而无需针对不同的数据类型定义不同函数。另外考虑带参宏的展开式，会发现其存在一定的缺陷，其中作为参数的表达式并不是值传递而是拷贝字符序列，所以表达式会执行两次，导致表达式可能存在副作用(如含有自增/自减运算符或输入输出)，如：</p>
<blockquote>
<p>max(i++,j++)中将对每个参数执行两次自增操作</p>
</blockquote>
<p>因此必须要注意适当使用圆括号以保证计算次序的正确性，如：</p>
<blockquote>
<p>#define square(x) x*x;  功能存在歧义<br>
square(z+1);            此时宏扩展后的结果为z*z+1=2*z+1!=z*z<br>
正确形式应为:#define square(x) (x)*(x);</p>
</blockquote>
<p>注意宏定义没有数据类型只是单纯的替换，所以无法替换数组和指针(如果在参数前上[]或*的话是无法识别宏参数的)。</p>
<p>宏替换在c语言中是十分具有价值的，头文件&lt;stdio.h&gt;中有一个很实用的例子: getchar与putchar函数在实际中常常被定义为宏，可以避免处理字符时经常需要调用函数所需的运行时开销。此外头文件&lt;ctype.h&gt;中定义的函数也常常是通过宏实现的。</p>
<p>可以通过#undef指令取消名字的宏定义，这样可以保证后续调用是函数调用而不是宏调用，宏替换在编译之前，所以有同名宏存在函数是无法调用的，如：</p>
<blockquote>
<p>#undef getchar<br>
int gartchar(void){…}</p>
</blockquote>
<p>宏定义可以包含两个专用的预处理运算符：#和##，编译器不识别这两个运算符，他们会在预处理时被执行。如果替换文本中参数名以#为前缀，则结果将被扩展为由实际参数替换该参数的的带引号的字符串(#运算符所执行操作可理解为“字符串化”)，如：</p>
<blockquote>
<p>#define deprint(expr) printf(#expr) 将#与字符串连接运算结合起来编写一个调试打印宏<br>
deprint(“hello\tworld”);            控制台将输出&quot;hello\tworld&quot;而不是hello    world<br>
#definr deprint(expr) printf(#expr&quot;=%g&quot;,expr)<br>
deprint(x/y);                       调用该宏后，宏被扩展为printf(“x/y”&quot;=%g&quot;,x/y);等价于printf(“x/y=%g”,x/y);</p>
</blockquote>
<p>#运算符实际上等同于将字符串字面值的双引号&quot;替换为\&quot;，反斜杠’\‘替换为’\\’，因此替换后的字符串是合法的字符串常量，如：</p>
<blockquote>
<p>字符串&quot;hello\tworld&quot;是先转为&quot;“hello\\tworld”“再作为字符串输出，结果为&quot;hello\tworld”</p>
</blockquote>
<p>如果替换文本中的参数与##相邻，则该参数将被实参替换，##与前后空白符将被删除，并对替换后的结果进行扫描，这为宏扩展提供了连接实参的手段，如:</p>
<blockquote>
<p>#define paste(front,back) front ## back<br>
paste(name,1);                      调用该宏后，宏将创建记号name1;</p>
</blockquote>
<h2 id="条件包含"><a class="markdownIt-Anchor" href="#条件包含"></a> 条件包含</h2>
<p>可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理执行过程中进行运算，这种方式为在编译过程中根据运算所得条件值而选择性地包含不同代码提供了一种手段。<br>
#if语句对其中的常量整型表达式求值</p>
<ul>
<li>其中不能包含sizeof、类型转换运算符或enum常量，原因主要在于预处理器不检查类型名</li>
<li>虽然条件编译中无法使用sizeof，但在#define中使用sizeof是合法的，因为预处理器并不计算#define语句的表达式，它只是为了原样在程序中展开</li>
</ul>
<p>若该表达式值为真(非0)，则包含其后的各行，直到遇到#endif、#elif或#else语句为止(预处理语句#elif类似于else if)。在#if语句中可以使用表达式defined(名字)，该表达式值遵循下列规则:当名字已经定义时，值为1，否则值为0，(defined也是预处理指令)</p>
<p>例1:保证hdr.h文件的内容没有重复包含，可以将该文件内容保存在条件语句中</p>
<pre class="line-numbers language-none"><code class="language-none">#if !defined(HDR)       &#x2F;&#x2F;第一次包含该头文件时，HDR还没有被定义
#define HDR             &#x2F;&#x2F;进入if分支，定义HDR
&#x2F;&#x2F;hdr.h文件的内容
#endif                  &#x2F;&#x2F;如果HDR已被定义，则!defined(HDR)为0，直接跳转到endif处，避免重复包含<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对这种情况，c专门定义了两个预处理语句#ifdef和#ifndef，用于测试某个名字是否已经定义，因此上例可改写为例2:</p>
<pre class="line-numbers language-none"><code class="language-none">#ifndef HDR
#define HDR
&#x2F;&#x2F;hdr.h文件的内容
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果多个头文件能够一致地使用这种结构，那么每个头文件都可以将其所依赖的任何头文件包含进来，用户不必考虑和处理头文件之间的各种依赖关系</p>
<p>例2:测试系统变量SYSTEM，根据该变量的值确定包含哪个版本的头文件</p>
<pre class="line-numbers language-none"><code class="language-none">#if SYSTEM&#x3D;&#x3D;SYSV
#define HDR &quot;sysv.h&quot;
#elif SYSTEM&#x3D;&#x3D;BSD
#define HDR &quot;bsd.h&quot;
#elif SYSTEM&#x3D;&#x3D;MSDOS
#define HDR &quot;msdos.h&quot;
#else
#define HDR &quot;default.h&quot;
#endif
#include HDR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="预处理器的简要工作流程"><a class="markdownIt-Anchor" href="#预处理器的简要工作流程"></a> 预处理器的简要工作流程</h2>
<p>预处理过程主要是处理那些源文件和头文件中以#开头的命令，比如 #include、#define、#ifdef等，其规则(以Linux系统为例)一般如下：</p>
<ol>
<li>从源代码文件中读取并转换字符，如果必要则将字符转换成源代码指定字符集的字符
<ul>
<li>如果行尾字符不是换行符时自动添加换行符，宽字符替换成对应单字符</li>
<li>如果添加换行符后存在反斜线符跟着换行符的情况，则将两者都删除(除非在文件的结尾需要以换行符结束)</li>
</ul>
</li>
<li>将源代码文件分解成若干预处理器标记和空格符序列
<ul>
<li>删除所有的注释//和/* … */，每个注释都被看作一个空格</li>
</ul>
</li>
<li>处理所有条件编译命令，比如 #if、#ifdef、#elif、#else、#endif等</li>
<li>处理#include命令，将被包含文件的内容插入到该命令所在的位置，这与复制粘贴的效果一样
<ul>
<li>这个过程是递归进行的，也就是说被包含的文件可能还会包含其他的文件</li>
</ul>
</li>
<li>删除所有#define，展开宏调用</li>
<li>添加行号和文件名标识，便于在调试和出错时给出具体的代码位置</li>
<li>保留所有的#pragma命令，因为编译器需要使用它们</li>
<li>字符常量和字符串字面量中的字符和转义序列被转换成运行字符集中对应的字符
<ul>
<li>相邻的字符串字面量被连接为一个字符串</li>
</ul>
</li>
<li>预处理的结果是生成.i文件</li>
</ol>
<p>当然只要不影响结果，在编译器具体实现中可以将多个步骤打乱并结合在一起。</p>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言控制流</title>
    <url>/posts/307e07dbb681</url>
    <content><![CDATA[<blockquote>
<p>程序语言中的控制流语句用于控制各运算执行的次序</p>
</blockquote>
<h2 id="语句与程序块"><a class="markdownIt-Anchor" href="#语句与程序块"></a> 语句与程序块</h2>
<pre><code>表达式后加上一个';'，就变成了一个语句，如：x=0;i++;printf(&quot;&quot;);

c中';'是语句结束符(简单语句)，但Pascal等语言中将';'用作语句之间分隔符

空语句指什么都不执行，语句本身只有一个分号';'

当一个语句过长时，可以直接换行，并不会影响语句的编译，特殊情况下需要在待续的行末尾加上一个反斜杠'\'

复合语句(也叫程序块)是以花括号&#123;&#125;将说明和若干个有序的语句(一组声明和语句)组合在一起而构成的语句集合
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">复合语句在语法上等价于单条语句
&#123;
    内部数据说明

    简单(复合)语句表
&#125;
如：函数体中、if-else、while、for中花括号括起来的多条语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>右花括号用于结束程序块，其后不需要分号

程序块的基本结构有三种：顺序结构，分支结构，循环结构
</code></pre>
<span id="more"></span>
<h2 id="选择语句"><a class="markdownIt-Anchor" href="#选择语句"></a> 选择语句</h2>
<blockquote>
<p>用于条件判定</p>
</blockquote>
<h3 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h3>
<blockquote>
<p>功能为单选结构<br>
语句既可以是简单语句也可以是复合语句(等价)</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">基本格式：if (表达式)
            语句(或复合语句);
if ((s1+s2+s3)&#x2F;3.0&gt;&#x3D;90)
&#123;

    printf(&quot;AV_score&#x3D;%f\n&quot;,(s1+s2+s3)&#x2F;3.0&gt;&#x3D;90);

    printf(&quot;excellence!\n&quot;);

&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="if-else语句"><a class="markdownIt-Anchor" href="#if-else语句"></a> if-else语句</h3>
<blockquote>
<p>功能为二选一分支结构</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">
基本格式：if(表达式)
	语句A;
        else
        语句B;

例:取a,b中的较大值(等效于三目运算符表达式：max&#x3D;a&gt;&#x3D;b?a:b)

    if(a&gt;&#x3D;b)max&#x3D;a

    else max&#x3D;b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>语句执行时先计算表达式的值，如果其值为真(非0)，执行if语句，值为假(0)，执行else语句

在编写if-else结构时最好加花括号来强制实现正确的匹配关系

嵌套语句中if与else的配对在不加花括号时是以最近配对为原则(与缩进无关)

因此即使编写的程序缩进结构明确表达了设计意图，但编译器无法获得这一信息，导致会给阅读程序人的理解带来歧义
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例1:if(表达式1)
    if(表达式2)                 将每个else与最近的前一个没有else配对的if进行配对
       语句1;
    else 语句2;                 与内层if配对

例2:一个歧义性有害的例子
    if(n&gt;&#x3D;0)                   外层if没加花括号
    for(i&#x3D;0;i&lt;n;i++)
    if(s[i]&gt;0)
    &#123;
        printf(&quot;…&quot;);
        return i;
    &#125;
    else printf(&quot;error--n is negative\n&quot;);   这里的else是与for里面的if配对，与程序原本的逻辑(判断n正负)相悖<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>由于if语句只是简单测试表达式的值，因此可以对某些代码进行简化，最明显的例子是：

if(表达式!=0)用if(表达式)替代

多数情况下这种表达紧凑美观、自然清晰，但也有部分情况会含义不清

else-if语句 功能为多选一分支结构，是多路判定最常用的方法

实质上是else后面嵌套了一个if语句
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">基本格式：if(表达式1)
         语句1;
         else if(表达式2)
         语句2;
          ...
         else if(表达式n)
         语句n;
         else
         语句n+1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>其中各表达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，然后终止整个语句序列的执行

最后的else用来处理“上述条件均不成立”的情况或默认情况

在不需要针对默认情况执行显式操作时，可以将结构末尾的else语句部分省略掉

该部分也可以用来检查错误，以捕获“不可能”的条件
</code></pre>
<h3 id="switch-多路开关语句"><a class="markdownIt-Anchor" href="#switch-多路开关语句"></a> switch 多路开关语句</h3>
<blockquote>
<p>使用if-else的多重嵌套方式，可以实现多路分支的判定结构，但c提供了更简洁的多重选择语句switch</p>
<p>switch语句也是一种多路判定语句，测试表达式是否与一些常量整数值中的某一个匹配，并执行相应的分支动作</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">基本格式：switch(表达式)          表达式类型为int
        &#123;
            case 常数1:语句1;
            break;             如果case分支中没有加break，那么程序执行完对应语句后还会往下继续执行
            case 常数2:语句2;
            break;
            ...
            case 常数n:语句n;
            break;
            default:语句n+1;
         &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>每个分支由一个或多个整数值常量或常量表达式标记，各分支表达式必须互不相同

如果没有哪一分支匹配表达式，则执行标记为default的分支

如果没有default分支也没有其他分支与表达式的值匹配，该switch语句不执行任何动作，各分支及default分支在逻辑上的排列次序是任意的

跳出switch语句最常用的方法是使用break和return语句，这两个语句将导致程序执行立即从switch语句中跳出

switch语句中case的作用只是一个标号，因此某个分支中的代码执行完后，程序进入下一分支继续执行(除非在程序中进行显式的跳转)

在switch语句中依次执行各分支的做法有优点也有缺点：

好的一面在于可以把若干个分支组合在一起完成一个任务，即可以对多种情况进行统一操作

但这种从一个分支直接进入下一个分支的做法并不健全，在修改时很容易出错，除了一个计算需要多个标号的情况外，应尽量避免这种操作

这种做法在不得不使用的时候，应当加上适当的程序注释

一般情况下为了防止直接进入下一分支，每个分支后面都会以break语句结尾

作为一种良好的程序设计风格，在switch语句的最后一个分支后面也应该加上一个break语句

从而降低日后需要向switch语句后再添加其他分支时发生错误的可能性

switch语句示例程序:从键盘输入一个月号，输出对应月份的英文名称
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    int month;
    int r&#x3D;scanf(&quot;%d&quot;,&amp;month);
    if (r&#x3D;&#x3D;1)
    &#123;
    	switch (month)
    	&#123;
    		case 1:printf(&quot;January&quot;);
    		break;
    		case 2:printf(&quot;February&quot;);
    		break;
    		case 3:printf(&quot;March&quot;);
    		break;
		case 4:printf(&quot;April&quot;);
		break;
		case 5:printf(&quot;May&quot;);
		break;
		case 6:printf(&quot;June&quot;);
		break;
		case 7:printf(&quot;July&quot;);
		break;
		case 8:printf(&quot;August&quot;);
		break;
		case 9:printf(&quot;September&quot;);
		break;
		case 10:printf(&quot;October&quot;);
		break;
		case 11:printf(&quot;November&quot;);
    		break;
		case 12:printf(&quot;December&quot;);
		break;
		default:printf(&quot;Data error&quot;);
		break;
	&#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="循环语句"><a class="markdownIt-Anchor" href="#循环语句"></a> 循环语句</h2>
<blockquote>
<p>功能为判断条件，只要为真(非0)则执行循环语句，并再次求该表达式的值</p>
<p>这一循环过程一直进行下去，直到条件为假(0)退出循环，随后执行语句后面的部分</p>
<p>分三种结构：for, while, do-while 三种结构均可嵌套使用，并且一般条件下可以相互替换</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">for语句
    基本格式：for(表达式1;表达式2;表达式3)
    循环体;
    等价于： 表达式1          特别的，当while或for循环语句中包含continue语句时，上述二者之间不一定等价
    while(表达式2)&#123;
	语句;表达式3;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>其中，表达式1为进入循环体之前运算的表达式在整个语句块中只执行一次

表达式2为循环的判断条件，循环体每执行完一次后重新判断表达式2，决定是否进入下次循环

表达式3为循环体执行完成后进行的运算，表达式3完成后一次循环结束

从语法角度看，for循环语句的3个组成部分都是表达式

最常见情况是，表达式1与表达式3是赋值表达式或函数调用，表达式2是关系表达式

这三个组成部分中任何部分都可以省略，但分号必须保留

如果for语句中省略表达式1与表达式3，就退化为while循环语句

如果省略测试条件即表达式2，则认为其值永远是真值

因此，如:for(;;);是无限循环语句，必须借助其他手段(如break语句或return语句)才能终止执行

例: 求n的1到5次方
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">int main()
&#123;
    float n,i,result&#x3D;1;
    scanf(&quot;%f&quot;,&amp;n);
    for (i&#x3D;0;i&lt;&#x3D;4;i++)
    &#123;
    	result*&#x3D;n;
    	printf(&quot;%.03f\n&quot;,result);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>使用for语句有很多优点：

可以在表达式中使用逗号运算符，增加数据处理和判断的灵活性
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例：for(i&#x3D;0,j&#x3D;100;j-i&gt;&#x3D;0;i++,j-&#x3D;5)
    允许在循环体内改变循环变量的值
例： int sum&#x3D;0,number
    for(count&#x3D;1;count&lt;&#x3D;100;count++)
    &#123;
	scanf(&quot;%d&quot;, number);
	sum+&#x3D;number;
	if (sum&gt;&#x3D;300)
		count&#x3D;100;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>表达式，循环体均可缺省
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">省略表达式3 例:for(i&#x3D;0;i!&#x3D;100;)    实际上，由于表达式3在循环体之后进行，因此均可以把表达式3放到循环体最后
    		scanf(&quot;%d&quot;,i);
省略表达式1 例:i&#x3D;(a+b)&#x2F;2
	for(;i&gt;20;i++);          同理，表达式1在循环开始前运算，因此完全可以将其放到整个循环语句之前
省略所有表达式 例:for (;;)循环体     甚至可以直接在循环体中设置判断循环的条件和跳出循环的手段，将三个表达式完全省略；如果没相关的条件则形成死循环
省略循环体 例: for(i&#x3D;1,j&#x3D;-1;i&lt;&#x3D;1000;i++,j*&#x3D;j); 表达式3实际在相当于起到循环体的作用，循环体为一个空语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">for循环嵌套示例:输出九九乘法表
int main()
&#123;
    int row,line;
    for(row&#x3D;1;row&lt;&#x3D;9;row++)
    &#123;
    	for(line&#x3D;1;line&lt;&#x3D;9;line++)printf(&quot;%d*%d&#x3D;%d\t&quot;, row,line,row*line);
	printf(&quot;\n&quot;);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="while-do-while-语句"><a class="markdownIt-Anchor" href="#while-do-while-语句"></a> while, do-while 语句</h3>
<blockquote>
<p>通常for语句用于可以预知循环次数，若不能的话也可以考虑使用while, do-while语句</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">while语句基本格式:    while(表达式)循环体;
do-while语句基本格式:   do&#123;                  do while语句特殊性在于先执行循环体，再判断条件
			循环体;             至少需要执行循环体一次，典型的直到型循环
		      &#125;while (表达式)       除了条件测试的语义不同外，do-while循环与Pascal语言的repeat-until语句等价
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>因此循环可分为:当型循环(for循环、while循环)和直到型循环(do while循环)

两种循环区别即在于先判断还是先执行一次循环体再判断

经验表明，do-while循环比while循环和for循环用得少得多
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:读入字符并回显，直到读入&#39;*&#39;为止
int main()          输入abcde?f*  输出结果:abcde?f*
&#123;                   输入abcde?f** 输出结果:abcde?f*
    int c;
    do&#123;
        c&#x3D;getchar();
	putchar(c);
    &#125;while (c!&#x3D;&#39;*&#39;);
&#125;
例:itoa函数，将数字n转换为字符串并保存到s中
char*itoa(int n,char*s)&#123;
    int i&#x3D;0,sign;
    if((sign&#x3D;n)&lt;0)n&#x3D;-n;
    do&#123;                         这里使用do-while语句会方便一些，因为当n&lt;10时也可以将该字符保存
	s[i++]&#x3D;n%10+&#39;0&#39;         do-while语句中只有一条语句，但仍然建议用花括号将语句括起来
    &#125;while(n&#x2F;&#x3D;10);              从而避免程序阅读者误以为while循环是个无限循环
    if(sign&lt;0)s[i++]&#x3D;&#39;-&#39;;
    s[i]&#x3D;&#39;\0&#39;;
    return reverse(s);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>一般在设计程序时到底选用while循环语句还是for循环语句，主要取决于个人偏好

如:while((c=getcahr()==' '||c=='\n'||c=='\t'))中没有初始化或重新初始化的操作，因此使用while循环语句更自然些

如果语句中需要执行简单的初始化或变量递增，使用for语句更合适一些，它将循环控制语句集中放在循环的开头，使结构更紧凑、清晰

如:for(i=0;i&lt;n;i++)是c处理数组前n个元素的一种习惯性写法，类似于Fortran语言中的DO循环或Pascal语言中的for循环

这种类比也不完全准确，因为在c中，for循环语句的循环变量和上限在循环体内可以修改，并且当循环因某种原因终止后循环变量i的值仍保留

并且由于for语句的各组成部分可以是任意表达式，所以for语句并不限于通过算术级数进行循环控制

但是尽管如此，牵强地把一些无关的计算放到for语句的初始化和变量递增部分是一种不好的程序设计风格，放到循环控制部分更合适

for循环将循环控制部分集中在一起，对多重嵌套循环优势更为明显
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:Shell排序算法
   Shell排序算法是D.L.Shell于1959年发明的，其基本思想是：
   先比较距离远的元素，而不是像简单交换排序算法那样先比较相邻的元素
   可以快速减少大量的无序情况，从而减轻后续的工作。被比较的元素之间的距离逐渐减小，直到减小为1，排序变成相邻元素的互换
    void shellsort(int* v,int n)
    &#123;
        int n,gap,i,j,tmp;
        for(gap&#x3D;n&#x2F;2;gap&gt;0;gap&#x2F;&#x3D;2)for(i&#x3D;gap;i&lt;n;i++)for(j&#x3D;i-gap;v[j]&gt;v[j+gap]&amp;&amp;j&gt;&#x3D;0;j-&#x3D;gap)
        &#123;
            tmp&#x3D;v[j];
            v[j]&#x3D;v[j+gap];
            v[j+gap]&#x3D;tmp;
        &#125;
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="break-continue-goto语句"><a class="markdownIt-Anchor" href="#break-continue-goto语句"></a> break, continue, goto语句</h3>
<blockquote>
<p>不通过循环头部或尾部的条件测试而跳出循环，有时是很方便的</p>
</blockquote>
<h4 id="break语句"><a class="markdownIt-Anchor" href="#break语句"></a> break语句</h4>
<pre><code>break语句能使程序从switch语句或最内层循环中立即跳出

在循环语句中可以提前退出循环
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:while(1)&#123;
	scanf(&quot;%c&quot;,&amp;ch);
	if(ch&#x3D;&#39;s&#39;)break;
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="continue语句"><a class="markdownIt-Anchor" href="#continue语句"></a> continue语句</h4>
<pre><code>在一次循环当中，跳过continue余下语句，直接进入下次循环操作

continue语句与break语句是相关联的，但它没有break语句常用

continue用于使for、while或do-while语句开始下一次循环的执行：

在while、do-while语句中，continue语句的执行意味着立即执行测试部分

在for循环中，则意味着使控制转移到递增循环变量部分

continue只用于循环语句，不用于switch语句，因而某个循环中包含switch语句中的continue语句时，将导致进入下一次循环

当循环后面的部分比较复杂时，常常会用到continue语句；如果不用continue，则可能需要将测试颠倒过来或者缩进另一层循环，使循环嵌套更深
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">例:for(i&#x3D;0;i&lt;n;i++)
   &#123;
       scanf(&quot;%f&quot;,&amp;a);
       if(a&lt;0)continue;
       printf(&quot;%f&quot;,a);
   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="goto语句"><a class="markdownIt-Anchor" href="#goto语句"></a> goto语句</h4>
<pre><code>无条件转移语句，直接从goto语句转移到标号所指语句

c提供了可随意滥用的goto语句以及标记跳转位置的标号

从理论上讲，goto语句是没有必要的，实践中不使用goto语句也可以很容易地写出代码
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">基本格式:goto 标号;               goto语句通常不用，因为它将使程序层次不清，且不易读，但在多层嵌套退出时，用goto语句则比较合理
        标号: 语句;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre><code>标号的命名同变量命名形式相同，标号后面要紧跟一个冒号

标号可以位于对应的goto语句所在函数的任何语句前面，标号的作用域是整个函数

某些场合下goto语句用得到，最常见的用法是终止程序在某些深度嵌套的结构中的处理，如一次跳出两层或多层循环
</code></pre>
<pre class="line-numbers language-none"><code class="language-none">如:for(…)
      for(…)
      &#123;
         …
         if(disaster)
         goto error;
      &#125;
      …
      error:处理错误情况<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre><code>这种情况下，如果错误处理的代码很重要，并且错误可能出现在多个地方，使用goto语句比较方便

所有使用了goto语句的程序代码都能改写成不带goto语句的程序，但可能会增加一些额外的重复测试或变量

但是在大多数情况下，使用goto语句的程序段比不使用goto语句的程序段要难以理解和维护，要尽可能少使用或避免使用goto语句
</code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言知识点总结</title>
    <url>/posts/f56cfbc8bd9c</url>
    <content><![CDATA[<h1 id="词法规则"><a class="markdownIt-Anchor" href="#词法规则"></a> 词法规则</h1>
<p>程序由存储在文件中的一个或多个翻译单元(translation unit)组成</p>
<p>程序的翻译分几个阶段完成，翻译的第一阶段完成低级的词法转换，执行以字符#开头的行中的指令，并进行宏定义和宏扩展</p>
<p>在预处理完成后，程序被归约为一个记号序列</p>
<p><strong><code>&lt;!-- more --&gt;</code></strong></p>
<h1 id="记号"><a class="markdownIt-Anchor" href="#记号"></a> 记号</h1>
<p>c中共有6类记号:标识符、关键字、常量、字符串字面值、运算符和其他分隔符</p>
<p>空格符、横向制表符、纵向制表符、换行符、换页符和注释(统称空白符)在程序中仅用来分隔记号，因此将被忽略</p>
<p>相邻标识符、关键字和常量之间需要用空白符来分隔(但标识符、常量、字符串字面值等和运算符直接相连是很常见的)</p>
<p>如果到某一字符为止的输入流被分隔成若干记号，那么下一个记号就是后续字符序列中可能构成记号的最长字符串</p>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p>‘/’+’<em>’……’</em>’+’/'表示c语言中的注释符号，可以多行，编译程序时完全忽略这部分内容</p>
<p>c99以上标准中的注释符号为单边的//，单行注释</p>
<p>注释出现的位置：文件头，函数，重点语句块前</p>
<p>注释不能够嵌套，也不能出现在字符串字面值、字符字面值中</p>
<p>如main，printf等统称为系统预定义标识符，用户自定义标识符包括变量，常量，函数名等</p>
<h3 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h3>
<p>标识符也称为名字，可以指代多种实体：函数、结构标记、联合标记和枚举标记；结构成员或联合成员；枚举常量；类型定义名；标号及对象等</p>
<p>标识符还具有一个作用域和一个连接，作用域即程序中可以访问此名字的区域，连接决定另一作用域中的同一个名字是否指向同一个对象或函数</p>
<p>标识符(包括常量、变量的名字等)是由字母和数字组成的序列，但其第一个字符必须为字母</p>
<p>下划线’_'被看作字母，通常用于命名较长的标识符名，提高其可读性</p>
<p>由于库例程(程序的意思，某个系统对外提供的功能接口或服务的集合)名通常以下划线开头，因此自定义标识符不应以下划线开头</p>
<p>区分大写小写字母，传统c程序中变量名使用小写字母，符号常量名全部使用大写字母</p>
<p>标识符可以为任意长度，对内部(内部-局部，外部-全局)标识符而言，编译器至少能识别前31个字符，在某些实现中可能更多，有效的字符数可能更多</p>
<p>内部标识符包括预处理器的宏名和其他所有所有没有外部链接的名字，带有外部链接的标识符限制更严格一些</p>
<p>如对函数和外部变量名而言，编译器能识别的字符数小于31个，由于这两种变量会被汇编程序和加载程序等使用，名字可能在这些其他地方被用掉了</p>
<p>ANSI标准中对外部标识符仅保证能识别前6个字符，并且不区分大小写（以上为c89标准，在c99标准中内部名识别63个，外部名识别31个）</p>
<p>标识符应尽量从字面上表达变量的用途，以防止发生混淆</p>
<p>内部变量一般使用较短变量名(尤其是循环控制变量)，而外部变量尽量使用较长名字    */</p>
<h3 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h3>
<p>如int，return等标识符被保留为关键字(或称系统保留字)，不能用于其他用途，并且自定义标识符不能与关键字重名</p>
<p>C语言关键字列表</p>
<p>auto,enum,restrict,unsigned,break,extern,</p>
<p>return,void,case,float,short,Volatile,</p>
<p>char,for,signed,while,const,goto,sizeof,_Bool,continue,if,</p>
<p>static,_Complex,default,inline,struct,_Imaginary,do,int,switch,</p>
<p>double,long,typedef,else,register,union</p>
<p>某些实现还将fortran和asm保留为关键字</p>
<p>关键字const、signed、volatile是在ANSI C中加入的，enum和void是在K&amp;R的第1版书后加入的，这些关键字现在都已被广泛应用</p>
<p>entry曾经被保留为关键字但从未被使用过，现已被剔除</p>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<p>c语言数据表示方式：常量(常数、符号常量、常量表达式等)，变量（定义变量必须先声明数据类型（变量初始化））</p>
<p>定义不同数据类型的作用：合理分配地址空间，不同数据类型具有不同存储长度，取值范围，允许的操作</p>
<p>数据类型包括：</p>
<p>基本类型             整型，字符型，单/双精度浮点型，空值型</p>
<p>构造(派生)类型    数组，结构，联合，枚举，指针</p>
<p>可以被解释为数字的类型统称为算术类型</p>
<p>由于char类型、各种大小的int类型(无论是否带符号)以及枚举类型都统称为整型类型(integral type)</p>
<p>类型float、double、long double统称为浮点类型(floating type)</p>
<p>此外void类型说明一个值的空集合，它常被用来说明不返回任何值的函数的类型</p>
<p>除基本类型外，还可以通过以下几种方法构造派生类型，从概念上讲派生类型可以有无限多个：</p>
<p>给定类型对象的数组、返回给定类型对象的函数、指向给定类型对象的指针、包含一系列不同类型对象的结构、可以包含多个不同类型对象中任意一个对象的联合</p>
<p>一般情况下构造对象的方法可以递归使用</p>
<p>对象的类型可以通过附加的类型限定符进行限定，声明为const的对象表明此对象的值不可以修改；声明为volatile的对象表明它具有与优化相关的特殊属性</p>
<p>限定符既不影响对象取值的范围，也不影响其算术属性</p>
<h3 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h3>
<p>int类型通常代表宿主机器体系架构决定的整数的自然长度，在16位编译器下是2字节，32/64位一般是4字节</p>
<p>long,short为限定符，通常用于限定整型(long也可以修饰long，double等)以提供满足需要的不同长度整型数，除非特别说明int类型都表示带符号数</p>
<p>short类型通常为16位(二进制表示)，int既可以16位又可以32位，long至少为32位，long long为64位</p>
<p>当整数太大时，int或short类型可以当作long型处理</p>
<p>(较长的整数至少要占有与较短整数一样的存储空间，但是具体是实现可以使得一般整型与短整型、长整型具有同样的大小)</p>
<p>枚举是一个具有整型值的特殊类型，与每个枚举相关联的是一个命名常量的集合，枚举类型类似于整型</p>
<p>如果每个特定枚举类型的对象赋值不是其常量中的一个或者赋值不是同一个类型的表达式，则编译器通常会产生警告信息</p>
<p>long double表示高精度浮点型，同整型一样，浮点型长度也取决于具体实现</p>
<p>float,double,long double类型可表示相同长度，也可表示不同长度</p>
<p>可以存储在带符号对象中的非负值的集合是可以存储在相应的无符号对象中的值的子集，并且这两个集合的重叠部分的表示是相同的</p>
<p>unsigned,signed可用于限定任意char类型或整型，整型默认是signed(有正负)</p>
<p>unsigned类型的值总是&gt;0(如:unsigned int a=-1;printf(&quot;%d&quot;,a&gt;0?1:0);输出为1)</p>
<p>unsigned类型遵守模2^n定律(相当于结果右移n位)，n为该类型占用的bit位，保证对无符号数的运算永远不会溢出</p>
<p>数据类型取值范围排序：long double &gt; double &gt; float &gt; long long &gt; long &gt; int &gt; short&gt; char</p>
<p>同类型中unsigned &gt; signed</p>
<p>如：char类型占用1字节(8位)，则unsigned char取值范围0～255，signed char取值范围-128～127(二进制补码)</p>
<p>对char类型而言取值范围和是否带符号取决于具体机器，但可打印的字符总是正值，声明为char的对象要大到足以存储执行字符集中的任何字符</p>
<p>如果字符集中的某个字符存储在一个char类型对象中则该对象的值等于字符的整型编码值并且是非负值</p>
<p>(以unsigned char声明的无符号字符与普通字符占用同样大小的空间，以signed char显式声明的带符号字符与普通字符也占用同样大小的空间)</p>
<p>声明时int可以省略只保留限定符名short,long,unsigned,signed等</p>
<p>单精度浮点数(float)、双精度浮点数(double)、多精度浮点数(long double)中任何类型都可能是同义的，但精度从前到后是递增的</p>
<p>(老式c语言编译器支持long float，但在c89中就已经被double替换了)</p>
<p>有关类型长度定义的符号常量及其他与编译器和机器有关的属性见标准头文件&lt;limits.h&gt;、&lt;float.h&gt;</p>
<h3 id="void对象"><a class="markdownIt-Anchor" href="#void对象"></a> void对象</h3>
<p>void对象的(不存在的)值不能够以任何方式使用，也不能够被显式或隐式地转换为任一非空类型</p>
<p>因为空(void)表达式表示一个不存在的值，只可以用在不需要值的地方，例如作为一个表达式语句或作为逗号运算符的左操作数(注意左操作数和左值的区别)</p>
<p>如:void func(void)强调函数没有任何参数，(void)0,(void)1,(void*)0,(void*)0x100000(常见于函数参数)</p>
<p>可以通过强制类型转换将表达式转换为void类型，例如在表达式语句中一个空的强制类型转换将丢掉函数调用的返回值，如:(void)func();</p>
<p>指向任何对象的指针都可以转换为void*类型，且不会丢失信息，如果将结果再转换为初始指针类型，则可以恢复初始指针</p>
<p>指针可以被赋值为void<em>类型的指针，也可以赋值给void</em>类型的指针，并可以与void*类型指针进行比较</p>
<p>(ANSI标准特别允许void*类型指针与其他对象指针在赋值表达式和关系表达式中混用，关键是不需要进行强制类型转换)</p>
<h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1>
<p>程序中一般不直接使用常数，可定义宏常量(c中一般所指的常数)或const常量</p>
<p>常量区别于变量的最大的特点是常量不可修改</p>
<p>宏常量定义格式(一般定义在文件头预处理部分) 例：#define PI 3.1415926，宏定义中如果是表达式则一般用括号括起来，否则极容易出错</p>
<p>const定义方法与变量相同，具有数据类型，某些环境下可直接对其进行调试</p>
<p>任何变量的声明都可以使用const限定符修饰，从而指定变量不可修改，</p>
<p>例：const char msg[]=“warning:”;int len(const char[]);</p>
<p>在c的环境下，const是c99新增，并且c99只认定const变量为只读数据不可修改的变量，不是真正的常量，因此不能用于定义数组长度等用途</p>
<h3 id="常量类型"><a class="markdownIt-Anchor" href="#常量类型"></a> 常量类型：</h3>
<p>常量有多种类型，每种类型的常量都有一个数据类型</p>
<p>数值型常量：整型常量，浮点型常量，枚举常量</p>
<p>字符型常量：字符常量，字符串常量，转义字符，符号常量</p>
<p>整型常量分八进制，十进制，十六进制三种数制</p>
<p>浮点型常量为实数在计算机中的表示形式，十进制表示，分小数形式或指数形式(如3.14e-3为3.14*10^-3)</p>
<p>整型常量由一串数字组成，并且可以带有不同的前缀和后缀代表不同的含义：</p>
<p>带有0前缀的常量表示八进制形式;前缀为0x或0X的常量表示十六进制形式，如:十进制31可写成八进制037或十六进制0x1F</p>
<p>带有l、L后缀的常量表示long或long long或double型常量;u,U表示无符号常量;ul,UL表示unsigned long 如:3567l;56u;58924ul</p>
<p>常量可以同时拥有前缀和后缀，如:0xFul</p>
<p>浮点型常量由整数部分、小数点、小数部分、一个e或E、一个可选的带符号整型类型的指数和一个可选的表示类型的后缀组成(即f,F,l或L之一)</p>
<p>整数和小数部分均由数组序列组成，可以没有整数部分或小数部分(但不能两者都没有)，同理也可以没有小数点或e和指数部分</p>
<p>浮点常量的类型由后缀确定，F或f后缀表示它是float类型，l或L后缀表明它是long double类型，没有后缀则默认是double类型</p>
<p>字符常量和字符串常量也可以称为单字符常量和多字符常量，字符串常量也称为字符串字面值(string literal)</p>
<p>字符常量为单引号括起的一个字符，按其对应的默认机器字符集(一般为ASCII)中的数值存储，占一个字节，可以像整数一样参与运算</p>
<p>字符常量不包括双引号字符和换行符，可以使用转义字符序列来表示这些字符以及其他一些字符</p>
<p>字符串常量为双引号括起的多个字符，例:China 存储格式为67 104 105 112 97 \0</p>
<p>字符串中使用&quot;表示双引号字符，如：“I am a “string””</p>
<p>编译时可以将多个字符串常量连接起来，如：“hello,”&quot; world&quot;等价于&quot;hello, world&quot;，这种连接未将较长的字符串分散开来提供了支持</p>
<p>如果程序试图修改字符串字面值，则行为是未定义的</p>
<p>从技术角度看，字符串常量就是字符数组，存储时加串结束标识符NULL或’\0’，因此字符串物理存储单元数比括在双引号中的字符数多一个</p>
<p>字符串存储类为static，使用给定的字符进行初始化，对相同的字符串字面值是否进行区分取决于具体实现</p>
<p>c中对字符串的长度没有限制，但程序必须扫描整个字符串后才能确定字符串的长度</p>
<p>标准库函数strlen()可返回字符串的长度，但不包括’\0’，标准头文件string.h中声明了strlen()和其他字符串函数</p>
<p>字符常量不同于仅包含一个字符的字符串，如:‘x’和&quot;x&quot;，前者是一个整数，后者是字符和’\0’组成的字符数组</p>
<p>枚举常量是一个常量整型值的列表，如:enum escapes{NO,YES};</p>
<p>在没有显示说明的情况下，enum类型中第一个枚举值为0，第二个为1，以此类推</p>
<p>如果只指定了部分枚举成员的值，则未指定成员的值依照最后一个指定值向后递增</p>
<p>如:enum months{JAN=1,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC}，其中FEB=2，MAR=3，以此类推</p>
<p>枚举为建立常量值与名字之间的关联提供了一种便利的方式，相对于宏定义其优势在于常量值可以自动生成</p>
<p>可以生成enum类型的变量，编译器会进行类型检查，但不检查这种类型的变量中存储的值是否有效(不会检查值是否属于定义的枚举常量所代表的值)</p>
<p>例：enum color{red,yellow,blue}mycolor=5;（在c中可以通过编译，但是c++不可以）</p>
<h3 id="常量表达式"><a class="markdownIt-Anchor" href="#常量表达式"></a> 常量表达式</h3>
<p>常量定义为标识符即为符号常量（如宏常量）</p>
<p>常量表达式是仅仅包含常量的表达式，这种表达式在编译时求值而不在运行时求值</p>
<p>可以出现在常量可以出现的任何位置，例：</p>
<p>#define MAXLINE 1000</p>
<p>#define LEAP 1</p>
<p>char line[MAXLINE+1];</p>
<p>int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31]</p>
<h1 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h1>
<p>转义字符为字符的特殊形式，表示不可打印或特殊用途</p>
<p>ANSI C中全部的转义字符序列为：</p>
<p>\0 空字符(null)，通常用’\0’形式代替0，以强调某些表达式的字符属性，但其值为空</p>
<p>\a 响铃符\ 反斜杠</p>
<p>\b 回退符? 问号</p>
<p>\f 换页符’ 单引号</p>
<p>\n 换行符&quot; 双引号</p>
<p>\r 回车符     \000 转义八进制数(0开头，数字范围0-7)，表示ASCII码等于该值十进制形式的字符</p>
<p>\t 横向制表符  \xhh 转义十六进制数(0x开头，数字0-9,a-f,A-F)，表示ASCII码等于该值十进制形式的字符</p>
<p>\v 纵向制表符</p>
<p>例：</p>
<p>#define VTAB ‘\013’ 或  #define VTAB ‘\xb’  表示将VTAB替换为ASCII纵向制表符(\v的ASCII码为11)</p>
<p>#define BELL ‘\007’ 或  #define BELL ‘\x7’  表示将BELL替换为ASCII响铃符(\a的ASCII码为7)</p>
<p>转义数字的位数没有限制，但如果字符值超过最大字符值或者字符值不在以上指定的转移字符序列中，则该行为是未定义的</p>
<p>如果转义数字的具体实现中将类型char看作是带符号的，则会对字符值进行符号扩展，类似于强制转换成char类型</p>
<h3 id="扩展字符集"><a class="markdownIt-Anchor" href="#扩展字符集"></a> 扩展字符集</h3>
<p>在c的某些实现中，还有一个扩展的字符集，不能用char类型来表示</p>
<p>扩展集中的常量要以一个前导符L开头(例如L’x’)，称为宽字符常量，这种常量的类型为wchar_t</p>
<p>w_char_t是一种整型类型，定义在头文件&lt;stddef.h&gt;中</p>
<p>与通常的字符常量一样，宽字符常量可以使用八进制或十六进制转移字符序列</p>
<p>但如果值超过wchar_t可以表示的范围则结果是未定义的</p>
<p>与宽字符常量一样，扩展字符集中的字符串字面值也以前导符L表示，如L&quot;…&quot;，宽字符常量字面值的类型为&quot;wchar_t类型的数组&quot;</p>
<p>将普通字符串字面值和宽字符字符串字面值进行连接的行为是未定义的</p>
<p>通常情况下美国和西欧所用的字符集可以用char类型来编码，增加wchar_t的主要目的是为了表示亚洲的语言</p>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<p>变量为程序执行时值可以变动的量，需先定义后使用，变量有时也称为对象，表示一个存储位置</p>
<p>存放变量的地址空间中首单元地址为变量地址，存放内容为变量值</p>
<p>对变量的解释依赖于两个主要属性：存储类和类型，存储类决定了与该标识对象相关联的存储区域生存期，类型决定了标识符对象中值的含义</p>
<h3 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h3>
<p>所有变量必须先声明后使用，尽管某些变量可以通过上下文进行隐式声明</p>
<p>注意，如果只定义指针，没有初始化时系统是不会给它分配内存的！！！</p>
<p>一个声明指定一种变量类型，后面跟的变量表可以包含一个或多个该类型的变量，例：</p>
<p>int lower,upper,step=MAX+1;</p>
<p>char c,line[1000];</p>
<p>也可以等价地写成多个变量拆开声明的形式：</p>
<p>int lower;                    这种形式虽然需要占用更多的篇幅，但便于向声明语句添加注释和进行修改</p>
<p>int upper;</p>
<p>int step=MAX+1;       声明同时可以对变量进行初始化，右边的表达式充当初始化表达式</p>
<p>char c;</p>
<p>char line[1000];</p>
<p>如果变量不是自动变量(动态局部变量),则只能进行一次初始化操作</p>
<p>从概念上来说是在程序开始运行之前，并且初始化表达式必须为常量表达式</p>
<p>对显式初始化的自动变量，每次进入函数或程序块时都将被自动初始化一次，初始化表达式可以是任何表达式</p>
<p>默认情况下，外部变量与静态变量被初始化为0，未经显式初始化的自动变量值为无效值</p>
<h3 id="变量初始化规则"><a class="markdownIt-Anchor" href="#变量初始化规则"></a> 变量初始化规则</h3>
<p>不进行显式初始化的情况下，外部变量和静态变量都将被自动初始化为0，自动变量和寄存器变量的初值则是没有意义的随机值(没有初始化过程)。定义标量变量时(只能存放单个数值的变量)，可以在变量名后紧跟一个等号和一个表达式来初始化变量，如：</p>
<blockquote>
<p>int x=1;char squote=’\’;long day=1000L*60L*60L*24L;</p>
</blockquote>
<p>定义数组时也分显式初始化和隐式初始化，显式初始化数组元素如：</p>
<blockquote>
<p>const int array_size=3;int array[array_size]={1,2,3};</p>
</blockquote>
<p>若无显式初始化，则函数体外定义的内置数组，元素均为0；函数体内定义的初始数组，无初始化(随机数填充)，这是隐式初始化。</p>
<p>对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次。从概念上讲是程序开始执行前进行初始化(实际还是与机器实现有关)，对于自动变量与寄存器变量来说，每次进入函数或程序块时都将进行初始化，初始化表达式可以不是常量表达式，表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用，如：</p>
<blockquote>
<p>int binsearch(int x,int v[],int n){int low=0,int high=n-1,int mid=(low+high)/2;}</p>
</blockquote>
<p>实际上自动变量的初始化等效于先声明后赋值，究竟采用哪种形式看个人的习惯。</p>
<h3 id="存储类型"><a class="markdownIt-Anchor" href="#存储类型"></a> 存储类型</h3>
<p>存储类分为两类：自动存储类(automatic)和静态存储类(static)</p>
<p>声明对象时使用的一些关键词和声明上下文共同决定了对象的存储类，自动存储类对象对于一个程序块来说是局部的，在退出程序块时该对象消失</p>
<p>如果没有使用存储类说明符或者如果使用了auto限定符，则程序块中的声明生成的都是自动存储类对象</p>
<p>声明为register的对象也是自动存储类的对象，并且将被存储在机器的快速寄存器中(如果可能的话)</p>
<p>静态对象可以是某个程序块的局部对象，也可以是所有程序块的外部对象，无论是哪一种情况在退出和再进入函数或程序块时其值保持不变</p>
<p>在一个程序块(包括提供函数代码的程序块)内，静态对象用关键字static声明，在所程序块外部声明且与函数定义在同一级的对象总是静态的</p>
<p>可以通过static关键字将对象声明为某个特定翻译单元的局部对象，这种类型的对象将具有内部连接</p>
<p>当省略显式的存储类或通过关键字extern进行声明时(在程序块外部)，对象对整个程序来说是全局可访问的，并且具有外部连接</p>
<h3 id="对象和左值"><a class="markdownIt-Anchor" href="#对象和左值"></a> 对象和左值</h3>
<p>对象是一个命名的存储区域，左值(lvalue)是引用某个对象的表达式，具有合适类型与存储类的标识符便是左值表达式的一个明显的例子</p>
<p>某些运算符可以产生左值，例如:如果E是一个指针类型的表达式，*E是一个左值表达式，它引用由E指向的对象</p>
<p>名字“左值”来源于赋值表达式E1=E2，其中左操作数E1必须是一个左值表达式</p>
<p>对每个运算符的讨论需要说明此运算符是否需要一个左值操作数以及它是否产生一个左值</p>
<h3 id="初等表达式"><a class="markdownIt-Anchor" href="#初等表达式"></a> 初等表达式</h3>
<p>初等表达式是标识符、常量、字符串或带括号的表达式</p>
<p>一个标识符只要是按下面所讨论的方式适当说明的就是初等表达式，其类型由说明指定:</p>
<p>如果一个标识符指定一个对象且其类型是算术、结构、联合或指针类型，那么它是一个左值；</p>
<p>一个常量是一个初等表达式，其类型依赖于它的形式；</p>
<p>一个字符串字面值是一个初等表达式，它的初始类型是char数组类型(对于宽字符字符串，则为wchar_t数组类型)，</p>
<p>通常被修改为指向char类型(wchar_t类型)的指针，从而结果是指向字符串中第一个字符的指针；</p>
<p>用括号括起来的表达式是一个初等表达式，它的类型和值与无括号的表达式一致，此表达式是否是左值不受括号的影响</p>
<h3 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式"></a> 后缀表达式</h3>
<p>后缀表达式中的运算符遵循从左到右的结合规则。</p>
<p>后缀表达式的形式主要包括:</p>
<p>1.初等表达式</p>
<p>2.后缀表达式[表达式] 即数组引用形式</p>
<p>带下标的数组由一个后缀表达式后跟一个括在方括号中的表达式来表示。方括号前的后缀表达式的类型必须为“指向T类型的指针”，</p>
<p>其中T为某种类型，方括号中表达式的类型必须为整型，结果得到的下标表达式的类型为T</p>
<p>表达式E1[E2]在定义上等同于*((E1)+(E2))</p>
<p>3.后缀表达式(变元表达式表opt)</p>
<p>函数调用由一个后缀表达式(称为函数标志符)后跟由圆括号括起来的包含一个可能为空的、由逗号分隔的赋值表达式列表组成，这些表达式就是函数的变元</p>
<p>如果后缀表达式包含一个在当前作用域中不存在的标识符，则此标识符将被隐式地声明，等同于在执行此函数调用的最内层程序块中包含下列声明:</p>
<p>extern int 标识符();  该后缀表达式(在可能的隐式声明和指针生成后)的类型必须为“指向返回T类型的函数的指针”</p>
<p>其中T为某种类型，且函数调用的值的类型为T</p>
<p>(旧语法中在通过指向函数的指针来调用此函数时必须有一个显式的*运算符，ANSI C标准允许现存的一些编泽程序用同样的语法来进行函数调用和</p>
<p>通过指向函数的指针来进行函数调用，旧的语法仍然可用)</p>
<p>变元表达式表形式:</p>
<p>赋值表达式   (注意是编译层次上的赋值表达式即可)</p>
<p>变元表达式表,赋值表达式</p>
<p>术语变元用来表示传递给函数调用的表达式，而术语参数则用来表示由函数定义或函数说明所接收的输入对象(或其标识符)，</p>
<p>通常也可用术语“实际变元”和“形式参数”来区分它们</p>
<p>在准备调用函数时，要对它的每个变元进行复制，所有变元传递严格地按值进行</p>
<p>函数可能会改变其参数对象的值(即变元表达式值的拷贝)，这个改变不会影响变元的值，但是可以将指针作为变元传递，以使函数可以改变指针所指向的对象的值</p>
<p>函数可以用两种方式说明；在新的方式中，形式参数的类型是作为函数类型的一部分显式指定的，这种说明称为函数原型，而在旧的方式中，参数类型没有说明</p>
<p>在函数调用的作用域中，如果函数是以旧方式声明的则按以下方式对每个实际变元进行缺省变元提升:</p>
<p>对每个整型变元进行整型提升；</p>
<p>将每个float类型的变元转换为double类型；</p>
<p>如果调用时变元的数目与函数定义中参数的数目不等，或者某个变元类型提升后与相应的参数类型不一致，那么函数调用的结果是未定义的</p>
<p>其中类型一致性依赖于函数定义是以新方式进行的还是以旧方式进行的:</p>
<p>如果定义是旧方式的，那么类型一致性检查将在提升过的函数调用的变元类型和提升过的参数类型之间进行；</p>
<p>如果定义是新方式的，那么提升过的实际变元类型必须与没有提升过的形式参数本身的类型一致；</p>
<p>如果在函数调用的作用域中函数说明是以新方式进行的，那么变元将被转换为函数原型中的相应参数类型，就像是赋值一样</p>
<p>变元数目必须与显式说明的参数数目相同，除非函数说明的参数表以省略号(,…)结束，在这种情况下变元的数目必须等于或超过参数的数目；</p>
<p>其后无显式指定类型的参数与之对应的变元要进行缺省变元提升</p>
<p>如果函数定义是以旧方式进行的，那么在调用中可见的原型中的每个变元类型必须与相应函数定义中的参数类型一致(函数定义中的参数类型已进行过变元提升)</p>
<p>(这些规则特别复杂，因为必须要考虑到新旧方式函数的混合使用，应尽可能避免新旧方式混合使用)</p>
<p>变元的求值次序没有指定，不同的编译器的实现方式各不相同，但是在进入函数前变元和函数命名符是完全求值的，包括所有的副作用</p>
<p>对任何函数都可以进行递归调用</p>
<p>4.后缀表达式.标识符</p>
<p>5.后缀表达式-&gt;标识符</p>
<p>6.后缀表达式++ / –</p>
<h1 id="c语言运算符表"><a class="markdownIt-Anchor" href="#c语言运算符表"></a> c语言运算符表</h1>
<p>运算符按照优先级大小由上向下排列，在同一行的运算符具有相同优先级。第二行是所有的一元运算符。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>名称或含义</th>
<th>使用形式</th>
<th>结合方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[]</td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>圆括号</td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-&gt;</td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>负号运算符</td>
<td>-表达式</td>
<td>右到左</td>
<td>单目运算符</td>
</tr>
<tr>
<td>(类型)</td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>++</td>
<td>自增运算符</td>
<td><ins>变量名/变量名</ins></td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>自减运算符</td>
<td>–变量名/变量名–</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>/</td>
<td>除</td>
<td>表达式/表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>表达式*表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>余数（取模）</td>
<td>整型表达式/整型表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>+</td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>表达式-表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;</td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>&gt;</td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>表达式&gt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>表达式&lt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>表达式&lt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>==</td>
<td>等于</td>
<td>表达式==表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>表达式!= 表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td></td>
<td>按位或</td>
<td>表达式</td>
<td>表达式</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>12</td>
<td></td>
<td></td>
<td></td>
<td>逻辑或</td>
<td>表达式</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>条件运算符</td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
<td>三目运算符</td>
</tr>
<tr>
<td>14</td>
<td>=</td>
<td>赋值运算符</td>
<td>变量=表达式</td>
<td>右到左</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>变量/=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>变量*=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td>取模后赋值</td>
<td>变量%=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
<td>变量+=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>变量-=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
<td>变量&lt;&lt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
<td>变量&gt;&gt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后赋值</td>
<td>变量&amp;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后赋值</td>
<td>变量^=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>=</td>
<td>按位或后赋值</td>
<td>变量</td>
<td>=表达式</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>,</td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>从左向右顺序运算</td>
</tr>
</tbody>
</table>
<p>注意+、-、*、&amp;作为一元运算符时优先级高于作为二元运算符的时候</p>
<p>c语言没有定义在表达式求值过程中的溢出、除法检查和其他异常的处理</p>
<p>大多数现有c语言的实现在进行有符号整数表达式的求值时以及在赋值时忽略溢出异常，但并不是所有实现都这样做</p>
<p>对除数为0和所有浮点异常的处理，不同的实现有不同的方式，有时候可以用非标准库函数进行调整</p>
<h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级：</h3>
<p>优先级指不同运算符之间运算次序，先高后低，共分15级</p>
<p>单目运算符优先级高于双目运算符高于三目运算符</p>
<p>算数运算符高于关系运算符高于逻辑运算符</p>
<p>移位运算符高于关系运算符高于按位逻辑运算符</p>
<p>逗号运算符优先级最低，赋值运算符，各种赋值运算符优先级次低</p>
<p>圆括号优先级最高</p>
<h3 id="运算符结合性"><a class="markdownIt-Anchor" href="#运算符结合性"></a> 运算符结合性</h3>
<p>运算符结合性：同优先级的运算符在同一个表达式中，且没有括号的时候，多个运算符与操作数之间的结合方式</p>
<p>如:x+=10+1中，操作数10和1与+结合后的返回结果与x和+=结合</p>
<p>相同优先级下按结合性决定运算顺序</p>
<p>右结合性   单目，三目运算符，赋值运算符</p>
<p>左结合性   其余运算符</p>
<p>运算符的优先级和结合性有明确的规定，但除少数例外情况外表达式的求值次序没有定义，甚至有些有副作用的子表达式也没有定义</p>
<p>因此除非运算符的定义保证了其操作数按某一特定顺序求值，否则具体的实现可以自由选择任意求值次序，甚至可以交换求值次序</p>
<p>每个运算符将其操作数生成的值结合起来的方式与表达式的语法分析方式是兼容的</p>
<p>运算符的优先级与结合性规定了表达式中相邻运算符间的相对运算次序，但是对于操作数而言其求值顺序依赖于具体实现</p>
<p>如:exp1+exp2<em>exp3 可以确定的是</em>运算会先于加法运算，但其中运算数exp2和exp3以及exp1和exp2*exp3的求值顺序</p>
<p>在不同编译器的实现下是不一样的</p>
<p>对于因操作数计算的次序不同产生不同，结果的表达式为带副作用的表达式，在计算时会影响其他操作数的值，引起副作用的运算符为带副作用的运算符</p>
<p>如:x=1,(x+2)*(++x); 第二个表达式在不同的操作数计算顺序下结果是不一样的</p>
<p>x=f()+g(); 其中f()可以在g()之前计算也可以在g()之后计算，因此如果f或g改变了另一个函数所用的变量则x的结果可能依赖于两个函数的计算顺序</p>
<p>(这种情况为保证特定的计算顺序最好将结果保存在中间变量当中)</p>
<p>在c++中规定，先计算逻辑与(&amp;&amp;)和逻辑或(||)的第一个操作数，再计算第二个操作数，以便进行短路求值</p>
<p>条件（?:）、逗号（,）运算符也规定了操作数的计算次序，除此以外，其他运算符没有规定操作数的计算次序，计算次序由具体的编译器决定。</p>
<p>因此在表达式中尽量避免在操作数中引入带副作用的运算符</p>
<p>函数调用、嵌套赋值语句、自增与自减运算符都可能产生“副作用”，对表达式求值的同时，修改了某些变量的值</p>
<p>如:printf(&quot;%d %d&quot;,++n,power(2,n));编译器会发出警告，结果取决于在不同编译器中n的自增是发生在power调用前还是调用之后</p>
<p>在有这些“副作用”影响的表达式中，执行结果与表达式中的变量被修改的顺序存在着微妙的依赖关系</p>
<p>c对大多数这类问题有意未进行具体规定，表达式会出现什么样的“副作用”由编译器决定，而最佳的求值顺序与机器结构有很大关系</p>
<p>(但是ANSI C明确规定所有对参数的副作用都必须在函数调用之前生效)</p>
<p>无论如何，在任何一种编程语言中，如果代码的执行结果与求值顺序相关，都是不好的程序设计风格</p>
<p>尤其是不知道这些问题在各种机器上是如何解决的，就最好不要尝试运用某种特殊的实现方式</p>
<h1 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h1>
<p>c中很多情况下在表达式中会进行隐式的数据类型转换：</p>
<p>一般而言是将&quot;比较窄的&quot;的操作数转换为&quot;比较宽的&quot;操作数，进行不丢失信息的转换，</p>
<p>如int i;char c;i=c,c=i; 此时c的值不变，但反过来就可能发生信息丢失   float x;int i;i=x; 此时x的小数部分被截去后值赋给</p>
<p>整型提升:在一个表达式中凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型或整型位字段，还可以使用枚举类型的对象</p>
<p>如果原始类型的所有值都可以用int类型表示，则其值将被转换为int类型，如果遇到无法提升的情况(比如short类型)则转换为unsigned int类型</p>
<p>这一过程称为整型提升(integral promotion)</p>
<p>其中将任何整数转换为某种指定的无符号类型数的方法为：以该无符号类型能够表示的最大值+1为模，找出与此整数同余的最小非负数</p>
<p>在二进制补码表示中，如果该无符号类型的位模式较窄，这相当于左截取；如果该无符号类型的位模式较宽，这相当于对带符号值进行符号扩展和对无符号值进行0填充</p>
<p>将任何整数转换为带符号类型时，如果它可以在新类型中表示出来，则其值保持不变，否则它的值同具体实现有关</p>
<p>由于函数调用的参数是表达式，在传递参数时也可能发生类型转换，因此在声明参数时应尽量声明为范围大的类型</p>
<p>同时也需注意类型的使用条件，如不能将下标设置为浮点型等</p>
<p>针对可能导致丢失信息的表达式，编译器可能会发出警告信息，如将long,float赋给int等，但这种表达式并不非法</p>
<p>许多运算符会在运算过程中引起转换，并产生结果类型，其效果是将所有操作数转换为同一公共类型，并以此作为结果类型</p>
<p>这种方式的转换称为普通算术类型转换</p>
<p>如果二元运算符(具有两个操作数)的两个操作数类型不同，则需先把较低类型转换为较高类型，结果返回较高的类型</p>
<p>如果不考虑unsigned类型操作数，表达式中只需要下列非正式规则即可：(优先级按顺序下降)</p>
<p>1.如果其中一个操作数类型为long double，则将另一个操作数转换为long double类型</p>
<p>2.如果其中一个操作数类型为double，则将另一个操作数转换为double类型</p>
<p>3.如果其中一个操作数类型为float，则将另一个操作数转换为float类型</p>
<p>4.将char与short类型的操作数直接自动转为int类型(整型提升)</p>
<p>5.整型提升后，如果任何一个操作数为unsigned long int类型，则将另一个操作数转换为unsigned long int类型</p>
<p>6.如果一个操作数为long int类型且另一个操作数为unsigned int类型，则结果依赖于long int类型是否可以表示所有的unsigned int类型值</p>
<p>如果long int类型不能覆盖所有的unsigned int取值，则将两个操作数都转换为unsigned long int类型</p>
<p>7.如果一个操作数为long int类型，则另一个操作数转换为long int类型</p>
<p>8.如果一个操作数为unsigned int类型，则另一个操作数转换为unsigned int类型</p>
<p>9.最后，如果以上都没有，则将两个操作数转换为int类型</p>
<p>注意，表达式中float类型操作数不会自动转换为double类型</p>
<p>一般而言，数学函数(如&lt;math.h&gt;中定义的函数)使用双精度类型变量</p>
<p>使用float主要为了在使用较大数组时节省存储空间，以及节省执行时间(双精度算术运算很费时)，但精度上有所欠缺</p>
<p>当表达式中包括unsigned类型时，转换规则要更复杂，主要原因在于进行的转换是与机器相关的，例：</p>
<p>假定int占16位，long占32位，则-1L&lt;1U，因为此时unsigned int被隐式转换为signed long，</p>
<p>但是-1L&gt;1UL，因为此时signed long被转为unsigned long，即-1在一些情况下可能被转为一个比1大的正整数</p>
<p>(这种情况下long可以覆盖unsigned的取值，因此两数都转换为long即可)</p>
<p>c中没有指定char类型是带符号(signed)还是无符号(unsigned)，因此在将char转化为int时其结果可能为负整数</p>
<p>不同机器的结果可能不同，某些机器中，如果char类型最左一位是1，则转换为负整数(符号扩展后，高于1字节的位数全置为1，算术移位)，</p>
<p>另一些机器中，在将char转换为int后，在char类型值左边加0(逻辑移位)，使转换后的值总是正值</p>
<p>要是转换后的字符总是正值，可以先将char转为unsigned char</p>
<p>c的定义保证机器的标准打印字符集中的字符为非负值，因此在表达式中这些字符总是正的，但是其位模式在某些机器中可能是负的</p>
<p>为保证程序的可移植性，如果要在char类型中存储非字符数据，最好指定signed或unsigned限定符</p>
<p>如果需要将浮点类型的值转换为整型，小数部分将被丢弃，如果结果值不能用整型值表示则其行为是未定义的</p>
<p>特别是将负的浮点数转换为无符号整型的结果是没有定义的；</p>
<p>如果需要将整型值转换为浮点类型时，如果该值在该浮点类型可以表示的范围内但不能精确表示，则结果可能是下一个较高或较低的可表示值</p>
<p>如果该值超出可表示范围，则其行为是未定义的；</p>
<p>将一个精度较低的浮点值转换为相同或更高精度的浮点类型时，它的值保持不变</p>
<p>将一个较高精度的浮点类型值转换为较低精度的浮点类型时，如果它的值在可表示范围内，则结果可能是下一个较高或较低的可表示值</p>
<p>同样的，如果该值超出可表示范围，则其行为是未定义的</p>
<p>ASCII字符集中，大写字母与其对应的小写字母数值之间的间隔是固定的，并且每个字母表是连续的，如a～z,A~Z之间只有字母</p>
<p>但是在EBCDIC字符集中字母就不是连续的</p>
<p>标准头文件&lt;ctype.h&gt;中定义了一组与字符集无关的测试和转换函数，如isdigit©对应于测试语句c&gt;=‘0’&amp;&amp;c&lt;=‘9’</p>
<h1 id="指针和整数"><a class="markdownIt-Anchor" href="#指针和整数"></a> 指针和整数</h1>
<p>指针可以加上或减去一个整型表达式，在这种情况下整型表达式的转换按照加法运算符的方式进行</p>
<p>两个指向同一数组中同一类型的对象的指针可以进行减法运算，其结果将转换为整型，转换方式按照减法运算符的方式进行；</p>
<p>值为0的整型常量表达式或强制转换为void*类型的表达式，可通过强制转换、赋值或比较操作转换为任意类型的指针，其结果将产生一个空指针</p>
<p>(注意此空指针等于指向同一类型的另一空指针，但不等于任何指向函数或对象的指针)</p>
<p>作为一种良好的编程习惯，很多程序员都不愿意在程序中到处出现未加修饰的0或者其他空指针常量，为了让程序中的空指针使用更加明确从而保持统一的编程风格</p>
<p>专门定义了一个标准预处理宏NULL，其值为“空指针常量”，VC++中定义预处理宏NULL的代码如下：</p>
<p>#ifndef NULL</p>
<p>#ifdef __cplusplus</p>
<p>#define NULL 0</p>
<p>#else</p>
<p>#define NULL ((void*)0)</p>
<p>#endif</p>
<p>#endif</p>
<p>指针可以转换为整型，但此整型必须足够大，所要求的大小和映射函数(转换方式)依赖于具体的实现</p>
<p>整型对象可以显式地转换为指针，这种映射通常是将一个足够宽的从指针转换来的整数转换为同一个指针，其他情况依赖于具体的实现</p>
<p>指向某一类型的指针可以显式地转换为指向另一类型的指针，但是如果该指针指向的对象不满足一定的存储对齐要求，则结果指针可能会导致地址异常</p>
<p>指向某对象的指针可以转换为一个指向具有更小相同存储对齐限制的对象的指针，并可以保证原封不动地再转换回来</p>
<p>“对齐”概念依赖于具体实现，但char类型具有最小的对齐限制</p>
<p>对于某类型T，如果某表达式或子表达式的类型为“T的数组”。那么此表达式的值是指向数组中第一个对象的指针，并且此表达式的类型被转换为“指向T的指针”</p>
<p>如果此表达式是一元运算符&amp;、++、–或sizeof的运算分量，或是赋值类运算符或圆点运算符.的左运算分量．那么转换不会发生</p>
<p>(int a[]={0,10,20};</p>
<p>printf(&quot;%p\n&quot;,a);           输出：0x7ff7b3a6a36c</p>
<p>printf(&quot;%p\n&quot;,&amp;a[0]);     输出：0x7ff7b3a6a36c</p>
<p>printf(&quot;%p\n&quot;,&amp;a);         输出：0x7ff7b3a6a36c</p>
<p>printf(&quot;%p\n&quot;,a+1);       输出：0x7ff7b3a6a370</p>
<p>printf(&quot;%p\n&quot;,&amp;a[0]+1); 输出：0x7ff7b3a6a370</p>
<p>printf(&quot;%p\n&quot;,&amp;a+1);     输出：0x7ff7b3a6a378</p>
<p>可以发现，数组名a、数组名首元素a[0]的地址、数组名a的地址三者的值是一样的，因此变量a存储的地址值即一个指针常量</p>
<p>但是从进行增1运算后的结果来看，a和a[0]都是增加4个字节的长度，但是&amp;a增1后直接位移了12个字节，也就是整个数组的</p>
<p>总长度，说明&amp;运算符和数组名结合后a并不能视作为指针类型，变量类型(符号表中的种属?)表示的是数组类型)</p>
<p>类似地，类型为“返回T的函数”的表达式被转换为类型“指向返回T的函数的指针”，除非此表达式被用作&amp;运算符的运算分量</p>
<p>一个指针可以转换为同类型的另一个指针，但增加或删除了指针所处的对象类型的限定符(比如volatile等)的情况有些特殊:</p>
<p>如果增加了限定符则新指针与原指针等价，不同的是增加了限定符带来的限制</p>
<p>如果删除了限定符，则对底层对象的运算仍受实际声明中的限定符的限制</p>
<p>指向一个函数的指针可以转换为指向另一个函数的指针，调用转换后指针所指函数的结果依赖于具体的实现</p>
<p>但是如果转换后的指针被重新转换为原来的类型，则结果与原来的指针一致</p>
<h1 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h1>
<p>任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换，优先级同其他一元运算符，基本格式为：</p>
<p>(类型名)表达式</p>
<p>表达式将按转换规则被转换为类型名指定的类型，即表达式首先被赋值给类型名指定的类型的某个变量，然后再用该变量替换整条语句，</p>
<p>强制类型转换只生成一个指定类型的n的值，n本身的值并没有改变</p>
<p>例：伪随机发生器的函数rand,及初始化随即种子数的函数srand，其中使用了强制类型转换(标准库中包含一个可移植的实现,其中使用了类似方法)</p>
<pre class="line-numbers language-none"><code class="language-none">unsigned long int next&#x3D;1;

   int rand()

   &#123;

    next&#x3D;next*1103515245+12345;

    return (unsigned int)(next&#x2F;65536)%32768;

   &#125;

   void srand(unsigned int seed)

   &#123;

    next&#x3D;seed;

   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>c语言标准</title>
    <url>/posts/7ff5cbd303ff</url>
    <content><![CDATA[<p>注：这本笔记c的内容主要参考的是K&amp;R的TCPL第二版，因此实际是ANSI C的标准</p>
<pre><code>关于C99出现的一些变化均集中整理到这部分来 (c11后面的变化暂时还没整理)
</code></pre>
<h1 id="kr-c"><a class="markdownIt-Anchor" href="#kr-c"></a> K&amp;R C</h1>
<pre><code>1978年，丹尼斯·里奇(Dennis Ritchie)和Brian Kernighan合作出版了《C程序设计语言》的第一版

书中介绍的C语言标准也被C语言程序设计师称作“K&amp;R C”，第二版的书中也包含了一些ANSI C的标准。

K&amp;R C主要介绍了以下特色：

结构(struct)类型、长整数(long int)类型、无符号整数(unsigned int)类型、把运算符=+和=-改为+=和-=

因为=+和=-会使得编译器不知道用户要处理i=+10还是i=-10，使得处理上产生混淆。

即使在后来ANSI C标准被提出的许多年后，K&amp;R C仍然是许多编译器的最低标准要求，许多老旧的编译仍然运行K&amp;R C的标准。
</code></pre>
<span id="more"></span>
<h1 id="c89ansi-cc90iso-c"><a class="markdownIt-Anchor" href="#c89ansi-cc90iso-c"></a> C89(ANSI C，C90，ISO C)</h1>
<pre><code>1989年，C语言被ANSI标准化(ANSI X3.159-1989)，标准化的一个目的是扩展K&amp;R C,这个标准包括了一些新特性

在K&amp;R出版值后，又有一些新特性被非官方地加到C语言中，如：

void函数、函数返回struct或union类型、void*数据类型

在ANSI标准化自己的过程中，一些新的特性被加了进去，ANSI也规定一套了标准函数库

ISO(国际标准化组织)成立 ISO/IEC JTC1/SC22/WG14工作组规定国际标准的C语言通过对ANSI标准的少量修改，最终通过了ISO 9899:1990

随后ISO标准被ANSI采纳

传统C语言到ANSI/ISO标准C语言的改进包括：

增加了真正的标准库、新的预处理命令与特性、函数原型允许在函数申明中指定参数类型、一些新的关键字，包括 const、volatile与signed、

宽字符、宽字符串与字节多字符、对约定规则、声明和类型检查的许多小改动与澄清

随后WG14工作小组之后又于1995年，对1985年颁布的标准做了两处技术修订(缺陷修复)和一个补充(扩展)

《标准修正案一》为C语言建立了一个新标准，但是只修正了一些C89标准中的细节和增加更多更广得国际字符集支持。

下面是1995年做出的所有修改：

3个新的标准库头文件iso646.h、wctype.h和wchar.h、几个新的记号与预定义宏，用于对国际化提供更好的支持、printf/sprintf函数、

一系列新的格式代码、大量的函数和一些类型与常量，用于多字节字符和宽字节字符

这个标准引出了1999年ISO 9899:1999的发表，它通常被成为C99，C99被ANSI于2000年3月采用。
</code></pre>
<h1 id="c99"><a class="markdownIt-Anchor" href="#c99"></a> C99</h1>
<pre><code>在ANSI的标准确立后，c的规范在一段时间内没有大的变动，而c++在自己的标准化建立过程中继续发展壮大

在C99中包括的特性有：

对编译器限制增加了，比如源程序每行要求至少支持到4095字节，变量名函数名的要求支持到63节(extern要求支持到31)

预处理增强了，例如：

宏支持取可变参数 #define Macro(...)__VA_ARGS__

使用宏的时候，参数如果不写，宏里直接用预处理符#,##会扩展成空串 (以前会出错的)

支持//行注释(这个特性实际上在C89的很多编译器上已经被支持了)

增加了新关键字restrict,inline,_Complex,_Imaginary,_Bool

支持long long,long double _Complex,float _Complex这样的类型

支持&lt;: :&gt; &lt;% %&gt; %: %:%: ，等等奇怪的符号替代，D&amp;E里提过这个

支持了不定长的数组，数组的长度就可以用变量了，声明类型的时候用int a[*]这样的写法

不过考虑到效率和实现，这并不是一个新类型，所以就不能用在外部或者struct和union中，如果用了这样的东西，goto语句就受限制了

变量声明不必放在语句块的开头，for语句提倡for(int i=0;i&lt;100;++i)的写法，int i的声明放在里面，i只在for里面有效

当一个类似结构的东西需要临时构造的时候，可以用(type_name)&#123;xx,xx,xx&#125;，有点像c++的构造函数

初始化结构的时候可以这样写：

struct&#123;int a[3],b;&#125;hehe[]=&#123;[0].a=&#123;1&#125;,[1].a=2&#125;;

struct&#123;int a,b,c,d;&#125;hehe=&#123;.a=1,.c=3,4,.b=5&#125;     //其中3,4是对.c,.d赋值的

字符串里面，/u支持unicode的字符

支持16进制的浮点数的描述，所以printf/scanf的格式化串多支持了ll/LL(VC6里用的I64)对应新的long long类型。

浮点数的内部数据描述支持了新标准，可以用#pragma编译器指定

除了已经有的__line__ __file__以外，又支持了一个__func__可以得到当前的函数名

对于非常数的表达式，也允许编译器做化简

修改了对于／%处理负数上的定义，比如老的标准里-22/7=-3,-22%7=-1而现在-22/7=-4,-22%7=6

取消了不写函数返回类型默认就是int的规定

允许struct定义的最后一个数组写做[]不指定其长度描述

const const int i;将被当作 const int i;处理

增加和修改了一些标准头文件：

比如定义bool的&lt;stdbool.h&gt; 定义一些标准长度的int的&lt;inttypes.h&gt; 定义复数的&lt;complex.h&gt; 定义宽字符的 &lt;wctype.h&gt;

有点泛型味道的数学函数&lt;tgmath.h&gt; 跟浮点数有关的 &lt;fenv.h&gt;

&lt;stdarg.h&gt;里多了一个va_copy可以复制...的参数 &lt;time.h&gt;里多了个struct tmx对struct tm做了扩展

输入输出对宽字符还有长整数等做了相应的支持

相对于c89的变化还有：(其中很多是为了与c++兼容)

*增加restrict指针

C99中增加了公适用于指针的restrict类型修饰符，它是初始访问指针所指对象的惟一途径，因此只有借助restrict指针表达式才能访问对象

restrict指针指针主要用做函数变元，或者指向由malloc()函数所分配的内存变量，restrict数据类型不改变程序的语义

如果某个函数定义了两个restrict指针变元，编译程序就假定它们指向两个不同的对象，memcpy()函数就是restrict指针的一个典型应用示例

C89中memcpy()函数原型为：void *memcpy (void *s1, const void *s2, size_t size);

传参时如果s1和s2所指向的对象重叠，其操作就是未定义的，memcpy()函数只能用于不重叠的对象

c99中memcpy()函数原型如下:代码: void *memcpy(void *restrict s1, const void *restrict s2,size_t size);

通过使用restrict修饰s1和s2 变元，可确保它们在该原型中指向不同的对象。

*inline(内联)关键字

内联函数除了保持结构化和函数式的定义方式外，还能使程序员写出高效率的代码

函数的每次调用与返回都会消耗相当大的系统资源，尤其是当函数调用发生在重复次数很多的循环语句中时

一般情况下，当发生一次函数调用时，变元需要进栈，各种寄存器内存需要保存,当函数返回时，寄存器的内容需要恢复

如果该函数在代码内进行联机扩展，当代码执行时，这些保存和恢复操作活动会再发生，而且函数调用的执行速度也会大大加快

函数的联机扩展会产生较长的代码，所以只应该内联对应用程序性能有显著影响的函数以及长度较短的函数

*新增数据类型

_Bool值是0或1，c99中增加了用来定义bool、true以及false宏的头文件夹&lt;stdbool.h&gt;，以便程序员能够编写同时兼容于c与c++的应用程序

在编写新的应用程序时，应该使用&lt;stdbool.h&gt;头文件中的bool宏

_Complex and _Imaginary

c99标准中定义的复数类型如下:

float_Complex；float_Imaginary;double_Complex;double_Imaginary;long double_Complex;long double_Imaginary;

&lt;complex.h&gt;头文件中定义了complex和imaginary宏，并扩展为_Complex和_Imaginary

因此在编写新的应用程序时应使用&lt;stdbool.h&gt;头文件中的complex和imaginary宏。

long long int

c99标准中引进了long long int (-(2e63-1)至2e63-1)和unsigned long long int (0至2e64-1)

long long int能够支持的整数长度为64位

*对数组的增强：可变长数组

c99中，程序员声明数组时，数组的维数可以由任一有效的整型表达式确定，包括只在运行时才能确定其值的表达式，这类数组就叫做可变长数组

不过只有局部数组才可以是变长的

可变长数组的维数在数组生存期内是不变的，也就是说，可变长数组不是动态的,可以变化的只是数组的大小

*数组声明中的类型修饰符

在c99中，如果需要使用数组作为函数变元，可以在数组声明的方括号内使用static关键字

这相当于告诉编译程序，变元所指向的数组将至少包含指定的元素个数

也可以在数组声明的方括号内使用restrict,volatile,const关键字，但只用于函数变元

如果使用restrict，指针是初始访问该对象的惟一途径，如果使用const，指针始终指向同一个数组，使用volatile没有任何意义

*单行注释

引入了单行注释标记&quot;//&quot;,可以像c++一样使用这种注释了

*分散代码与声明

*预处理程序的修改

*变元列表

宏可以带变元，在宏定义中用省略号(...)表示

内部预处理标识符__VA_ARGS__决定变元将在何处得到替换

如:#define MySum(...) sum(__VA_ARGS__)

语句MySum(k,m,n);将被转换成:sum(k,m,n);

变元还可以包含变元

如:#define compare(compf, ...) compf(__VA_ARGS__)

其中的compare(strcmp,&quot;small&quot;, &quot;large&quot;);将替换成:strcmp(&quot;small&quot;,&quot;large&quot;);

*_Pragma运算符

c99引入了在程序中定义编译指令的另外一种方法:_Pragma运算符，格式为:_Pragma(&quot;directive&quot;)

其中directive是要满打满算的编译指令，_Pragma运算符允许编译指令参与宏替换。

*内部编译指令

STDCFP_CONTRACT ON/OFF/DEFAULT       若为ON，浮点表达式被当做基于硬件方式处理的独立单元，默认值是定义的工具

STDCFEVN_ACCESS ON/OFF/DEFAULT       告诉编译程序可以访问浮点环境，默认值是定义的工具

STDC CX_LIMITED_RANGE ON/OFF/DEFAULT 若值为ON，相当于告诉编译程序某程序某些含有复数的公式是可靠的，默认是OFF

*新增的内部宏

__STDC_HOSTED__                      若操作系统存在，则为1

__STDC_VERSION__                     199991L或更高。代表C的版本

__STDC_IEC_599__                     若支持IEC 60559浮点运算，则为1

__STDC_IEC_599_COMPLEX__             若支持IEC 60599复数运算，则为1

__STDC_ISO_10646__                   由编译程序支持，用于说明ISO/IEC 10646标准的年和月格式：yyymmmL

*复合赋值

c99中，复合赋值中，可以指定对象类型的数组、结构或联合表达式。当使用复合赋值时，应在括弧内指定类型，后跟由花括号围起来的初始化列表；若类型为数组，则不能指定数组的大小。建成的对象是未命名的。

如:double *fp=(double[])&#123;1.1,2.2,3.3&#125;;

该语句用于建立一个指向double的指针fp，且该指针指向这个3元素数组的第一个元素

在文件域内建立的复合赋值只在程序的整个生存期内有效在模块内建立的复合赋值是局部对象，在退出模块后不再存在。

*柔性数组结构成员

c99中，结构中的最后一个元素允许是未知大小的数组，这就叫做柔性数组成员，但结构中的柔性数组成员前面必须至少一个其他成员。柔性数组成员允许结构中包含一个大小可变的数组。sizeof返回的这种结构大小不包括柔性数组的内存。包含柔性数组成员的结构用malloc()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

*指定的初始化符

c99中，该特性对经常使用稀疏数组的程序员十分有用

指定的初始化符通常有两种用法：用于数组，以及用于结构和联合

用于数组的格式:=vol;                   其中，index表示数组的下标，vol表示本数组元素的初始化值

如:int x[10]=&#123;[0]=10,[5]=30&#125;;        其中只有x[0]和x[5]得到了初始化

用于结构或联合的格式为:member-name(成员名称)

对结构进行指定的初始化时，允许采用简单的方法对结构中的指定成员进行初始化

如:struct example&#123;int k,m,n;&#125; object=&#123;m=10,n=200&#125;; 其中，没有初始化k。对结构成员进行初始化的顺序没有限制

*printf()和scanf()函数系列的增强

c99中printf()和scanf()函数系列引进了处理long long int和unsigned long long int数据类型的特性

long long int 类型的格式修饰符是ll，在printf()和scanf()函数中，ll适用于d,i,o,u和x格式说明符

另外，C99还引进了hh修饰符，当使用d,i,o,u和x格式说明符时，hh用于指定char型变元，ll和hh修饰符均可以用于n说明符

格式修饰符a和A用在printf()函数中时，结果将会输出十六进制的浮点数，格式为:[-]0xh,hhhhp+d

使用A格式修饰符时，x和p必须是大写。A和a格式修饰符也可以用在scanf()函数中，用于读取浮点数

调用printf()函数时，允许在%f说明符前加上l修饰符，即%lf，但不起作用。

*c99新增的库

c89中标准的头文件

&lt;assert.h&gt; 定义宏assert()          &lt;ctype.h&gt; 字符处理

&lt;errno.h&gt; 错误报告                 &lt;float.h&gt; 定义与实现相关的浮点值

&lt;limits.h&gt; 定义与实现相关的各种极限值 &lt;locale.h&gt; 支持函数setlocale()

&lt;math.h&gt; 数学函数库使用的各种定义     &lt;setjmp.h&gt; 支持非局部跳转

&lt;signal.h&gt; 定义信号值               &lt;stdarg.h&gt; 支持可变长度的变元列表

&lt;stddef.h&gt; 定义常用常数             &lt;stdio.h&gt;  支持文件输入和输出

&lt;stdlib.h&gt; 其他各种声明             &lt;string.h&gt; 支持串函数

&lt;time.h&gt; 支持系统时间函数

c99新增的头文件和库

&lt;complex.h&gt; 支持复数算法            &lt;fenv.h&gt; 给出对浮点状态标记和浮点环境的其他方面的访问

&lt;inttypes.h&gt; 定义标准的、可移植的整型类型集合。也支持处理最大宽度整数的函数

&lt;iso646.h&gt; 首先在此1995年第一次修订时引进，用于定义对应各种运算符的宏

&lt;stdbool.h&gt; 支持布尔数据类型类型，定义宏bool，以便兼容于c++

&lt;stdint.h&gt; 定义标准的、可移植的整型类型集合。该文件包含在&lt;inttypes.h&gt;中

&lt;tgmath.h&gt; 定义一般类型的浮点宏      &lt;wchar.h&gt; 首先在1995年第一次修订时引进，用于支持多字节和宽字节函数

&lt;wctype.h&gt; 首先在1995年第一次修订时引进，用于支持多字节和宽字节分类函数

*__func__预定义标识符

用于指出__func__所存放的函数名，类似于字符串赋值。

*其它特性的改动：放宽的转换限制

限制                                      C89标准     C99标准

数据块的嵌套层数                     15             127

条件语句的嵌套层数                   8               63

内部标识符中的有效字符个数   31               63

外部标识符中的有效字符个数    6                31

结构或联合中的成员个数         127            1023

函数调用中的参数个数               31             127

不再支持隐含式的int规则，删除了隐含式函数声明

对返回值的约束，c99中，非空类型函数必须使用带返回值的return语句

扩展的整数类型

扩展类型                含义

int16_t                 整数长度为精确16位

int_least16_t     整数长度为至少16位

int_fast32_t      最稳固的整数类型，其长度为至少32位

c89中，表达式中类型为char，short int或int的值可以提升为int或unsigned int类型

c99中，每种整数类型都有一个级别

如:long long int的级别高于int，int的级别高于char等

在表达式中，其级别低于int或unsigned int的任何整数类型均可被替换成int或unsigned int类型

但是各个公司对C99的支持所表现出来的兴趣不同

当GCC和其它一些商业编译器支持C99的大部分特性的时候，微软和Borland对此则不甚感兴趣。
</code></pre>
]]></content>
      <categories>
        <category>c&amp;c++学习</category>
      </categories>
      <tags>
        <tag>程序设计语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客，写给自己</title>
    <url>/posts/476c37a9e6e9</url>
    <content><![CDATA[<p>这是我的第一篇博客，早就想用博客记录一些生活中的所学所想，但是一直碍于麻烦，所以一拖再拖，直到今天折腾了好久才把博客搭起来。</p>
<p>不出意外的话接下来一段时间每天都保持更新，博客的内容基本上是自己之前看视频和论坛整理下来的文本，基本都是非常小白的内容，另外还有一些看过文章的转载。</p>
<p>我不知道我会在这条道路上走多远多久，既然选择了这条路，那就踏踏实实走下去，最起码学会一点技能也是好的吧。</p>
<p>也许未来的路会很曲折，我对于开发的信心也不是很足，至少从现在来看，我学的非常浅显，算是最基础的东西。</p>
<p>我希望通过深入的学习，发掘最根本最精华的东西，然后去探寻我内心深处真正热爱的事业。</p>
<p>“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下不积跬步，无以至千里；不积小流，无以成江海。“</p>
<p>任何事物的运动变化，总是先以微小的、不显著的变化开始，经过逐步积累而达到显著的、根本性质的变化。</p>
<p>慢慢积累，未来可期。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
