<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>c语言知识点总结 | hetumessi's Blog</title><meta name="keywords" content="程序设计语言学习"><meta name="author" content="hetumessi"><meta name="copyright" content="hetumessi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="词法规则 程序由存储在文件中的一个或多个翻译单元(translation unit)组成 程序的翻译分几个阶段完成，翻译的第一阶段完成低级的词法转换，执行以字符#开头的行中的指令，并进行宏定义和宏扩展 在预处理完成后，程序被归约为一个记号序列 &lt;!-- more --&gt;  记号 c中共有6类记号:标识符、关键字、常量、字符串字面值、运算符和其他分隔符 空格符、横向制表符、纵向制表符、">
<meta property="og:type" content="article">
<meta property="og:title" content="c语言知识点总结">
<meta property="og:url" content="http://hetumessi.github.io/2022/04/21/c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="hetumessi&#39;s Blog">
<meta property="og:description" content="词法规则 程序由存储在文件中的一个或多个翻译单元(translation unit)组成 程序的翻译分几个阶段完成，翻译的第一阶段完成低级的词法转换，执行以字符#开头的行中的指令，并进行宏定义和宏扩展 在预处理完成后，程序被归约为一个记号序列 &lt;!-- more --&gt;  记号 c中共有6类记号:标识符、关键字、常量、字符串字面值、运算符和其他分隔符 空格符、横向制表符、纵向制表符、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hetumessi.github.io/img/newdefaultcover.jpeg">
<meta property="article:published_time" content="2022-04-21T14:04:39.000Z">
<meta property="article:modified_time" content="2022-05-04T05:13:32.000Z">
<meta property="article:author" content="hetumessi">
<meta property="article:tag" content="程序设计语言学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hetumessi.github.io/img/newdefaultcover.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://hetumessi.github.io/2022/04/21/c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":"flase","highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'c语言知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-04 13:13:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="/css/scroll.css"><link rel="stylesheet" href="/css/footer.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/fonts.css"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,300&display=swap" rel="stylesheet"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="hetumessi's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/author.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> comments</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><i class="fa-fw fa fa-sitemap"></i><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/404/"><i class="fa-fw fa fa-heartbeat"></i><span> commonweal</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/newdefaultcover.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">hetumessi's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> comments</span></a></div><div class="menus_item"><a class="site-page" href="/sitemap.xml"><i class="fa-fw fa fa-sitemap"></i><span> sitemap</span></a></div><div class="menus_item"><a class="site-page" href="/404/"><i class="fa-fw fa fa-heartbeat"></i><span> commonweal</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">c语言知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-21T14:04:39.000Z" title="发表于 2022-04-21 22:04:39">2022-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-04T05:13:32.000Z" title="更新于 2022-05-04 13:13:32">2022-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c-c-%E5%AD%A6%E4%B9%A0/">c&amp;c++学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>NaN:aN分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="c语言知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="词法规则"><a class="markdownIt-Anchor" href="#词法规则"></a> 词法规则</h1>
<p>程序由存储在文件中的一个或多个翻译单元(translation unit)组成</p>
<p>程序的翻译分几个阶段完成，翻译的第一阶段完成低级的词法转换，执行以字符#开头的行中的指令，并进行宏定义和宏扩展</p>
<p>在预处理完成后，程序被归约为一个记号序列</p>
<p><strong><code>&lt;!-- more --&gt;</code></strong></p>
<h1 id="记号"><a class="markdownIt-Anchor" href="#记号"></a> 记号</h1>
<p>c中共有6类记号:标识符、关键字、常量、字符串字面值、运算符和其他分隔符</p>
<p>空格符、横向制表符、纵向制表符、换行符、换页符和注释(统称空白符)在程序中仅用来分隔记号，因此将被忽略</p>
<p>相邻标识符、关键字和常量之间需要用空白符来分隔(但标识符、常量、字符串字面值等和运算符直接相连是很常见的)</p>
<p>如果到某一字符为止的输入流被分隔成若干记号，那么下一个记号就是后续字符序列中可能构成记号的最长字符串</p>
<h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3>
<p>‘/’+’<em>’……’</em>’+’/'表示c语言中的注释符号，可以多行，编译程序时完全忽略这部分内容</p>
<p>c99以上标准中的注释符号为单边的//，单行注释</p>
<p>注释出现的位置：文件头，函数，重点语句块前</p>
<p>注释不能够嵌套，也不能出现在字符串字面值、字符字面值中</p>
<p>如main，printf等统称为系统预定义标识符，用户自定义标识符包括变量，常量，函数名等</p>
<h3 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h3>
<p>标识符也称为名字，可以指代多种实体：函数、结构标记、联合标记和枚举标记；结构成员或联合成员；枚举常量；类型定义名；标号及对象等</p>
<p>标识符还具有一个作用域和一个连接，作用域即程序中可以访问此名字的区域，连接决定另一作用域中的同一个名字是否指向同一个对象或函数</p>
<p>标识符(包括常量、变量的名字等)是由字母和数字组成的序列，但其第一个字符必须为字母</p>
<p>下划线’_'被看作字母，通常用于命名较长的标识符名，提高其可读性</p>
<p>由于库例程(程序的意思，某个系统对外提供的功能接口或服务的集合)名通常以下划线开头，因此自定义标识符不应以下划线开头</p>
<p>区分大写小写字母，传统c程序中变量名使用小写字母，符号常量名全部使用大写字母</p>
<p>标识符可以为任意长度，对内部(内部-局部，外部-全局)标识符而言，编译器至少能识别前31个字符，在某些实现中可能更多，有效的字符数可能更多</p>
<p>内部标识符包括预处理器的宏名和其他所有所有没有外部链接的名字，带有外部链接的标识符限制更严格一些</p>
<p>如对函数和外部变量名而言，编译器能识别的字符数小于31个，由于这两种变量会被汇编程序和加载程序等使用，名字可能在这些其他地方被用掉了</p>
<p>ANSI标准中对外部标识符仅保证能识别前6个字符，并且不区分大小写（以上为c89标准，在c99标准中内部名识别63个，外部名识别31个）</p>
<p>标识符应尽量从字面上表达变量的用途，以防止发生混淆</p>
<p>内部变量一般使用较短变量名(尤其是循环控制变量)，而外部变量尽量使用较长名字    */</p>
<h3 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h3>
<pre><code>如int，return等标识符被保留为关键字(或称系统保留字)，不能用于其他用途，并且自定义标识符不能与关键字重名

C语言关键字列表

auto,enum,restrict,unsigned,break,extern,

return,void,case,float,short,Volatile,

char,for,signed,while,const,goto,sizeof,_Bool,continue,if,

static,_Complex,default,inline,struct,_Imaginary,do,int,switch,

double,long,typedef,else,register,union
</code></pre>
<p>某些实现还将fortran和asm保留为关键字</p>
<p>关键字const、signed、volatile是在ANSI C中加入的，enum和void是在K&amp;R的第1版书后加入的，这些关键字现在都已被广泛应用</p>
<p>entry曾经被保留为关键字但从未被使用过，现已被剔除</p>
<h1 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h1>
<p>c语言数据表示方式：常量(常数、符号常量、常量表达式等)，变量（定义变量必须先声明数据类型（变量初始化））</p>
<p>定义不同数据类型的作用：合理分配地址空间，不同数据类型具有不同存储长度，取值范围，允许的操作</p>
<p>数据类型包括：</p>
<p>基本类型             整型，字符型，单/双精度浮点型，空值型</p>
<p>构造(派生)类型    数组，结构，联合，枚举，指针</p>
<p>可以被解释为数字的类型统称为算术类型</p>
<p>由于char类型、各种大小的int类型(无论是否带符号)以及枚举类型都统称为整型类型(integral type)</p>
<p>类型float、double、long double统称为浮点类型(floating type)</p>
<p>此外void类型说明一个值的空集合，它常被用来说明不返回任何值的函数的类型</p>
<p>除基本类型外，还可以通过以下几种方法构造派生类型，从概念上讲派生类型可以有无限多个：</p>
<p>给定类型对象的数组、返回给定类型对象的函数、指向给定类型对象的指针、包含一系列不同类型对象的结构、可以包含多个不同类型对象中任意一个对象的联合</p>
<p>一般情况下构造对象的方法可以递归使用</p>
<p>对象的类型可以通过附加的类型限定符进行限定，声明为const的对象表明此对象的值不可以修改；声明为volatile的对象表明它具有与优化相关的特殊属性</p>
<p>限定符既不影响对象取值的范围，也不影响其算术属性</p>
<h3 id="数据存储"><a class="markdownIt-Anchor" href="#数据存储"></a> 数据存储</h3>
<p>int类型通常代表宿主机器体系架构决定的整数的自然长度，在16位编译器下是2字节，32/64位一般是4字节</p>
<p>long,short为限定符，通常用于限定整型(long也可以修饰long，double等)以提供满足需要的不同长度整型数，除非特别说明int类型都表示带符号数</p>
<p>short类型通常为16位(二进制表示)，int既可以16位又可以32位，long至少为32位，long long为64位</p>
<p>当整数太大时，int或short类型可以当作long型处理</p>
<p>(较长的整数至少要占有与较短整数一样的存储空间，但是具体是实现可以使得一般整型与短整型、长整型具有同样的大小)</p>
<p>枚举是一个具有整型值的特殊类型，与每个枚举相关联的是一个命名常量的集合，枚举类型类似于整型</p>
<p>如果每个特定枚举类型的对象赋值不是其常量中的一个或者赋值不是同一个类型的表达式，则编译器通常会产生警告信息</p>
<p>long double表示高精度浮点型，同整型一样，浮点型长度也取决于具体实现</p>
<p>float,double,long double类型可表示相同长度，也可表示不同长度</p>
<p>可以存储在带符号对象中的非负值的集合是可以存储在相应的无符号对象中的值的子集，并且这两个集合的重叠部分的表示是相同的</p>
<p>unsigned,signed可用于限定任意char类型或整型，整型默认是signed(有正负)</p>
<p>unsigned类型的值总是&gt;0(如:unsigned int a=-1;printf(&quot;%d&quot;,a&gt;0?1:0);输出为1)</p>
<p>unsigned类型遵守模2^n定律(相当于结果右移n位)，n为该类型占用的bit位，保证对无符号数的运算永远不会溢出</p>
<p>数据类型取值范围排序：long double &gt; double &gt; float &gt; long long &gt; long &gt; int &gt; short&gt; char</p>
<p>同类型中unsigned &gt; signed</p>
<p>如：char类型占用1字节(8位)，则unsigned char取值范围0～255，signed char取值范围-128～127(二进制补码)</p>
<p>对char类型而言取值范围和是否带符号取决于具体机器，但可打印的字符总是正值，声明为char的对象要大到足以存储执行字符集中的任何字符</p>
<p>如果字符集中的某个字符存储在一个char类型对象中则该对象的值等于字符的整型编码值并且是非负值</p>
<p>(以unsigned char声明的无符号字符与普通字符占用同样大小的空间，以signed char显式声明的带符号字符与普通字符也占用同样大小的空间)</p>
<p>声明时int可以省略只保留限定符名short,long,unsigned,signed等</p>
<p>单精度浮点数(float)、双精度浮点数(double)、多精度浮点数(long double)中任何类型都可能是同义的，但精度从前到后是递增的</p>
<p>(老式c语言编译器支持long float，但在c89中就已经被double替换了)</p>
<p>有关类型长度定义的符号常量及其他与编译器和机器有关的属性见标准头文件&lt;limits.h&gt;、&lt;float.h&gt;</p>
<h3 id="void对象"><a class="markdownIt-Anchor" href="#void对象"></a> void对象</h3>
<p>void对象的(不存在的)值不能够以任何方式使用，也不能够被显式或隐式地转换为任一非空类型</p>
<p>因为空(void)表达式表示一个不存在的值，只可以用在不需要值的地方，例如作为一个表达式语句或作为逗号运算符的左操作数(注意左操作数和左值的区别)</p>
<p>如:void func(void)强调函数没有任何参数，(void)0,(void)1,(void*)0,(void*)0x100000(常见于函数参数)</p>
<p>可以通过强制类型转换将表达式转换为void类型，例如在表达式语句中一个空的强制类型转换将丢掉函数调用的返回值，如:(void)func();</p>
<p>指向任何对象的指针都可以转换为void*类型，且不会丢失信息，如果将结果再转换为初始指针类型，则可以恢复初始指针</p>
<p>指针可以被赋值为void<em>类型的指针，也可以赋值给void</em>类型的指针，并可以与void*类型指针进行比较</p>
<p>(ANSI标准特别允许void*类型指针与其他对象指针在赋值表达式和关系表达式中混用，关键是不需要进行强制类型转换)</p>
<h1 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h1>
<p>程序中一般不直接使用常数，可定义宏常量(c中一般所指的常数)或const常量</p>
<pre><code>常量区别于变量的最大的特点是常量不可修改

宏常量定义格式(一般定义在文件头预处理部分) 例：#define PI 3.1415926，宏定义中如果是表达式则一般用括号括起来，否则极容易出错

const定义方法与变量相同，具有数据类型，某些环境下可直接对其进行调试

任何变量的声明都可以使用const限定符修饰，从而指定变量不可修改，

例：const char msg[]=&quot;warning:&quot;;int len(const char[]);

在c的环境下，const是c99新增，并且c99只认定const变量为只读数据不可修改的变量，不是真正的常量，因此不能用于定义数组长度等用途
</code></pre>
<h3 id="常量类型"><a class="markdownIt-Anchor" href="#常量类型"></a> 常量类型：</h3>
<p>常量有多种类型，每种类型的常量都有一个数据类型</p>
<pre><code>数值型常量：整型常量，浮点型常量，枚举常量

字符型常量：字符常量，字符串常量，转义字符，符号常量

整型常量分八进制，十进制，十六进制三种数制

浮点型常量为实数在计算机中的表示形式，十进制表示，分小数形式或指数形式(如3.14e-3为3.14*10^-3)

整型常量由一串数字组成，并且可以带有不同的前缀和后缀代表不同的含义：

带有0前缀的常量表示八进制形式;前缀为0x或0X的常量表示十六进制形式，如:十进制31可写成八进制037或十六进制0x1F

带有l、L后缀的常量表示long或long long或double型常量;u,U表示无符号常量;ul,UL表示unsigned long 如:3567l;56u;58924ul

常量可以同时拥有前缀和后缀，如:0xFul

浮点型常量由整数部分、小数点、小数部分、一个e或E、一个可选的带符号整型类型的指数和一个可选的表示类型的后缀组成(即f,F,l或L之一)

整数和小数部分均由数组序列组成，可以没有整数部分或小数部分(但不能两者都没有)，同理也可以没有小数点或e和指数部分

浮点常量的类型由后缀确定，F或f后缀表示它是float类型，l或L后缀表明它是long double类型，没有后缀则默认是double类型

字符常量和字符串常量也可以称为单字符常量和多字符常量，字符串常量也称为字符串字面值(string literal)

字符常量为单引号括起的一个字符，按其对应的默认机器字符集(一般为ASCII)中的数值存储，占一个字节，可以像整数一样参与运算

字符常量不包括双引号字符和换行符，可以使用转义字符序列来表示这些字符以及其他一些字符

字符串常量为双引号括起的多个字符，例:China 存储格式为67 104 105 112 97 \0

字符串中使用\&quot;表示双引号字符，如：&quot;I am a \&quot;string\&quot;&quot;

编译时可以将多个字符串常量连接起来，如：&quot;hello,&quot;&quot; world&quot;等价于&quot;hello, world&quot;，这种连接未将较长的字符串分散开来提供了支持

如果程序试图修改字符串字面值，则行为是未定义的

从技术角度看，字符串常量就是字符数组，存储时加串结束标识符NULL或'\0'，因此字符串物理存储单元数比括在双引号中的字符数多一个

字符串存储类为static，使用给定的字符进行初始化，对相同的字符串字面值是否进行区分取决于具体实现

c中对字符串的长度没有限制，但程序必须扫描整个字符串后才能确定字符串的长度

标准库函数strlen()可返回字符串的长度，但不包括'\0'，标准头文件string.h中声明了strlen()和其他字符串函数

字符常量不同于仅包含一个字符的字符串，如:'x'和&quot;x&quot;，前者是一个整数，后者是字符和'\0'组成的字符数组

枚举常量是一个常量整型值的列表，如:enum escapes&#123;NO,YES&#125;;

在没有显示说明的情况下，enum类型中第一个枚举值为0，第二个为1，以此类推

如果只指定了部分枚举成员的值，则未指定成员的值依照最后一个指定值向后递增

如:enum months&#123;JAN=1,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC&#125;，其中FEB=2，MAR=3，以此类推

枚举为建立常量值与名字之间的关联提供了一种便利的方式，相对于宏定义其优势在于常量值可以自动生成

可以生成enum类型的变量，编译器会进行类型检查，但不检查这种类型的变量中存储的值是否有效(不会检查值是否属于定义的枚举常量所代表的值)

例：enum color&#123;red,yellow,blue&#125;mycolor=5;（在c中可以通过编译，但是c++不可以）
</code></pre>
<h3 id="常量表达式"><a class="markdownIt-Anchor" href="#常量表达式"></a> 常量表达式</h3>
<pre><code>常量定义为标识符即为符号常量（如宏常量）

常量表达式是仅仅包含常量的表达式，这种表达式在编译时求值而不在运行时求值

可以出现在常量可以出现的任何位置，例：
</code></pre>
<p>#define MAXLINE 1000</p>
<pre><code>#define LEAP 1

char line[MAXLINE+1];

int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31]
</code></pre>
<h1 id="转义字符"><a class="markdownIt-Anchor" href="#转义字符"></a> 转义字符</h1>
<pre><code>转义字符为字符的特殊形式，表示不可打印或特殊用途

ANSI C中全部的转义字符序列为：

\0 空字符(null)，通常用'\0'形式代替0，以强调某些表达式的字符属性，但其值为空

\a 响铃符\\ 反斜杠

\b 回退符\? 问号

\f 换页符\' 单引号

\n 换行符\&quot; 双引号

\r 回车符     \000 转义八进制数(0开头，数字范围0-7)，表示ASCII码等于该值十进制形式的字符

\t 横向制表符  \xhh 转义十六进制数(0x开头，数字0-9,a-f,A-F)，表示ASCII码等于该值十进制形式的字符

\v 纵向制表符
</code></pre>
<p>例：</p>
<pre><code>#define VTAB '\013' 或  #define VTAB '\xb'  表示将VTAB替换为ASCII纵向制表符(\v的ASCII码为11)

#define BELL '\007' 或  #define BELL '\x7'  表示将BELL替换为ASCII响铃符(\a的ASCII码为7)

转义数字的位数没有限制，但如果字符值超过最大字符值或者字符值不在以上指定的转移字符序列中，则该行为是未定义的

如果转义数字的具体实现中将类型char看作是带符号的，则会对字符值进行符号扩展，类似于强制转换成char类型
</code></pre>
<h3 id="扩展字符集"><a class="markdownIt-Anchor" href="#扩展字符集"></a> 扩展字符集</h3>
<p>在c的某些实现中，还有一个扩展的字符集，不能用char类型来表示</p>
<p>扩展集中的常量要以一个前导符L开头(例如L’x’)，称为宽字符常量，这种常量的类型为wchar_t</p>
<p>w_char_t是一种整型类型，定义在头文件&lt;stddef.h&gt;中</p>
<p>与通常的字符常量一样，宽字符常量可以使用八进制或十六进制转移字符序列</p>
<p>但如果值超过wchar_t可以表示的范围则结果是未定义的</p>
<p>与宽字符常量一样，扩展字符集中的字符串字面值也以前导符L表示，如L&quot;…&quot;，宽字符常量字面值的类型为&quot;wchar_t类型的数组&quot;</p>
<p>将普通字符串字面值和宽字符字符串字面值进行连接的行为是未定义的</p>
<p>通常情况下美国和西欧所用的字符集可以用char类型来编码，增加wchar_t的主要目的是为了表示亚洲的语言</p>
<h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1>
<p>变量为程序执行时值可以变动的量，需先定义后使用，变量有时也称为对象，表示一个存储位置</p>
<p>存放变量的地址空间中首单元地址为变量地址，存放内容为变量值</p>
<p>对变量的解释依赖于两个主要属性：存储类和类型，存储类决定了与该标识对象相关联的存储区域生存期，类型决定了标识符对象中值的含义</p>
<h3 id="变量声明"><a class="markdownIt-Anchor" href="#变量声明"></a> 变量声明</h3>
<p>所有变量必须先声明后使用，尽管某些变量可以通过上下文进行隐式声明</p>
<p>注意，如果只定义指针，没有初始化时系统是不会给它分配内存的！！！</p>
<p>一个声明指定一种变量类型，后面跟的变量表可以包含一个或多个该类型的变量，例：</p>
<p>int lower,upper,step=MAX+1;</p>
<p>char c,line[1000];</p>
<p>也可以等价地写成多个变量拆开声明的形式：</p>
<p>int lower;                    这种形式虽然需要占用更多的篇幅，但便于向声明语句添加注释和进行修改</p>
<p>int upper;</p>
<p>int step=MAX+1;       声明同时可以对变量进行初始化，右边的表达式充当初始化表达式</p>
<p>char c;</p>
<p>char line[1000];</p>
<p>如果变量不是自动变量(动态局部变量),则只能进行一次初始化操作</p>
<p>从概念上来说是在程序开始运行之前，并且初始化表达式必须为常量表达式</p>
<p>对显式初始化的自动变量，每次进入函数或程序块时都将被自动初始化一次，初始化表达式可以是任何表达式</p>
<p>默认情况下，外部变量与静态变量被初始化为0，未经显式初始化的自动变量值为无效值</p>
<h3 id="存储类型"><a class="markdownIt-Anchor" href="#存储类型"></a> 存储类型</h3>
<p>存储类分为两类：自动存储类(automatic)和静态存储类(static)</p>
<p>声明对象时使用的一些关键词和声明上下文共同决定了对象的存储类，自动存储类对象对于一个程序块来说是局部的，在退出程序块时该对象消失</p>
<p>如果没有使用存储类说明符或者如果使用了auto限定符，则程序块中的声明生成的都是自动存储类对象</p>
<p>声明为register的对象也是自动存储类的对象，并且将被存储在机器的快速寄存器中(如果可能的话)</p>
<p>静态对象可以是某个程序块的局部对象，也可以是所有程序块的外部对象，无论是哪一种情况在退出和再进入函数或程序块时其值保持不变</p>
<p>在一个程序块(包括提供函数代码的程序块)内，静态对象用关键字static声明，在所程序块外部声明且与函数定义在同一级的对象总是静态的</p>
<p>可以通过static关键字将对象声明为某个特定翻译单元的局部对象，这种类型的对象将具有内部连接</p>
<p>当省略显式的存储类或通过关键字extern进行声明时(在程序块外部)，对象对整个程序来说是全局可访问的，并且具有外部连接</p>
<h3 id="对象和左值"><a class="markdownIt-Anchor" href="#对象和左值"></a> 对象和左值</h3>
<p>对象是一个命名的存储区域，左值(lvalue)是引用某个对象的表达式，具有合适类型与存储类的标识符便是左值表达式的一个明显的例子</p>
<p>某些运算符可以产生左值，例如:如果E是一个指针类型的表达式，*E是一个左值表达式，它引用由E指向的对象</p>
<p>名字“左值”来源于赋值表达式E1=E2，其中左操作数E1必须是一个左值表达式</p>
<p>对每个运算符的讨论需要说明此运算符是否需要一个左值操作数以及它是否产生一个左值</p>
<h3 id="初等表达式"><a class="markdownIt-Anchor" href="#初等表达式"></a> 初等表达式</h3>
<p>初等表达式是标识符、常量、字符串或带括号的表达式</p>
<p>一个标识符只要是按下面所讨论的方式适当说明的就是初等表达式，其类型由说明指定:</p>
<pre><code>如果一个标识符指定一个对象且其类型是算术、结构、联合或指针类型，那么它是一个左值；

一个常量是一个初等表达式，其类型依赖于它的形式；

一个字符串字面值是一个初等表达式，它的初始类型是char数组类型(对于宽字符字符串，则为wchar_t数组类型)，

通常被修改为指向char类型(wchar_t类型)的指针，从而结果是指向字符串中第一个字符的指针；

用括号括起来的表达式是一个初等表达式，它的类型和值与无括号的表达式一致，此表达式是否是左值不受括号的影响
</code></pre>
<h3 id="后缀表达式"><a class="markdownIt-Anchor" href="#后缀表达式"></a> 后缀表达式</h3>
<pre><code>后缀表达式中的运算符遵循从左到右的结合规则。

后缀表达式的形式主要包括:

1.初等表达式

2.后缀表达式[表达式] 即数组引用形式

带下标的数组由一个后缀表达式后跟一个括在方括号中的表达式来表示。方括号前的后缀表达式的类型必须为“指向T类型的指针”，

其中T为某种类型，方括号中表达式的类型必须为整型，结果得到的下标表达式的类型为T

表达式E1[E2]在定义上等同于*((E1)+(E2))

3.后缀表达式(变元表达式表opt)

函数调用由一个后缀表达式(称为函数标志符)后跟由圆括号括起来的包含一个可能为空的、由逗号分隔的赋值表达式列表组成，这些表达式就是函数的变元

如果后缀表达式包含一个在当前作用域中不存在的标识符，则此标识符将被隐式地声明，等同于在执行此函数调用的最内层程序块中包含下列声明:

extern int 标识符();  该后缀表达式(在可能的隐式声明和指针生成后)的类型必须为“指向返回T类型的函数的指针”

其中T为某种类型，且函数调用的值的类型为T

(旧语法中在通过指向函数的指针来调用此函数时必须有一个显式的*运算符，ANSI C标准允许现存的一些编泽程序用同样的语法来进行函数调用和

通过指向函数的指针来进行函数调用，旧的语法仍然可用)

变元表达式表形式:

赋值表达式   (注意是编译层次上的赋值表达式即可)

变元表达式表,赋值表达式

术语变元用来表示传递给函数调用的表达式，而术语参数则用来表示由函数定义或函数说明所接收的输入对象(或其标识符)，

通常也可用术语“实际变元”和“形式参数”来区分它们

在准备调用函数时，要对它的每个变元进行复制，所有变元传递严格地按值进行

函数可能会改变其参数对象的值(即变元表达式值的拷贝)，这个改变不会影响变元的值，但是可以将指针作为变元传递，以使函数可以改变指针所指向的对象的值

函数可以用两种方式说明；在新的方式中，形式参数的类型是作为函数类型的一部分显式指定的，这种说明称为函数原型，而在旧的方式中，参数类型没有说明

在函数调用的作用域中，如果函数是以旧方式声明的则按以下方式对每个实际变元进行缺省变元提升:

对每个整型变元进行整型提升；

将每个float类型的变元转换为double类型；

如果调用时变元的数目与函数定义中参数的数目不等，或者某个变元类型提升后与相应的参数类型不一致，那么函数调用的结果是未定义的

其中类型一致性依赖于函数定义是以新方式进行的还是以旧方式进行的:

如果定义是旧方式的，那么类型一致性检查将在提升过的函数调用的变元类型和提升过的参数类型之间进行；

如果定义是新方式的，那么提升过的实际变元类型必须与没有提升过的形式参数本身的类型一致；

如果在函数调用的作用域中函数说明是以新方式进行的，那么变元将被转换为函数原型中的相应参数类型，就像是赋值一样

变元数目必须与显式说明的参数数目相同，除非函数说明的参数表以省略号(,...)结束，在这种情况下变元的数目必须等于或超过参数的数目；

其后无显式指定类型的参数与之对应的变元要进行缺省变元提升

如果函数定义是以旧方式进行的，那么在调用中可见的原型中的每个变元类型必须与相应函数定义中的参数类型一致(函数定义中的参数类型已进行过变元提升)

(这些规则特别复杂，因为必须要考虑到新旧方式函数的混合使用，应尽可能避免新旧方式混合使用)

变元的求值次序没有指定，不同的编译器的实现方式各不相同，但是在进入函数前变元和函数命名符是完全求值的，包括所有的副作用

对任何函数都可以进行递归调用

4.后缀表达式.标识符

5.后缀表达式-&gt;标识符

6.后缀表达式++ / --
</code></pre>
<h1 id="c语言运算符表"><a class="markdownIt-Anchor" href="#c语言运算符表"></a> c语言运算符表</h1>
<p>运算符按照优先级大小由上向下排列，在同一行的运算符具有相同优先级。第二行是所有的一元运算符。</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>名称或含义</th>
<th>使用形式</th>
<th>结合方向</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[]</td>
<td>数组下标</td>
<td>数组名[常量表达式]</td>
<td>左到右</td>
<td></td>
</tr>
<tr>
<td>()</td>
<td>圆括号</td>
<td>（表达式）/函数名(形参表)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>.</td>
<td>成员选择（对象）</td>
<td>对象.成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-&gt;</td>
<td>成员选择（指针）</td>
<td>对象指针-&gt;成员名</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>负号运算符</td>
<td>-表达式</td>
<td>右到左</td>
<td>单目运算符</td>
</tr>
<tr>
<td>(类型)</td>
<td>强制类型转换</td>
<td>(数据类型)表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>++</td>
<td>自增运算符</td>
<td><ins>变量名/变量名</ins></td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>–</td>
<td>自减运算符</td>
<td>–变量名/变量名–</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>取值运算符</td>
<td>*指针变量</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>取地址运算符</td>
<td>&amp;变量名</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符</td>
<td>!表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符</td>
<td>~表达式</td>
<td>单目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sizeof</td>
<td>长度运算符</td>
<td>sizeof(表达式)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>/</td>
<td>除</td>
<td>表达式/表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>表达式*表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>余数（取模）</td>
<td>整型表达式/整型表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>+</td>
<td>加</td>
<td>表达式+表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>表达式-表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt;</td>
<td>左移</td>
<td>变量&lt;&lt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>变量&gt;&gt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>&gt;</td>
<td>大于</td>
<td>表达式&gt;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>表达式&gt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>表达式&lt;表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>表达式&lt;=表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>==</td>
<td>等于</td>
<td>表达式==表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>表达式!= 表达式</td>
<td>双目运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>按位与</td>
<td>表达式&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>按位异或</td>
<td>表达式^表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>10</td>
<td></td>
<td></td>
<td>按位或</td>
<td>表达式</td>
<td>表达式</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>表达式&amp;&amp;表达式</td>
<td>左到右</td>
<td>双目运算符</td>
</tr>
<tr>
<td>12</td>
<td></td>
<td></td>
<td></td>
<td>逻辑或</td>
<td>表达式</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>条件运算符</td>
<td>表达式1? 表达式2: 表达式3</td>
<td>右到左</td>
<td>三目运算符</td>
</tr>
<tr>
<td>14</td>
<td>=</td>
<td>赋值运算符</td>
<td>变量=表达式</td>
<td>右到左</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td>除后赋值</td>
<td>变量/=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>*=</td>
<td>乘后赋值</td>
<td>变量*=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td>取模后赋值</td>
<td>变量%=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>+=</td>
<td>加后赋值</td>
<td>变量+=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>-=</td>
<td>减后赋值</td>
<td>变量-=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
<td>变量&lt;&lt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
<td>变量&gt;&gt;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与后赋值</td>
<td>变量&amp;=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>^=</td>
<td>按位异或后赋值</td>
<td>变量^=表达式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>=</td>
<td>按位或后赋值</td>
<td>变量</td>
<td>=表达式</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>,</td>
<td>逗号运算符</td>
<td>表达式,表达式,…</td>
<td>左到右</td>
<td>从左向右顺序运算</td>
</tr>
</tbody>
</table>
<p>注意+、-、*、&amp;作为一元运算符时优先级高于作为二元运算符的时候</p>
<p>c语言没有定义在表达式求值过程中的溢出、除法检查和其他异常的处理</p>
<p>大多数现有c语言的实现在进行有符号整数表达式的求值时以及在赋值时忽略溢出异常，但并不是所有实现都这样做</p>
<p>对除数为0和所有浮点异常的处理，不同的实现有不同的方式，有时候可以用非标准库函数进行调整</p>
<h3 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级：</h3>
<p>优先级指不同运算符之间运算次序，先高后低，共分15级</p>
<p>单目运算符优先级高于双目运算符高于三目运算符</p>
<p>算数运算符高于关系运算符高于逻辑运算符</p>
<p>移位运算符高于关系运算符高于按位逻辑运算符</p>
<p>逗号运算符优先级最低，赋值运算符，各种赋值运算符优先级次低</p>
<p>圆括号优先级最高</p>
<h3 id="运算符结合性"><a class="markdownIt-Anchor" href="#运算符结合性"></a> 运算符结合性</h3>
<p>运算符结合性：同优先级的运算符在同一个表达式中，且没有括号的时候，多个运算符与操作数之间的结合方式</p>
<p>如:x+=10+1中，操作数10和1与+结合后的返回结果与x和+=结合</p>
<p>相同优先级下按结合性决定运算顺序</p>
<p>右结合性   单目，三目运算符，赋值运算符</p>
<p>左结合性   其余运算符</p>
<p>运算符的优先级和结合性有明确的规定，但除少数例外情况外表达式的求值次序没有定义，甚至有些有副作用的子表达式也没有定义</p>
<p>因此除非运算符的定义保证了其操作数按某一特定顺序求值，否则具体的实现可以自由选择任意求值次序，甚至可以交换求值次序</p>
<p>每个运算符将其操作数生成的值结合起来的方式与表达式的语法分析方式是兼容的</p>
<p>运算符的优先级与结合性规定了表达式中相邻运算符间的相对运算次序，但是对于操作数而言其求值顺序依赖于具体实现</p>
<p>如:exp1+exp2<em>exp3 可以确定的是</em>运算会先于加法运算，但其中运算数exp2和exp3以及exp1和exp2*exp3的求值顺序</p>
<pre><code>在不同编译器的实现下是不一样的
</code></pre>
<p>对于因操作数计算的次序不同产生不同，结果的表达式为带副作用的表达式，在计算时会影响其他操作数的值，引起副作用的运算符为带副作用的运算符</p>
<p>如:x=1,(x+2)*(++x); 第二个表达式在不同的操作数计算顺序下结果是不一样的</p>
<pre><code>x=f()+g(); 其中f()可以在g()之前计算也可以在g()之后计算，因此如果f或g改变了另一个函数所用的变量则x的结果可能依赖于两个函数的计算顺序

(这种情况为保证特定的计算顺序最好将结果保存在中间变量当中)
</code></pre>
<p>在c++中规定，先计算逻辑与(&amp;&amp;)和逻辑或(||)的第一个操作数，再计算第二个操作数，以便进行短路求值</p>
<p>条件（?:）、逗号（,）运算符也规定了操作数的计算次序，除此以外，其他运算符没有规定操作数的计算次序，计算次序由具体的编译器决定。</p>
<p>因此在表达式中尽量避免在操作数中引入带副作用的运算符</p>
<p>函数调用、嵌套赋值语句、自增与自减运算符都可能产生“副作用”，对表达式求值的同时，修改了某些变量的值</p>
<p>如:printf(&quot;%d %d&quot;,++n,power(2,n));编译器会发出警告，结果取决于在不同编译器中n的自增是发生在power调用前还是调用之后</p>
<p>在有这些“副作用”影响的表达式中，执行结果与表达式中的变量被修改的顺序存在着微妙的依赖关系</p>
<p>c对大多数这类问题有意未进行具体规定，表达式会出现什么样的“副作用”由编译器决定，而最佳的求值顺序与机器结构有很大关系</p>
<p>(但是ANSI C明确规定所有对参数的副作用都必须在函数调用之前生效)</p>
<p>无论如何，在任何一种编程语言中，如果代码的执行结果与求值顺序相关，都是不好的程序设计风格</p>
<p>尤其是不知道这些问题在各种机器上是如何解决的，就最好不要尝试运用某种特殊的实现方式</p>
<h1 id="隐式类型转换"><a class="markdownIt-Anchor" href="#隐式类型转换"></a> 隐式类型转换</h1>
<p>c中很多情况下在表达式中会进行隐式的数据类型转换：</p>
<p>一般而言是将&quot;比较窄的&quot;的操作数转换为&quot;比较宽的&quot;操作数，进行不丢失信息的转换，</p>
<p>如int i;char c;i=c,c=i; 此时c的值不变，但反过来就可能发生信息丢失   float x;int i;i=x; 此时x的小数部分被截去后值赋给</p>
<p>整型提升:在一个表达式中凡是可以使用整型的地方都可以使用带符号或无符号的字符、短整型或整型位字段，还可以使用枚举类型的对象</p>
<p>如果原始类型的所有值都可以用int类型表示，则其值将被转换为int类型，如果遇到无法提升的情况(比如short类型)则转换为unsigned int类型</p>
<p>这一过程称为整型提升(integral promotion)</p>
<p>其中将任何整数转换为某种指定的无符号类型数的方法为：以该无符号类型能够表示的最大值+1为模，找出与此整数同余的最小非负数</p>
<p>在二进制补码表示中，如果该无符号类型的位模式较窄，这相当于左截取；如果该无符号类型的位模式较宽，这相当于对带符号值进行符号扩展和对无符号值进行0填充</p>
<p>将任何整数转换为带符号类型时，如果它可以在新类型中表示出来，则其值保持不变，否则它的值同具体实现有关</p>
<p>由于函数调用的参数是表达式，在传递参数时也可能发生类型转换，因此在声明参数时应尽量声明为范围大的类型</p>
<p>同时也需注意类型的使用条件，如不能将下标设置为浮点型等</p>
<p>针对可能导致丢失信息的表达式，编译器可能会发出警告信息，如将long,float赋给int等，但这种表达式并不非法</p>
<pre><code>许多运算符会在运算过程中引起转换，并产生结果类型，其效果是将所有操作数转换为同一公共类型，并以此作为结果类型

这种方式的转换称为普通算术类型转换

如果二元运算符(具有两个操作数)的两个操作数类型不同，则需先把较低类型转换为较高类型，结果返回较高的类型

如果不考虑unsigned类型操作数，表达式中只需要下列非正式规则即可：(优先级按顺序下降)

1.如果其中一个操作数类型为long double，则将另一个操作数转换为long double类型

2.如果其中一个操作数类型为double，则将另一个操作数转换为double类型

3.如果其中一个操作数类型为float，则将另一个操作数转换为float类型

4.将char与short类型的操作数直接自动转为int类型(整型提升)

5.整型提升后，如果任何一个操作数为unsigned long int类型，则将另一个操作数转换为unsigned long int类型

6.如果一个操作数为long int类型且另一个操作数为unsigned int类型，则结果依赖于long int类型是否可以表示所有的unsigned int类型值

如果long int类型不能覆盖所有的unsigned int取值，则将两个操作数都转换为unsigned long int类型

7.如果一个操作数为long int类型，则另一个操作数转换为long int类型

8.如果一个操作数为unsigned int类型，则另一个操作数转换为unsigned int类型

9.最后，如果以上都没有，则将两个操作数转换为int类型

注意，表达式中float类型操作数不会自动转换为double类型

一般而言，数学函数(如&lt;math.h&gt;中定义的函数)使用双精度类型变量

使用float主要为了在使用较大数组时节省存储空间，以及节省执行时间(双精度算术运算很费时)，但精度上有所欠缺

当表达式中包括unsigned类型时，转换规则要更复杂，主要原因在于进行的转换是与机器相关的，例：

假定int占16位，long占32位，则-1L&lt;1U，因为此时unsigned int被隐式转换为signed long，

但是-1L&gt;1UL，因为此时signed long被转为unsigned long，即-1在一些情况下可能被转为一个比1大的正整数

(这种情况下long可以覆盖unsigned的取值，因此两数都转换为long即可)
</code></pre>
<p>c中没有指定char类型是带符号(signed)还是无符号(unsigned)，因此在将char转化为int时其结果可能为负整数</p>
<p>不同机器的结果可能不同，某些机器中，如果char类型最左一位是1，则转换为负整数(符号扩展后，高于1字节的位数全置为1，算术移位)，</p>
<p>另一些机器中，在将char转换为int后，在char类型值左边加0(逻辑移位)，使转换后的值总是正值</p>
<p>要是转换后的字符总是正值，可以先将char转为unsigned char</p>
<p>c的定义保证机器的标准打印字符集中的字符为非负值，因此在表达式中这些字符总是正的，但是其位模式在某些机器中可能是负的</p>
<p>为保证程序的可移植性，如果要在char类型中存储非字符数据，最好指定signed或unsigned限定符</p>
<p>如果需要将浮点类型的值转换为整型，小数部分将被丢弃，如果结果值不能用整型值表示则其行为是未定义的</p>
<p>特别是将负的浮点数转换为无符号整型的结果是没有定义的；</p>
<p>如果需要将整型值转换为浮点类型时，如果该值在该浮点类型可以表示的范围内但不能精确表示，则结果可能是下一个较高或较低的可表示值</p>
<p>如果该值超出可表示范围，则其行为是未定义的；</p>
<p>将一个精度较低的浮点值转换为相同或更高精度的浮点类型时，它的值保持不变</p>
<p>将一个较高精度的浮点类型值转换为较低精度的浮点类型时，如果它的值在可表示范围内，则结果可能是下一个较高或较低的可表示值</p>
<p>同样的，如果该值超出可表示范围，则其行为是未定义的</p>
<p>ASCII字符集中，大写字母与其对应的小写字母数值之间的间隔是固定的，并且每个字母表是连续的，如a～z,A~Z之间只有字母</p>
<p>但是在EBCDIC字符集中字母就不是连续的</p>
<p>标准头文件&lt;ctype.h&gt;中定义了一组与字符集无关的测试和转换函数，如isdigit©对应于测试语句c&gt;=‘0’&amp;&amp;c&lt;=‘9’</p>
<h1 id="指针和整数"><a class="markdownIt-Anchor" href="#指针和整数"></a> 指针和整数</h1>
<p>指针可以加上或减去一个整型表达式，在这种情况下整型表达式的转换按照加法运算符的方式进行</p>
<p>两个指向同一数组中同一类型的对象的指针可以进行减法运算，其结果将转换为整型，转换方式按照减法运算符的方式进行；</p>
<p>值为0的整型常量表达式或强制转换为void*类型的表达式，可通过强制转换、赋值或比较操作转换为任意类型的指针，其结果将产生一个空指针</p>
<p>(注意此空指针等于指向同一类型的另一空指针，但不等于任何指向函数或对象的指针)</p>
<p>作为一种良好的编程习惯，很多程序员都不愿意在程序中到处出现未加修饰的0或者其他空指针常量，为了让程序中的空指针使用更加明确从而保持统一的编程风格</p>
<p>专门定义了一个标准预处理宏NULL，其值为“空指针常量”，VC++中定义预处理宏NULL的代码如下：</p>
<pre><code>#ifndef NULL

#ifdef __cplusplus

#define NULL 0

#else

#define NULL ((void*)0)

#endif

#endif
</code></pre>
<p>指针可以转换为整型，但此整型必须足够大，所要求的大小和映射函数(转换方式)依赖于具体的实现</p>
<p>整型对象可以显式地转换为指针，这种映射通常是将一个足够宽的从指针转换来的整数转换为同一个指针，其他情况依赖于具体的实现</p>
<p>指向某一类型的指针可以显式地转换为指向另一类型的指针，但是如果该指针指向的对象不满足一定的存储对齐要求，则结果指针可能会导致地址异常</p>
<p>指向某对象的指针可以转换为一个指向具有更小相同存储对齐限制的对象的指针，并可以保证原封不动地再转换回来</p>
<p>“对齐”概念依赖于具体实现，但char类型具有最小的对齐限制</p>
<p>对于某类型T，如果某表达式或子表达式的类型为“T的数组”。那么此表达式的值是指向数组中第一个对象的指针，并且此表达式的类型被转换为“指向T的指针”</p>
<p>如果此表达式是一元运算符&amp;、++、–或sizeof的运算分量，或是赋值类运算符或圆点运算符.的左运算分量．那么转换不会发生</p>
<p>(int a[]={0,10,20};</p>
<pre><code>printf(&quot;%p\n&quot;,a);           输出：0x7ff7b3a6a36c

printf(&quot;%p\n&quot;,&amp;a[0]);     输出：0x7ff7b3a6a36c

printf(&quot;%p\n&quot;,&amp;a);         输出：0x7ff7b3a6a36c

printf(&quot;%p\n&quot;,a+1);       输出：0x7ff7b3a6a370

printf(&quot;%p\n&quot;,&amp;a[0]+1); 输出：0x7ff7b3a6a370

printf(&quot;%p\n&quot;,&amp;a+1);     输出：0x7ff7b3a6a378

可以发现，数组名a、数组名首元素a[0]的地址、数组名a的地址三者的值是一样的，因此变量a存储的地址值即一个指针常量

但是从进行增1运算后的结果来看，a和a[0]都是增加4个字节的长度，但是&amp;a增1后直接位移了12个字节，也就是整个数组的

总长度，说明&amp;运算符和数组名结合后a并不能视作为指针类型，变量类型(符号表中的种属?)表示的是数组类型)
</code></pre>
<p>类似地，类型为“返回T的函数”的表达式被转换为类型“指向返回T的函数的指针”，除非此表达式被用作&amp;运算符的运算分量</p>
<p>一个指针可以转换为同类型的另一个指针，但增加或删除了指针所处的对象类型的限定符(比如volatile等)的情况有些特殊:</p>
<p>如果增加了限定符则新指针与原指针等价，不同的是增加了限定符带来的限制</p>
<p>如果删除了限定符，则对底层对象的运算仍受实际声明中的限定符的限制</p>
<p>指向一个函数的指针可以转换为指向另一个函数的指针，调用转换后指针所指函数的结果依赖于具体的实现</p>
<p>但是如果转换后的指针被重新转换为原来的类型，则结果与原来的指针一致</p>
<h1 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h1>
<p>任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换，优先级同其他一元运算符，基本格式为：</p>
<p>(类型名)表达式</p>
<p>表达式将按转换规则被转换为类型名指定的类型，即表达式首先被赋值给类型名指定的类型的某个变量，然后再用该变量替换整条语句，</p>
<p>强制类型转换只生成一个指定类型的n的值，n本身的值并没有改变</p>
<p>例：伪随机发生器的函数rand,及初始化随即种子数的函数srand，其中使用了强制类型转换(标准库中包含一个可移植的实现,其中使用了类似方法)</p>
<pre class="line-numbers language-none"><code class="language-none">unsigned long int next&#x3D;1;

   int rand()

   &#123;

    next&#x3D;next*1103515245+12345;

    return (unsigned int)(next&#x2F;65536)%32768;

   &#125;

   void srand(unsigned int seed)

   &#123;

    next&#x3D;seed;

   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://hetumessi.github.io">hetumessi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://hetumessi.github.io/2022/04/21/c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">http://hetumessi.github.io/2022/04/21/c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://hetumessi.github.io" target="_blank">hetumessi's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">程序设计语言学习</a></div><div class="post_share"><div class="social-share" data-image="/img/newdefaultcover.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png"/></a><div class="post-qr-code-desc"></div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/01/Solidity%E5%85%A5%E9%97%A8%E4%BA%86%E8%A7%A3/" title="Solidity入门了解"><img class="cover" src="https://s2.loli.net/2022/05/12/w6pOHIGoFMxrTEa.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">Solidity入门了解</div></div></a></div><div><a href="/2022/04/30/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="异常处理"><img class="cover" src="/img/newdefaultcover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">异常处理</div></div></a></div><div><a href="/2022/04/30/%E6%A8%A1%E6%9D%BF/" title="模板"><img class="cover" src="/img/newdefaultcover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">模板</div></div></a></div><div><a href="/2022/04/30/%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%A4%9A%E6%80%81%E6%80%A7/" title="多态性与虚函数"><img class="cover" src="/img/newdefaultcover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">多态性与虚函数</div></div></a></div><div><a href="/2022/04/30/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/" title="运算符重载"><img class="cover" src="/img/newdefaultcover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">运算符重载</div></div></a></div><div><a href="/2022/04/28/%E5%8D%95%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E7%BB%A7%E6%89%BF/" title="单继承和多继承、派生类构造析构规则"><img class="cover" src="/img/newdefaultcover.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-28</div><div class="title">单继承和多继承、派生类构造析构规则</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/author.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">hetumessi</div><div class="author-info__description">个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/hetumessi"><i class="fab fa-github"></i><span>要来gayhub瞧瞧嘛🤡</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hetumessi" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/392384886@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！有任何问题或者意见，还请QQ：392384886，或者致信QQ邮箱：392384886@qq.com</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text"> 词法规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0%E5%8F%B7"><span class="toc-number">2.</span> <span class="toc-text"> 记号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">2.0.1.</span> <span class="toc-text"> 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.0.2.</span> <span class="toc-text"> 标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.0.3.</span> <span class="toc-text"> 关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text"> 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">3.0.1.</span> <span class="toc-text"> 数据存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.0.2.</span> <span class="toc-text"> void对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text"> 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.0.1.</span> <span class="toc-text"> 常量类型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.0.2.</span> <span class="toc-text"> 常量表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text"> 转义字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">5.0.1.</span> <span class="toc-text"> 扩展字符集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text"> 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">6.0.1.</span> <span class="toc-text"> 变量声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.0.2.</span> <span class="toc-text"> 存储类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B7%A6%E5%80%BC"><span class="toc-number">6.0.3.</span> <span class="toc-text"> 对象和左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%AD%89%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.0.4.</span> <span class="toc-text"> 初等表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.0.5.</span> <span class="toc-text"> 后缀表达式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text"> c语言运算符表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.0.1.</span> <span class="toc-text"> 运算符优先级：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">7.0.2.</span> <span class="toc-text"> 运算符结合性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.</span> <span class="toc-text"> 隐式类型转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B4%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text"> 指针和整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.</span> <span class="toc-text"> 强制类型转换</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/12/%E5%AF%B9%E8%AF%9Dlinus/" title="【转】对话Linus Torvalds：大多黑客甚至连指针都未理解"><img src="https://s2.loli.net/2022/05/12/eLAWbUxHw2gP3ME.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【转】对话Linus Torvalds：大多黑客甚至连指针都未理解"/></a><div class="content"><a class="title" href="/2022/05/12/%E5%AF%B9%E8%AF%9Dlinus/" title="【转】对话Linus Torvalds：大多黑客甚至连指针都未理解">【转】对话Linus Torvalds：大多黑客甚至连指针都未理解</a><time datetime="2022-05-12T03:39:27.023Z" title="发表于 2022-05-12 11:39:27">2022-05-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/11/Sort%20with%20Swap(0,%20i)/" title="15.Insert or Merge、Insertion or Heap Sort、Sort with Swap(0, i)"><img src="https://s2.loli.net/2022/05/12/RkWMs6VzwjIG8uL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="15.Insert or Merge、Insertion or Heap Sort、Sort with Swap(0, i)"/></a><div class="content"><a class="title" href="/2022/05/11/Sort%20with%20Swap(0,%20i)/" title="15.Insert or Merge、Insertion or Heap Sort、Sort with Swap(0, i)">15.Insert or Merge、Insertion or Heap Sort、Sort with Swap(0, i)</a><time datetime="2022-05-11T10:24:30.529Z" title="发表于 2022-05-11 18:24:30">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/11/%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/" title="14.公路村村通、关键活动、How Long Does It Take"><img src="https://s2.loli.net/2022/05/12/RkWMs6VzwjIG8uL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="14.公路村村通、关键活动、How Long Does It Take"/></a><div class="content"><a class="title" href="/2022/05/11/%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/" title="14.公路村村通、关键活动、How Long Does It Take">14.公路村村通、关键活动、How Long Does It Take</a><time datetime="2022-05-11T10:01:41.503Z" title="发表于 2022-05-11 18:01:41">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/11/Subway%20Map/" title="13.Subway Map、Public Bike Management"><img src="https://s2.loli.net/2022/05/12/RkWMs6VzwjIG8uL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="13.Subway Map、Public Bike Management"/></a><div class="content"><a class="title" href="/2022/05/11/Subway%20Map/" title="13.Subway Map、Public Bike Management">13.Subway Map、Public Bike Management</a><time datetime="2022-05-11T09:45:54.813Z" title="发表于 2022-05-11 17:45:54">2022-05-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/05/11/%E6%95%91%E9%82%A6%E5%BE%B7%E5%A4%8D%E6%9D%82%E7%89%88/" title="12.救邦德复杂版、Gas Station、条条大路通罗马"><img src="https://s2.loli.net/2022/05/12/RkWMs6VzwjIG8uL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="12.救邦德复杂版、Gas Station、条条大路通罗马"/></a><div class="content"><a class="title" href="/2022/05/11/%E6%95%91%E9%82%A6%E5%BE%B7%E5%A4%8D%E6%9D%82%E7%89%88/" title="12.救邦德复杂版、Gas Station、条条大路通罗马">12.救邦德复杂版、Gas Station、条条大路通罗马</a><time datetime="2022-05-11T09:25:31.677Z" title="发表于 2022-05-11 17:25:31">2022-05-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By hetumessi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎光临小破站！🎉</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'facd33fa531a29d93105',
      clientSecret: '7c0e063309085031b84369f86c21bbbee8e77c64',
      repo: 'blog_comments',
      owner: 'hetumessi',
      admin: ['hetumessi'],
      id: 'b0a30da5478d5117afedc3392b29a641',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><div class="aplayer no-destroy" data-id="3180545941" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script defer src="/live2d-widget/autoload.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/null.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>